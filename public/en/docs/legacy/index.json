[{"categories":null,"content":"So you want to start work on I2P? Great! Here\u0026rsquo;s a quick guide to getting started on contributing to the website or the software, doing development, or creating translations.\nNot quite ready for coding? Try getting involved first: /get-involved/\nGet to Know Java The I2P router and its embedded applications use Java as the main development language. If you don\u0026rsquo;t have experience with Java, you can always have a look at Thinking in Java\nStudy the how intro, other \u0026ldquo;how\u0026rdquo; documents, the tech intro, and associated documents:\nHow introduction: Introduction to I2P Documentation hub: Documentation Technical introduction: Technical Introduction These will give you a good overview of how I2P is structured and what different things it does.\nGetting the I2P Code For development on the I2P router or the embedded applications, you need to get the source code.\nOur current way: Git I2P has official Git services and accepts contributions via Git at our own GitLab:\nInside I2P: http://git.idk.i2p Outside I2P: https://i2pgit.org Clone the main repository:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git A read‑only mirror is also available at GitHub:\nGitHub mirror: https://github.com/i2p/i2p.i2p git clone https://github.com/i2p/i2p.i2p.git Building I2P To compile the code, you need the Sun/Oracle Java Development Kit 6 or higher, or equivalent JDK (Sun/Oracle JDK 6 strongly recommended) and Apache Ant version 1.7.0 or higher. If you are working on the main I2P code, go into the i2p.i2p directory and run ant to see the build options.\nTo build or work on console translations, you need the xgettext, msgfmt, and msgmerge tools from the GNU gettext package.\nFor development on new applications, see the application development guide: /get-involved/develop/applications/\nDevelopment Ideas See the project TODO list or the issue list on GitLab for ideas:\nGitLab issues: https://i2pgit.org/I2P_Developers/i2p.i2p/issues Making the Results Available See the bottom of the licenses page for commit privilege requirements. You need these to put code into i2p.i2p (not required for the website!).\nLicenses page: /get-involved/develop/licenses#commit Get to Know Us! The developers hang around on IRC. They can be reached on various networks and on the I2P internal networks. The usual place to look is #i2p-dev. Join the channel and say hi! We also have additional guidelines for regular developers: /docs/develop/dev-guidelines/\nTranslations Website and router console translators: See the New Translator\u0026rsquo;s Guide for next steps: /get-involved/guides/new-translators/\nTools I2P is open source software that is mostly developed using open‑source toolkits. The I2P project recently acquired a license for the YourKit Java Profiler. Open source projects are eligible to receive a free license provided that YourKit is referenced on the project web site. Please get in touch if you are interested in profiling the I2P codebase.\nYourKit is kindly supporting open source projects with its full‑featured profilers. YourKit, LLC is the creator of innovative and intelligent tools for profiling Java and .NET applications. Take a look at YourKit\u0026rsquo;s leading software products:\nYourKit Java Profiler: http://www.yourkit.com/java/profiler/index.jsp YourKit .NET Profiler: http://www.yourkit.com/.net/profiler/index.jsp ","description":"How to start contributing to I2P: study materials, source code, building, ideas, publishing, community, translations, and tools","id":"e74ff72be9767cc925c6712e11e5e1c5","section":"docs","title":"[Needs Review] New Developer's Guide","url":"/en/docs/develop/new-developers/"},{"categories":null,"content":"Access filters let I2PTunnel server operators allow, deny, or throttle inbound connections based on the source Destination and recent connection rate. The filter is a plain text file of rules. The file is read top to bottom and the first matching rule wins.\nChanges to the filter definition take effect on tunnel restart. Some builds may re-read file-based lists at runtime, but plan for a restart to guarantee changes are applied.\nFile format One rule per line. Blank lines are ignored. # starts a comment that runs to end of line. Rules are evaluated in order; the first match is used. Thresholds A threshold defines how many connection attempts from a single Destination are permitted in a rolling time window.\nNumeric: N/S means allow N connections per S seconds. Example: 15/5 permits up to 15 connections every 5 seconds. The N+1 attempt within the window is rejected. Keywords: allow means no limit. deny means always reject. Rule syntax Rules take the form:\n\u0026lt;threshold\u0026gt; \u0026lt;scope\u0026gt; \u0026lt;target\u0026gt; Where:\n\u0026lt;threshold\u0026gt; is N/S, allow, or deny \u0026lt;scope\u0026gt; is one of default, explicit, file, or record (see below) \u0026lt;target\u0026gt; depends on scope Default rule Applies when no other rule matches. Only one default rule is allowed. If omitted, unknown Destinations are permitted without restriction.\n15/5 default allow default deny default Explicit rule Targets a specific Destination by Base32 address (for example example1.b32.i2p) or full key.\n15/5 explicit example1.b32.i2p deny explicit example2.b32.i2p allow explicit example3.b32.i2p File-based rule Targets all Destinations listed in an external file. Each line contains one Destination; # comments and blank lines are allowed.\n15/5 file /var/i2p/throttled.txt deny file /var/i2p/blocked.txt allow file /var/i2p/trusted.txt Operational note: Some implementations re-read file lists periodically. If you edit a list while the tunnel is running, expect a short delay before changes are noticed. Restart to apply immediately.\nRecorder (progressive control) A recorder monitors connection attempts and writes Destinations that breach a threshold to a file. You can then reference that file in a file rule to apply throttles or blocks on future attempts.\n# Start permissive allow default # Record Destinations exceeding 30 connections in 5 seconds 30/5 record /var/i2p/aggressive.txt # Apply throttling to recorded Destinations 15/5 file /var/i2p/aggressive.txt Verify recorder support in your build before relying on it. Use file lists for guaranteed behavior.\nEvaluation order Put specific rules first, then general ones. A common pattern:\nExplicit allows for trusted peers Explicit denies for known abusers File-based allow/deny lists Recorders for progressive throttling Default rule as a catch-all Full example # Moderate limits by default 30/10 default # Always allow trusted peers allow explicit friend1.b32.i2p allow explicit friend2.b32.i2p # Block known bad actors deny file /var/i2p/blocklist.txt # Throttle aggressive sources 15/5 file /var/i2p/throttle.txt # Automatically populate the throttle list 60/5 record /var/i2p/throttle.txt Implementation notes The access filter operates at the tunnel layer, before application handling, so abusive traffic can be rejected early. Place the filter file in your I2PTunnel configuration directory and restart the tunnel to apply changes. Share file-based lists across multiple tunnels if you want consistent policy across services. ","description":"Syntax for tunnel access-control filter files","id":"d8b5745531fca07ea47765403a9a4d0c","section":"docs","title":"Access Filter Format","url":"/en/docs/specs/filter-format/"},{"categories":null,"content":"Overview This specification extends the address subscription feed with commands, enabling name servers to broadcast entry updates from hostname holders. Originally proposed in Proposal 112 (September 2014), implemented in version 0.9.26 (June 2016), and deployed network-wide with status CLOSED.\nThe system has remained stable and unchanged since its initial implementation, continuing to operate identically in I2P 2.10.0 (Router API 0.9.65, September 2025).\nMotivation Previously, the hosts.txt subscription servers sent data only in a simple hosts.txt format:\nexample.i2p=b64destination This basic format created several problems:\nHostname holders cannot update the Destination associated with their hostnames (for example, to upgrade the signing key to a stronger cryptographic type). Hostname holders cannot relinquish their hostnames arbitrarily. They must give the corresponding Destination private keys directly to the new holder. There is no way to authenticate that a subdomain is controlled by the corresponding base hostname. This is currently enforced only individually by some name servers. Design This specification adds command lines to the hosts.txt format. With these commands, name servers can extend their services to provide additional features. Clients that implement this specification can listen for these features through the regular subscription process.\nAll command lines must be signed by the corresponding Destination. This ensures that changes are made only at the request of the hostname holder.\nSecurity Implications This specification does not affect anonymity.\nThere is an increase in the risk associated with losing control of a Destination key, as someone who obtains it can use these commands to make changes to any associated hostnames. However, this is no more of a problem than the status quo, where someone who obtains a Destination can impersonate a hostname and (partially) take over its traffic. The increased risk is balanced by giving hostname holders the ability to change the Destination associated with a hostname in the event that they believe the Destination has been compromised. This is impossible with the current system.\nSpecification New Line Types There are two new types of lines:\nAdd and Change commands: example.i2p=b64destination#!key1=val1#key2=val2... Remove commands: #!key1=val1#key2=val2... Ordering A feed is not necessarily in-order or complete. For example, a change command may appear on a line before an add command, or without an add command.\nKeys may be in any order. Duplicate keys are not allowed. All keys and values are case-sensitive.\nCommon Keys Required in all commands:\nsig Base64 signature, using signing key from the destination References to a second hostname and/or destination:\noldname A second hostname (new or changed) olddest A second Base64 destination (new or changed) oldsig A second Base64 signature, using signing key from olddest Other common keys:\naction A command name The hostname, only present if not preceded by example.i2p=b64dest dest The Base64 destination, only present if not preceded by example.i2p=b64dest date In seconds since epoch expires In seconds since epoch Commands All commands except the \u0026ldquo;Add\u0026rdquo; command must contain an action=command key/value pair.\nFor compatibility with older clients, most commands are preceded by example.i2p=b64dest, as noted below. For changes, these are always the new values. Any old values are included in the key/value section.\nListed keys are required. All commands may contain additional key/value items not defined here.\nAdd Hostname Preceded by example.i2p=b64dest YES, this is the new hostname and destination. action NOT included, it is implied. sig signature Example:\nexample.i2p=b64dest#!sig=b64sig Change Hostname Preceded by example.i2p=b64dest YES, this is the new hostname and old destination. action changename oldname the old hostname, to be replaced sig signature Example:\nexample.i2p=b64dest#!action=changename#oldname=oldhostname#sig=b64sig Change Destination Preceded by example.i2p=b64dest YES, this is the old hostname and new destination. action changedest olddest the old destination, to be replaced oldsig signature using olddest sig signature Example:\nexample.i2p=b64dest#!action=changedest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Add Hostname Alias Preceded by example.i2p=b64dest YES, this is the new (alias) hostname and old destination. action addname oldname the old hostname sig signature Example:\nexample.i2p=b64dest#!action=addname#oldname=oldhostname#sig=b64sig Add Destination Alias (Used for crypto upgrade)\nPreceded by example.i2p=b64dest YES, this is the old hostname and new (alternate) destination. action adddest olddest the old destination oldsig signature using olddest sig signature using dest Example:\nexample.i2p=b64dest#!action=adddest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Add Subdomain Preceded by subdomain.example.i2p=b64dest YES, this is the new subdomain name and destination. action addsubdomain oldname the higher-level hostname (example.i2p) olddest the higher-level destination (for example.i2p) oldsig signature using olddest sig signature using dest Example:\nsubdomain.example.i2p=b64dest#!action=addsubdomain#oldname=example.i2p#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Update Metadata Preceded by example.i2p=b64dest YES, this is the old hostname and destination. action update sig signature (add any updated keys here)\nExample:\nexample.i2p=b64dest#!action=update#k1=v1#k2=v2#sig=b64sig Remove Hostname Preceded by example.i2p=b64dest NO, these are specified in the options action remove name the hostname dest the destination sig signature Example:\n#!action=remove#name=example.i2p#dest=b64dest#sig=b64sig Remove All with This Destination Preceded by example.i2p=b64dest NO, these are specified in the options action removeall dest the destination sig signature Example:\n#!action=removeall#dest=b64dest#sig=b64sig Signatures All commands must be signed by the corresponding Destination. Commands with two destinations may need two signatures.\noldsig is always the \u0026ldquo;inner\u0026rdquo; signature. Sign and verify without the oldsig or sig keys present. sig is always the \u0026ldquo;outer\u0026rdquo; signature. Sign and verify with the oldsig key present but not the sig key.\nInput for Signatures To generate a byte stream to create or verify the signature, serialize as follows:\nRemove the sig key If verifying with oldsig, also remove the oldsig key For Add or Change commands only, output example.i2p=b64dest If any keys remain, output #! Sort the options by UTF-8 key, fail if duplicate keys For each key/value, output key=value, followed by (if not the last key/value) a # Notes\nDo not output a newline Output encoding is UTF-8 All destination and signature encoding is in Base 64 using the I2P alphabet Keys and values are case-sensitive Hostnames must be in lowercase Current Signature Types As of I2P 2.10.0, the following signature types are supported for destinations:\nEdDSA_SHA512_Ed25519 (Type 7): Most common for destinations since 0.9.15. Uses a 32-byte public key and 64-byte signature. This is the recommended signature type for new destinations. RedDSA_SHA512_Ed25519 (Type 13): Available for destinations and encrypted leasesets only (since 0.9.39). Legacy types (DSA_SHA1, ECDSA variants): Still supported but deprecated for new Router Identities as of 0.9.58. Note: Post-quantum cryptographic options are available as of I2P 2.10.0 but are not yet the default signature types.\nCompatibility All new lines in the hosts.txt format are implemented using leading comment characters (#!), so all older I2P versions will interpret the new commands as comments and ignore them gracefully.\nWhen I2P routers update to the new specification, they will not re-interpret old comments, but will start listening to new commands in subsequent fetches of their subscription feeds. Thus it is important for name servers to persist command entries in some fashion, or enable ETag support so that routers can fetch all past commands.\nImplementation Status Initial deployment: Version 0.9.26 (June 7, 2016)\nCurrent status: Stable and unchanged through I2P 2.10.0 (Router API 0.9.65, September 2025)\nProposal status: CLOSED (successfully deployed network-wide)\nImplementation location: apps/addressbook/java/src/net/i2p/addressbook/ in the I2P Java router\nKey classes:\nSubscriptionList.java: Manages subscription processing Subscription.java: Handles individual subscription feeds AddressBook.java: Core addressbook functionality Daemon.java: Addressbook background service Default subscription URL: http://i2p-projekt.i2p/hosts.txt\nTransport Details Subscriptions use HTTP with conditional GET support:\nETag header: Supports efficient change detection Last-Modified header: Tracks subscription update times 304 Not Modified: Servers should return this when content has not changed Content-Length: Strongly recommended for all responses The I2P router uses standard HTTP client behavior with proper caching support.\nVersion Context I2P versioning note: Starting around version 1.5.0 (August 2021), I2P changed from 0.9.x versioning to semantic versioning (1.x, 2.x, etc.). However, the internal Router API version continues to use 0.9.x numbering for backward compatibility. As of October 2025, the current release is I2P 2.10.0 with Router API version 0.9.65.\nThis specification document was originally written for version 0.9.49 (February 2021) and remains completely accurate for the current version 0.9.65 (I2P 2.10.0) because the subscription feed system has had no changes since its original implementation in 0.9.26.\nReferences Proposal 112 (Original) Official Specification I2P Naming Documentation Common Structures Specification I2P Source Repository I2P Gitea Repository Related Developments While the subscription feed system itself has not changed, the following related developments in I2P\u0026rsquo;s naming infrastructure may be of interest:\nExtended Base32 Names (0.9.40+): Support for 56+ character base32 addresses for encrypted leasesets. Does not affect subscription feed format. .i2p.alt TLD Registration (RFC 9476, late 2023): Official GANA registration of .i2p.alt as an alternative TLD. Future router updates may strip .alt suffix, but no changes to subscription commands are required. Post-Quantum Cryptography (2.10.0+): Available but not default. Future consideration for signature algorithms in subscription feeds. ","description":"Extension to address subscription feeds enabling hostname holders to update and manage their entries","id":"fa3cedda5fbeac90d0dcf029a44ee945","section":"docs","title":"Address Subscription Feed Commands","url":"/en/docs/specs/subscription/"},{"categories":null,"content":"The main I2P client implementation uses Java. If you cannot or prefer not to use Java on a particular system, there are alternative I2P client implementations developed and maintained by community members. These programs provide the same core functionality using different programming languages or approaches.\nComparison Table Client Language Maturity Actively Maintained Suitable For Notes Java I2P Java Stable ✅ Yes (official) General users Standard full router; includes console, plugins, and tools i2pd C++ Stable ✅ Yes Low-resource systems, servers Lightweight, fully compatible with Java I2P, includes web console Go-I2P Go Experimental ⚙️ In development Developers, testing Early-stage Go implementation; not yet production ready I2P+ Java Stable (fork) ✅ Yes Advanced users Enhanced Java I2P fork with UI and performance improvements i2pd (C++) Website: https://i2pd.website\nDescription: i2pd (the I2P Daemon) is a full-featured I2P client implemented in C++. It has been stable for production use for many years (since around 2016) and is actively maintained by the community. i2pd fully implements the I2P network protocols and APIs, making it completely compatible with the Java I2P network. This C++ router is often used as a lightweight alternative on systems where the Java runtime is unavailable or undesired. i2pd includes a built-in web-based console for configuration and monitoring. It is cross-platform and available in many packaging formats — there is even an Android version of i2pd available (for example, via F-Droid).\nGo-I2P (Go) Repository: https://github.com/go-i2p/go-i2p\nDescription: Go-I2P is an I2P client written in the Go programming language. It is an independent implementation of the I2P router, aiming to leverage Go’s efficiency and portability. The project is under active development, but it is still in an early stage and not yet feature-complete. As of 2025, Go-I2P is considered experimental — it is being actively worked on by community developers, but it is not recommended for production use until it matures further. The goal of Go-I2P is to provide a modern, lightweight I2P router with full compatibility with the I2P network once development is complete.\nI2P+ (Java fork) Website: https://i2pplus.github.io\nDescription: I2P+ is a community-maintained fork of the standard Java I2P client. It is not a reimplementation in a new language, but rather an enhanced version of the Java router with additional features and optimizations. I2P+ focuses on delivering an improved user experience and better performance while remaining fully compatible with the official I2P network. It introduces a refreshed web console interface, more user-friendly configuration options, and various optimizations (for example, improved torrent performance and better handling of network peers, especially for routers behind firewalls). I2P+ requires a Java environment just like the official I2P software, so it is not a solution for non-Java environments. However, for users who do have Java and want an alternative build with extra capabilities, I2P+ provides a compelling option. This fork is kept up-to-date with the upstream I2P releases (with its version numbering appending a “+”) and can be obtained from the project’s website.\n","description":"Community-maintained I2P client implementations (updated for 2025)","id":"fdcfc5a7a482cf9fe8fe449e9198b146","section":"docs","title":"Alternative I2P Clients","url":"/en/docs/overview/alternative-clients/"},{"categories":null,"content":" Why write I2P-specific code? Important concepts Development options Start developing - a simple guide Why write I2P-specific code? There are multiple ways to use applications in I2P. Using I2PTunnel, you can use regular applications without needing to program explicit I2P support. This is very effective for client-server scenarios, where you need to connect to a single website. You can simply create a tunnel using I2PTunnel to connect to that website, as shown in Figure 1. If your application is distributed, it will require connections to a large amount of peers. Using I2PTunnel, you will need to create a new tunnel for each peer you want to contact, as shown in Figure 2. This process can of course be automated, but running a lot of I2PTunnel instances creates a large amount of overhead. In addition, with many protocols you will need to force everyone to use the same set of ports for all peers - e.g. if you want to reliably run DCC chat, everyone needs to agree that port 10001 is Alice, port 10002 is Bob, port 10003 is Charlie, and so on, since the protocol includes TCP/IP specific information (host and port). General network applications often send a lot of additional data that could be used to identify users. Hostnames, port numbers, time zones, character sets, etc. are often sent without informing the user. As such, designing the network protocol specifically with anonymity in mind can avoid compromising user identities. There are also efficiency considerations to review when determining how to interact on top of I2P. The streaming library and things built on top of it operate with handshakes similar to TCP, while the core I2P protocols (I2NP and I2CP) are strictly message based (like UDP or in some instances raw IP). The important distinction is that with I2P, communication is operating over a long fat network - each end to end message will have nontrivial latencies, but may contain payloads of up to several KB. An application that needs a simple request and response can get rid of any state and drop the latency incurred by the startup and teardown handshakes by using (best effort) datagrams without having to worry about MTU detection or fragmentation of messages. Figure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel. Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels. In summary, a number of reasons to write I2P-specific code:\nCreating a large amount of I2PTunnel instances consumes a non-trivial amount of resources, which is problematic for distributed applications (a new tunnel is required for each peer). General network protocols often send a lot of additional data that can be used to identify users. Programming specifically for I2P allows the creation of a network protocol that does not leak such information, keeping users anonymous and secure. Network protocols designed for use on the regular internet can be inefficient on I2P, which is a network with a much higher latency. I2P supports a standard plugins interface for developers so that applications may be easily integrated and distributed. Applications written in Java and accessible/runnable using an HTML interface via the standard webapps/app.war may be considered for inclusion in the I2P distribution. Important concepts There are a few changes that require adjusting to when using I2P: Destinations An application running on I2P sends messages from and receives messages to a unique cryptographically secure end point - a \"destination\". In TCP or UDP terms, a destination could (largely) be considered the equivalent of a hostname plus port number pair, though there are a few differences. An I2P destination itself is a cryptographic construct - all data sent to one is encrypted as if there were universal deployment of IPsec with the (anonymized) location of the end point signed as if there were universal deployment of DNSSEC. I2P destinations are mobile identifiers - they can be moved from one I2P router to another (or it can even \"multihome\" - operate on multiple routers at once). This is quite different from the TCP or UDP world where a single end point (port) must stay on a single host. I2P destinations are ugly and large - behind the scenes, they contain a 2048 bit ElGamal public key for encryption, a 1024 bit DSA public key for signing, and a variable size certificate, which may contain proof of work or blinded data. There are existing ways to refer to these large and ugly destinations by short and pretty names (e.g. \"irc.duck.i2p\"), but those techniques do not guarantee globally uniqueness (since they're stored locally in a database on each person's machine) and the current mechanism is not especially scalable nor secure (updates to the host list are managed using \"subscriptions\" to naming services). There may be some secure, human readable, scalable, and globally unique, naming system some day, but applications shouldn't depend upon it being in place. Further information on the naming system is available. While most applications do not need to distinguish protocols and ports, I2P does support them. Complex applications may specify a protocol, from port, and to port, on a per-message basis, to multiplex traffic on a single destination. See the datagram page for details. Simple applications operate by listening for \"all protocols\" on \"all ports\" of a destination. Anonymity and confidentiality I2P has transparent end to end encryption and authentication for all data passed over the network - if Bob sends to Alice's destination, only Alice's destination can receive it, and if Bob is using the datagrams or streaming library, Alice knows for certain that Bob's destination is the one who sent the data. Of course, I2P transparently anonymizes the data sent between Alice and Bob, but it does nothing to anonymize the content of what they send. For instance, if Alice sends Bob a form with her full name, government IDs, and credit card numbers, there is nothing I2P can do. As such, protocols and applications should keep in mind what information they are trying to protect and what information they are willing to expose. I2P datagrams can be up to several KB Applications that use I2P datagrams (either raw or repliable ones) can essentially be thought of in terms of UDP - the datagrams are unordered, best effort, and connectionless - but unlike UDP, applications don't need to worry about MTU detection and can simply fire off large datagrams. While the upper limit is nominally 32 KB, the message is fragmented for transport, thus dropping the reliability of the whole. Datagrams over about 10 KB are not currently recommended. See the datagram page for details. For many applications, 10 KB of data is sufficient for an entire request or response, allowing them to transparently operate in I2P as a UDP-like application without having to write fragmentation, resends, etc. Development options There are several means of sending data over I2P, each with their own pros and cons. The streaming lib is the recommended interface, used by the majority of I2P applications. Streaming Lib The full streaming library is now the standard interface. It allows programming using TCP-like sockets, as explained in the Streaming development guide. BOB BOB is the Basic Open Bridge, allowing an application in any language to make streaming connections to and from I2P. At this point in time it lacks UDP support, but UDP support is planned in the near future. BOB also contains several tools, such as destination key generation, and verification that an address conforms to I2P specifications. Up to date info and applications that use BOB can be found at this I2P Site. SAM, SAM V2, SAM V3 SAM is not recommended. SAM V2 is okay, SAM V3 is recommended.\nSAM is the Simple Anonymous Messaging protocol, allowing an application written in any language to talk to a SAM bridge through a plain TCP socket and have that bridge multiplex all of its I2P traffic, transparently coordinating the encryption/decryption and event based handling. SAM supports three styles of operation: streams, for when Alice and Bob want to send data to each other reliably and in order repliable datagrams, for when Alice wants to send Bob a message that Bob can reply to raw datagrams, for when Alice wants to squeeze the most bandwidth and performance as possible, and Bob doesn't care whether the data's sender is authenticated or not (e.g. the data transferred is self authenticating) SAM V3 aims at the same goal as SAM and SAM V2, but does not require multiplexing/demultiplexing. Each I2P stream is handled by its own socket between the application and the SAM bridge. Besides, datagrams can be sent and received by the application through datagram communications with the SAM bridge. SAM V2 is a new version used by imule that fixes some of the problems in SAM. SAM V3 is used by imule since version 1.4.0. I2PTunnel The I2PTunnel application allows applications to build specific TCP-like tunnels to peers by creating either I2PTunnel 'client' applications (which listen on a specific port and connect to a specific I2P destination whenever a socket to that port is opened) or I2PTunnel 'server' applications (which listen to a specific I2P destination and whenever it gets a new I2P connection it outproxies to a specific TCP host/port). These streams are 8-bit clean, and are authenticated and secured through the same streaming library that SAM uses, but there is a nontrivial overhead involved with creating multiple unique I2PTunnel instances, since each have their own unique I2P destination and their own set of tunnels, keys, etc. SOCKS I2P supports a SOCKS V4 and V5 proxy. Outbound connections work well. Inbound (server) and UDP functionality may be incomplete and untested. Ministreaming Removed\nThere used to be a simple \"ministreaming\" library, but now ministreaming.jar contains only the interfaces for the full streaming library. Datagrams Recommended for UDP-like applications\nThe Datagram library allows sending UDP-like packets. It's possible to use: Repliable datagrams Raw datagrams I2CP Not recommended\nI2CP itself is a language independent protocol, but to implement an I2CP library in something other than Java there is a significant amount of code to be written (encryption routines, object marshalling, asynchronous message handling, etc). While someone could write an I2CP library in C or something else, it would most likely be more useful to use the C SAM library instead. Web Applications I2P comes with the Jetty webserver, and configuring to use the Apache server instead is straightforward. Any standard web app technology should work. Start developing - a simple guide Developing using I2P requires a working I2P installation and a development environment of your own choice. If you are using Java, you can start development with the streaming library or datagram library. Using another programming language, SAM or BOB can be used. Developing with the streaming library Below is a trimmed and modernized version of the example in the original page. For the full example, see the legacy page or our Java examples in the codebase. // Server example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); I2PServerSocket server = manager.getServerSocket(); I2PSocket socket = server.accept(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s; while ((s = br.readLine()) != null) { System.out.println(\"Received: \" + s); } Code example: basic server receiving data.\n// Client example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); Destination dest = new Destination(serverDestBase64); I2PSocket socket = manager.connect(dest); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(\"Hello I2P!\\n\"); bw.flush(); Code example: client connecting and sending a line.\n","description":"Why write I2P-specific apps, key concepts, development options, and a simple getting-started guide","id":"d137fc4f3bedf693b877aa1ba9bde3eb","section":"docs","title":"Application Development","url":"/en/docs/develop/applications/"},{"categories":null,"content":"Overview Standard Base 32 (\u0026ldquo;b32\u0026rdquo;) addresses contain the hash of the destination. This will not work for encrypted LS2 (proposal 123).\nWe cannot use a traditional base 32 address for an encrypted LS2 (proposal 123), as it contains only the hash of the destination. It does not provide the non-blinded public key. Clients must know the destination\u0026rsquo;s public key, signature type, the blinded signature type, and an optional secret or private key to fetch and decrypt the leaseset. Therefore, a base 32 address alone is insufficient. The client needs either the full destination (which contains the public key), or the public key by itself. If the client has the full destination in an address book, and the address book supports reverse lookup by hash, then the public key may be retrieved.\nThis format puts the public key instead of the hash into a base32 address. This format must also contain the signature type of the public key, and the signature type of the blinding scheme.\nThis document specifies a b32 format for these addresses. While we have referred to this new format during discussions as a \u0026ldquo;b33\u0026rdquo; address, the actual new format retains the usual \u0026ldquo;.b32.i2p\u0026rdquo; suffix.\nImplementation Status Proposal 123 (New netDB Entries) achieved full implementation in version 0.9.43 (October 2019). The encrypted LS2 feature set has remained stable through version 2.10.0 (September 2025) with no breaking changes to the addressing format or cryptographic specifications.\nKey implementation milestones:\n0.9.38: Floodfill support for standard LS2 with offline keys 0.9.39: RedDSA signature type 11 and basic encryption/decryption 0.9.40: Complete B32 addressing support (Proposal 149) 0.9.41: X25519-based per-client authentication 0.9.42: All blinding features operational 0.9.43: Complete implementation declared (October 2019) Design New format contains the unblinded public key, unblinded signature type, and blinded signature type. Optionally indicates secret and/or private key requirements for private links. Uses the existing \u0026ldquo;.b32.i2p\u0026rdquo; suffix, but with a longer length. Includes a checksum for error detection. Addresses for encrypted leasesets are identified by 56 or more encoded characters (35 or more decoded bytes), compared to 52 characters (32 bytes) for traditional base 32 addresses. Specification Creation and Encoding Construct a hostname of {56+ chars}.b32.i2p (35+ chars in binary) as follows:\nflag (1 byte) bit 0: 0 for one-byte sigtypes, 1 for two-byte sigtypes bit 1: 0 for no secret, 1 if secret is required bit 2: 0 for no per-client auth, 1 if client private key is required bits 7-3: Unused, set to 0 public key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero blinded key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero public key Number of bytes as implied by sigtype Post-processing and checksum:\nConstruct the binary data as above. Treat checksum as little-endian. Calculate checksum = CRC-32(data[3:end]) data[0] ^= (byte) checksum data[1] ^= (byte) (checksum \u0026gt;\u0026gt; 8) data[2] ^= (byte) (checksum \u0026gt;\u0026gt; 16) hostname = Base32.encode(data) || \u0026#34;.b32.i2p\u0026#34; Any unused bits at the end of the b32 must be 0. There are no unused bits for a standard 56 character (35 byte) address.\nDecoding and Verification strip the \u0026#34;.b32.i2p\u0026#34; from the hostname data = Base32.decode(hostname) Calculate checksum = CRC-32(data[3:end]) Treat checksum as little-endian. flags = data[0] ^ (byte) checksum if 1 byte sigtypes: pubkey sigtype = data[1] ^ (byte) (checksum \u0026gt;\u0026gt; 8) blinded sigtype = data[2] ^ (byte) (checksum \u0026gt;\u0026gt; 16) else (2 byte sigtypes): pubkey sigtype = data[1] ^ ((byte) (checksum \u0026gt;\u0026gt; 8)) || data[2] ^ ((byte) (checksum \u0026gt;\u0026gt; 16)) blinded sigtype = data[3] || data[4] parse the remainder based on the flags to get the public key Secret and Private Key Bits The secret and private key bits are used to indicate to clients, proxies, or other client-side code that the secret and/or private key will be required to decrypt the leaseset. Particular implementations may prompt the user to supply the required data, or reject connection attempts if the required data is missing.\nThese bits serve as indicators only. The secret or private key must never be included in the B32 address itself, as that would compromise security.\nCryptographic Details Blinding Scheme The blinding scheme uses RedDSA based on Ed25519 and ZCash\u0026rsquo;s design, producing Red25519 signatures over the Ed25519 curve using SHA-512. This approach ensures blinded public keys remain on the prime-order subgroup, avoiding the security concerns present in some alternative designs.\nBlinded keys rotate daily based on UTC date using the formula:\nblinded_key = BLIND(unblinded_key, date, optional_secret) The DHT storage location is computed as:\nSHA256(type_byte || blinded_public_key) Encryption The encrypted leaseset uses ChaCha20 stream cipher for encryption, chosen for superior performance on devices lacking AES hardware acceleration. The specification employs HKDF for key derivation and X25519 for Diffie-Hellman operations.\nEncrypted leasesets have a three-layer structure:\nOuter layer: plaintext metadata Middle layer: client authentication (DH or PSK methods) Inner layer: actual LS2 data with lease information Authentication Methods Per-client authentication supports two methods:\nDH Authentication: Uses X25519 key agreement. Each authorized client provides their public key to the server, and the server encrypts the middle layer using a shared secret derived from ECDH.\nPSK Authentication: Uses pre-shared keys directly for encryption.\nFlag bit 2 in the B32 address indicates whether per-client authentication is required.\nCaching While outside the scope of this specification, routers and clients must remember and cache (persistently recommended) the mapping of public key to destination, and vice versa.\nThe blockfile naming service, I2P\u0026rsquo;s default address book system since version 0.9.8, maintains multiple address books with a dedicated reverse-lookup map providing rapid lookups by hash. This functionality is critical for encrypted leaseset resolution when only a hash is initially known.\nSignature Types As of I2P version 2.10.0, signature types 0 through 11 are defined. Single-byte encoding remains standard, with two-byte encoding available but unused in practice.\nCommonly Used Types:\nType 0 (DSA_SHA1): Deprecated for routers, supported for destinations Type 7 (EdDSA_SHA512_Ed25519): Current standard for router identities and destinations Type 11 (RedDSA_SHA512_Ed25519): Exclusively for encrypted LS2 leasesets with blinding support Important Note: Only Ed25519 (type 7) and Red25519 (type 11) support the blinding necessary for encrypted leasesets. Other signature types cannot be used with this feature.\nTypes 9-10 (GOST algorithms) remain reserved but unimplemented. Types 4-6 and 8 are marked \u0026ldquo;offline only\u0026rdquo; for offline signing keys.\nNotes Distinguish old from new flavors by length. Old b32 addresses are always {52 chars}.b32.i2p. New ones are {56+ chars}.b32.i2p The base32 encoding follows RFC 4648 standards with case-insensitive decoding and lowercase output preferred Addresses can exceed 200 characters when using signature types with larger public keys (e.g., ECDSA P521 with 132-byte keys) New format can be used in jump links (and served by jump servers) if desired, just like standard b32 Blinded keys rotate daily based on UTC date to enhance privacy This format diverges from Tor\u0026rsquo;s rend-spec-v3.txt appendix A.2 approach, which has potential security implications with off-curve blinded public keys Version Compatibility This specification is accurate for I2P version 0.9.47 (August 2020) through version 2.10.0 (September 2025). No breaking changes have occurred to the B32 addressing format, encrypted LS2 structure, or cryptographic implementations during this period. All addresses created with 0.9.47 remain fully compatible with current versions.\nReferences CRC-32\nhttps://en.wikipedia.org/wiki/CRC-32 https://tools.ietf.org/html/rfc3309 I2P Specifications\nEncrypted LeaseSet Specification: /docs/specs/encryptedleaseset/ Proposal 123 (New netDB Entries): /proposals/123-new-netdb-entries/ Proposal 149 (B32 for Encrypted LS2): /proposals/149-b32-encrypted-ls2/ Common Structures Specification: /docs/specs/common-structures/ Naming and Address Book: /docs/overview/naming/ Tor Comparison\nTor discussion thread (design context): https://lists.torproject.org/pipermail/tor-dev/2017-January/011816.html Additional Resources\nI2P Project: / I2P Forum: https://i2pforum.net Java API Documentation: http://docs.i2p-projekt.de/javadoc/ ","description":"Base 32 address format for encrypted LS2 leasesets","id":"cac162c86c1b599cb6bab03e6270c404","section":"docs","title":"B32 for Encrypted Leasesets","url":"/en/docs/specs/b32-for-encrypted-leasesets/"},{"categories":null,"content":"Overview BitTorrent over I2P enables anonymous file sharing through encrypted tunnels using I2P’s streaming layer. All peers are identified by cryptographic I2P destinations instead of IP addresses. The system supports HTTP and UDP trackers, hybrid magnet links, and post-quantum hybrid encryption.\n1. Protocol Stack Layer Function Example Application BitTorrent i2psnark, BiglyBT Transport Streaming / SAM v3 I2CP, NTCP2 Network Garlic routing I2NP All connections run through I2P’s encrypted transport layer (NTCP2 or SSU2). Even UDP tracker packets are encapsulated within I2P streaming.\n2. Trackers HTTP Trackers Standard .i2p trackers respond to HTTP GET requests such as:\nhttp://tracker2.postman.i2p/announce?info_hash=\u0026lt;20-byte\u0026gt;\u0026amp;peer_id=\u0026lt;20-byte\u0026gt;\u0026amp;port=6881\u0026amp;uploaded=0\u0026amp;downloaded=0\u0026amp;left=1234\u0026amp;compact=1 Responses are bencoded and use I2P destination hashes for peers.\nUDP Trackers UDP trackers were standardized in 2025 (Proposal 160).\nPrimary UDP Trackers\nudp://tracker2.postman.i2p/announce udp://opentracker.simp.i2p/a http://opentracker.skank.i2p/a http://opentracker.dg2.i2p/a 3. Magnet Links magnet:?xt=urn:btih:\u0026lt;infohash\u0026gt;\u0026amp;dn=\u0026lt;name\u0026gt;\u0026amp;tr=http://tracker2.postman.i2p/announce\u0026amp;tr=udp://denpa.i2p/announce\u0026amp;xs=i2p:\u0026lt;destination.b32.i2p\u0026gt; Parameter Meaning xs=i2p:\u0026lt;dest\u0026gt; Explicit I2P destination tr= Tracker URLs (HTTP or UDP) dn= Display name Magnet links support hybrid swarms across I2P and clearnet when configured.\n4. DHT Implementations Implementation Type Status Java I2P Experimental overlay Stable i2pd UDP-based internal overlay Active BiglyBT SAM v3.3-based Fully supported 5. Client Implementations I2PSnark Bundled with all routers HTTP-only tracker support Built-in tracker at http://127.0.0.1:7658/ No UDP tracker support BiglyBT Full-featured with I2P plugin Supports HTTP + UDP trackers Hybrid torrent support Uses SAM v3.3 interface Tixati / XD Lightweight clients SAM-based tunneling Experimental ML-KEM hybrid encryption 6. Configuration I2PSnark i2psnark.dir=/home/user/torrents i2psnark.autostart=true i2psnark.maxUpBW=128 i2psnark.maxDownBW=256 i2psnark.enableDHT=false BiglyBT SAMHost=127.0.0.1 SAMPort=7656 SAMNickname=BiglyBT-I2P SAMAutoStart=true DHTEnabled=true 7. Security Model Component Description Encryption NTCP2 / SSU2 with X25519+ML-KEM hybrid Identity I2P destinations replace IP addresses Anonymity Peer info hidden; traffic multiplexed Leak Prevention Remove headers (X-Forwarded-For, Client-IP, Via) Hybrid (clearnet + I2P) torrents should be used only if anonymity isn’t critical.\n8. Performance Factor Impact Recommendation Tunnel length Adds latency 1-hop client, 2-hop server Peers Boosts speed 20+ active peers Compression Minimal gain Usually off Bandwidth Router-limited Default settings optimal Typical speeds range 30–80 KB/s, depending on peers and network conditions.\n9. Known Issues Partial DHT interoperability between Java I2P and i2pd Magnet metadata fetch delay under heavy load NTCP1 deprecated but still used by old peers UDP simulated over streaming increases latency 10. Future Roadmap QUIC-like multiplexing Full ML-KEM integration Unified hybrid swarm logic Improved reseed mirrors Adaptive DHT retries References BEP 15 – UDP Tracker Protocol Proposal 160 – UDP Tracker over I2P I2PSnark Docs Streaming Library Spec ","description":"Detailed specification and ecosystem overview for BitTorrent within the I2P network","id":"5d0ca50c8763996448d3099a14dc36b0","section":"docs","title":"BitTorrent over I2P","url":"/en/docs/applications/bittorrent/"},{"categories":null,"content":"Overview This document specifies the I2P blockfile file format and the tables in the hostsdb.blockfile used by the Blockfile Naming Service.\nFor background, see I2P Naming and Address Book.\nThe blockfile enables fast destination lookups in a compact binary format.\nCompared to the legacy hosts.txt system:\nDestinations are stored in binary, not Base64. Arbitrary metadata (e.g., added date, source, comments) can be attached. Lookup times are roughly 10× faster. Disk use increases modestly. A blockfile is an on-disk collection of sorted maps (key-value pairs) implemented as skiplists.\nIt was derived from the Metanotion Blockfile Database.\nThis specification first defines the file structure, then describes how it is used by the BlockfileNamingService.\nThe Blockfile Naming Service replaced the old hosts.txt implementation in I2P 0.8.8.\nOn initialization, it imports entries from privatehosts.txt, userhosts.txt, and hosts.txt.\nBlockfile Format The format is composed of 1024-byte pages, each prefixed with a magic number for integrity.\nPages are numbered starting at 1:\nPage Description 1 Superblock (starts at byte 0) 2 Metaindex skiplist (starts at byte 1024) All integers use network byte order (big-endian).\n2-byte values are unsigned; 4-byte values (page numbers) are signed and must be positive.\nThreading: The database is designed for single-threaded access; BlockfileNamingService provides synchronization.\nSuperblock Format Byte Contents 0-5 Magic number 0x3141de493250 (\"1A\" 0xde \"I2P\") 6 Major version 0x01 7 Minor version 0x02 8-15 File length (in bytes) 16-19 First free list page 20-21 Mounted flag (0x01 = yes) 22-23 Span size (max key/value pairs per span, 16 for hostsdb) 24-27 Page size (as of v1.2; 1024 before that) 28-1023 Unused Skip List Block Page Format Byte Contents 0-7 Magic 0x536b69704c697374 (\"SkipList\") 8-11 First span page 12-15 First level page 16-19 Size (total keys, valid at startup) 20-23 Spans (total spans, valid at startup) 24-27 Levels (total levels, valid at startup) 28-29 Span size (as of v1.2; used for new spans) 30-1023 Unused Skip Level Block Page Format Every level has a span, but not all spans have levels.\nByte Contents 0-7 Magic 0x42534c6576656c73 (\"BSLevels\") 8-9 Max height 10-11 Current height 12-15 Span page 16-… Next level pages (current height × 4 bytes, lowest first) \u0026mdash; Remaining bytes unused Skip Span Block Page Format Key/value pairs are sorted by key across spans.\nNon-first spans must not be empty.\nByte Contents 0-3 Magic 0x5370616e (\"Span\") 4-7 First continuation page or 0 8-11 Previous span page or 0 12-15 Next span page or 0 16-17 Max keys (16 for hostsdb) 18-19 Size (current keys) 20-1023 Key/value structures Span Continuation Block Page Format Byte Contents 0-3 Magic 0x434f4e54 (\"CONT\") 4-7 Next continuation page or 0 8-1023 Key/value structures Key/Value Structure Format Key and value length fields cannot span pages (all 4 bytes must fit).\nIf insufficient space remains, pad up to 3 bytes and continue at offset 8 of the next page.\nByte Contents 0-1 Key length (bytes) 2-3 Value length (bytes) 4-… Key data → Value data \u0026mdash; Max length = 65535 bytes each Free List Block Page Format Byte Contents 0-7 Magic 0x2366724c69737423 (\"#frList#\") 8-11 Next free list block or 0 12-15 Number of valid free pages (0 – 252) 16-1023 Free page numbers (4 bytes each) Free Page Block Format Byte Contents 0-7 Magic 0x7e2146524545217e (\"~!FREE!~\") 8-1023 Unused Metaindex Located at page 2.\nMaps US-ASCII strings → 4-byte integers.\nThe key is the skiplist name; the value is the page index.\nBlockfile Naming Service Tables The service defines several skiplists.\nEach span supports up to 16 entries.\nProperties Skiplist %%__INFO__%% contains one entry:\nKey Value info A Properties object (UTF-8 String / String map) serialized as a Mapping Typical fields:\nProperty Description version \"4\" created Java long (ms since epoch) upgraded Java long (ms since epoch, since DB v2) lists Comma-separated host DBs (e.g. privatehosts.txt,userhosts.txt,hosts.txt) listversion_* Version of each DB (used to detect partial upgrades, since v4) Reverse Lookup Skiplist %%__REVERSE__%% contains Integer → Properties entries (since DB v2).\nKey: First 4 bytes of the SHA-256 hash of the Destination. Value: Properties object (serialized Mapping). Multiple entries handle collisions and multi-hostname Destinations. Each property key = hostname; value = empty string. Host Database Skiplists Each of hosts.txt, userhosts.txt, and privatehosts.txt maps hostnames → Destinations.\nVersion 4 supports multiple Destinations per hostname (introduced in I2P 0.9.26).\nVersion 3 databases are migrated automatically.\nKey UTF-8 string (hostname, lowercase, ending in .i2p)\nValue Version 4: 1 byte count of Property/Destination pairs For each pair: Properties → Destination (binary) Version 3: Properties → Destination (binary) DestEntry Properties Key Meaning a Time added (Java long ms) m Last modified (Java long ms) notes User comments s Source (file or subscription URL) v Signature verified (true/false) Implementation Notes The BlockfileNamingService Java class implements this specification.\nOutside router context, the database opens read-only unless i2p.naming.blockfile.writeInAppContext=true. Not intended for multi-instance or multi-JVM access. Maintains three primary maps (privatehosts, userhosts, hosts) and a reverse map for fast lookups. References I2P Naming and Address Book Docs Common Structures Specification Metanotion Blockfile Database BlockfileNamingService JavaDoc ","description":"On-disk blockfile storage format used by I2P for hostname resolution","id":"5cbdbb030530ec5e0200cc202d4bff7f","section":"docs","title":"Blockfile Specification","url":"/en/docs/specs/blockfile/"},{"categories":null,"content":" Warning: BOB only supports the legacy DSA-SHA1 signature type. Java I2P stopped shipping BOB in 1.7.0 (2022-02); it remains only on installations that started with 1.6.1 or earlier and on some i2pd builds. New applications must use SAM v3.\nLanguage Bindings Go – ccondom Python – i2py-bob Twisted – txi2p C++ – bobcpp Protocol Notes KEYS denotes a base64 destination (public + private keys). KEY is a base64 public key. ERROR responses have the form ERROR \u0026lt;description\u0026gt;\\n. OK indicates command completion; optional data follows on the same line. DATA lines stream additional output before a final OK. The help command is the only exception: it may return nothing to signal “no such command”.\nConnection Banner BOB uses newline-terminated ASCII lines (LF or CRLF). On connect it emits:\nBOB \u0026lt;version\u0026gt; OK Current version: 00.00.10. Earlier builds used uppercase hex digits and non-standard numbering.\nBOB Version Router Version Notes 00.00.100.9.8Latest defined version 00.00.00 – 00.00.0F—Development builds Core Commands For complete command details, connect with telnet localhost 2827 and run help.\nCOMMAND OPERAND RETURNS help [command] NOTHING | OK \u0026lt;info\u0026gt; clear ERROR | OK getdest ERROR | OK \u0026lt;KEY\u0026gt; getkeys ERROR | OK \u0026lt;KEYS\u0026gt; getnick \u0026lt;tunnelname\u0026gt; ERROR | OK inhost \u0026lt;hostname | IP\u0026gt; ERROR | OK inport \u0026lt;port\u0026gt; ERROR | OK list ERROR | DATA... + OK lookup \u0026lt;hostname\u0026gt; ERROR | OK \u0026lt;KEY\u0026gt; nick \u0026lt;friendlyname\u0026gt; ERROR | OK outhost \u0026lt;hostname | IP\u0026gt; ERROR | OK outport \u0026lt;port\u0026gt; ERROR | OK quit ERROR | OK setkey \u0026lt;base64 destination\u0026gt; ERROR | OK start ERROR | OK status ERROR | DATA... + OK stop ERROR | OK Deprecation Summary BOB has no support for modern signature types, encrypted LeaseSets, or transport features. The API is frozen; no new commands will be added. Applications still relying on BOB should migrate to SAM v3 as soon as possible. ","description":"Deprecated API for destination management (deprecated)","id":"97b881216518f8e2516b859bbca19c0b","section":"docs","title":"BOB – Basic Open Bridge","url":"/en/docs/legacy/bob/"},{"categories":null,"content":"Overview This document specifies the fundamental data structures used across all I2P protocols, including I2NP, I2CP, SSU2, NTCP2, and others. These common structures ensure interoperability between different I2P implementations and protocol layers.\nKey Changes Since 0.9.58 ElGamal and DSA-SHA1 deprecated for Router Identities (use X25519 + EdDSA) Post-quantum ML-KEM support in beta testing (opt-in as of 2.10.0) Service record options standardized (Proposal 167, implemented 0.9.66) Compressible padding specifications finalized (Proposal 161, implemented 0.9.57) Common Type Specifications Integer Description: Represents a non-negative integer in network byte order (big-endian).\nContents: 1 to 8 bytes representing an unsigned integer.\nUsage: Field lengths, counts, type identifiers, and numeric values throughout I2P protocols.\nDate Description: Timestamp representing milliseconds since Unix epoch (January 1, 1970 00:00:00 GMT).\nContents: 8-byte Integer (unsigned long)\nSpecial Values:\n0 = Undefined or null date Maximum value: 0xFFFFFFFFFFFFFFFF (year 584,942,417,355) Implementation Notes:\nAlways UTC/GMT timezone Millisecond precision required Used for lease expiration, RouterInfo publication, and timestamp validation String Description: UTF-8 encoded string with length prefix.\nFormat:\n+----+----+----+----+----+----+ |len | UTF-8 encoded data... | +----+----+----+----+----+----+ len :: Integer (1 byte) Value: 0-255 (string length in bytes, NOT characters) data :: UTF-8 encoded bytes Length: 0-255 bytes Constraints:\nMaximum length: 255 bytes (not characters - multi-byte UTF-8 sequences count as multiple bytes) Length may be zero (empty string) Null terminator NOT included String is NOT null-terminated Important: UTF-8 sequences can use multiple bytes per character. A string with 100 characters might exceed the 255-byte limit if using multi-byte characters.\nCryptographic Key Structures PublicKey Description: Public key for asymmetric encryption. Key type and length are context-dependent or specified in a Key Certificate.\nDefault Type: ElGamal (deprecated for Router Identities as of 0.9.58)\nSupported Types:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations only (unused field)Deprecated for RIs P256164TBDBigReservedSee Proposal 145 P384296TBDBigReservedSee Proposal 145 P5213132TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-8000.9.67TBDHandshakes onlyBeta MLKEM768-11840.9.67TBDHandshakes onlyBeta MLKEM1024-15680.9.67TBDHandshakes onlyBeta MLKEM512_CT-7680.9.67TBDHandshakes onlyBeta MLKEM768_CT-10880.9.67TBDHandshakes onlyBeta MLKEM1024_CT-15680.9.67TBDHandshakes onlyBeta Implementation Requirements:\nX25519 (Type 4) - Current Standard:\nUsed for ECIES-X25519-AEAD-Ratchet encryption Mandatory for Router Identities since 0.9.48 Little-endian encoding (unlike other types) See ECIES and ECIES-ROUTERS ElGamal (Type 0) - Legacy:\nDeprecated for Router Identities as of 0.9.58 Still valid for Destinations (field unused since 0.6/2005) Uses constant primes defined in ElGamal specification Support maintained for backward compatibility MLKEM (Post-Quantum) - Beta:\nHybrid approach combines ML-KEM with X25519 NOT enabled by default in 2.10.0 Requires manual activation via Hidden Service Manager See ECIES-HYBRID and Proposal 169 Type codes and specifications subject to change JavaDoc: PublicKey\nPrivateKey Description: Private key for asymmetric decryption, corresponding to PublicKey types.\nStorage: Type and length inferred from context or stored separately in data structures/key files.\nSupported Types:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations onlyDeprecated for RIs P256132TBDBigReservedSee Proposal 145 P384248TBDBigReservedSee Proposal 145 P521366TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-16320.9.67TBDHandshakes onlyBeta MLKEM768-24000.9.67TBDHandshakes onlyBeta MLKEM1024-31680.9.67TBDHandshakes onlyBeta Security Notes:\nPrivate keys MUST be generated using cryptographically secure random number generators X25519 private keys use scalar clamping as defined in RFC 7748 Key material MUST be securely erased from memory when no longer needed JavaDoc: PrivateKey\nSessionKey Description: Symmetric key for AES-256 encryption and decryption in I2P\u0026rsquo;s tunnel and garlic encryption.\nContents: 32 bytes (256 bits)\nUsage:\nTunnel layer encryption (AES-256/CBC with IV) Garlic message encryption End-to-end session encryption Generation: MUST use cryptographically secure random number generator.\nJavaDoc: SessionKey\nSigningPublicKey Description: Public key for signature verification. Type and length specified in Key Certificate of Destination or inferred from context.\nDefault Type: DSA_SHA1 (deprecated as of 0.9.58)\nSupported Types:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA10128-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Reserved (GOST)964-BigReservedProposal 134 Reserved (GOST)10128-BigReservedProposal 134 Reserved (MLDSA)12-20TBD-TBDReservedProposal 169 Experimental65280-65534Varies-VariesTesting onlyNever production Reserved65535---Future expansion- Implementation Requirements:\nEdDSA_SHA512_Ed25519 (Type 7) - Current Standard:\nDefault for all new Router Identities and Destinations since late 2015 Uses Ed25519 curve with SHA-512 hashing 32-byte public keys, 64-byte signatures Little-endian encoding (unlike most other types) High performance and security RedDSA_SHA512_Ed25519 (Type 11) - Specialized:\nUsed ONLY for encrypted leasesets and blinding Never used for Router Identities or standard Destinations Key differences from EdDSA: Private keys via modular reduction (not clamping) Signatures include 80 bytes of random data Uses public keys directly (not hashes of private keys) See [Red25519 specification](//docs/specs/red25519-signature-scheme/ DSA_SHA1 (Type 0) - Legacy:\nDeprecated for Router Identities as of 0.9.58 Discouraged for new Destinations 1024-bit DSA with SHA-1 (known weaknesses) Support maintained for compatibility only Multi-element Keys:\nWhen composed of two elements (e.g., ECDSA points X,Y) Each element padded to length/2 with leading zeros Example: 64-byte ECDSA key = 32-byte X + 32-byte Y JavaDoc: SigningPublicKey\nSigningPrivateKey Description: Private key for creating signatures, corresponding to SigningPublicKey types.\nStorage: Type and length specified at creation time.\nSupported Types:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1020-BigLegacy onlyDeprecated ECDSA_SHA256_P2561320.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842480.9.12BigRareDeprecated ECDSA_SHA512_P5213660.9.12BigRareDeprecated RSA_SHA256_204845120.9.12BigOffline signing onlyDeprecated RSA_SHA384_307257680.9.12BigOffline signing onlyDeprecated RSA_SHA512_4096610240.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Security Requirements:\nGenerate using cryptographically secure random source Protect with appropriate access controls Securely erase from memory when finished For EdDSA: 32-byte seed hashed with SHA-512, first 32 bytes become scalar (clamped) For RedDSA: Different key generation (modular reduction instead of clamping) JavaDoc: SigningPrivateKey\nSignature Description: Cryptographic signature over data, using the signing algorithm corresponding to the SigningPrivateKey type.\nType and Length: Inferred from the key type used for signing.\nSupported Types:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1040-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyCurrent for SU3 EdDSA_SHA512_Ed255197640.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8640.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911640.9.39LittleEncrypted leasesets onlySpecialized Format Notes:\nMulti-element signatures (e.g., ECDSA R,S values) are padded to length/2 per element with leading zeros EdDSA and RedDSA use little-endian encoding All other types use big-endian encoding Verification:\nUse the corresponding SigningPublicKey Follow the signature algorithm specifications for the key type Check that signature length matches expected length for the key type JavaDoc: Signature\nHash Description: SHA-256 hash of data, used throughout I2P for integrity verification and identification.\nContents: 32 bytes (256 bits)\nUsage:\nRouter Identity hashes (network database keys) Destination hashes (network database keys) Tunnel gateway identification in Leases Data integrity verification Tunnel ID generation Algorithm: SHA-256 as defined in FIPS 180-4\nJavaDoc: Hash\nSession Tag Description: Random number used for session identification and tag-based encryption.\nImportant: Session Tag size varies by encryption type:\nElGamal/AES+SessionTag: 32 bytes (legacy) ECIES-X25519: 8 bytes (current standard) Current Standard (ECIES):\nContents: 8 bytes Usage: Ratchet-based encryption for Destinations and Routers See ECIES and ECIES-ROUTERS for detailed specifications.\nLegacy (ElGamal/AES):\nContents: 32 bytes Usage: Deprecated encryption scheme Generation: MUST use cryptographically secure random number generator.\nJavaDoc: SessionTag\nTunnelId Description: Unique identifier for a router\u0026rsquo;s position in a tunnel. Each hop in a tunnel has its own TunnelId.\nFormat:\nContents: 4-byte Integer (unsigned 32-bit) Range: Generally \u0026gt; 0 (zero reserved for special cases) Usage:\nIdentifies incoming/outgoing tunnel connections at each router Different TunnelId at each hop in the tunnel chain Used in Lease structures to identify gateway tunnels Special Values:\n0 = Reserved for special protocol uses (avoid in normal operation) TunnelIds are locally significant to each router JavaDoc: TunnelId\nCertificate Specifications Certificate Description: Container for receipts, proof-of-work, or cryptographic metadata used throughout I2P.\nFormat:\n+----+----+----+----+----+----+-// |type| length | payload +----+----+----+----+----+----+-// type :: Integer (1 byte) Values: 0-5 (see types below) length :: Integer (2 bytes, big-endian) Size of payload in bytes payload :: data length -\u0026gt; $length bytes Total Size: 3 bytes minimum (NULL certificate), up to 65538 bytes maximum\nCertificate Types Type Code Payload Length Total Size Status Usage NULL003CurrentDefault/empty certificate HASHCASH1VariesVariesDeprecatedUnused (was for proof-of-work) HIDDEN203DeprecatedUnused (hidden routers don't advertise) SIGNED340 or 7243 or 75DeprecatedUnused (DSA signature ± destination hash) MULTIPLE4VariesVariesDeprecatedUnused (multiple certificates) KEY54+7+CurrentSpecifies key types (see below) Key Certificate (Type 5) Introduction: Version 0.9.12 (December 2013)\nPurpose: Specifies non-default key types and stores excess key data beyond the standard 384-byte KeysAndCert structure.\nPayload Structure:\n+----+----+----+----+----+----+----+----+-// |SPKtype|CPKtype| Excess SPK data | +----+----+----+----+----+----+----+----+-// | Excess CPK data... | +----+----+----+----+----+----+----+----+ SPKtype :: Signing Public Key Type (2 bytes) See SigningPublicKey table above CPKtype :: Crypto Public Key Type (2 bytes) See PublicKey table above Excess SPK data :: Signing key bytes beyond 128 bytes Length: 0 to 65531 bytes Excess CPK data :: Crypto key bytes beyond 256 bytes Length: 0 to remaining space Critical Implementation Notes:\nKey Type Order:\nWARNING: Signing key type comes BEFORE Crypto key type This is counterintuitive but maintained for compatibility Order: SPKtype, CPKtype (not CPKtype, SPKtype) Key Data Layout in KeysAndCert:\n[Crypto Public Key (partial/complete)] [Padding (if total key lengths \u0026lt; 384)] [Signing Public Key (partial/complete)] [Certificate Header (3 bytes)] [Key Certificate (4+ bytes)] [Excess Signing Key Data] [Excess Crypto Key Data] Calculating Excess Key Data:\nIf Crypto Key \u0026gt; 256 bytes: Excess = (Crypto Length - 256) If Signing Key \u0026gt; 128 bytes: Excess = (Signing Length - 128) Padding = max(0, 384 - Crypto Length - Signing Length) Examples (ElGamal Crypto Key):\nSigning Key Type Total SPK Length Padding Excess in Cert Total Structure Size DSA_SHA112800387 + 7 = 394 ECDSA_P25664640387 + 7 = 394 ECDSA_P38496320387 + 7 = 394 ECDSA_P52113204387 + 11 = 398 RSA_20482560128387 + 135 = 522 RSA_40965120384387 + 391 = 778 EdDSA32960387 + 7 = 394 Router Identity Requirements:\nNULL certificate used until version 0.9.15 Key Certificate required for non-default key types since 0.9.16 X25519 encryption keys supported since 0.9.48 Destination Requirements:\nNULL certificate OR Key Certificate (as needed) Key Certificate required for non-default signing key types since 0.9.12 Crypto public key field unused since 0.6 (2005) but must still be present Important Warnings:\nNULL vs KEY Certificate:\nA KEY certificate with types (0,0) specifying ElGamal+DSA_SHA1 is allowed but discouraged Always use NULL certificate for ElGamal+DSA_SHA1 (canonical representation) KEY certificate with (0,0) is 4 bytes longer and may cause compatibility issues Some implementations may not handle (0,0) KEY certificates correctly Excess Data Validation:\nImplementations MUST verify certificate length matches expected length for key types Reject certificates with excess data that doesn\u0026rsquo;t correspond to key types Prohibit trailing garbage data after valid certificate structure JavaDoc: Certificate\nMapping Description: Key-value property collection used for configuration and metadata.\nFormat:\n+----+----+----+----+----+----+----+----+ | size | key_string (len + data)| = | +----+----+----+----+----+----+----+----+ | val_string (len + data) | ; | ... +----+----+----+----+----+----+----+ size :: Integer (2 bytes, big-endian) Total number of bytes that follow (not including size field) Range: 0 to 65535 key_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes = :: Single byte (0x3D, \u0026#39;=\u0026#39; character) val_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes ; :: Single byte (0x3B, \u0026#39;;\u0026#39; character) [Repeat key_string = val_string ; for additional entries] Size Limits:\nKey length: 0-255 bytes (+ 1 length byte) Value length: 0-255 bytes (+ 1 length byte) Total mapping size: 0-65535 bytes (+ 2 size field bytes) Maximum structure size: 65537 bytes Critical Sorting Requirement:\nWhen mappings appear in signed structures (RouterInfo, RouterAddress, Destination properties, I2CP SessionConfig), entries MUST be sorted by key to ensure signature invariance:\nSort Method: Lexicographic ordering using Unicode code point values (equivalent to Java String.compareTo()) Case Sensitivity: Keys and values are generally case-sensitive (application-dependent) Duplicate Keys: NOT allowed in signed structures (will cause signature verification failure) Character Encoding: UTF-8 byte-level comparison Why Sorting Matters:\nSignatures are computed over the byte representation Different key orders produce different signatures Unsigned mappings don\u0026rsquo;t require sorting but should follow the same convention Implementation Notes:\nEncoding Redundancy:\nBoth = and ; delimiters AND string length bytes are present This is inefficient but maintained for compatibility Length bytes are authoritative; delimiters are required but redundant Character Support:\nDespite documentation, = and ; ARE supported within strings (length bytes handle this) UTF-8 encoding supports full Unicode Warning: I2CP uses UTF-8, but I2NP historically did not handle UTF-8 correctly Use ASCII for I2NP mappings when possible for maximum compatibility Special Contexts:\nRouterInfo/RouterAddress: MUST be sorted, no duplicates I2CP SessionConfig: MUST be sorted, no duplicates Application mappings: Sorting recommended but not always required Example (RouterInfo options):\nMapping size: 45 bytes Sorted entries: caps=L (capabilities) netId=2 (network ID) router.version=0.9.67 JavaDoc: DataHelper\nCommon Structure Specification KeysAndCert Description: Fundamental structure combining encryption key, signing key, and certificate. Used as both RouterIdentity and Destination.\nStructure:\n+----+----+----+----+----+----+----+----+ | public_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | padding (optional) | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | certificate | +----+----+----+-// public_key :: PublicKey (partial or full) Default: 256 bytes (ElGamal) Other sizes: As specified in Key Certificate padding :: Random data Length: 0 bytes or as needed CONSTRAINT: public_key + padding + signing_key = 384 bytes signing_key :: SigningPublicKey (partial or full) Default: 128 bytes (DSA_SHA1) Other sizes: As specified in Key Certificate certificate :: Certificate Minimum: 3 bytes (NULL certificate) Common: 7 bytes (Key Certificate with default keys) TOTAL LENGTH: 387+ bytes (never assume exactly 387!) Key Alignment:\nCrypto Public Key: Aligned at start (byte 0) Padding: In the middle (if needed) Signing Public Key: Aligned at end (byte 256 to byte 383) Certificate: Starts at byte 384 Size Calculation:\nTotal size = 384 + 3 + key_certificate_length For NULL certificate (ElGamal + DSA_SHA1): Total = 384 + 3 = 387 bytes For Key Certificate (EdDSA + X25519): Total = 384 + 3 + 4 = 391 bytes For larger keys (e.g., RSA_4096): Total = 384 + 3 + 4 + excess_key_data_length Padding Generation Guidelines (Proposal 161) Implementation Version: 0.9.57 (January 2023, release 2.1.0)\nBackground:\nFor non-ElGamal+DSA keys, padding is present in the 384-byte fixed structure For Destinations, the 256-byte public key field has been unused since 0.6 (2005) Padding should be generated to be compressible while remaining secure Requirements:\nMinimum Random Data:\nUse at least 32 bytes of cryptographically secure random data This provides sufficient entropy for security Compression Strategy:\nRepeat the 32 bytes throughout the padding/public key field Protocols like I2NP Database Store, Streaming SYN, SSU2 handshake use compression Significant bandwidth savings without compromising security Examples:\nRouter Identity (X25519 + EdDSA):\nStructure: - 32 bytes X25519 public key - 320 bytes padding (10 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~288 bytes when compressed Destination (ElGamal-unused + EdDSA):\nStructure: - 256 bytes unused ElGamal field (11 copies of 32-byte random data, truncated to 256) - 96 bytes padding (3 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~320 bytes when compressed Why This Works:\nSHA-256 hash of the complete structure still includes all entropy Network database DHT distribution depends only on the hash Signing key (32 bytes EdDSA/X25519) provides 256 bits of entropy Additional 32 bytes of repeated random data = 512 bits total entropy More than sufficient for cryptographic strength Implementation Notes:\nMUST store and transmit the full 387+ byte structure SHA-256 hash computed over complete uncompressed structure Compression applied at protocol layer (I2NP, Streaming, SSU2) Backward compatible with all versions since 0.6 (2005) JavaDoc: KeysAndCert\nRouterIdentity Description: Uniquely identifies a router in the I2P network. Identical structure to KeysAndCert.\nFormat: See KeysAndCert structure above\nCurrent Requirements (as of 0.9.58):\nMandatory Key Types:\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Deprecated Key Types:\nElGamal (type 0) deprecated for Router Identities as of 0.9.58 DSA_SHA1 (type 0) deprecated for Router Identities as of 0.9.58 These should NOT be used for new routers Typical Size:\nX25519 + EdDSA with Key Certificate = 391 bytes 32 bytes X25519 public key 320 bytes padding (compressible per Proposal 161) 32 bytes EdDSA public key 7 bytes certificate (3-byte header + 4-byte key types) Historical Evolution:\nPre-0.9.16: Always NULL certificate (ElGamal + DSA_SHA1) 0.9.16-0.9.47: Key Certificate support added 0.9.48+: X25519 encryption keys supported 0.9.58+: ElGamal and DSA_SHA1 deprecated Network Database Key:\nRouterInfo keyed by SHA-256 hash of complete RouterIdentity Hash computed over full 391+ byte structure (including padding) See Also:\nPadding generation guidelines (Proposal 161) Key Certificate specification above JavaDoc: RouterIdentity\nDestination Description: Endpoint identifier for secure message delivery. Structurally identical to KeysAndCert, but with different usage semantics.\nFormat: See KeysAndCert structure above\nCritical Difference from RouterIdentity:\nPublic key field is UNUSED and may contain random data This field has been unused since version 0.6 (2005) Was originally for old I2CP-to-I2CP encryption (disabled) Currently only used as IV for deprecated LeaseSet encryption Current Recommendations:\nSigning Key:\nRecommended: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Alternative: ECDSA types for older compatibility Avoid: DSA_SHA1 (deprecated, discouraged) Encryption Key:\nField is unused but must be present Recommended: Fill with random data per Proposal 161 (compressible) Size: Always 256 bytes (ElGamal slot, even though not used for ElGamal) Certificate:\nNULL certificate for ElGamal + DSA_SHA1 (legacy only) Key Certificate for all other signing key types Typical Modern Destination:\nStructure: - 256 bytes unused field (random data, compressible) - 96 bytes padding (random data, compressible) - 32 bytes EdDSA signing public key - 7 bytes Key Certificate Total: 391 bytes Compression savings: ~320 bytes Actual Encryption Key:\nEncryption key for the Destination is in the LeaseSet, not the Destination LeaseSet contains current encryption public key(s) See LeaseSet2 specification for encryption key handling Network Database Key:\nLeaseSet keyed by SHA-256 hash of complete Destination Hash computed over full 387+ byte structure JavaDoc: Destination\nNetwork Database Structures Lease Description: Authorizes a specific tunnel to receive messages for a Destination. Part of the original LeaseSet format (type 1).\nFormat:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date +----+----+----+----+----+----+----+----+ | +----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of the gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at the gateway router end_date :: Date (8 bytes) Expiration timestamp in milliseconds since epoch Total Size: 44 bytes\nUsage:\nUsed only in original LeaseSet (type 1, deprecated) For LeaseSet2 and later variants, use Lease2 instead JavaDoc: Lease\nLeaseSet (Type 1) Description: Original LeaseSet format. Contains authorized tunnels and keys for a Destination. Stored in network database. Status: Deprecated (use LeaseSet2 instead).\nStructure:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | encryption_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease ($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes encryption_key :: PublicKey (256 bytes, ElGamal) Used for end-to-end ElGamal/AES+SessionTag encryption Generated anew at each router startup (not persistent) signing_key :: SigningPublicKey (128+ bytes) Same type as Destination signing key Used for LeaseSet revocation (unimplemented) Generated anew at each router startup (not persistent) num :: Integer (1 byte) Number of Leases to follow Range: 0-16 leases :: Array of Lease structures Length: $num × 44 bytes Each Lease is 44 bytes signature :: Signature (40+ bytes) Length determined by Destination signing key type Signed by Destination\u0026#39;s SigningPrivateKey Database Storage:\nDatabase Type: 1 Key: SHA-256 hash of Destination Value: Complete LeaseSet structure Important Notes:\nDestination Public Key Unused:\nThe encryption public key field in the Destination is unused Encryption key in the LeaseSet is the actual encryption key Temporary Keys:\nencryption_key is temporary (regenerated at router startup) signing_key is temporary (regenerated at router startup) Neither key is persistent across restarts Revocation (Unimplemented):\nsigning_key was intended for LeaseSet revocation Revocation mechanism never implemented Zero-lease LeaseSet was intended for revocation but is unused Versioning/Timestamp:\nLeaseSet has no explicit published timestamp field Version is the earliest expiration of all leases New LeaseSet must have earlier lease expiration to be accepted Lease Expiration Publishing:\nPre-0.9.7: All leases published with same expiration (earliest) 0.9.7+: Actual individual lease expirations published This is an implementation detail, not part of the specification Zero Leases:\nLeaseSet with zero leases is technically allowed Intended for revocation (unimplemented) Unused in practice LeaseSet2 variants require at least one Lease Deprecation: LeaseSet type 1 is deprecated. New implementations should use LeaseSet2 (type 3) which provides:\nPublished timestamp field (better versioning) Multiple encryption key support Offline signature capability 4-byte lease expirations (vs 8-byte) More flexible options JavaDoc: LeaseSet\nLeaseSet Variants Lease2 Description: Improved lease format with 4-byte expiration. Used in LeaseSet2 (type 3) and MetaLeaseSet (type 7).\nIntroduction: Version 0.9.38 (see Proposal 123)\nFormat:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at gateway end_date :: 4-byte timestamp (seconds since epoch) Rolls over in year 2106 Total Size: 40 bytes (4 bytes smaller than original Lease)\nComparison with Original Lease:\nFeature Lease (Type\u0026nbsp;1) Lease2 (Type\u0026nbsp;3+) Size44 bytes40 bytes Expiration Size8 bytes (ms)4 bytes (seconds) PrecisionMillisecondSecond RolloverYear\u0026nbsp;292,277,026,596Year\u0026nbsp;2106 Used InLeaseSet (deprecated)LeaseSet2, MetaLeaseSet JavaDoc: Lease2\nOfflineSignature Description: Optional structure for pre-signed transient keys, allowing LeaseSet publication without online access to the Destination\u0026rsquo;s private signing key.\nIntroduction: Version 0.9.38 (see Proposal 123)\nFormat:\n+----+----+----+----+----+----+----+----+ | expires | sigtype | | +----+----+----+----+----+----+ + | transient_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ expires :: 4-byte timestamp (seconds since epoch) Expiration of transient key validity Rolls over in year 2106 sigtype :: 2-byte signature type Type of transient_public_key (see SigningPublicKey types) transient_public_key :: SigningPublicKey Length determined by sigtype Temporary signing key for LeaseSet signature :: Signature Length determined by Destination\u0026#39;s signing key type Signature of (expires || sigtype || transient_public_key) Signed by Destination\u0026#39;s permanent SigningPrivateKey Purpose:\nEnables offline LeaseSet generation Protects Destination master key from online exposure Transient key can be revoked by publishing new LeaseSet without offline signature Usage Scenarios:\nHigh-Security Destinations:\nMaster signing key stored offline (HSM, cold storage) Transient keys generated offline for limited time periods Compromised transient key doesn\u0026rsquo;t expose master key Encrypted LeaseSet Publishing:\nEncryptedLeaseSet can include offline signature Blinded public key + offline signature provides additional security Security Considerations:\nExpiration Management:\nSet reasonable expiration (days to weeks, not years) Generate new transient keys before expiration Shorter expiration = better security, more maintenance Key Generation:\nGenerate transient keys offline in secure environment Sign with master key offline Transfer only signed transient key + signature to online router Revocation:\nPublish new LeaseSet without offline signature to implicitly revoke Or publish new LeaseSet with different transient key Signature Verification:\nData to sign: expires (4 bytes) || sigtype (2 bytes) || transient_public_key Verification: 1. Extract Destination from LeaseSet 2. Get Destination\u0026#39;s SigningPublicKey 3. Verify signature over (expires || sigtype || transient_public_key) 4. Check that current time \u0026lt; expires 5. If valid, use transient_public_key to verify LeaseSet signature Implementation Notes:\nTotal size varies based on sigtype and Destination signing key type Minimum size: 4 + 2 + 32 (EdDSA key) + 64 (EdDSA signature) = 102 bytes Maximum practical size: ~600 bytes (RSA-4096 transient key + RSA-4096 signature) Compatible With:\nLeaseSet2 (type 3) EncryptedLeaseSet (type 5) MetaLeaseSet (type 7) See Also: Proposal 123 for detailed offline signature protocol.\nLeaseSet2Header Description: Common header structure for LeaseSet2 (type 3) and MetaLeaseSet (type 7).\nIntroduction: Version 0.9.38 (see Proposal 123)\nFormat:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes published :: 4-byte timestamp (seconds since epoch) Publication time of this LeaseSet Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published timestamp Maximum: 65535 seconds (18.2 hours) flags :: 2 bytes (bit flags) See flag definitions below offline_signature :: OfflineSignature (optional) Present only if flags bit 0 is set Variable length Minimum Total Size: 395 bytes (without offline signature)\nFlag Definitions (bit order: 15 14 \u0026hellip; 3 2 1 0):\nBit Name Description 0Offline Keys0 = No offline keys, 1 = Offline signature present 1Unpublished0 = Standard published, 1 = Unpublished (client-side only) 2Blinded0 = Standard, 1 = Will be blinded when published 3-15ReservedMust be 0 for compatibility Flag Details:\nBit 0 - Offline Keys:\n0: No offline signature, use Destination\u0026rsquo;s signing key to verify LeaseSet signature 1: OfflineSignature structure follows flags field Bit 1 - Unpublished:\n0: Standard published LeaseSet, should be flooded to floodfills 1: Unpublished LeaseSet (client-side only) Should NOT be flooded, published, or sent in response to queries If expired, do NOT query netdb for replacement (unless bit 2 also set) Used for local tunnels or testing Bit 2 - Blinded (since 0.9.42):\n0: Standard LeaseSet 1: This unencrypted LeaseSet will be blinded and encrypted when published Published version will be EncryptedLeaseSet (type 5) If expired, query the blinded location in netdb for replacement Must also set bit 1 to 1 (unpublished + blinded) Used for encrypted hidden services Expiration Limits:\nLeaseSet Type Maximum Expires Value Maximum Actual Time LeaseSet2 (type 3)≈660 seconds≈11 minutes MetaLeaseSet (type 7)65,535 seconds≈18.2 hours Published Timestamp Requirements:\nLeaseSet (type 1) did not have a published field, requiring searching for earliest lease expiration for versioning. LeaseSet2 adds explicit published timestamp with 1-second resolution.\nCritical Implementation Note:\nRouters MUST rate-limit LeaseSet publishing to much slower than once per second per Destination If publishing faster, ensure each new LeaseSet has published time at least 1 second later Floodfills will reject LeaseSet if published time is not newer than current version Recommended minimum interval: 10-60 seconds between publications Calculation Examples:\nLeaseSet2 (11-minute max):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 660 (seconds) Actual expiration = 1704067200 + 660 = 1704067860 (2024-01-01 00:11:00 UTC) MetaLeaseSet (18.2-hour max):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 65535 (seconds) Actual expiration = 1704067200 + 65535 = 1704132735 (2024-01-01 18:12:15 UTC) Versioning:\nLeaseSet is considered \u0026ldquo;newer\u0026rdquo; if published timestamp is greater Floodfills store and flood only the newest version Take care when oldest Lease matches previous LeaseSet\u0026rsquo;s oldest Lease LeaseSet2 (Type 3) Description: Modern LeaseSet format with multiple encryption keys, offline signatures, and service records. Current standard for I2P hidden services.\nIntroduction: Version 0.9.38 (see Proposal 123)\nStructure:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numk| keytype0| keylen0 | | +----+----+----+----+----+ + | encryption_key_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | keytypen| keylenn | | +----+----+----+----+ + | encryption_key_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease2 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease2($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes (varies with offline signature) options :: Mapping Key-value pairs for service records and metadata Length: 2+ bytes (size field + data) numk :: Integer (1 byte) Number of encryption keys Range: 1 to (implementation-defined maximum, typically 8) keytype :: 2-byte encryption type See PublicKey type table keylen :: 2-byte key length Must match keytype specification encryption_key :: PublicKey Length: keylen bytes Type: keytype [Repeat keytype/keylen/encryption_key for each key] num :: Integer (1 byte) Number of Lease2s Range: 1-16 (at least one required) leases :: Array of Lease2 structures Length: $num × 40 bytes signature :: Signature Length determined by signing key type Signed over entire structure including database type prefix Database Storage:\nDatabase Type: 3 Key: SHA-256 hash of Destination Value: Complete LeaseSet2 structure Signature Computation:\nData to sign: database_type (1 byte, value=3) || complete LeaseSet2 data Verification: 1. Prepend database type byte (0x03) to LeaseSet2 data 2. If offline signature present: - Verify offline signature against Destination key - Verify LeaseSet2 signature against transient key 3. Else: - Verify LeaseSet2 signature against Destination key Encryption Key Preference Order For Published (Server) LeaseSet:\nKeys listed in order of server preference (most preferred first) Clients supporting multiple types SHOULD honor server preference Select first supported type from the list Generally, higher-numbered (newer) key types are more secure/efficient Recommended order: List keys in reverse order by type code (newest first) Example Server Preference:\nnumk = 2 Key 0: X25519 (type 4, 32 bytes) [Most preferred] Key 1: ElGamal (type 0, 256 bytes) [Legacy compatibility] For Unpublished (Client) LeaseSet:\nKey order effectively doesn\u0026rsquo;t matter (connections rarely attempted to clients) Follow same convention for consistency Client Key Selection:\nHonor server preference (select first supported type) Or use implementation-defined preference Or determine combined preference based on both capabilities Options Mapping Requirements:\nOptions MUST be sorted by key (lexicographic, UTF-8 byte order) Sorting ensures signature invariance Duplicate keys NOT allowed Standard Format (Proposal 167):\nAs of API 0.9.66 (June 2025, release 2.9.0), service record options follow a standardized format. See Proposal 167 for complete specification.\nService Record Option Format:\nKey: _service._proto Value: record_type ttl [priority weight] port target [appoptions] service :: Symbolic name of service (lowercase, [a-z0-9-]) Examples: smtp, http, irc, mumble Use standard identifiers from IANA Service Name Registry or Linux /etc/services when available proto :: Transport protocol (lowercase, [a-z0-9-]) \u0026#34;tcp\u0026#34; = streaming protocol \u0026#34;udp\u0026#34; = repliable datagrams Protocol indicators for raw datagrams may be defined later record_type :: \u0026#34;0\u0026#34; (self-reference) or \u0026#34;1\u0026#34; (SRV record) ttl :: Time to live in seconds (positive integer) Recommended minimum: 86400 (one day) Prevents frequent re-queries For record_type = 0 (self-reference): port :: I2CP port number (non-negative integer) appoptions :: Optional application-specific data (no spaces or commas) For record_type = 1 (SRV record): priority :: Lower value = more preferred (non-negative integer) weight :: Relative weight for same priority, higher = more likely (non-negative) port :: I2CP port number (non-negative integer) target :: Hostname or b32 of destination (lowercase) Format: \u0026#34;example.i2p\u0026#34; or \u0026#34;aaaaa...aaaa.b32.i2p\u0026#34; Recommend b32 unless hostname is \u0026#34;well known\u0026#34; appoptions :: Optional application-specific data (no spaces or commas) Example Service Records:\n1. Self-Referencing SMTP Server:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;0 999999 25\u0026#34; Meaning: This destination provides SMTP service on I2CP port 25 2. Single External SMTP Server:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p\u0026#34; Meaning: SMTP service provided by bbbb...bbbb on port 25 TTL = 1 day, single server (priority=0, weight=0) 3. Multiple SMTP Servers (Load Balancing):\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p,1 86400 1 0 25 cccc...cccc.b32.i2p\u0026#34; Meaning: Two SMTP servers bbbb...bbbb (priority=0, preferred) cccc...cccc (priority=1, backup) 4. HTTP Service with App Options:\nOption: \u0026#34;_http._tcp\u0026#34; = \u0026#34;0 86400 80 tls=1.3;cert=ed25519\u0026#34; Meaning: HTTP on port 80 with TLS 1.3 and EdDSA certificates TTL Recommendations:\nMinimum: 86400 seconds (1 day) Longer TTL reduces netdb query load Balance between query reduction and service update propagation For stable services: 604800 (7 days) or longer Implementation Notes:\nEncryption Keys (as of 0.9.44):\nElGamal (type 0, 256 bytes): Legacy compatibility X25519 (type 4, 32 bytes): Current standard MLKEM variants: Post-quantum (beta, not finalized) Key Length Validation:\nFloodfills and clients MUST be able to parse unknown key types Use keylen field to skip unknown keys Do not fail parsing if key type is unknown Published Timestamp:\nSee LeaseSet2Header notes about rate-limiting Minimum 1-second increment between publications Recommended: 10-60 seconds between publications Encryption Type Migration:\nMultiple keys support gradual migration List both old and new keys during transition period Remove old key after sufficient client upgrade period JavaDoc: LeaseSet2\nMetaLease Description: Lease structure for MetaLeaseSet that can reference other LeaseSets rather than tunnels. Used for load balancing and redundancy.\nIntroduction: Version 0.9.38, scheduled working 0.9.40 (see Proposal 123)\nFormat:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | flags |cost| end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of: - Gateway RouterIdentity (for type 1), OR - Another MetaLeaseSet destination (for type 3/5/7) flags :: 3 bytes Bit order: 23 22 ... 3 2 1 0 Bits 3-0: Entry type (see table below) Bits 23-4: Reserved (must be 0) cost :: 1 byte (0-255) Lower value = higher priority Used for load balancing end_date :: 4-byte timestamp (seconds since epoch) Expiration time Rolls over in year 2106 Total Size: 40 bytes\nEntry Type (flags bits 3-0):\nType Code Description Unknown0Unknown/invalid entry LeaseSet1Points to LeaseSet (type 1, deprecated) LeaseSet23Points to LeaseSet2 (type 3) EncryptedLeaseSet5Points to EncryptedLeaseSet (type 5) MetaLeaseSet7Points to another MetaLeaseSet (type 7) Usage Scenarios:\nLoad Balancing:\nMetaLeaseSet with multiple MetaLease entries Each entry points to different LeaseSet2 Clients select based on cost field Redundancy:\nMultiple entries pointing to backup LeaseSets Fallback if primary LeaseSet unavailable Service Migration:\nMetaLeaseSet points to new LeaseSet Allows smooth transition between Destinations Cost Field Usage:\nLower cost = higher priority Cost 0 = highest priority Cost 255 = lowest priority Clients SHOULD prefer lower-cost entries Equal-cost entries may be load-balanced randomly Comparison with Lease2:\nFeature Lease2 MetaLease Size40 bytes40 bytes Tunnel ID4 bytesReplaced by flags (3 bytes) + cost (1 byte) Points ToSpecific tunnelLeaseSet or MetaLeaseSet UsageDirect tunnel referenceIndirection/load balancing JavaDoc: MetaLease\nMetaLeaseSet (Type 7) Description: LeaseSet variant that contains MetaLease entries, providing indirection to other LeaseSets. Used for load balancing, redundancy, and service migration.\nIntroduction: Defined 0.9.38, scheduled working 0.9.40 (see Proposal 123)\nStatus: Specification complete. Production deployment status should be verified with current I2P releases.\nStructure:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| MetaLease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | MetaLease($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numr| | +----+ + | revocation_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | revocation_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes options :: Mapping Length: 2+ bytes (size + data) MUST be sorted by key num :: Integer (1 byte) Number of MetaLease entries Range: 1 to (implementation-defined, recommend 1-16) metaleases :: Array of MetaLease structures Length: $num × 40 bytes numr :: Integer (1 byte) Number of revocation hashes Range: 0 to (implementation-defined, recommend 0-16) revocations :: Array of Hash structures Length: $numr × 32 bytes SHA-256 hashes of revoked LeaseSet Destinations Database Storage:\nDatabase Type: 7 Key: SHA-256 hash of Destination Value: Complete MetaLeaseSet structure Signature Computation:\nData to sign: database_type (1 byte, value=7) || complete MetaLeaseSet data Verification: 1. Prepend database type byte (0x07) to MetaLeaseSet data 2. If offline signature present in header: - Verify offline signature against Destination key - Verify MetaLeaseSet signature against transient key 3. Else: - Verify MetaLeaseSet signature against Destination key Usage Scenarios:\n1. Load Balancing:\nMetaLeaseSet for primary.i2p: MetaLease 0: cost=0, points to server1.i2p LeaseSet2 MetaLease 1: cost=0, points to server2.i2p LeaseSet2 MetaLease 2: cost=0, points to server3.i2p LeaseSet2 Clients randomly select among equal-cost entries 2. Failover:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to primary.i2p LeaseSet2 MetaLease 1: cost=100, points to backup.i2p LeaseSet2 Clients prefer cost=0 (primary), fall back to cost=100 (backup) 3. Service Migration:\nMetaLeaseSet for old-domain.i2p: MetaLease 0: cost=0, points to new-domain.i2p LeaseSet2 Transparently redirects clients from old to new destination 4. Multi-Tier Architecture:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to region1-meta.i2p (another MetaLeaseSet) MetaLease 1: cost=0, points to region2-meta.i2p (another MetaLeaseSet) Each region MetaLeaseSet points to regional servers Allows hierarchical load balancing Revocation List:\nThe revocation list allows MetaLeaseSet to explicitly revoke previously published LeaseSets:\nPurpose: Mark specific Destinations as no longer valid Contents: SHA-256 hashes of revoked Destination structures Usage: Clients MUST NOT use LeaseSets whose Destination hash appears in revocation list Typical Value: Empty (numr=0) in most deployments Example Revocation:\nService migrates from dest-v1.i2p to dest-v2.i2p: MetaLease 0: points to dest-v2.i2p Revocations: [hash(dest-v1.i2p)] Clients will use v2 and ignore v1 even if cached Expiration Handling:\nMetaLeaseSet uses LeaseSet2Header with maximum expires=65535 seconds (~18.2 hours):\nMuch longer than LeaseSet2 (max ~11 minutes) Suitable for relatively static indirection Referenced LeaseSets can have shorter expiration Clients must check expiration of both MetaLeaseSet AND referenced LeaseSets Options Mapping:\nUse same format as LeaseSet2 options Can include service records (Proposal 167) MUST be sorted by key Service records typically describe the ultimate service, not the indirection structure Client Implementation Notes:\nResolution Process:\n1. Query netdb for MetaLeaseSet using SHA-256(Destination) 2. Parse MetaLeaseSet, extract MetaLease entries 3. Sort entries by cost (lower = better) 4. For each entry in cost order: a. Extract LeaseSet hash from tunnel_gw field b. Determine entry type from flags c. Query netdb for referenced LeaseSet (may be another MetaLeaseSet) d. Check revocation list e. Check expiration f. If valid, use the LeaseSet; else try next entry Caching:\nCache both MetaLeaseSet and referenced LeaseSets Check expiration of both levels Monitor for updated MetaLeaseSet publication Failover:\nIf preferred entry fails, try next-lowest cost Consider marking failed entries temporarily unavailable Re-check periodically for recovery Implementation Status:\nProposal 123 notes portions remain \u0026ldquo;in development.\u0026rdquo; Implementers should:\nVerify production readiness in target I2P version Test MetaLeaseSet support before deployment Check for updated specifications in newer I2P releases JavaDoc: MetaLeaseSet\nEncryptedLeaseSet (Type 5) Description: Encrypted and blinded LeaseSet for enhanced privacy. Only the blinded public key and metadata are visible; actual leases and encryption keys are encrypted.\nIntroduction: Defined 0.9.38, working 0.9.39 (see Proposal 123)\nStructure:\n+----+----+----+----+----+----+----+----+ | sigtype | | +----+----+ + | blinded_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | len | | +----+----+ + | encrypted_data | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ sigtype :: 2-byte signature type Type of blinded_public_key MUST be RedDSA_SHA512_Ed25519 (type 11) blinded_public_key :: SigningPublicKey (32 bytes for RedDSA) Blinded version of Destination signing key Used to verify signature on EncryptedLeaseSet published :: 4-byte timestamp (seconds since epoch) Publication time Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published Maximum: 65535 seconds (18.2 hours) Practical maximum for LeaseSet data: ~660 seconds (~11 min) flags :: 2 bytes Bit 0: Offline signature present (0=no, 1=yes) Bit 1: Unpublished (0=published, 1=client-side only) Bits 15-2: Reserved (must be 0) offline_signature :: OfflineSignature (optional) Present only if flags bit 0 = 1 Variable length len :: 2-byte integer Length of encrypted_data Range: 1 to 65535 encrypted_data :: Encrypted payload Length: len bytes Contains encrypted LeaseSet2 or MetaLeaseSet signature :: Signature (64 bytes for RedDSA) Length determined by sigtype Signed by blinded_public_key or transient key Database Storage:\nDatabase Type: 5 Key: SHA-256 hash of blinded Destination (not original Destination) Value: Complete EncryptedLeaseSet structure Critical Differences from LeaseSet2:\nDoes NOT use LeaseSet2Header structure (has similar fields but different layout) Blinded public key instead of full Destination Encrypted payload instead of cleartext leases and keys Database key is hash of blinded Destination, not original Destination Signature Computation:\nData to sign: database_type (1 byte, value=5) || complete EncryptedLeaseSet data Verification: 1. Prepend database type byte (0x05) to EncryptedLeaseSet data 2. If offline signature present (flags bit 0 = 1): - Verify offline signature against blinded public key - Verify EncryptedLeaseSet signature against transient key 3. Else: - Verify EncryptedLeaseSet signature against blinded public key Signature Type Requirement:\nMUST use RedDSA_SHA512_Ed25519 (type 11):\n32-byte blinded public keys 64-byte signatures Required for blinding security properties See [Red25519 specification](//docs/specs/red25519-signature-scheme/ Key Differences from EdDSA:\nPrivate keys via modular reduction (not clamping) Signatures include 80 bytes of random data Uses public keys directly (not hashes) Enables secure blinding operation Blinding and Encryption:\nSee EncryptedLeaseSet specification for complete details:\n1. Key Blinding:\nBlinding process (daily rotation): secret = HKDF(original_signing_private_key, date_string, \u0026#34;i2pblinding1\u0026#34;) alpha = SHA-256(secret) mod L (where L is Ed25519 group order) blinded_private_key = alpha * original_private_key blinded_public_key = alpha * original_public_key 2. Database Location:\nClient publishes to: Key = SHA-256(blinded_destination) Where blinded_destination uses: - Blinded public key (signing key) - Same unused public key field (random) - Same certificate structure 3. Encryption Layers (Three-Layer):\nLayer 1 - Authentication Layer (Client Access):\nEncryption: ChaCha20 stream cipher Key derivation: HKDF with per-client secrets Authenticated clients can decrypt outer layer Layer 2 - Encryption Layer:\nEncryption: ChaCha20 Key: Derived from DH between client and server Contains the actual LeaseSet2 or MetaLeaseSet Layer 3 - Inner LeaseSet:\nComplete LeaseSet2 or MetaLeaseSet Includes all tunnels, encryption keys, options Only accessible after successful decryption Encryption Key Derivation:\nClient has: ephemeral_client_private_key Server has: ephemeral_server_public_key (in encrypted_data) Shared secret = X25519(client_private, server_public) Encryption key = HKDF(shared_secret, context_info, \u0026#34;i2pblinding2\u0026#34;) Discovery Process:\nFor authorized clients:\n1. Client knows original Destination 2. Client computes current blinded Destination (based on current date) 3. Client computes database key: SHA-256(blinded_destination) 4. Client queries netdb for EncryptedLeaseSet using blinded key 5. Client decrypts layer 1 using authorization credentials 6. Client decrypts layer 2 using DH shared secret 7. Client extracts inner LeaseSet2/MetaLeaseSet 8. Client uses tunnels from inner LeaseSet for communication For unauthorized clients:\nCannot decrypt even if they find the EncryptedLeaseSet Cannot determine original Destination from blinded version Cannot link EncryptedLeaseSets across different blinding periods (daily rotation) Expiration Times:\nContent Type Maximum Expires Notes EncryptedLeaseSet (outer)65,535 sec (≈18.2 hr)Full 2-byte expires field Inner LeaseSet2≈660 sec (≈11 min)Actual lease data practical maximum Inner MetaLeaseSet65,535 sec (≈18.2 hr)Indirection can be longer-lived Published Timestamp:\nSame requirements as LeaseSet2Header:\nMust increment by at least 1 second between publications Floodfills reject if not newer than current version Recommended: 10-60 seconds between publications Offline Signatures with Encrypted LeaseSets:\nSpecial considerations when using offline signatures:\nBlinded public key rotates daily Offline signature must be regenerated daily with new blinded key OR use offline signature on inner LeaseSet, not outer EncryptedLeaseSet See Proposal 123 notes Implementation Notes:\nClient Authorization:\nMultiple clients can be authorized with different keys Each authorized client has unique decryption credentials Revoke client by changing authorization keys Daily Key Rotation:\nBlinded keys change at UTC midnight Clients must recompute blinded Destination daily Old EncryptedLeaseSets become undiscoverable after rotation Privacy Properties:\nFloodfills cannot determine original Destination Unauthorized clients cannot access service Different blinding periods cannot be linked No cleartext metadata beyond expiration times Performance:\nClients must perform daily blinding calculation Three-layer encryption adds computational overhead Consider caching decrypted inner LeaseSet Security Considerations:\nAuthorization Key Management:\nSecurely distribute client authorization credentials Use unique credentials per client for granular revocation Rotate authorization keys periodically Clock Synchronization:\nDaily blinding depends on synchronized UTC dates Clock skew can cause lookup failures Consider supporting previous/next day\u0026rsquo;s blinding for tolerance Metadata Leakage:\nPublished and expires fields are cleartext Pattern analysis might reveal service characteristics Randomize publication intervals if concerned JavaDoc: EncryptedLeaseSet\nRouter Structures RouterAddress Description: Defines connection information for a router through a specific transport protocol.\nFormat:\n+----+----+----+----+----+----+----+----+ |cost| expiration +----+----+----+----+----+----+----+----+ | transport_style | +----+----+----+----+-//-+----+----+----+ | | + + | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ cost :: Integer (1 byte) Relative cost, 0=free, 255=expensive Typical values: 5-6: SSU2 10-11: NTCP2 expiration :: Date (8 bytes) MUST BE ALL ZEROS (see critical note below) transport_style :: String (1-256 bytes) Transport protocol name Current values: \u0026#34;SSU2\u0026#34;, \u0026#34;NTCP2\u0026#34; Legacy: \u0026#34;SSU\u0026#34;, \u0026#34;NTCP\u0026#34; (removed) options :: Mapping Transport-specific configuration Common options: \u0026#34;host\u0026#34;, \u0026#34;port\u0026#34; Transport-specific options vary CRITICAL - Expiration Field:\n⚠️ The expiration field MUST be set to all zeros (8 zero bytes).\nReason: Since release 0.9.3, non-zero expiration causes signature verification failure History: Expiration was originally unused, always null Current Status: Field was recognized again as of 0.9.12, but must wait for network upgrade Implementation: Always set to 0x0000000000000000 Any non-zero expiration will cause the RouterInfo signature to fail validation.\nTransport Protocols Current Protocols (as of 2.10.0):\nProtocol Status Introduced Removed Notes SSU2Current0.9.54 (May 2022)-Default since 0.9.56 NTCP2Current0.9.36 (Aug 2018)-Active NTCPRemoved-0.9.50 (May 2021)Use NTCP2 SSURemoved-2.4.0 (Dec 2023)Use SSU2 Transport Style Values:\n\u0026quot;SSU2\u0026quot;: Current UDP-based transport \u0026quot;NTCP2\u0026quot;: Current TCP-based transport \u0026quot;NTCP\u0026quot;: Legacy, removed (do not use) \u0026quot;SSU\u0026quot;: Legacy, removed (do not use) Common Options All transports typically include:\n\u0026#34;host\u0026#34; = IPv4 or IPv6 address or hostname \u0026#34;port\u0026#34; = Port number (1-65535) SSU2-Specific Options See SSU2 specification for complete details.\nRequired Options:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = UDP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Introduction key X25519 (Base64, 44 characters = 32 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Optional Options:\n\u0026#34;caps\u0026#34; = Capability string (e.g., \u0026#34;B\u0026#34; for bandwidth tier) \u0026#34;ihost0\u0026#34;, \u0026#34;ihost1\u0026#34;, ... = Introducer IP addresses \u0026#34;iport0\u0026#34;, \u0026#34;iport1\u0026#34;, ... = Introducer ports \u0026#34;ikey0\u0026#34;, \u0026#34;ikey1\u0026#34;, ... = Introducer static keys (Base64, 44 chars) \u0026#34;itag0\u0026#34;, \u0026#34;itag1\u0026#34;, ... = Introducer relay tags \u0026#34;iexp0\u0026#34;, \u0026#34;iexp1\u0026#34;, ... = Introducer expiration timestamps \u0026#34;mtu\u0026#34; = Maximum transmission unit (default 1500, min 1280) \u0026#34;mtu6\u0026#34; = IPv6 MTU (if different from IPv4) Example SSU2 RouterAddress:\ncost: 5 expiration: 0x0000000000000000 transport_style: \u0026#34;SSU2\u0026#34; options: host=198.51.100.42 port=12345 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=QW5vdGhlciBTYW1wbGUgS2V5IGZvciBJbnRyb2R1Y3Rpb24= v=2 caps=BC mtu=1472 NTCP2-Specific Options See NTCP2 specification for complete details.\nRequired Options:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = TCP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Initialization vector (Base64, 24 characters = 16 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Optional Options (since 0.9.50):\n\u0026#34;caps\u0026#34; = Capability string Example NTCP2 RouterAddress:\ncost: 10 expiration: 0x0000000000000000 transport_style: \u0026#34;NTCP2\u0026#34; options: host=198.51.100.42 port=23456 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=U2FtcGxlIElWIGhlcmU= v=2 Implementation Notes Cost Values:\nUDP (SSU2) typically lower cost (5-6) due to efficiency TCP (NTCP2) typically higher cost (10-11) due to overhead Lower cost = preferred transport Multiple Addresses:\nRouters may publish multiple RouterAddress entries Different transports (SSU2 and NTCP2) Different IP versions (IPv4 and IPv6) Clients select based on cost and capabilities Hostname vs IP:\nIP addresses preferred for performance Hostnames supported but add DNS lookup overhead Consider using IP for published RouterInfos Base64 Encoding:\nAll keys and binary data encoded in Base64 Standard Base64 (RFC 4648) No padding or non-standard characters JavaDoc: RouterAddress\nRouterInfo Description: Complete published information about a router, stored in the network database. Contains identity, addresses, and capabilities.\nFormat:\n+----+----+----+----+----+----+----+----+ | router_ident | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | +----+----+----+----+----+----+----+----+ |size| RouterAddress 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress ($size-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+-//-+----+----+----+ |psiz| options | +----+----+----+----+-//-+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ router_ident :: RouterIdentity Length: 387+ bytes (typically 391 for X25519+EdDSA) published :: Date (8 bytes) Publication timestamp (milliseconds since epoch) size :: Integer (1 byte) Number of RouterAddress entries Range: 0-255 addresses :: Array of RouterAddress Variable length Each RouterAddress has variable size peer_size :: Integer (1 byte) Number of peer hashes (ALWAYS 0) Historical, unused feature options :: Mapping Router capabilities and metadata MUST be sorted by key signature :: Signature Length determined by router_ident signing key type Typically 64 bytes (EdDSA) Signed by router_ident\u0026#39;s SigningPrivateKey Database Storage:\nDatabase Type: 0 Key: SHA-256 hash of RouterIdentity Value: Complete RouterInfo structure Published Timestamp:\n8-byte Date (milliseconds since epoch) Used for RouterInfo versioning Routers publish new RouterInfo periodically Floodfills keep newest version based on published timestamp Address Sorting:\nHistorical: Very old routers required addresses sorted by SHA-256 of their data Current: Sorting NOT required, not worth implementing for compatibility Addresses can be in any order Peer Size Field (Historical):\nAlways 0 in modern I2P Was intended for restricted routes (unimplemented) If implemented, would be followed by that many Router Hashes Some old implementations might have required sorted peer list Options Mapping:\nOptions MUST be sorted by key. Standard options include:\nCapability Options:\n\u0026#34;caps\u0026#34; = Capability string Common values: f = Floodfill (network database) L or M or N or O = Bandwidth tier (L=lowest, O=highest) R = Reachable U = Unreachable/firewalled Example: \u0026#34;fLRU\u0026#34; = Floodfill, Low bandwidth, Reachable, Unreachable Network Options:\n\u0026#34;netId\u0026#34; = Network ID (default \u0026#34;2\u0026#34; for main I2P network) Different values for test networks \u0026#34;router.version\u0026#34; = I2P version string Example: \u0026#34;0.9.67\u0026#34; or \u0026#34;2.10.0\u0026#34; Statistical Options:\n\u0026#34;stat_uptime\u0026#34; = Uptime in milliseconds \u0026#34;coreVersion\u0026#34; = Core I2P version \u0026#34;router.version\u0026#34; = Full router version string See Network Database RouterInfo documentation for complete list of standard options.\nSignature Computation:\nData to sign: Complete RouterInfo structure from router_ident through options Verification: 1. Extract RouterIdentity from RouterInfo 2. Get SigningPublicKey from RouterIdentity (type determines algorithm) 3. Verify signature over all data preceding signature field 4. Signature must match signing key type and length Typical Modern RouterInfo:\nRouterIdentity: 391 bytes (X25519+EdDSA with Key Certificate) Published: 8 bytes Size: 1 byte (typically 1-4 addresses) RouterAddress × N: Variable (typically 200-500 bytes each) Peer Size: 1 byte (value=0) Options: Variable (typically 50-200 bytes) Signature: 64 bytes (EdDSA) Total: ~1000-2500 bytes typical Implementation Notes:\nMultiple Addresses:\nRouters typically publish 1-4 addresses IPv4 and IPv6 variants SSU2 and/or NTCP2 transports Each address independent Versioning:\nNewer RouterInfo has later published timestamp Routers republish every ~2 hours or when addresses change Floodfills store and flood only newest version Validation:\nVerify signature before accepting RouterInfo Check expiration field is all zeros in each RouterAddress Validate options mapping is sorted by key Check certificate and key types are known/supported Network Database:\nFloodfills store RouterInfo indexed by Hash(RouterIdentity) Stored for ~2 days after last publication Routers query floodfills to discover other routers JavaDoc: RouterInfo\nImplementation Notes Byte Order (Endianness) Default: Big-Endian (Network Byte Order)\nMost I2P structures use big-endian byte order:\nAll Integer types (1-8 bytes) Date timestamps TunnelId String length prefix Certificate types and lengths Key type codes Mapping size fields Exception: Little-Endian\nThe following key types use little-endian encoding:\nX25519 encryption keys (type 4) EdDSA_SHA512_Ed25519 signing keys (type 7) EdDSA_SHA512_Ed25519ph signing keys (type 8) RedDSA_SHA512_Ed25519 signing keys (type 11) Implementation:\n// Big-endian (most structures) int value = ((bytes[0] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[3] \u0026amp; 0xFF); // Little-endian (X25519, EdDSA, RedDSA) int value = (bytes[0] \u0026amp; 0xFF) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24); Structure Versioning Never Assume Fixed Sizes:\nMany structures have variable length:\nRouterIdentity: 387+ bytes (not always 387) Destination: 387+ bytes (not always 387) LeaseSet2: Varies significantly Certificate: 3+ bytes Always Read Size Fields:\nCertificate length at bytes 1-2 Mapping size at beginning KeysAndCert always compute as 384 + 3 + certificate_length Check for Excess Data:\nProhibit trailing garbage after valid structures Validate certificate lengths match key types Enforce exact expected lengths for fixed-size types Current Recommendations (October 2025) For New Router Identities:\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per Proposal 161 For New Destinations:\nUnused Public Key Field: 256 bytes random (compressible) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per Proposal 161 For New LeaseSets:\nType: LeaseSet2 (type 3) Encryption Keys: X25519 (type 4, 32 bytes) Leases: At least 1, typically 3-5 Options: Include service records per Proposal 167 Signature: EdDSA (64 bytes) For Encrypted Services:\nType: EncryptedLeaseSet (type 5) Blinding: RedDSA_SHA512_Ed25519 (type 11) Inner LeaseSet: LeaseSet2 (type 3) Rotation: Daily blinding key rotation Authorization: Per-client encryption keys Deprecated Features - Do Not Use Deprecated Encryption:\nElGamal (type 0) for Router Identities (deprecated 0.9.58) ElGamal/AES+SessionTag encryption (use ECIES-X25519) Deprecated Signing:\nDSA_SHA1 (type 0) for Router Identities (deprecated 0.9.58) ECDSA variants (types 1-3) for new implementations RSA variants (types 4-6) except for SU3 files Deprecated Network Formats:\nLeaseSet type 1 (use LeaseSet2) Lease (44 bytes, use Lease2) Original Lease expiration format Deprecated Transports:\nNTCP (removed 0.9.50) SSU (removed 2.4.0) Deprecated Certificates:\nHASHCASH (type 1) HIDDEN (type 2) SIGNED (type 3) MULTIPLE (type 4) Security Considerations Key Generation:\nAlways use cryptographically secure random number generators Never reuse keys across different contexts Protect private keys with appropriate access controls Securely erase key material from memory when finished Signature Verification:\nAlways verify signatures before trusting data Check signature length matches key type Validate signed data includes expected fields For sorted mappings, verify sort order before signing/verifying Timestamp Validation:\nCheck that published times are reasonable (not far future) Validate lease expirations are not expired Consider clock skew tolerance (±30 seconds typical) Network Database:\nValidate all structures before storing Enforce size limits to prevent DoS Rate-limit queries and publications Verify database keys match structure hashes Compatibility Notes Backward Compatibility:\nElGamal and DSA_SHA1 still supported for legacy routers Deprecated key types remain functional but discouraged Compressible padding (Proposal 161) backward compatible to 0.6 Forward Compatibility:\nUnknown key types can be parsed using length fields Unknown certificate types can be skipped using length Unknown signature types should be handled gracefully Implementers should not fail on unknown optional features Migration Strategies:\nSupport both old and new key types during transition LeaseSet2 can list multiple encryption keys Offline signatures enable secure key rotation MetaLeaseSet enables transparent service migration Testing and Validation Structure Validation:\nVerify all length fields are within expected ranges Check that variable-length structures parse correctly Validate that signatures verify successfully Test with both minimum and maximum size structures Edge Cases:\nZero-length strings Empty mappings Minimum and maximum lease counts Certificate with zero-length payload Very large structures (near maximum sizes) Interoperability:\nTest against official Java I2P implementation Verify compatibility with i2pd Test with various network database contents Validate against known-good test vectors References Specifications I2NP Protocol: /docs/specs/i2np/ I2CP Protocol: /docs/specs/i2cp/ SSU2 Transport: /docs/specs/ssu2/ NTCP2 Transport: /docs/specs/ntcp2/ Tunnel Protocol: /docs/specs/implementation/ Datagram Protocol: /docs/api/datagrams/ Cryptography Cryptography Overview: /docs/specs/cryptography/ ElGamal/AES Encryption: /docs/legacy/elgamal-aes/ ECIES-X25519 Encryption: /docs/specs/ecies/ ECIES for Routers: /docs/specs/ecies/#routers ECIES Hybrid (Post-Quantum): /docs/specs/ecies/#hybrid Red25519 Signatures: [//docs/specs/red25519-signature-scheme/(//docs/specs/red25519-signature-scheme/ Encrypted LeaseSet: /docs/specs/encryptedleaseset/ Proposals Proposal 123 (New netDB Entries): /proposals/123-new-netdb-entries/ Proposal 134 (GOST Sig Types): //spec/proposals/134-gost Proposal 136 (Experimental Sig Types): /proposals/136-experimental-sigtypes/ Proposal 145 (ECIES-P256): Referenced in specification Proposal 156 (ECIES Routers): Referenced in specification Proposal 161 (Padding Generation): Referenced in KeysAndCert section Proposal 167 (Service Records): /proposals/167-service-records/ Proposal 169 (Post-Quantum Crypto): /proposals/169-pq-crypto/ All Proposals Index: //spec/proposals Network Database Network Database Overview: /docs/specs/common-structures/ RouterInfo Standard Options: /docs/specs/common-structures/#routerInfo JavaDoc API Reference Core Data Package: http://docs.i2p-projekt.de/javadoc/net/i2p/data/ PublicKey: http://docs.i2p-projekt.de/javadoc/net/i2p/data/PublicKey.html PrivateKey: http://docs.i2p-projekt.de/javadoc/net/i2p/data/PrivateKey.html SessionKey: http://docs.i2p-projekt.de/javadoc/net/i2p/data/SessionKey.html SigningPublicKey: http://docs.i2p-projekt.de/javadoc/net/i2p/data/SigningPublicKey.html SigningPrivateKey: http://docs.i2p-projekt.de/javadoc/net/i2p/data/SigningPrivateKey.html Signature: http://docs.i2p-projekt.de/javadoc/net/i2p/data/Signature.html Hash: http://docs.i2p-projekt.de/javadoc/net/i2p/data/Hash.html SessionTag: http://docs.i2p-projekt.de/javadoc/net/i2p/data/SessionTag.html TunnelId: http://docs.i2p-projekt.de/javadoc/net/i2p/data/TunnelId.html Certificate: http://docs.i2p-projekt.de/javadoc/net/i2p/data/Certificate.html DataHelper: http://docs.i2p-projekt.de/javadoc/net/i2p/data/DataHelper.html KeysAndCert: http://docs.i2p-projekt.de/javadoc/net/i2p/data/KeysAndCert.html RouterIdentity: http://docs.i2p-projekt.de/javadoc/net/i2p/data/router/RouterIdentity.html Destination: http://docs.i2p-projekt.de/javadoc/net/i2p/data/Destination.html Lease: http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease.html LeaseSet: http://docs.i2p-projekt.de/javadoc/net/i2p/data/LeaseSet.html Lease2: http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease2.html LeaseSet2: http://docs.i2p-projekt.de/javadoc/net/i2p/data/LeaseSet2.html MetaLease: http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLease.html MetaLeaseSet: http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLeaseSet.html EncryptedLeaseSet: http://docs.i2p-projekt.de/javadoc/net/i2p/data/EncryptedLeaseSet.html RouterAddress: http://docs.i2p-projekt.de/javadoc/net/i2p/data/router/RouterAddress.html RouterInfo: http://docs.i2p-projekt.de/javadoc/net/i2p/data/router/RouterInfo.html External Standards RFC 7748 (X25519): Elliptic Curves for Security RFC 7539 (ChaCha20): ChaCha20 and Poly1305 for IETF Protocols RFC 4648 (Base64): The Base16, Base32, and Base64 Data Encodings FIPS 180-4 (SHA-256): Secure Hash Standard FIPS 204 (ML-DSA): Module-Lattice-Based Digital Signature Standard IANA Service Registry: http://www.dns-sd.org/ServiceTypes.html Community Resources I2P Website: / I2P Forum: https://i2pforum.net I2P Gitea: https://i2pgit.org/I2P_Developers/i2p.i2p I2P GitHub Mirror: https://github.com/i2p/i2p.i2p Technical Documentation Index: /docs/ Release Information I2P 2.10.0 Release: /blog/2025-09-08-i2p-2-10-0-release/ Release History: https://github.com/i2p/i2p.i2p/blob/master/history.txt Changelog: https://github.com/i2p/i2p.i2p/blob/master/debian/changelog Appendix: Quick Reference Tables Key Type Quick Reference Current Standard (Recommended for all new implementations):\nEncryption: X25519 (type 4, 32 bytes, little-endian) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes, little-endian) Legacy (Supported but deprecated):\nEncryption: ElGamal (type 0, 256 bytes, big-endian) Signing: DSA_SHA1 (type 0, 20-byte private / 128-byte public, big-endian) Specialized:\nSigning (Encrypted LeaseSet): RedDSA_SHA512_Ed25519 (type 11, 32 bytes, little-endian) Post-Quantum (Beta, not finalized):\nHybrid Encryption: MLKEM_X25519 variants (types 5-7) Pure PQ Encryption: MLKEM variants (no assigned type codes yet) Structure Size Quick Reference Structure Minimum Size Typical Size Maximum Size Integer1 byteVaries8 bytes Date8 bytes8 bytes8 bytes String1 byteVaries256 bytes SessionKey32 bytes32 bytes32 bytes Hash32 bytes32 bytes32 bytes TunnelId4 bytes4 bytes4 bytes Certificate3 bytes7 bytes65,538 bytes KeysAndCert387 bytes391 bytes≈1000+ bytes RouterIdentity387 bytes391 bytes≈1000+ bytes Destination387 bytes391 bytes≈1000+ bytes Lease44 bytes44 bytes44 bytes Lease240 bytes40 bytes40 bytes LeaseSet≈1000 bytes≈1200 bytes≈2000+ bytes LeaseSet2≈500 bytes≈800 bytes≈2000+ bytes EncryptedLeaseSet≈600 bytes≈1000 bytes≈3000+ bytes RouterAddress≈150 bytes≈300 bytes≈600 bytes RouterInfo≈1000 bytes≈1500 bytes≈3000+ bytes Database Type Quick Reference Type Structure Status Notes 0RouterInfoCurrentStored under Hash(RouterIdentity) 1LeaseSetDeprecatedUse LeaseSet2 instead 3LeaseSet2CurrentStored under Hash(Destination) 5EncryptedLeaseSetCurrentStored under Hash(Blinded Destination) 7MetaLeaseSetDefinedVerify production status Transport Protocol Quick Reference Protocol Status Port Type Since Notes SSU2CurrentUDP0.9.54Default since 0.9.56 NTCP2CurrentTCP0.9.36Active SSURemovedUDP-Removed in 2.4.0 NTCPRemovedTCP-Removed in 0.9.50 Version Milestone Quick Reference Version API Date Key Changes 0.60.6.x2005Destination encryption disabled 0.9.120.9.12Dec 2013Key Certificates introduced 0.9.150.9.15Sep 2015EdDSA support added 0.9.160.9.16Nov 2015Router Key Certificates 0.9.360.9.36Aug 2018NTCP2 introduced 0.9.380.9.38Nov 2018LeaseSet2, X25519 for Destinations 0.9.390.9.39Dec 2018EncryptedLeaseSet working 0.9.480.9.48Jul 2020X25519 for Router Identities 0.9.500.9.50May 2021NTCP removed 0.9.540.9.54May 2022SSU2 testing 0.9.570.9.57Jan 2023Proposal 161 padding (release 2.1.0) 0.9.580.9.58Mar 2023ElGamal/DSA deprecated for RIs (2.2.0) 0.9.660.9.66Jun 2025Proposal 167 service records (2.9.0) 0.9.670.9.67Sep 2025ML-KEM beta support (2.10.0) ","description":"Shared data types and serialization formats used across I2P specs","id":"178a1cfe9e5d2970a6e9f8d07c374b78","section":"docs","title":"Common Structures","url":"/en/docs/specs/common-structures/"},{"categories":null,"content":"What is an Eepsite? An eepsite is a website that lives exclusively on the I2P network. Unlike traditional websites accessible through the clearnet, eepsites are only reachable through I2P, providing anonymity and privacy for both the site operator and visitors. Eepsites use the .i2p pseudo-top-level domain and are accessed through special .b32.i2p addresses or human-readable names registered in the I2P address book.\nAll Java I2P deployments come with Jetty, a lightweight Java-based webserver, pre-installed and pre-configured. This makes it simple to start hosting your own eepsite within minutes - no additional software installation required.\nThis guide will walk you through the process of creating and configuring your first eepsite using I2P\u0026rsquo;s built-in tools.\nStep 1: Access the Hidden Services Manager The Hidden Services Manager (also called the I2P Tunnel Manager) is where you configure all I2P server and client tunnels, including HTTP servers (eepsites).\nOpen your I2P router console (typically at http://127.0.0.1:7657) Navigate to the Hidden Services Manager at http://127.0.0.1:7657/i2ptunnelmgr You should see the Hidden Services Manager interface showing:\nStatus Messages - Current tunnel and client status Global Tunnel Control - Buttons to manage all tunnels at once I2P Hidden Services - List of configured server tunnels By default, you\u0026rsquo;ll see an existing I2P webserver entry configured but not started. This is the pre-configured Jetty webserver ready for you to use.\nStep 2: Configure Your Eepsite Server Settings Click on the I2P webserver entry in the Hidden Services list to open the server configuration page. This is where you\u0026rsquo;ll customize your eepsite\u0026rsquo;s settings.\nConfiguration Options Explained Name\nThis is an internal identifier for your tunnel Useful if you\u0026rsquo;re running multiple eepsites to keep track of which is which Default: \u0026ldquo;I2P webserver\u0026rdquo; Description\nA brief description of your eepsite for your own reference Only visible to you in the Hidden Services Manager Example: \u0026ldquo;My eepsite\u0026rdquo; or \u0026ldquo;Personal blog\u0026rdquo; Auto Start Tunnel\nImportant: Check this box to automatically start your eepsite when your I2P router starts Ensures your site remains available without manual intervention after router restarts Recommended: Enabled Target (Host and Port)\nHost: The local address where your webserver is running (default: 127.0.0.1) Port: The port your webserver listens on (default: 7658 for Jetty) If you\u0026rsquo;re using the pre-installed Jetty webserver, leave these at default values Only change if you\u0026rsquo;re running a custom webserver on a different port Website Hostname\nThis is your eepsite\u0026rsquo;s human-readable .i2p domain name Default: mysite.i2p (placeholder) You can register a custom domain like stormycloud.i2p or myblog.i2p Leave blank if you only want to use the auto-generated .b32.i2p address (for outproxies) See Registering Your I2P Domain below for how to claim a custom hostname Local Destination\nThis is your eepsite\u0026rsquo;s unique cryptographic identifier (destination address) Auto-generated when the tunnel is first created Think of this as your site\u0026rsquo;s permanent \u0026ldquo;IP address\u0026rdquo; on I2P The long alphanumeric string is your site\u0026rsquo;s .b32.i2p address in encoded form Private Key File\nLocation where your eepsite\u0026rsquo;s private keys are stored Default: eepsite/eepPriv.dat Keep this file secure - anyone with access to this file can impersonate your eepsite Never share or delete this file Important Note The yellow warning box reminds you that to enable QR code generation or registration authentication features, you must configure a Website Hostname with an .i2p suffix (e.g., mynewsite.i2p).\nStep 3: Advanced Networking Options (Optional) If you scroll down on the configuration page, you\u0026rsquo;ll find advanced networking options. These settings are optional - the defaults work well for most users. However, you can adjust them based on your security requirements and performance needs.\nTunnel Length Options Tunnel Length\nDefault: 3 hop tunnel (high anonymity) Controls how many router hops a request passes through before reaching your eepsite More hops = Higher anonymity, but slower performance Fewer hops = Faster performance, but reduced anonymity Options range from 0-3 hops with variance settings Recommendation: Keep at 3 hops unless you have specific performance requirements Tunnel Variance\nDefault: 0 hop variance (no randomization, consistent performance) Adds randomization to tunnel length for added security Example: \u0026ldquo;0-1 hop variance\u0026rdquo; means tunnels will randomly be 3 or 4 hops Increases unpredictability but may cause inconsistent load times Tunnel Quantity Options Count (Inbound/Outbound Tunnels)\nDefault: 2 inbound, 2 outbound tunnels (standard bandwidth and reliability) Controls how many parallel tunnels are dedicated to your eepsite More tunnels = Better availability and load handling, but higher resource usage Fewer tunnels = Lower resource usage, but reduced redundancy Recommended for most users: 2/2 (default) High-traffic sites may benefit from 3/3 or higher Backup Count\nDefault: 0 backup tunnels (no redundancy, no added resource usage) Standby tunnels that activate if primary tunnels fail Increases reliability but consumes more bandwidth and CPU Most personal eepsites don\u0026rsquo;t need backup tunnels POST Limits If your eepsite includes forms (contact forms, comment sections, file uploads, etc.), you can configure POST request limits to prevent abuse:\nPer Client Limits\nPer Period: Maximum requests from a single client (default: 6 per 5 minutes) Ban Duration: How long to block abusive clients (default: 20 minutes) Total Limits\nTotal: Maximum POST requests from all clients combined (default: 20 per 5 minutes) Ban Duration: How long to reject all POST requests if limit exceeded (default: 10 minutes) POST Limit Period\nTime window for measuring request rates (default: 5 minutes) These limits help protect against spam, denial-of-service attacks, and automated form submission abuse.\nWhen to Adjust Advanced Settings High-traffic community site: Increase tunnel quantity (3-4 inbound/outbound) Performance-critical application: Reduce tunnel length to 2 hops (privacy tradeoff) Maximum anonymity required: Keep 3 hops, add 0-1 variance Forms with legitimate high usage: Increase POST limits accordingly Personal blog/portfolio: Use all defaults Step 4: Adding Content to Your Eepsite Now that your eepsite is configured, you need to add your website files (HTML, CSS, images, etc.) to the webserver\u0026rsquo;s document root directory. The location varies depending on your operating system, installation type, and I2P implementation.\nFinding Your Document Root The document root (often called docroot) is the folder where you place all your website files. Your index.html file should go directly in this folder.\nJava I2P (Standard Distribution) Linux\nStandard install: ~/.i2p/eepsite/docroot/ Package install (running as service): /var/lib/i2p/i2p-config/eepsite/docroot/ Windows\nStandard install: %LOCALAPPDATA%\\I2P\\eepsite\\docroot\\ Typical path: C:\\Users\\YourUsername\\AppData\\Local\\I2P\\eepsite\\docroot\\ Windows Service install: %PROGRAMDATA%\\I2P\\eepsite\\docroot\\ Typical path: C:\\ProgramData\\I2P\\eepsite\\docroot\\ macOS\nStandard install: /Users/YourUsername/Library/Application Support/i2p/eepsite/docroot/ I2P+ (Enhanced I2P Distribution) I2P+ uses the same directory structure as Java I2P. Follow the paths above based on your operating system.\ni2pd (C++ Implementation) Linux/Unix\nDefault: /var/lib/i2pd/eepsite/ or ~/.i2pd/eepsite/ Check your i2pd.conf configuration file for the actual root setting under your HTTP server tunnel Windows\nCheck i2pd.conf in your i2pd installation directory macOS\nTypically: ~/Library/Application Support/i2pd/eepsite/ Adding Your Website Files Navigate to your document root using your file manager or terminal Create or copy your website files into the docroot folder At minimum, create an index.html file (this is your homepage) Add CSS, JavaScript, images, and other assets as needed Organize subdirectories as you would for any website: docroot/ ├── index.html ├── about.html ├── css/ │ └── style.css ├── images/ │ └── logo.png └── js/ └── script.js Quick Start: Simple HTML Example If you\u0026rsquo;re just getting started, create a basic index.html file in your docroot folder:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My I2P Eepsite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to My Eepsite!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first website on the I2P network.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Privacy-focused and decentralized!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Permissions (Linux/Unix/macOS) If you\u0026rsquo;re running I2P as a service or different user, make sure the I2P process has read access to your files:\n# Set appropriate ownership (if running as i2p user) sudo chown -R i2p:i2p /var/lib/i2p/i2p-config/eepsite/docroot/ # Or set readable permissions for all users chmod -R 755 ~/.i2p/eepsite/docroot/ Tips Default content: When you first install I2P, there\u0026rsquo;s already sample content in the docroot folder - feel free to replace it Static sites work best: While Jetty supports servlets and JSP, simple HTML/CSS/JavaScript sites are easiest to maintain External webservers: Advanced users can run custom webservers (Apache, Nginx, Node.js, etc.) on different ports and point the I2P tunnel to them Step 5: Starting Your Eepsite Now that your eepsite is configured and has content, it\u0026rsquo;s time to start it and make it accessible on the I2P network.\nStart the Tunnel Return to the Hidden Services Manager at http://127.0.0.1:7657/i2ptunnelmgr Find your I2P webserver entry in the list Click the Start button in the Control column Wait for Tunnel Establishment After clicking Start, your eepsite tunnel will begin building. This process typically takes 30-60 seconds. Watch the status indicator:\nRed light = Tunnel starting/building Yellow light = Tunnel partially established Green light = Tunnel fully operational and ready Once you see the green light, your eepsite is live on the I2P network!\nAccess Your Eepsite Click the Preview button next to your running eepsite. This will open a new browser tab with your eepsite\u0026rsquo;s address.\nYour eepsite has two types of addresses:\nBase32 address (.b32.i2p): A long cryptographic address that looks like:\nhttp://fcyianvr325tdgiiueyg4rsq4r5iuibzovl26msox5ryoselykpq.b32.i2p This is your eepsite\u0026rsquo;s permanent, cryptographically-derived address It cannot be changed and is tied to your private key Always works, even without domain registration Human-readable domain (.i2p): If you set a Website Hostname (e.g., testwebsite.i2p)\nOnly works after domain registration (see next section) Easier to remember and share Maps to your .b32.i2p address The Copy Hostname button lets you quickly copy your full .b32.i2p address for sharing.\n⚠️ Critical: Backup Your Private Key Before going any further, you must backup your eepsite\u0026rsquo;s private key file. This is critically important for several reasons:\nWhy Backup Your Key? Your private key (eepPriv.dat) is your eepsite\u0026rsquo;s identity. It determines your .b32.i2p address and proves ownership of your eepsite.\nKey = .b32 address: Your private key mathematically generates your unique .b32.i2p address Cannot be recovered: If you lose your key, you lose your eepsite address permanently Cannot be changed: If you registered a domain pointing to a .b32 address, there is no way to update it - the registration is permanent Required for migration: Moving to a new computer or reinstalling I2P requires this key to keep the same address Multihoming support: Running your eepsite from multiple locations requires the same key on each server Where is the Private Key? By default, your private key is stored at:\nLinux: ~/.i2p/eepsite/eepPriv.dat (or /var/lib/i2p/i2p-config/eepsite/eepPriv.dat for service installs) Windows: %LOCALAPPDATA%\\I2P\\eepsite\\eepPriv.dat or %PROGRAMDATA%\\I2P\\eepsite\\eepPriv.dat macOS: /Users/YourUsername/Library/Application Support/i2p/eepsite/eepPriv.dat You can also check/change this path in your tunnel configuration under \u0026ldquo;Private Key File\u0026rdquo;.\nHow to Backup Stop your tunnel (optional, but safer) Copy eepPriv.dat to a secure location: External USB drive Encrypted backup drive Password-protected archive Secure cloud storage (encrypted) Keep multiple backups in different physical locations Never share this file - anyone with it can impersonate your eepsite Restore from Backup To restore your eepsite on a new system or after reinstalling:\nInstall I2P and create/configure your tunnel settings Stop the tunnel before copying the key Copy your backed-up eepPriv.dat to the correct location Start the tunnel - it will use your original .b32 address If You\u0026rsquo;re Not Registering a Domain Congratulations! If you don\u0026rsquo;t plan to register a custom .i2p domain name, your eepsite is now complete and operational.\nYou can:\nShare your .b32.i2p address with others Access your site through the I2P network using any I2P-enabled browser Update your website files in the docroot folder anytime Monitor your tunnel status in the Hidden Services Manager If you want a human-readable domain (like mysite.i2p instead of a long .b32 address), continue to the next section.\nRegistering Your I2P Domain A human-readable .i2p domain (like testwebsite.i2p) is much easier to remember and share than a long .b32.i2p address. Domain registration is free and links your chosen name to your eepsite\u0026rsquo;s cryptographic address.\nPrerequisites Your eepsite must be running with a green light You must have set a Website Hostname in your tunnel configuration (Step 2) Example: testwebsite.i2p or myblog.i2p Step 1: Generate Authentication String Return to your tunnel configuration in the Hidden Services Manager Click on your I2P webserver entry to open the settings Scroll down to find the Registration Authentication button Click Registration Authentication Copy the entire authentication string shown for \u0026ldquo;Authentication for adding host [yourdomainhere]\u0026rdquo; The authentication string will look like:\ntestwebsite.i2p=I8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1uNxFZ0HN7tQbbVj1pmbahepQZNxEW0ufwnMYAoFo8opBQAEAAcAAA==#!date=1762104890#sig=9DjEfrcNRxsoSxiE0Mp0-7rH~ktYWtgwU8c4J0eSo0VHbGxDxdiO9D1Cvwcx8hkherMO07UWOC9BWf-1wRyUAw== This string contains:\nYour domain name (testwebsite.i2p) Your destination address (the long cryptographic identifier) A timestamp A cryptographic signature proving you own the private key Keep this authentication string - you\u0026rsquo;ll need it for both registration services.\nStep 2: Register with stats.i2p Navigate to http://stats.i2p/i2p/addkey.html (within I2P) Paste the authentication string into the \u0026ldquo;Authentication String\u0026rdquo; field Add your name (optional) - defaults to \u0026ldquo;Anonymous\u0026rdquo; Add a description (recommended) - briefly describe what your eepsite is about Example: \u0026ldquo;New I2P Eepsite\u0026rdquo;, \u0026ldquo;Personal blog\u0026rdquo;, \u0026ldquo;File sharing service\u0026rdquo; Check \u0026ldquo;HTTP Service?\u0026rdquo; if this is a website (leave checked for most eepsites) Uncheck for IRC, NNTP, proxies, XMPP, git, etc. Click Submit If successful, you\u0026rsquo;ll see a confirmation that your domain has been added to the stats.i2p address book.\nStep 3: Register with reg.i2p To ensure maximum availability, you should also register with the reg.i2p service:\nNavigate to http://reg.i2p/add (within I2P) Paste the same authentication string into the \u0026ldquo;Auth string\u0026rdquo; field Add a description (optional but recommended) This helps other I2P users understand what your site offers Click Submit You should receive confirmation that your domain has been registered.\nStep 4: Wait for Propagation After submitting to both services, your domain registration will propagate through the I2P network\u0026rsquo;s address book system.\nPropagation timeline:\nInitial registration: Immediate on the registration services Network-wide propagation: Several hours to 24+ hours Full availability: May take up to 48 hours for all routers to update This is normal! The I2P address book system updates periodically, not instantly. Your eepsite is working - other users just need to receive the updated address book.\nVerify Your Domain After a few hours, you can test your domain:\nOpen a new browser tab in your I2P browser Try accessing your domain directly: http://yourdomainname.i2p If it loads, your domain is registered and propagating! If it doesn\u0026rsquo;t work yet:\nWait longer (address books update on their own schedule) Your router\u0026rsquo;s address book may need time to sync Try restarting your I2P router to force an address book update Important Notes Registration is permanent: Once registered and propagated, your domain points to your .b32.i2p address permanently Cannot change the destination: You cannot update which .b32.i2p address your domain points to - that\u0026rsquo;s why backing up eepPriv.dat is critical Domain ownership: Only the holder of the private key can register or update the domain Free service: Domain registration on I2P is free, community-run, and decentralized Multiple registrars: Registering with both stats.i2p and reg.i2p increases reliability and propagation speed Congratulations! Your I2P eepsite is now fully operational with a registered domain!\nNext steps:\nAdd more content to your docroot folder Share your domain with the I2P community Keep your eepPriv.dat backup safe Monitor your tunnel status regularly Consider joining I2P forums or IRC to promote your site Welcome to the I2P network! 🎉\n","description":"Learn how to create and host your own website on the I2P network using the built-in Jetty webserver","id":"cdd089b486cced0cc2a37529ae0ace6b","section":"docs","title":"Creating an I2P Eepsite","url":"/en/docs/guides/creating-an-i2p-eepsite/"},{"categories":null,"content":"An SSH tunnel provides a secure, encrypted connection to access your remote I2P router\u0026rsquo;s console or other services. This guide shows you how to create SSH tunnels on Windows, Linux, and Mac systems.\nWhat is an SSH Tunnel? An SSH tunnel is a method of routing data and information securely over an encrypted SSH connection. Think of it as creating a protected \u0026ldquo;pipeline\u0026rdquo; through the internet - your data travels through this encrypted tunnel, preventing anyone from intercepting or reading it along the way.\nSSH tunneling is particularly useful for:\nAccessing remote I2P routers: Connect to your I2P console running on a remote server Secure connections: All traffic is encrypted end-to-end Bypassing restrictions: Access services on remote systems as if they were local Port forwarding: Map a local port to a remote service In the context of I2P, you can use an SSH tunnel to access your I2P router console (typically on port 7657) on a remote server by forwarding it to a local port on your computer.\nPrerequisites Before creating an SSH tunnel, you\u0026rsquo;ll need:\nSSH client: Windows: PuTTY (free download) Linux/Mac: Built-in SSH client (via Terminal) Remote server access: Username for the remote server IP address or hostname of the remote server SSH password or key-based authentication Available local port: Choose an unused port between 1-65535 (7657 is commonly used for I2P) Understanding the Tunnel Command The SSH tunnel command follows this pattern:\nssh -L [local_port]:[destination_ip]:[destination_port] [username]@[remote_server] Parameters explained:\nlocal_port: The port on your local machine (e.g., 7657) destination_ip: Usually 127.0.0.1 (localhost on the remote server) destination_port: The port of the service on the remote server (e.g., 7657 for I2P) username: Your username on the remote server remote_server: IP address or hostname of the remote server Example: ssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58\nThis creates a tunnel where:\nLocal port 7657 on your machine forwards to\u0026hellip; Port 7657 on the remote server\u0026rsquo;s localhost (where I2P is running) Connecting as user i2p to server 20.228.143.58 Creating SSH Tunnels on Windows Windows users can create SSH tunnels using PuTTY, a free SSH client.\nStep 1: Download and Install PuTTY Download PuTTY from putty.org and install it on your Windows system.\nStep 2: Configure the SSH Connection Open PuTTY and configure your connection:\nIn the Session category: Enter your remote server\u0026rsquo;s IP address or hostname in the Host Name field Ensure Port is set to 22 (default SSH port) Connection type should be SSH Step 3: Configure the Tunnel Navigate to Connection → SSH → Tunnels in the left sidebar:\nSource port: Enter the local port you want to use (e.g., 7657) Destination: Enter 127.0.0.1:7657 (localhost:port on remote server) Click Add to add the tunnel The tunnel should appear in the \u0026ldquo;Forwarded ports\u0026rdquo; list Step 4: Connect Click Open to initiate the connection If this is your first time connecting, you\u0026rsquo;ll see a security alert - click Yes to trust the server Enter your username when prompted Enter your password when prompted Once connected, you can access your remote I2P console by opening a browser and navigating to http://127.0.0.1:7657\nOptional: Save Your Session To avoid reconfiguring each time:\nReturn to the Session category Enter a name in Saved Sessions (e.g., \u0026ldquo;I2P Tunnel\u0026rdquo;) Click Save Next time, just load this session and click Open Creating SSH Tunnels on Linux Linux systems have SSH built into the terminal, making tunnel creation quick and straightforward.\nUsing the Terminal Open a terminal and run the SSH tunnel command:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Replace:\n7657 (first occurrence): Your desired local port 127.0.0.1:7657: The destination address and port on the remote server i2p: Your username on the remote server 20.228.143.58: Your remote server\u0026rsquo;s IP address When prompted, enter your password. Once connected, the tunnel is active.\nAccess your remote I2P console at http://127.0.0.1:7657 in your browser.\nKeeping the Tunnel Active The tunnel stays active as long as the SSH session is running. To keep it running in the background:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Additional flags:\n-f: Runs SSH in the background -N: Don\u0026rsquo;t execute remote commands (tunnel only) To close a background tunnel, find and kill the SSH process:\nps aux | grep ssh kill [process_id] Using SSH Keys (Recommended) For better security and convenience, use SSH key authentication:\nGenerate an SSH key pair (if you don\u0026rsquo;t have one):\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; Copy your public key to the remote server:\nssh-copy-id i2p@20.228.143.58 Now you can connect without a password:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Creating SSH Tunnels on Mac Mac systems use the same SSH client as Linux, so the process is identical.\nUsing the Terminal Open Terminal (Applications → Utilities → Terminal) and run:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Replace:\n7657 (first occurrence): Your desired local port 127.0.0.1:7657: The destination address and port on the remote server i2p: Your username on the remote server 20.228.143.58: Your remote server\u0026rsquo;s IP address Enter your password when prompted. Once connected, access your remote I2P console at http://127.0.0.1:7657\nBackground Tunnels on Mac Same as Linux, you can run the tunnel in the background:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 SSH Key Setup on Mac Mac SSH key setup is identical to Linux:\n# Generate key (if needed) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # Copy to remote server ssh-copy-id i2p@20.228.143.58 Common Use Cases Accessing I2P Console The most common use case - access your remote I2P router console:\nssh -L 7657:127.0.0.1:7657 user@remote-server Then open http://127.0.0.1:7657 in your browser.\nMultiple Tunnels Forward multiple ports at once:\nssh -L 7657:127.0.0.1:7657 -L 7658:127.0.0.1:7658 user@remote-server This forwards both port 7657 (I2P console) and 7658 (another service).\nCustom Local Port Use a different local port if 7657 is already in use:\nssh -L 8080:127.0.0.1:7657 user@remote-server Access I2P console at http://127.0.0.1:8080 instead.\nTroubleshooting Port Already in Use Error: \u0026ldquo;bind: Address already in use\u0026rdquo;\nSolution: Choose a different local port or kill the process using that port:\n# Linux/Mac - find process on port 7657 lsof -i :7657 # Kill the process kill [process_id] Connection Refused Error: \u0026ldquo;Connection refused\u0026rdquo; or \u0026ldquo;channel 2: open failed\u0026rdquo;\nPossible causes:\nRemote service isn\u0026rsquo;t running (check I2P router is running on remote server) Firewall blocking the connection Incorrect destination port Solution: Verify the I2P router is running on the remote server:\nssh user@remote-server \u0026#34;systemctl status i2p\u0026#34; Authentication Failed Error: \u0026ldquo;Permission denied\u0026rdquo; or \u0026ldquo;Authentication failed\u0026rdquo;\nPossible causes:\nIncorrect username or password SSH key not properly configured SSH access disabled on remote server Solution: Verify credentials and ensure SSH access is enabled on the remote server.\nTunnel Drops Connection Error: Connection drops after period of inactivity\nSolution: Add keep-alive settings to your SSH config (~/.ssh/config):\nHost remote-server ServerAliveInterval 60 ServerAliveCountMax 3 Security Best Practices Use SSH keys: More secure than passwords, harder to compromise Disable password authentication: Once SSH keys are set up, disable password login on the server Use strong passwords: If using password authentication, use a strong, unique password Limit SSH access: Configure firewall rules to limit SSH access to trusted IPs Keep SSH updated: Regularly update your SSH client and server software Monitor logs: Check SSH logs on the server for suspicious activity Use non-standard SSH ports: Change the default SSH port (22) to reduce automated attacks Automating Tunnels Linux/Mac: Create a Startup Script Create a script to automatically establish tunnels:\n#!/bin/bash # i2p-tunnel.sh ssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 echo \u0026#34;I2P tunnel established\u0026#34; Make it executable:\nchmod +x i2p-tunnel.sh ./i2p-tunnel.sh Linux: SystemD Service Create a systemd service for automatic tunnel creation:\nsudo nano /etc/systemd/system/i2p-tunnel.service Add:\n[Unit] Description=I2P SSH Tunnel After=network.target [Service] ExecStart=/usr/bin/ssh -NT -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Restart=always RestartSec=10 User=your-username [Install] WantedBy=multi-user.target Enable and start:\nsudo systemctl enable i2p-tunnel sudo systemctl start i2p-tunnel Advanced Tunneling Dynamic Port Forwarding (SOCKS Proxy) Create a SOCKS proxy for dynamic forwarding:\nssh -D 8080 user@remote-server Configure your browser to use 127.0.0.1:8080 as a SOCKS5 proxy.\nReverse Tunneling Allow the remote server to access services on your local machine:\nssh -R 7657:127.0.0.1:7657 user@remote-server Jump Host Tunneling Tunnel through an intermediate server:\nssh -J jumphost.example.com -L 7657:127.0.0.1:7657 user@final-server Conclusion SSH tunneling is a powerful tool for securely accessing remote I2P routers and other services. Whether you\u0026rsquo;re using Windows, Linux, or Mac, the process is straightforward and provides strong encryption for your connections.\nFor additional help or questions, visit the I2P community:\nForum: i2pforum.net IRC: #i2p on various networks Documentation: I2P Docs Guide originally created by Stormy Cloud, adapted for I2P documentation.\n","description":"Learn how to create secure SSH tunnels on Windows, Linux, and Mac to access your remote I2P router","id":"7d461aaa86788adfcb07bfb98f6e4965","section":"docs","title":"Creating an SSH Tunnel to Access I2P Remotely","url":"/en/docs/guides/creating-an-ssh-tunnel-to-access-i2p-remotely/"},{"categories":null,"content":"Reseed hosts are crucial infrastructure for the I2P network, providing new routers with an initial group of nodes during the bootstrap process. This guide will walk you through setting up and running your own reseed server.\nWhat is an I2P Reseed Server? An I2P reseed server helps integrate new routers into the I2P network by:\nProviding initial peer discovery: New routers receive a starting set of network nodes to connect to Bootstrap recovery: Helping routers that are struggling to maintain connections Secure distribution: The reseeding process is encrypted and digitally signed to ensure network security When a new I2P router starts for the first time (or has lost all its peer connections), it contacts reseed servers to download an initial set of router information. This allows the new router to begin building its own network database and establishing tunnels.\nPrerequisites Before beginning, you\u0026rsquo;ll need:\nA Linux server (Debian/Ubuntu recommended) with root access A domain name pointing to your server At least 1GB RAM and 10GB disk space A running I2P router on the server to populate the network database Basic familiarity with Linux system administration Preparing the Server Step 1: Update System and Install Dependencies First, update your system and install the required packages:\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt-get install golang-go git make docker.io docker-compose -y This installs:\ngolang-go: Go programming language runtime git: Version control system make: Build automation tool docker.io \u0026amp; docker-compose: Container platform for running Nginx Proxy Manager Step 2: Clone and Build Reseed Tools Clone the reseed-tools repository and build the application:\ncd /home/i2p git clone https://i2pgit.org/idk/reseed-tools cd reseed-tools make build sudo make install The reseed-tools package provides the core functionality for running a reseed server. It handles:\nCollecting router information from your local network database Packaging router info into signed SU3 files Serving these files over HTTPS Step 3: Generate SSL Certificate Generate your reseed server\u0026rsquo;s SSL certificate and private key:\nsu - i2p -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Important parameters:\n--signer: Your email address (replace admin@stormycloud.org with your own) --netdb: Path to your I2P router\u0026rsquo;s network database --port: Internal port (8443 is recommended) --ip: Bind to localhost (we\u0026rsquo;ll use a reverse proxy for public access) --trustProxy: Trust X-Forwarded-For headers from the reverse proxy The command will generate:\nA private key for signing SU3 files An SSL certificate for secure HTTPS connections Step 4: Backup Your Keys Critical: Securely backup the generated keys located in /home/i2p/.reseed/:\nsudo tar -czf reseed-keys-backup.tar.gz /home/i2p/.reseed/ Store this backup in a secure, encrypted location with limited access. These keys are essential for your reseed server\u0026rsquo;s operation and should be protected carefully.\nConfiguring the Service Step 5: Create Systemd Service Create a systemd service to run the reseed server automatically:\nsudo tee /etc/systemd/system/reseed.service \u0026lt;\u0026lt;EOF [Unit] Description=Reseed Service After=network.target [Service] User=i2p WorkingDirectory=/home/i2p ExecStart=/bin/bash -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF Remember to replace admin@stormycloud.org with your own email address.\nNow enable and start the service:\nsudo systemctl daemon-reload sudo systemctl enable reseed sudo systemctl start reseed Check that the service is running:\nsudo systemctl status reseed Step 6: Optional - Configure Periodic Restarts For optimal performance, you may want to restart the reseed service periodically to refresh the router information:\nsudo crontab -e Add this line to restart the service every 3 hours:\n0 */3 * * * systemctl restart reseed Setting Up Reverse Proxy The reseed server runs on localhost:8443 and needs a reverse proxy to handle public HTTPS traffic. We recommend Nginx Proxy Manager for its ease of use.\nInstall Nginx Proxy Manager Deploy Nginx Proxy Manager using Docker:\ndocker run -d \\ --name nginx-proxy-manager \\ -p 80:80 \\ -p 81:81 \\ -p 443:443 \\ -v $(pwd)/data:/data \\ -v $(pwd)/letsencrypt:/etc/letsencrypt \\ --restart unless-stopped \\ jc21/nginx-proxy-manager:latest This exposes:\nPort 80: HTTP traffic Port 81: Admin interface Port 443: HTTPS traffic Configure Proxy Manager Access the admin interface at http://your-server-ip:81\nLogin with default credentials:\nEmail: admin@example.com Password: changeme Important: Change these credentials immediately after first login!\nNavigate to Proxy Hosts and click Add Proxy Host Configure the proxy host: Domain Name: Your reseed domain (e.g., reseed.example.com) Scheme: https Forward Hostname / IP: 127.0.0.1 Forward Port: 8443 Enable Cache Assets Enable Block Common Exploits Enable Websockets Support In the SSL tab: Select Request a new SSL Certificate (Let\u0026rsquo;s Encrypt) Enable Force SSL Enable HTTP/2 Support Agree to Let\u0026rsquo;s Encrypt Terms of Service Click Save Your reseed server should now be accessible at https://reseed.example.com\nRegistering Your Reseed Server Once your reseed server is operational, contact the I2P developers to have it added to the official reseed server list.\nContact Information Email zzz (I2P lead developer) with the following information:\nI2P Email: zzz@mail.i2p Clearnet Email: zzz@i2pmail.org Required Information Include in your email:\nReseed server URL: The full HTTPS URL (e.g., https://reseed.example.com) Public reseed certificate: Located at /home/i2p/.reseed/ (attach the .crt file) Contact email: Your preferred contact method for server maintenance notifications Server location: Optional but helpful (country/region) Expected uptime: Your commitment to maintaining the server Verification The I2P developers will verify your reseed server is:\nProperly configured and serving router information Using valid SSL certificates Providing correctly signed SU3 files Accessible and responsive Once approved, your reseed server will be added to the list distributed with I2P routers, helping new users join the network!\nMonitoring and Maintenance Check Service Status Monitor your reseed service:\nsudo systemctl status reseed sudo journalctl -u reseed -f Monitor Resource Usage Keep an eye on system resources:\nhtop df -h Update Reseed Tools Periodically update the reseed-tools to get the latest improvements:\ncd /home/i2p/reseed-tools git pull make build sudo make install sudo systemctl restart reseed Certificate Renewal If using Let\u0026rsquo;s Encrypt through Nginx Proxy Manager, certificates will auto-renew. Verify renewal is working:\ndocker logs nginx-proxy-manager | grep -i certificate Troubleshooting Service Won\u0026rsquo;t Start Check logs for errors:\nsudo journalctl -u reseed -n 50 Common issues:\nI2P router not running or network database empty Port 8443 already in use Permission issues with /home/i2p/.reseed/ directory No Router Info Being Served Ensure your I2P router is running and has populated its network database:\nls -lh /home/i2p/.i2p/netDb/ You should see many .dat files. If empty, wait for your I2P router to discover peers.\nSSL Certificate Errors Verify your certificates are valid:\nopenssl s_client -connect reseed.example.com:443 -servername reseed.example.com Can\u0026rsquo;t Access via Domain Check:\nDNS records are correctly pointing to your server Firewall allows ports 80 and 443 Nginx Proxy Manager is running: docker ps Security Considerations Keep your private keys secure: Never share or expose /home/i2p/.reseed/ contents Regular updates: Keep system packages, Docker, and reseed-tools updated Monitor logs: Watch for suspicious access patterns Rate limiting: Consider implementing rate limiting to prevent abuse Firewall rules: Only expose necessary ports (80, 443, 81 for admin) Admin interface: Restrict Nginx Proxy Manager admin interface (port 81) to trusted IPs Contributing to the Network By running a reseed server, you\u0026rsquo;re providing critical infrastructure for the I2P network. Thank you for contributing to a more private and decentralized internet!\nFor questions or assistance, reach out to the I2P community:\nForum: i2pforum.net IRC/Reddit: #i2p on various networks Development: i2pgit.org Guide originally created by Stormy Cloud, adapted for I2P documentation.\n","description":"Complete guide to setting up and operating an I2P reseed server to help new routers join the network","id":"d360e14f0f61d776e3c0b0f5b1262be5","section":"docs","title":"Creating and Running an I2P Reseed Server","url":"/en/docs/guides/creating-and-running-an-i2p-reseed-server/"},{"categories":null,"content":"Overview Datagrams provide message-oriented communication above I2CP and parallel to the streaming library.\nThey enable repliable, authenticated, or raw packets without requiring connection-oriented streams.\nRouters encapsulate datagrams into I2NP messages and tunnel messages, regardless of whether NTCP2 or SSU2 carries the traffic.\nThe core motivation is to allow applications (like trackers, DNS resolvers, or games) to send self-contained packets that identify their sender.\nNew in 2025: The I2P Project approved Datagram2 (protocol 19) and Datagram3 (protocol 20), adding replay protection and lower-overhead repliable messaging for the first time in a decade.\n1. Protocol Constants Protocol Value Description Introduced PROTO_DATAGRAM 17 Signed (repliable) datagram – “Datagram1” Original PROTO_DATAGRAM_RAW 18 Unsigned (raw) datagram – no sender info Original PROTO_DATAGRAM2 19 Signed + replay-protected datagram API 0.9.66 (2025) PROTO_DATAGRAM3 20 Repliable (no signature, hash only) API 0.9.66 (2025) Protocols 19 and 20 were formalized in Proposal 163 (April 2025).\nThey coexist with Datagram1 / RAW for backward compatibility.\n2. Datagram Types Type Protocol Repliable Authenticated Replay Protection Min Overhead Notes Raw 18 No No No 0 Minimal size; spoofable. Datagram1 17 Yes Yes No ≈ 427 Full Destination + signature. Datagram2 19 Yes Yes Yes ≈ 457 Replay prevention + offline signatures; PQ-ready. Datagram3 20 Yes No No ≈ 34 Sender hash only; low overhead. Typical Design Patterns Request → Response: Send a signed Datagram2 (request + nonce), receive a raw or Datagram3 reply (echo nonce). High-frequency/low-overhead: Prefer Datagram3 or RAW. Authenticated control messages: Datagram2. Legacy compatibility: Datagram1 still fully supported. 3. Datagram2 and Datagram3 Details (2025) Datagram2 (Protocol 19) Enhanced replacement for Datagram1.\nFeatures:\nReplay prevention: 4-byte anti-replay token. Offline signature support: enables use by offline-signed Destinations. Expanded signature coverage: includes destination hash, flags, options, offline sig block, payload. Post-quantum ready: compatible with future ML-KEM hybrids. Overhead: ≈ 457 bytes (X25519 keys). Datagram3 (Protocol 20) Bridges gap between raw and signed types.\nFeatures:\nRepliable without signature: contains sender’s 32-byte hash + 2-byte flags. Tiny overhead: ≈ 34 bytes. No replay defense — application must implement. Both protocols are API 0.9.66 features and implemented in the Java router since Release 2.9.0; no i2pd or Go implementations yet (October 2025).\n4. Size and Fragmentation Limits Tunnel message size: 1 028 bytes (4 B Tunnel ID + 16 B IV + 1 008 B payload). Initial fragment: 956 B (typical TUNNEL delivery). Follow-on fragment: 996 B. Max fragments: 63–64. Practical limit: ≈ 62 708 B (~61 KB). Recommended limit: ≤ 10 KB for reliable delivery (drops increase exponentially beyond this). Overhead summary:\nDatagram1 ≈ 427 B (minimum). Datagram2 ≈ 457 B. Datagram3 ≈ 34 B. Additional layers (I2CP gzip header, I2NP, Garlic, Tunnel): + ~5.5 KB worst case. 5. I2CP / I2NP Integration Message path:\nApplication creates datagram (via I2P API or SAM). I2CP wraps with gzip header (0x1F 0x8B 0x08, RFC 1952) and CRC-32 checksum. Protocol + Port numbers stored in gzip header fields. Router encapsulates as I2NP message → Garlic clove → 1 KB tunnel fragments. Fragments traverse outbound → network → inbound tunnel. Reassembled datagram delivered to application handler based on protocol number. Integrity: CRC-32 (from I2CP) + optional cryptographic signature (Datagram1/2).\nThere is no separate checksum field within the datagram itself.\n6. Programming Interfaces Java API Package net.i2p.client.datagram includes:\nI2PDatagramMaker – builds signed datagrams. I2PDatagramDissector – verifies and extracts sender info. I2PInvalidDatagramException – thrown on verification failure. I2PSessionMuxedImpl (net.i2p.client.impl.I2PSessionMuxedImpl) manages protocol and port multiplexing for apps sharing a Destination.\nJavadoc access:\nhttp://idk.i2p/javadoc-i2p/ (I2P network only) https://eyedeekay.github.io/javadoc-i2p/ (clearnet mirror) http://docs.i2p-projekt.de/javadoc/ (official docs) SAM v3 Support SAM 3.2 (2016): added PORT and PROTOCOL parameters. SAM 3.3 (2016): introduced PRIMARY/subsession model; allows streams + datagrams on one Destination. Support for Datagram2 / 3 session styles added spec 2025 (implementation pending). Official spec: \u0026lt;/docs/api/samv3/\u0026gt; i2ptunnel Modules udpTunnel: Fully functional base for I2P UDP apps (net.i2p.i2ptunnel.udpTunnel). streamr: Operational for A/V streaming (net.i2p.i2ptunnel.streamr). SOCKS UDP: Not functional as of 2.10.0 (UDP stub only). For general-purpose UDP, use the Datagram API or udpTunnel directly—do not rely on SOCKS UDP.\n7. Ecosystem and Language Support (2025) Language Library / Package SAM Version Status Javacore API (net.i2p.client.datagram)3.3✓ full support C++i2pd / libsam33.2 partialLimited Gogo-i2p / sam33.1–3.2Active Pythoni2plib, i2p.socket, txi2p3.2Active Rusti2p-rs, i2p_client3.3Active C#I2PSharp3.3Active JS/TSnode-i2p, i2p-sam3.2Active Haskellnetwork-anonymous-i2p3.2Experimental Luamooni2p3.2Experimental Java I2P is the only router supporting full SAM 3.3 subsessions and Datagram2 API at this time.\n8. Example Usage – UDP Tracker (I2PSnark 2.10.0) First real-world application of Datagram2/3:\nOperation Datagram Type Purpose Announce RequestDatagram3Repliable but low-overhead update ResponseRaw DatagramMinimal payload return Pattern demonstrates mixed use of authenticated and lightweight datagrams to balance security and performance.\n9. Security and Best Practices Use Datagram2 for any authenticated exchange or when replay attacks matter. Prefer Datagram3 for fast repliable responses with moderate trust. Use RAW for public broadcasts or anonymous data. Keep payloads ≤ 10 KB for reliable delivery. Be aware that SOCKS UDP remains non-functional. Always verify gzip CRC and digital signatures on receipt. 10. Technical Specification This section covers the low-level datagram formats, encapsulation, and protocol details.\n10.1 Protocol Identification Datagram formats do not share a common header. Routers cannot infer the type from payload bytes alone.\nWhen mixing multiple datagram types—or when combining datagrams with streaming—explicitly set:\nThe protocol number (via I2CP or SAM) Optionally the port number, if your application multiplexes services Leaving the protocol unset (0 or PROTO_ANY) is discouraged and may lead to routing or delivery errors.\n10.2 Raw Datagrams Non-repliable datagrams carry no sender or authentication data. They are opaque payloads, handled outside the higher-level datagram API but supported via SAM and I2PTunnel.\nProtocol: 18 (PROTO_DATAGRAM_RAW)\nFormat:\n+----+----+----+----+----// | payload... +----+----+----+----+----// Payload length is constrained by transport limits (≈32 KB practical max, often much less).\n10.3 Datagram1 (Repliable Datagrams) Embeds sender\u0026rsquo;s Destination and a Signature for authentication and reply addressing.\nProtocol: 17 (PROTO_DATAGRAM)\nOverhead: ≥427 bytes Payload: up to ~31.5 KB (limited by transport)\nFormat:\n+----+----+----+----+----+----+----+----+ | from | + + | | ~ Destination bytes ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | +----+----+----+----+----+----+----+----+ | payload... +----+----+----+----// from: a Destination (387+ bytes) signature: a Signature matching the key type For DSA_SHA1: Signature of the SHA-256 hash of the payload For other key types: Signature directly over the payload Notes:\nSignatures for non-DSA types were standardized in I2P 0.9.14. LS2 (Proposal 123) offline signatures are not currently supported in Datagram1. 10.4 Datagram2 Format An improved repliable datagram that adds replay resistance as defined in Proposal 163.\nProtocol: 19 (PROTO_DATAGRAM2)\nImplementation is ongoing. Applications should include nonce or timestamp checks for redundancy.\n10.5 Datagram3 Format Provides repliable but unauthenticated datagrams. Relies on router-maintained session authentication rather than embedded destination and signature.\nProtocol: 20 (PROTO_DATAGRAM3) Status: Under development since 0.9.66\nUseful when:\nDestinations are large (e.g., post-quantum keys) Authentication occurs at another layer Bandwidth efficiency is critical 10.6 Data Integrity Datagram integrity is protected by the gzip CRC-32 checksum in the I2CP layer. No explicit checksum field exists within the datagram payload format itself.\n10.7 Packet Encapsulation Each datagram is encapsulated as a single I2NP message or as an individual clove in a Garlic Message. I2CP, I2NP, and tunnel layers handle length and framing — there is no internal delimiter or length field in the datagram protocol.\n10.8 Post-Quantum (PQ) Considerations If Proposal 169 (ML-DSA signatures) is implemented, signature and destination sizes will rise dramatically — from ~455 bytes to ≥3739 bytes. This change will substantially increase datagram overhead and reduce effective payload capacity.\nDatagram3, which relies on session-level authentication (not embedded signatures), will likely become the preferred design in post-quantum I2P environments.\n11. References Proposal 163 – Datagram2 and Datagram3 Proposal 160 – UDP Tracker Integration Proposal 144 – Streaming MTU Calculations Proposal 169 – Post-Quantum Signatures I2CP Specification I2NP Specification Tunnel Message Specification SAM v3 Specification i2ptunnel Documentation 12. Change Log Highlights (2019 – 2025) Year Release Change 2019 0.9.43 Datagram API stabilization 2021 0.9.50 Protocol port handling reworked 2022 2.0.0 SSU2 adoption completed 2024 2.6.0 Legacy transport removal simplified UDP code 2025 2.9.0 Datagram2/3 support added (Java API) 2025 2.10.0 UDP Tracker implementation released 13. Summary The datagram subsystem now supports four protocol variants offering a spectrum from fully-authenticated to lightweight raw transmission.\nDevelopers should migrate toward Datagram2 for security-sensitive use cases and Datagram3 for efficient repliable traffic.\nAll older types remain compatible to ensure long-term interoperability.\n","description":"Authenticated, repliable, and raw message formats above I2CP","id":"b3c644204c779b5d6fc6a41438a3eb1b","section":"docs","title":"Datagrams","url":"/en/docs/api/datagrams/"},{"categories":null,"content":"Read the New Developers Guide first: /docs/develop/new-developers/\nBasic Guidelines and Coding Style Most of the following should be common sense for anybody who has worked on open source or in a commercial programming environment. The following applies mostly to the main development branch i2p.i2p. Guidelines for other branches, plugins, and external apps may be substantially different; check with the appropriate developer for guidance.\nCommunity Please don\u0026rsquo;t just write code. If you can, participate in other development activities, including: development discussions and support on IRC and i2pforum.i2p; testing; bug reporting and responses; documentation; code reviews; etc. Active devs should be available periodically on IRC #i2p-dev. Be aware of the current release cycle. Adhere to release milestones such as feature freeze, tag freeze, and the check-in deadline for a release. Release Cycle The normal release cycle is 10–16 weeks, four releases a year. Following are the approximate deadlines within a typical 13‑week cycle. Actual deadlines for each release are set by the release manager after consultation with the full team.\n1–2 days after previous release: Check-ins to trunk are allowed. 2–3 weeks after previous release: Deadline to propagate major changes from other branches to trunk. 4–5 weeks before release: Deadline to request new home page links. 3–4 weeks before release: Feature freeze. Deadline for major new features. 2–3 weeks before release: Hold project meeting to review new home page link requests, if any. 10–14 days before release: String freeze. No more changes to translated (tagged) strings. Push strings to Transifex, announce translation deadline on Transifex. 10–14 days before release: Feature deadline. Bug fixes only after this time. No more features, refactoring or cleanup. 3–4 days before release: Translation deadline. Pull translations from Transifex and check in. 3–4 days before release: Check-in deadline. No check-ins after this time without the permission of the release builder. Hours before release: Code review deadline. Git Have a basic understanding of distributed source control systems, even if you haven\u0026rsquo;t used git before. Ask for help if you need it. Once pushed, check-ins are forever; there is no undo. Please be careful. If you have not used git before, start with baby steps. Check in some small changes and see how it goes. Test your changes before checking them in. If you prefer the check-in‑before‑test development model, use your own development branch in your own account, and create an MR once the work is done. Do not break the build. Do not cause regressions. In case you do (it happens), please do not vanish for a long period after you push your change. If your change is non-trivial, or you want people to test it and need good test reports to know whether your change was tested or not, add a check-in comment to history.txt and increment the build revision in RouterVersion.java. Do not check in major changes into the main i2p.i2p branch late in the release cycle. If a project will take you more than a couple days, create your own branch in git, in your own account, and do the development there so you do not block releases. For big changes (generally speaking, more than 100 lines, or touching more than three files), check it into a new branch on your own GitLab account, create an MR, and assign a reviewer. Assign the MR to yourself. Merge the MR yourself once the reviewer approves it. Do not create WIP branches in the main I2P_Developers account (except for i2p.www). WIP belongs in your own account. When the work is done, create an MR. The only branches in the main account should be for true forks, like a point release. Do development in a transparent fashion and with the community in mind. Check in often. Check in or merge into the main branch as frequently as possible, given the guidelines above. If you are working on some big project in your own branch/account, let people know so they may follow along and review/test/comment. Coding Style Coding style throughout most of the code is 4 spaces for indentation. Do not use tabs. Do not reformat code. If your IDE or editor wants to reformat everything, get control of it. In some places, the coding style is different. Use common sense. Emulate the style in the file you are modifying. All new public and package-private classes and methods require Javadocs. Add @since release-number. Javadocs for new private methods are desirable. For any Javadocs added, there must not be any doclint errors or warnings. Run ant javadoc with Oracle Java 14 or higher to check. All params must have @param lines, all non-void methods must have @return lines, all exceptions declared thrown must have @throws lines, and no HTML errors. Classes in core/ (i2p.jar) and portions of i2ptunnel are part of our official API. There are several out-of-tree plugins and other applications that rely on this API. Be careful not to make any changes that break compatibility. Don\u0026rsquo;t add methods to the API unless they are of general utility. Javadocs for API methods should be clear and complete. If you add or change the API, also update the documentation on the website (i2p.www branch). Tag strings for translation where appropriate, which is true for all UI strings. Don\u0026rsquo;t change existing tagged strings unless really necessary, as it will break existing translations. Do not add or change tagged strings after the tag freeze in the release cycle so that translators have a chance to update before the release. Use generics and concurrent classes where possible. I2P is a highly multi-threaded application. Be familiar with common Java pitfalls that are caught by FindBugs/SpotBugs. Run ant findbugs to learn more. Java 8 is required to build and run I2P as of release 0.9.47. Do not use Java 7 or 8 classes or methods in embedded subsystems: addressbook, core, i2ptunnel.jar (non‑UI), mstreaming, router, routerconsole (news only), streaming. These subsystems are used by Android and embedded applications that require only Java 6. All classes must be available in Android API 14. Java 7 language features are acceptable in these subsystems if supported by the current version of the Android SDK and they compile to Java 6‑compatible code. Try‑with‑resources cannot be used in embedded subsystems as it requires java.lang.AutoCloseable in the runtime, and this is not available until Android API 19 (KitKat 4.4). The java.nio.file package cannot be used in embedded subsystems as it is not available until Android API 26 (Oreo 8). Other than the above limitations, Java 8 classes, methods, and constructs may be used in the following subsystems only: BOB, desktopgui, i2psnark, i2ptunnel.war (UI), jetty‑i2p.jar, jsonrpc, routerconsole (except news), SAM, susidns, susimail, systray. Plugin authors may require any minimum Java version via the plugin.config file. Explicitly convert between primitive types and classes; don\u0026rsquo;t rely on autoboxing/unboxing. Don\u0026rsquo;t use URL. Use URI. Don\u0026rsquo;t catch Exception. Catch RuntimeException and checked exceptions individually. Don\u0026rsquo;t use String.getBytes() without a UTF‑8 charset argument. You may also use DataHelper.getUTF8() or DataHelper.getASCII(). Always specify a UTF‑8 charset when reading or writing files. The DataHelper utilities may be helpful. Always specify a locale (for example Locale.US) when using String.toLowerCase() or String.toUpperCase(). Do not use String.equalsIgnoreCase(), as a locale cannot be specified. Don\u0026rsquo;t use String.split(). Use DataHelper.split(). Don\u0026rsquo;t add code to format dates and times. Use DataHelper.formatDate() and DataHelper.formatTime(). Ensure that InputStreams and OutputStreams are closed in finally blocks. Use {} for all for and while blocks, even if only one line. If you use {} for either the if, else, or if-else block, use it for all blocks. Put } else { on a single line. Specify fields as final wherever possible. Don\u0026rsquo;t store I2PAppContext, RouterContext, Log, or any other references to router or context items in static fields. Don\u0026rsquo;t start threads in constructors. Use I2PAppThread instead of Thread. Logging The following guidelines apply to the router, webapps, and all plugins.\nFor any messages not displayed at the default log level (WARN, INFO, and DEBUG), unless the message is a static string (no concatenation), always use log.shouldWarn(), log.shouldInfo(), or log.shouldDebug() before the log call to avoid unnecessary object churn. Log messages that may be displayed at the default log level (ERROR, CRIT, and logAlways()) should be brief, clear, and understandable to a non‑technical user. This includes exception reason text that may also be displayed. Consider translating if the error is likely to happen (for example, on form submission errors). Otherwise, translation is not necessary, but it may be helpful to search for and reuse a string that is already tagged for translation elsewhere. Log messages not displayed at the default log level (WARN, INFO, and DEBUG) are intended for developer use, and do not have the above requirements. However, WARN messages are available in the Android log tab, and may be of assistance to users debugging issues, so use some care with WARN messages as well. INFO and DEBUG log messages should be used sparingly, especially in hot code paths. While useful during development, consider removing them or commenting them out after testing is complete. Do not log to stdout or stderr (wrapper log). Licenses Only check in code that you wrote yourself. Before checking in any code or library JARs from other sources, justify why it is necessary, verify the license is compatible, and obtain approval from the release manager. If you do obtain approval to add external code or JARs, and binaries are available in any Debian or Ubuntu package, you must implement build and packaging options to use the external package instead. Checklist of files to modify: build.properties, build.xml, debian/control, debian/i2p-router.install, debian/i2p-router.links, debian/rules, sub-build.xml. For any images checked in from external sources, it is your responsibility to first verify the license is compatible. Include the license and source information in the check-in comment. Bugs Managing issues is everybody\u0026rsquo;s job; please help. Monitor GitLab for issues you can help with: https://i2pgit.org/I2P_Developers/i2p.i2p/issues. Comment on, fix, and close issues if you can. New developers should start by fixing issues. When you have a fix, attach your patch to the issue and add the keyword review-needed. Do not close the issue until it\u0026rsquo;s been successfully reviewed and you\u0026rsquo;ve checked your changes in. Once you\u0026rsquo;ve done this smoothly for a couple of tickets, you may follow the normal procedure above. Close an issue when you think you\u0026rsquo;ve fixed it. We don\u0026rsquo;t have a test department to verify and close tickets. If you aren’t sure you fixed it, close it and add a note saying \u0026ldquo;I think I fixed it, please test and reopen if it\u0026rsquo;s still broken\u0026rdquo;. Add a comment with the dev build number or revision and set the milestone to the next release. ","description":"End-to-end guidelines for contributing to I2P: workflow, release cycle, coding style, logging, licensing, and issue handling","id":"6c8fe691caf216ba9024152afc39c5c6","section":"docs","title":"Developer Guidelines and Coding Style","url":"/en/docs/develop/dev-guidelines/"},{"categories":null,"content":"Overview Purpose ECIES-X25519-AEAD-Ratchet is I2P\u0026rsquo;s modern end-to-end encryption protocol, replacing the legacy ElGamal/AES+SessionTags system. It provides forward secrecy, authenticated encryption, and significant improvements in performance and security.\nKey Improvements Over ElGamal/AES+SessionTags Smaller Keys: 32-byte keys vs 256-byte ElGamal public keys (87.5% reduction) Forward Secrecy: Achieved through DH ratcheting (not available in legacy protocol) Modern Cryptography: X25519 DH, ChaCha20-Poly1305 AEAD, SHA-256 Authenticated Encryption: Built-in authentication via AEAD construction Bidirectional Protocol: Paired inbound/outbound sessions vs unidirectional legacy Efficient Tags: 8-byte session tags vs 32-byte tags (75% reduction) Traffic Obfuscation: Elligator2 encoding makes handshakes indistinguishable from random Deployment Status Initial Release: Version 0.9.46 (May 25, 2020) Network Deployment: Complete as of 2020 Current Status: Mature, widely deployed (5+ years in production) Router Support: Version 0.9.46 or higher required Floodfill Requirements: Near 100% adoption for encrypted lookups Implementation Status Fully Implemented:\nNew Session (NS) messages with binding New Session Reply (NSR) messages Existing Session (ES) messages DH ratchet mechanism Session tag and symmetric key ratchets DateTime, NextKey, ACK, ACK Request, Garlic Clove, and Padding blocks Not Implemented (as of version 0.9.50):\nMessageNumbers block (type 6) Options block (type 5) Termination block (type 4) Protocol-layer automatic responses Zero static key mode Multicast sessions Note: Implementation status for versions 1.5.0 through 2.10.0 (2021-2025) requires verification as some features may have been added.\nProtocol Foundation Noise Protocol Framework ECIES-X25519-AEAD-Ratchet is based on the Noise Protocol Framework (Revision 34, 2018-07-11), specifically the IK (Interactive, Known remote static key) handshake pattern with I2P-specific extensions.\nNoise Protocol Identifier Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256 Identifier Components:\nNoise - Base framework IK - Interactive handshake pattern with Known remote static key elg2 - Elligator2 encoding for ephemeral keys (I2P extension) +hs2 - MixHash called before second message to mix in tag (I2P extension) 25519 - X25519 Diffie-Hellman function ChaChaPoly - ChaCha20-Poly1305 AEAD cipher SHA256 - SHA-256 hash function Noise Handshake Pattern IK Pattern Notation:\n\u0026lt;- s (Bob\u0026#39;s static key known to Alice) ... -\u0026gt; e, es, s, ss (Alice sends ephemeral, DH es, static key, DH ss) \u0026lt;- e, ee, se (Bob sends ephemeral, DH ee, DH se) Token Meanings:\ne - Ephemeral key transmission s - Static key transmission es - DH between Alice\u0026rsquo;s ephemeral and Bob\u0026rsquo;s static ss - DH between Alice\u0026rsquo;s static and Bob\u0026rsquo;s static ee - DH between Alice\u0026rsquo;s ephemeral and Bob\u0026rsquo;s ephemeral se - DH between Bob\u0026rsquo;s static and Alice\u0026rsquo;s ephemeral Noise Security Properties Using Noise terminology, the IK pattern provides:\nMessage Authentication Level Confidentiality Level Message\u0026nbsp;1 (NS) Level\u0026nbsp;1 (sender auth, KCI vulnerable) Level\u0026nbsp;2 (weak forward secrecy) Message\u0026nbsp;2 (NSR) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;4 (weak forward secrecy) Transport (ES) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;5 (strong forward secrecy) Authentication Levels:\nLevel 1: Payload is authenticated as belonging to the sender\u0026rsquo;s static key owner, but vulnerable to Key Compromise Impersonation (KCI) Level 2: Resistant to KCI attacks after NSR Confidentiality Levels:\nLevel 2: Forward secrecy if sender\u0026rsquo;s static key is later compromised Level 4: Forward secrecy if sender\u0026rsquo;s ephemeral key is later compromised Level 5: Full forward secrecy after both ephemeral keys are deleted IK vs XK Differences The IK pattern differs from the XK pattern used in NTCP2 and SSU2:\nFour DH Operations: IK uses 4 DH operations (es, ss, ee, se) vs 3 for XK Immediate Authentication: Alice is authenticated in the first message (Authentication Level 1) Faster Forward Secrecy: Full forward secrecy (Level 5) achieved after second message (1-RTT) Trade-off: First message payload is not forward-secret (vs XK where all payloads are forward-secret) Summary: IK enables 1-RTT delivery of Bob\u0026rsquo;s response with full forward secrecy, at the cost of the initial request not being forward-secret.\nSignal Double Ratchet Concepts ECIES incorporates concepts from the Signal Double Ratchet Algorithm:\nDH Ratchet: Provides forward secrecy by periodically exchanging new DH keys Symmetric Key Ratchet: Derives new session keys for each message Session Tag Ratchet: Generates one-time-use session tags deterministically Key Differences from Signal:\nLess Frequent Ratcheting: I2P ratchets only when needed (near tag exhaustion or by policy) Session Tags Instead of Header Encryption: Uses deterministic tags rather than encrypted headers Explicit ACKs: Uses in-band ACK blocks rather than relying solely on reverse traffic Separate Tag and Key Ratchets: More efficient for receiver (can defer key calculation) I2P Extensions to Noise Elligator2 Encoding: Ephemeral keys encoded to be indistinguishable from random Tag Prepended to NSR: Session tag added before NSR message for correlation Defined Payload Format: Block-based payload structure for all message types I2NP Encapsulation: All messages wrapped in I2NP Garlic Message headers Separate Data Phase: Transport messages (ES) diverge from standard Noise data phase Cryptographic Primitives X25519 Diffie-Hellman Specification: RFC 7748\nKey Properties:\nPrivate Key Size: 32 bytes Public Key Size: 32 bytes Shared Secret Size: 32 bytes Endianness: Little-endian Curve: Curve25519 Operations:\nX25519 GENERATE_PRIVATE() Generates a random 32-byte private key:\nprivkey = CSRNG(32) X25519 DERIVE_PUBLIC(privkey) Derives the corresponding public key:\npubkey = curve25519_scalarmult_base(privkey) Returns 32-byte little-endian public key.\nX25519 DH(privkey, pubkey) Performs Diffie-Hellman key agreement:\nsharedSecret = curve25519_scalarmult(privkey, pubkey) Returns 32-byte shared secret.\nSecurity Note: Implementers must validate that the shared secret is not all zeros (weak key). Reject and abort handshake if this occurs.\nChaCha20-Poly1305 AEAD Specification: RFC 7539 section 2.8\nParameters:\nKey Size: 32 bytes (256 bits) Nonce Size: 12 bytes (96 bits) MAC Size: 16 bytes (128 bits) Block Size: 64 bytes (internal) Nonce Format:\nByte 0-3: 0x00 0x00 0x00 0x00 (always zero) Byte 4-11: Little-endian counter (message number N) AEAD Construction:\nThe AEAD combines ChaCha20 stream cipher with Poly1305 MAC:\nGenerate ChaCha20 keystream from key and nonce Encrypt plaintext via XOR with keystream Compute Poly1305 MAC over (associated data || ciphertext) Append 16-byte MAC to ciphertext ChaCha20-Poly1305 ENCRYPT(k, n, plaintext, ad) Encrypts plaintext with authentication:\n# Inputs k = 32-byte cipher key n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number) plaintext = data to encrypt (0 to 65519 bytes) ad = associated data (optional, used in MAC calculation) # Output ciphertext = chacha20_encrypt(k, n, plaintext) mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n)) return ciphertext || mac # Total length = len(plaintext) + 16 Properties:\nCiphertext is same length as plaintext (stream cipher) Output is plaintext_length + 16 bytes (includes MAC) Entire output is indistinguishable from random if key is secret MAC authenticates both associated data and ciphertext ChaCha20-Poly1305 DECRYPT(k, n, ciphertext, ad) Decrypts and verifies authentication:\n# Split ciphertext and MAC ct_without_mac = ciphertext[0:-16] received_mac = ciphertext[-16:] # Verify MAC expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n)) if not constant_time_compare(received_mac, expected_mac): raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) # Decrypt plaintext = chacha20_decrypt(k, n, ct_without_mac) return plaintext Critical Security Requirements:\nNonces MUST be unique for each message with the same key Nonces MUST NOT be reused (catastrophic failure if reused) MAC verification MUST use constant-time comparison to prevent timing attacks Failed MAC verification MUST result in complete message rejection (no partial decryption) SHA-256 Hash Function Specification: NIST FIPS 180-4\nProperties:\nOutput Size: 32 bytes (256 bits) Block Size: 64 bytes (512 bits) Security Level: 128 bits (collision resistance) Operations:\nSHA-256 H(p, d) SHA-256 hash with personalization string:\nH(p, d) := SHA256(p || d) Where || denotes concatenation, p is personalization string, d is data.\nSHA-256 MixHash(d) Updates running hash with new data:\nh = SHA256(h || d) Used throughout Noise handshake to maintain transcript hash.\nHKDF Key Derivation Specification: RFC 5869\nDescription: HMAC-based Key Derivation Function using SHA-256\nParameters:\nHash Function: HMAC-SHA256 Salt Length: Up to 32 bytes (SHA-256 output size) Output Length: Variable (up to 255 * 32 bytes) HKDF Function:\ndef HKDF(salt, ikm, info, length): \u0026#34;\u0026#34;\u0026#34; Args: salt: Salt value (32 bytes max for SHA-256) ikm: Input key material (any length) info: Context-specific info string length: Desired output length in bytes Returns: output: Derived key material (length bytes) \u0026#34;\u0026#34;\u0026#34; # Extract phase prk = HMAC-SHA256(salt, ikm) # Expand phase n = ceil(length / 32) t = b\u0026#39;\u0026#39; okm = b\u0026#39;\u0026#39; for i in range(1, n + 1): t = HMAC-SHA256(prk, t || info || byte(i)) okm = okm || t return okm[0:length] Common Usage Patterns:\n# Generate two keys (64 bytes total) keydata = HKDF(chainKey, sharedSecret, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey = keydata[32:63] # Generate session tag (8 bytes) tagdata = HKDF(chainKey, CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) nextChainKey = tagdata[0:31] sessionTag = tagdata[32:39] # Generate symmetric key (32 bytes) keydata = HKDF(chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) nextChainKey = keydata[0:31] sessionKey = keydata[32:63] Info Strings Used in ECIES:\n\u0026quot;KDFDHRatchetStep\u0026quot; - DH ratchet key derivation \u0026quot;TagAndKeyGenKeys\u0026quot; - Initialize tag and key chain keys \u0026quot;STInitialization\u0026quot; - Session tag ratchet initialization \u0026quot;SessionTagKeyGen\u0026quot; - Session tag generation \u0026quot;SymmetricRatchet\u0026quot; - Symmetric key generation \u0026quot;XDHRatchetTagSet\u0026quot; - DH ratchet tagset key \u0026quot;SessionReplyTags\u0026quot; - NSR tagset generation \u0026quot;AttachPayloadKDF\u0026quot; - NSR payload key derivation Elligator2 Encoding Purpose: Encode X25519 public keys to be indistinguishable from uniform random 32-byte strings.\nSpecification: Elligator2 Paper\nProblem: Standard X25519 public keys have recognizable structure. An observer can identify handshake messages by detecting these keys, even if content is encrypted.\nSolution: Elligator2 provides a bijective mapping between ~50% of valid X25519 public keys and random-looking 254-bit strings.\nKey Generation with Elligator2:\nElligator2 GENERATE_PRIVATE_ELG2() Generates a private key that maps to an Elligator2-encodable public key:\nwhile True: privkey = CSRNG(32) pubkey = DERIVE_PUBLIC(privkey) # Test if public key is Elligator2-encodable try: encoded = ENCODE_ELG2(pubkey) # Success - this key pair is suitable return privkey except NotEncodableError: # Try again with new random key continue Important: Approximately 50% of randomly generated private keys will produce non-encodable public keys. These must be discarded and regeneration attempted.\nPerformance Optimization: Generate keys in advance in a background thread to maintain a pool of suitable key pairs, avoiding delays during handshake.\nElligator2 ENCODE_ELG2(pubkey) Encodes a public key to 32 random-looking bytes:\ndef ENCODE_ELG2(pubkey): \u0026#34;\u0026#34;\u0026#34; Encodes X25519 public key using Elligator2. Args: pubkey: 32-byte X25519 public key (little-endian) Returns: encoded: 32-byte encoded key indistinguishable from random Raises: NotEncodableError: If pubkey cannot be encoded \u0026#34;\u0026#34;\u0026#34; # Perform Elligator2 representative calculation # Returns 254-bit value (31.75 bytes) encodedKey = elligator2_encode(pubkey) # Add 2 random bits to MSB to make full 32 bytes randomByte = CSRNG(1) encodedKey[31] |= (randomByte \u0026amp; 0xc0) return encodedKey Encoding Details:\nElligator2 produces 254 bits (not full 256) Top 2 bits of byte 31 are random padding Result is uniformly distributed across 32-byte space Successfully encodes approximately 50% of valid X25519 public keys Elligator2 DECODE_ELG2(encodedKey) Decodes back to original public key:\ndef DECODE_ELG2(encodedKey): \u0026#34;\u0026#34;\u0026#34; Decodes Elligator2-encoded key back to X25519 public key. Args: encodedKey: 32-byte encoded key Returns: pubkey: 32-byte X25519 public key (little-endian) \u0026#34;\u0026#34;\u0026#34; # Mask out 2 random padding bits from MSB encodedKey[31] \u0026amp;= 0x3f # Perform Elligator2 representative inversion pubkey = elligator2_decode(encodedKey) return pubkey Security Properties:\nEncoded keys are computationally indistinguishable from random bytes No statistical tests can reliably detect Elligator2-encoded keys Decoding is deterministic (same encoded key always produces same public key) Encoding is bijective for the ~50% of keys in the encodable subset Implementation Notes:\nStore encoded keys in generation phase to avoid re-encoding during handshake Unsuitable keys from Elligator2 generation can be used for NTCP2 (which doesn\u0026rsquo;t require Elligator2) Background key generation is essential for performance Average generation time doubles due to 50% rejection rate Message Formats Overview ECIES defines three message types:\nNew Session (NS): Initial handshake message from Alice to Bob New Session Reply (NSR): Bob\u0026rsquo;s handshake reply to Alice Existing Session (ES): All subsequent messages in both directions All messages are encapsulated in I2NP Garlic Message format with additional encryption layers.\nI2NP Garlic Message Container All ECIES messages are wrapped in standard I2NP Garlic Message headers:\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ | length | | +----+----+----+----+ + | encrypted data | ~ ~ Fields:\ntype: 0x26 (Garlic Message) msg_id: 4-byte I2NP message ID expiration: 8-byte Unix timestamp (milliseconds) size: 2-byte payload size chks: 1-byte checksum length: 4-byte encrypted data length encrypted data: ECIES-encrypted payload Purpose: Provides I2NP-layer message identification and routing. The length field allows receivers to know the total encrypted payload size.\nNew Session (NS) Message The New Session message initiates a new session from Alice to Bob. It comes in three variants:\nWith Binding (1b): Includes Alice\u0026rsquo;s static key for bidirectional communication Without Binding (1c): Omits static key for one-way communication One-Time (1d): Single-message mode with no session establishment NS Message with Binding (Type 1b) Use Case: Streaming, repliable datagrams, any protocol requiring replies\nTotal Length: 96 + payload_length bytes\nFormat:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Static Key Section + | ChaCha20 encrypted data | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Static Key Section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Field Details:\nEphemeral Public Key (32 bytes, cleartext):\nAlice\u0026rsquo;s one-time X25519 public key Encoded with Elligator2 (indistinguishable from random) Generated fresh for each NS message (never reused) Little-endian format Static Key Section (32 bytes encrypted, 48 bytes with MAC):\nContains Alice\u0026rsquo;s X25519 static public key (32 bytes) Encrypted with ChaCha20 Authenticated with Poly1305 MAC (16 bytes) Used by Bob to bind session to Alice\u0026rsquo;s destination Payload Section (variable length encrypted, +16 bytes MAC):\nContains garlic cloves and other blocks Must include DateTime block as first block Usually includes Garlic Clove blocks with application data May include NextKey block for immediate ratchet Encrypted with ChaCha20 Authenticated with Poly1305 MAC (16 bytes) Security Properties:\nEphemeral key provides forward secrecy component Static key authenticates Alice (binding to destination) Both sections have separate MACs for domain separation Total handshake performs 2 DH operations (es, ss) NS Message without Binding (Type 1c) Use Case: Raw datagrams where no reply is expected or desired\nTotal Length: 96 + payload_length bytes\nFormat:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | All zeros | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for above section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Key Difference: Flags Section contains 32 bytes of zeros instead of static key.\nDetection: Bob determines message type by decrypting the 32-byte section and checking if all bytes are zero:\nAll zeros → Unbound session (type 1c) Non-zero → Bound session with static key (type 1b) Properties:\nNo static key means no binding to Alice\u0026rsquo;s destination Bob cannot send replies (no destination known) Performs only 1 DH operation (es) Follows Noise \u0026ldquo;N\u0026rdquo; pattern rather than \u0026ldquo;IK\u0026rdquo; More efficient when replies are never needed Flags Section (reserved for future use): Currently all zeros. May be used for feature negotiation in future versions.\nNS One-Time Message (Type 1d) Use Case: Single anonymous message with no session or reply expected\nTotal Length: 96 + payload_length bytes\nFormat: Identical to NS without binding (type 1c)\nDistinction:\nType 1c may send multiple messages in the same session (ES messages follow) Type 1d sends exactly one message with no session establishment In practice, implementations may treat these identically initially Properties:\nMaximum anonymity (no static key, no session) No session state retained by either party Follows Noise \u0026ldquo;N\u0026rdquo; pattern Single DH operation (es) New Session Reply (NSR) Message Bob sends one or more NSR messages in response to Alice\u0026rsquo;s NS message. NSR completes the Noise IK handshake and establishes bidirectional session.\nTotal Length: 72 + payload_length bytes\nFormat:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Ephemeral Public Key + | | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Key Section (empty) + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Field Details:\nSession Tag (8 bytes, cleartext):\nGenerated from NSR tagset (see KDF sections) Correlates this reply with Alice\u0026rsquo;s NS message Allows Alice to identify which NS this NSR responds to One-time use (never reused) Ephemeral Public Key (32 bytes, cleartext):\nBob\u0026rsquo;s one-time X25519 public key Encoded with Elligator2 Generated fresh for each NSR message Must be different for each NSR sent Key Section MAC (16 bytes):\nAuthenticates empty data (ZEROLEN) Part of Noise IK protocol (se pattern) Uses hash transcript as associated data Critical for binding NSR to NS Payload Section (variable length):\nContains garlic cloves and blocks Usually includes application-layer replies May be empty (ACK-only NSR) Maximum size: 65519 bytes (65535 - 16 byte MAC) Multiple NSR Messages:\nBob may send multiple NSR messages in response to one NS:\nEach NSR has unique ephemeral key Each NSR has unique session tag Alice uses first NSR received to complete handshake Other NSRs are redundancy (in case of packet loss) Critical Timing:\nAlice must receive one NSR before sending ES messages Bob must receive one ES message before sending ES messages NSR establishes bidirectional session keys via split() operation Security Properties:\nCompletes Noise IK handshake Performs 2 additional DH operations (ee, se) Total 4 DH operations across NS+NSR Achieves mutual authentication (Level 2) Provides weak forward secrecy (Level 4) for NSR payload Existing Session (ES) Message All messages after the NS/NSR handshake use the Existing Session format. ES messages are used bidirectionally by both Alice and Bob.\nTotal Length: 8 + payload_length + 16 bytes (minimum 24 bytes)\nFormat:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) + | 16 bytes | +----+----+----+----+----+----+----+----+ Field Details:\nSession Tag (8 bytes, cleartext):\nGenerated from current outbound tagset Identifies the session and message number Receiver looks up tag to find session key and nonce One-time use (each tag used exactly once) Format: First 8 bytes of HKDF output Payload Section (variable length):\nContains garlic cloves and blocks No required blocks (may be empty) Common blocks: Garlic Clove, NextKey, ACK, ACK Request, Padding Maximum size: 65519 bytes (65535 - 16 byte MAC) MAC (16 bytes):\nPoly1305 authentication tag Computed over entire payload Associated data: the 8-byte session tag Must verify correctly or message is rejected Tag Lookup Process:\nReceiver extracts 8-byte tag Looks up tag in all current inbound tagsets Retrieves associated session key and message number N Constructs nonce: [0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)] Decrypts payload using AEAD with tag as associated data Removes tag from tagset (one-time use) Processes decrypted blocks Session Tag Not Found:\nIf tag is not found in any tagset:\nMay be an NS message → attempt NS decryption May be NSR message → attempt NSR decryption May be out-of-order ES → wait briefly for tagset update May be replay attack → reject May be corrupted data → reject Empty Payload:\nES messages may have empty payloads (0 bytes):\nServes as explicit ACK when ACK Request was received Provides protocol-layer response without application data Still consumes a session tag Useful when higher layer has no immediate data to send Security Properties:\nFull forward secrecy (Level 5) after NSR received Authenticated encryption via AEAD Tag acts as additional associated data Maximum 65535 messages per tagset before ratchet required Key Derivation Functions This section documents all KDF operations used in ECIES, showing the complete cryptographic derivations.\nNotation and Constants Constants:\nZEROLEN - Zero-length byte array (empty string) || - Concatenation operator Variables:\nh - Running hash transcript (32 bytes) chainKey - Chaining key for HKDF (32 bytes) k - Symmetric cipher key (32 bytes) n - Nonce / message number Keys:\nask / apk - Alice\u0026rsquo;s static private/public key aesk / aepk - Alice\u0026rsquo;s ephemeral private/public key bsk / bpk - Bob\u0026rsquo;s static private/public key besk / bepk - Bob\u0026rsquo;s ephemeral private/public key NS Message KDFs KDF 1: Initial Chain Key Performed once at protocol initialization (can be precalculated):\n# Protocol name (40 bytes, ASCII, no null termination) protocol_name = \u0026#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256\u0026#34; # Initialize hash h = SHA256(protocol_name) # Initialize chaining key chainKey = h # MixHash with empty prologue h = SHA256(h) # State: chainKey and h initialized # Can be precalculated for all outbound sessions Result:\nchainKey = Initial chaining key for all subsequent KDFs h = Initial hash transcript KDF 2: Bob\u0026rsquo;s Static Key Mixing Bob performs this once (can be precalculated for all inbound sessions):\n# Bob\u0026#39;s static keys (published in LeaseSet) bsk = GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk) # Mix Bob\u0026#39;s public key into hash h = SHA256(h || bpk) # State: h updated with Bob\u0026#39;s identity # Can be precalculated by Bob for all inbound sessions KDF 3: Alice\u0026rsquo;s Ephemeral Key Generation Alice generates fresh keys for each NS message:\n# Generate ephemeral key pair suitable for Elligator2 aesk = GENERATE_PRIVATE_ELG2() aepk = DERIVE_PUBLIC(aesk) # Mix ephemeral public key into hash h = SHA256(h || aepk) # Elligator2 encode for transmission elg2_aepk = ENCODE_ELG2(aepk) # State: h updated with Alice\u0026#39;s ephemeral key # Send elg2_aepk as first 32 bytes of NS message KDF 4: NS Static Key Section (es DH) Derives keys for encrypting Alice\u0026rsquo;s static key:\n# Perform first DH (ephemeral-static) sharedSecret = DH(aesk, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, aepk) # Bob computes # Derive cipher key from shared secret keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption parameters nonce = 0 associated_data = h # Current hash transcript # Encrypt static key section if binding_requested: plaintext = apk # Alice\u0026#39;s static public key (32 bytes) else: plaintext = bytes(32) # All zeros for unbound ciphertext = ENCRYPT(k, nonce, plaintext, associated_data) # ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Static key section encrypted, h updated # Send ciphertext (48 bytes) as next part of NS message KDF 5: NS Payload Section (ss DH, bound only) For bound sessions, perform second DH for payload encryption:\nif binding_requested: # Alice\u0026#39;s static keys ask = GENERATE_PRIVATE() # Alice\u0026#39;s long-term key apk = DERIVE_PUBLIC(ask) # Perform second DH (static-static) sharedSecret = DH(ask, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, apk) # Bob computes # Derive cipher key keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] nonce = 0 associated_data = h else: # Unbound: reuse keys from static key section # chainKey and k unchanged nonce = 1 # Increment nonce (reusing same key) associated_data = h # Encrypt payload payload = build_payload() # DateTime + Garlic Cloves + etc. ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Payload encrypted, h contains complete NS transcript # Save chainKey and h for NSR processing # Send ciphertext as final part of NS message Important Notes:\nBound vs Unbound:\nBound performs 2 DH operations (es + ss) Unbound performs 1 DH operation (es only) Unbound increments nonce instead of deriving new key Key Reuse Safety:\nDifferent nonces (0 vs 1) prevent key/nonce reuse Different associated data (h is different) provides domain separation Hash Transcript:\nh now contains: protocol_name, empty prologue, bpk, aepk, static_key_ciphertext, payload_ciphertext This transcript binds all parts of NS message together NSR Reply Tagset KDF Bob generates tags for NSR messages:\n# Chain key from NS payload section # chainKey = final chainKey from NS KDF # Generate tagset key tagsetKey = HKDF(chainKey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) # Initialize NSR tagset (see DH_INITIALIZE below) tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey) # Get tag for this NSR tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes # State: tag available for NSR message # Send tag as first 8 bytes of NSR NSR Message KDFs KDF 6: NSR Ephemeral Key Generation Bob generates fresh ephemeral key for each NSR:\n# Mix tag into hash (I2P extension to Noise) h = SHA256(h || tag) # Generate ephemeral key pair besk = GENERATE_PRIVATE_ELG2() bepk = DERIVE_PUBLIC(besk) # Mix ephemeral public key into hash h = SHA256(h || bepk) # Elligator2 encode for transmission elg2_bepk = ENCODE_ELG2(bepk) # State: h updated with tag and Bob\u0026#39;s ephemeral key # Send elg2_bepk as bytes 9-40 of NSR message KDF 7: NSR Key Section (ee and se DH) Derives keys for NSR key section:\n# Perform third DH (ephemeral-ephemeral) sharedSecret_ee = DH(aesk, bepk) # Alice computes # Equivalent: sharedSecret_ee = DH(besk, aepk) # Bob computes # Mix ee into chain keydata = HKDF(chainKey, sharedSecret_ee, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # Perform fourth DH (static-ephemeral) sharedSecret_se = DH(ask, bepk) # Alice computes # Equivalent: sharedSecret_se = DH(besk, apk) # Bob computes # Derive cipher key from se keydata = HKDF(chainKey, sharedSecret_se, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption of empty data (key section has no payload) nonce = 0 associated_data = h ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data) # ciphertext = 16 bytes (MAC only, no plaintext) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Key section encrypted, chainKey contains all 4 DH results # Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR Critical: This completes the Noise IK handshake. chainKey now contains contributions from all 4 DH operations (es, ss, ee, se).\nKDF 8: NSR Payload Section Derives keys for NSR payload encryption:\n# Split chainKey into bidirectional keys keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob key k_ba = keydata[32:63] # Bob → Alice key # Initialize ES tagsets for both directions tagset_ab = DH_INITIALIZE(chainKey, k_ab) # Alice → Bob tagset_ba = DH_INITIALIZE(chainKey, k_ba) # Bob → Alice # Derive NSR payload key (Bob → Alice) k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) # Encrypt NSR payload nonce = 0 associated_data = h # Binds payload to entire NSR payload = build_payload() # Usually application reply ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data) # State: Bidirectional ES sessions established # tagset_ab and tagset_ba ready for ES messages # Send ciphertext as bytes 57+ of NSR message Important Notes:\nSplit Operation:\nCreates independent keys for each direction Prevents key reuse between Alice→Bob and Bob→Alice NSR Payload Binding:\nUses h as associated data to bind payload to handshake Separate KDF (\u0026ldquo;AttachPayloadKDF\u0026rdquo;) provides domain separation ES Readiness:\nAfter NSR, both parties can send ES messages Alice must receive NSR before sending ES Bob must receive ES before sending ES ES Message KDFs ES messages use pre-generated session keys from tagsets:\n# Sender gets next tag and key tagsetEntry = outbound_tagset.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes k = tagsetEntry.SESSION_KEY # 32 bytes N = tagsetEntry.INDEX # Message number # Construct nonce (12 bytes) nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD encryption associated_data = tag # Tag is associated data payload = build_payload() ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Send: tag || ciphertext (8 + len(ciphertext) bytes) Receiver Process:\n# Extract tag tag = message[0:8] # Look up tag in inbound tagsets tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag) if tagsetEntry is None: # Not an ES message, try NS/NSR decryption return try_handshake_decryption(message) k = tagsetEntry.SESSION_KEY N = tagsetEntry.INDEX # Construct nonce nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD decryption associated_data = tag ciphertext = message[8:] try: payload = DECRYPT(k, nonce, ciphertext, associated_data) except AuthenticationError: # MAC verification failed, reject message return reject_message() # Process payload blocks process_payload(payload) # Remove tag from tagset (one-time use) inbound_tagset.remove(tag) DH_INITIALIZE Function Creates a tagset for a single direction:\ndef DH_INITIALIZE(rootKey, k): \u0026#34;\u0026#34;\u0026#34; Initializes a tagset with session tag and symmetric key ratchets. Args: rootKey: Chain key from previous DH ratchet (32 bytes) k: Key material from split() or DH ratchet (32 bytes) Returns: tagset: Initialized tagset object \u0026#34;\u0026#34;\u0026#34; # Derive next root key and chain key keydata = HKDF(rootKey, k, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey_tagset = keydata[32:63] # Derive separate chain keys for tags and keys keydata = HKDF(chainKey_tagset, ZEROLEN, \u0026#34;TagAndKeyGenKeys\u0026#34;, 64) sessTag_ck = keydata[0:31] # Session tag chain key symmKey_ck = keydata[32:63] # Symmetric key chain key # Create tagset object tagset = Tagset() tagset.nextRootKey = nextRootKey tagset.sessTag_chainKey = sessTag_ck tagset.symmKey_chainKey = symmKey_ck tagset.lastIndex = -1 return tagset Usage Contexts:\nNSR Tagset: DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR) ES Tagsets: DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba) Ratcheted Tagsets: DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH) Ratchet Mechanisms ECIES uses three synchronized ratchet mechanisms to provide forward secrecy and efficient session management.\nRatchet Overview Three Ratchet Types:\nDH Ratchet: Performs Diffie-Hellman key exchanges to generate new root keys Session Tag Ratchet: Derives one-time-use session tags deterministically Symmetric Key Ratchet: Derives session keys for message encryption Relationship:\nDH Ratchet (periodic) ↓ Creates new tagset ↓ Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message) ↓ ↓ Session Tags (8 bytes each) Session Keys (32 bytes each) Key Properties:\nSender: Generates tags and keys on-demand (no storage needed) Receiver: Pre-generates tags for look-ahead window (storage required) Synchronization: Tag index determines key index (N_tag = N_key) Forward Secrecy: Achieved through periodic DH ratchet Efficiency: Receiver can defer key calculation until tag is received DH Ratchet The DH ratchet provides forward secrecy by periodically exchanging new ephemeral keys.\nDH Ratchet Frequency Required Ratchet Conditions:\nTag set approaching exhaustion (tag 65535 is maximum) Implementation-specific policies: Message count threshold (e.g., every 4096 messages) Time threshold (e.g., every 10 minutes) Data volume threshold (e.g., every 100 MB) Recommended First Ratchet: Around tag number 4096 to avoid reaching limit\nMaximum Values:\nMaximum tag set ID: 65535 Maximum key ID: 32767 Maximum messages per tag set: 65535 Theoretical maximum data per session: ~6.9 TB (64K tag sets × 64K messages × 1730 bytes avg) DH Ratchet Tag and Key IDs Initial Tag Set (post-handshake):\nTag set ID: 0 No NextKey blocks have been sent yet No key IDs assigned After First Ratchet:\nTag set ID: 1 = (1 + Alice\u0026rsquo;s key ID + Bob\u0026rsquo;s key ID) = (1 + 0 + 0) Alice sends NextKey with key ID 0 Bob replies with NextKey with key ID 0 Subsequent Tag Sets:\nTag set ID = 1 + sender\u0026rsquo;s key ID + receiver\u0026rsquo;s key ID Example: Tag set 5 = (1 + sender_key_2 + receiver_key_2) Tag Set Progression Table:\nTag Set ID Sender Key ID Receiver Key ID Notes 0 n/a n/a Initial tag set (post-NSR) 1 0 * 0 * First ratchet (both generate new keys) 2 1 * 0 Sender generates new key 3 1 1 * Receiver generates new key 4 2 * 1 Sender generates new key 5 2 2 * Receiver generates new key ... ... ... Pattern repeats 65534 32767 * 32766 Second-to-last tag set 65535 32767 32767 * Final tag set * = New key generated this ratchet\nKey ID Rules:\nIDs are sequential starting from 0 IDs increment only when new key is generated Maximum key ID is 32767 (15 bits) After key ID 32767, new session required DH Ratchet Message Flow Roles:\nTag Sender: Owns the outbound tag set, sends messages Tag Receiver: Owns the inbound tag set, receives messages Pattern: Tag sender initiates ratchet when tag set is nearly exhausted.\nMessage Flow Diagram:\nTag Sender Tag Receiver ... using tag set #0 ... (Tag set #0 approaching exhaustion) (Generate new key #0) NextKey forward, request reverse, with key #0 --------\u0026gt; (Repeat until NextKey ACK received) (Generate new key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create inbound tag set #1) \u0026lt;--------------- NextKey reverse, with key #0 (Repeat until tag from tag set #1 received) (Receive NextKey with key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create outbound tag set #1) ... using tag set #1 ... (Tag set #1 approaching exhaustion) (Generate new key #1) NextKey forward, with key #1 --------\u0026gt; (Repeat until NextKey ACK received) (Reuse existing key #0) (Perform DH: sender_key_1 × receiver_key_0) (Create inbound tag set #2) \u0026lt;-------------- NextKey reverse, id 0 (ACK) (Repeat until tag from tag set #2 received) (Receive NextKey with id 0) (Perform DH: sender_key_1 × receiver_key_0) (Create outbound tag set #2) ... using tag set #2 ... (Tag set #2 approaching exhaustion) (Reuse existing key #1) NextKey forward, request reverse, id 1 --------\u0026gt; (Repeat until NextKey received) (Generate new key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create inbound tag set #3) \u0026lt;-------------- NextKey reverse, with key #1 (Receive NextKey with key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create outbound tag set #3) ... using tag set #3 ... (Pattern repeats: even-numbered tag sets use forward key, odd-numbered use reverse key) Ratchet Patterns:\nCreating Even-Numbered Tag Sets (2, 4, 6, \u0026hellip;):\nSender generates new key Sender sends NextKey block with new key Receiver sends NextKey block with old key ID (ACK) Both perform DH with (new sender key × old receiver key) Creating Odd-Numbered Tag Sets (3, 5, 7, \u0026hellip;):\nSender requests reverse key (sends NextKey with request flag) Receiver generates new key Receiver sends NextKey block with new key Both perform DH with (old sender key × new receiver key) NextKey Block Format See Payload Format section for detailed NextKey block specification.\nKey Elements:\nFlags byte: Bit 0: Key present (1) or ID only (0) Bit 1: Reverse key (1) or forward key (0) Bit 2: Request reverse key (1) or no request (0) Key ID: 2 bytes, big-endian (0-32767) Public Key: 32 bytes X25519 (if bit 0 = 1) Example NextKey Blocks:\n# Sender initiates ratchet with new key (key ID 0, tag set 1) NextKey(flags=0x01, key_id=0, pubkey=sender_key_0) # Receiver replies with new key (key ID 0, tag set 1) NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0) # Sender ratchets again with new key (key ID 1, tag set 2) NextKey(flags=0x01, key_id=1, pubkey=sender_key_1) # Receiver ACKs with old key ID (tag set 2) NextKey(flags=0x02, key_id=0) # Sender requests reverse key (tag set 3) NextKey(flags=0x04, key_id=1) # Receiver sends new reverse key (key ID 1, tag set 3) NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1) DH Ratchet KDF When new keys are exchanged:\n# Tag sender generates or reuses key if generating_new: sender_sk = GENERATE_PRIVATE() sender_pk = DERIVE_PUBLIC(sender_sk) else: # Reuse existing key pair sender_pk = existing_sender_pk # Tag receiver generates or reuses key if generating_new: receiver_sk = GENERATE_PRIVATE() receiver_pk = DERIVE_PUBLIC(receiver_sk) else: # Reuse existing key pair receiver_pk = existing_receiver_pk # Both parties perform DH sharedSecret = DH(sender_sk, receiver_pk) # Derive tagset key tagsetKey = HKDF(sharedSecret, ZEROLEN, \u0026#34;XDHRatchetTagSet\u0026#34;, 32) # Get next root key from previous tagset rootKey = previous_tagset.nextRootKey # Initialize new tagset new_tagset = DH_INITIALIZE(rootKey, tagsetKey) # Tag sender: outbound tagset # Tag receiver: inbound tagset Critical Timing:\nTag Sender:\nCreates new outbound tag set immediately Begins using new tags immediately Deletes old outbound tag set Tag Receiver:\nCreates new inbound tag set Retains old inbound tag set for grace period (3 minutes) Accepts tags from both old and new tag sets during grace period Deletes old inbound tag set after grace period DH Ratchet State Management Sender State:\nCurrent outbound tag set Tag set ID and key IDs Next root key (for next ratchet) Message count in current tag set Receiver State:\nCurrent inbound tag set(s) (may have 2 during grace period) Previous messages numbers (PN) for gap detection Look-ahead window of pre-generated tags Next root key (for next ratchet) State Transition Rules:\nBefore First Ratchet:\nUsing tag set 0 (from NSR) No key IDs assigned Initiating Ratchet:\nGenerate new key (if sender is generating this round) Send NextKey block in ES message Wait for NextKey reply before creating new outbound tag set Receiving Ratchet Request:\nGenerate new key (if receiver is generating this round) Perform DH with received key Create new inbound tag set Send NextKey reply Retain old inbound tag set for grace period Completing Ratchet:\nReceive NextKey reply Perform DH Create new outbound tag set Begin using new tags Session Tag Ratchet The session tag ratchet generates one-time-use 8-byte session tags deterministically.\nSession Tag Ratchet Purpose Replaces explicit tag transmission (ElGamal sent 32-byte tags) Enables receiver to pre-generate tags for look-ahead window Sender generates on-demand (no storage required) Synchronizes with symmetric key ratchet via index Session Tag Ratchet Formula Initialization:\n# From DH_INITIALIZE sessTag_ck = initial_chain_key # 32 bytes # Initialize session tag ratchet keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) sessTag_chainKey = keydata[0:31] # First chain key SESSTAG_CONSTANT = keydata[32:63] # Constant for all tags in this tagset Tag Generation (for tag N):\n# Generate tag N keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata[0:31] # Chain key for next tag tag_N = keydata[32:39] # Session tag (8 bytes) # Chain continues for each tag # tag_0, tag_1, tag_2, ..., tag_65535 Complete Sequence:\n# Tag 0 keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_0 = keydata_0[0:31] tag_0 = keydata_0[32:39] # Tag 1 keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_1 = keydata_1[0:31] tag_1 = keydata_1[32:39] # Tag N keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata_N[0:31] tag_N = keydata_N[32:39] Session Tag Ratchet Sender Implementation class OutboundTagset: def __init__(self, sessTag_ck): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 def get_next_tag(self): # Increment index self.index += 1 if self.index \u0026gt; 65535: raise TagsetExhausted(\u0026#34;Ratchet required\u0026#34;) # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] return (tag, self.index) Sender Process:\nCall get_next_tag() for each message Use returned tag in ES message Store index N for potential ACK tracking No tag storage required (generated on-demand) Session Tag Ratchet Receiver Implementation class InboundTagset: def __init__(self, sessTag_ck, look_ahead=32): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 self.look_ahead = look_ahead self.tags = {} # Dictionary: tag -\u0026gt; index # Pre-generate initial tags self.extend(look_ahead) def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Generate \u0026#39;count\u0026#39; more tags\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 if self.index \u0026gt; 65535: return # Cannot exceed maximum # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] # Store tag self.tags[tag] = self.index def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Look up tag and return index\u0026#34;\u0026#34;\u0026#34; if tag in self.tags: index = self.tags[tag] # Remove tag (one-time use) del self.tags[tag] return index return None def check_and_extend(self): \u0026#34;\u0026#34;\u0026#34;Extend if tag count is low\u0026#34;\u0026#34;\u0026#34; current_count = len(self.tags) if current_count \u0026lt; self.look_ahead // 2: # Extend to restore window self.extend(self.look_ahead - current_count) Receiver Process:\nPre-generate tags for look-ahead window (e.g., 32 tags) Store tags in hash table or dictionary When message arrives, look up tag to get index N Remove tag from storage (one-time use) Extend window if tag count drops below threshold Session Tag Look-Ahead Strategy Purpose: Balance memory usage vs. out-of-order message handling\nRecommended Look-Ahead Sizes:\nTagset Type Initial Size Maximum Size Notes NSR tagset 12 12 Short-lived ES tagset 0 24 160 Initial ES tagset ES tagset 1+ 160 160 Ratcheted tagsets Adaptive Look-Ahead:\n# Dynamic look-ahead based on highest tag received look_ahead = min(tsmax, tsmin + N // 4) # Example: # tsmin = 24, tsmax = 160 # N = 0: look_ahead = min(160, 24 + 0/4) = 24 # N = 100: look_ahead = min(160, 24 + 100/4) = 49 # N = 500: look_ahead = min(160, 24 + 500/4) = 149 # N = 544: look_ahead = min(160, 24 + 544/4) = 160 Trim Behind:\n# Trim tags far behind highest received trim_behind = look_ahead // 2 # If highest received tag is N=100, trim tags below N=50 Memory Calculation:\n# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes # Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset # With multiple sessions: # 100 inbound sessions × 2.5 KB = 250 KB total Session Tag Out-of-Order Handling Scenario: Messages arrive out of order\nExpected: tag_5, tag_6, tag_7, tag_8 Received: tag_5, tag_7, tag_6, tag_8 Receiver Behavior:\nReceive tag_5:\nLook up: found at index 5 Process message Remove tag_5 Highest received: 5 Receive tag_7 (out of order):\nLook up: found at index 7 Process message Remove tag_7 Highest received: 7 Note: tag_6 still in storage (not yet received) Receive tag_6 (delayed):\nLook up: found at index 6 Process message Remove tag_6 Highest received: 7 (unchanged) Receive tag_8:\nLook up: found at index 8 Process message Remove tag_8 Highest received: 8 Window Maintenance:\nKeep track of highest received index Maintain list of missing indices (gaps) Extend window based on highest index Optional: Expire old gaps after timeout Symmetric Key Ratchet The symmetric key ratchet generates 32-byte encryption keys synchronized with session tags.\nSymmetric Key Ratchet Purpose Provides unique encryption key for each message Synchronized with session tag ratchet (same index) Sender can generate on-demand Receiver can defer generation until tag is received Symmetric Key Ratchet Formula Initialization:\n# From DH_INITIALIZE symmKey_ck = initial_chain_key # 32 bytes # No additional initialization needed # Unlike session tag ratchet, no constant is derived Key Generation (for key N):\n# Generate key N SYMMKEY_CONSTANT = ZEROLEN # Empty string keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata[0:31] # Chain key for next key key_N = keydata[32:63] # Session key (32 bytes) Complete Sequence:\n# Key 0 keydata_0 = HKDF(symmKey_ck, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_0 = keydata_0[0:31] key_0 = keydata_0[32:63] # Key 1 keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_1 = keydata_1[0:31] key_1 = keydata_1[32:63] # Key N keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata_N[0:31] key_N = keydata_N[32:63] Symmetric Key Ratchet Sender Implementation class OutboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Fast-forward to desired index if needed while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] # Should not reach here if called correctly raise ValueError(\u0026#34;Key already generated\u0026#34;) Sender Process:\nGet next tag and its index N Generate key for index N Use key to encrypt message No key storage required Symmetric Key Ratchet Receiver Implementation Strategy 1: Deferred Generation (Recommended)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = {} # Optional: cache recently used keys def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Check cache first (optional optimization) if index in self.cache: key = self.cache[index] del self.cache[index] return key # Fast-forward to desired index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] raise ValueError(\u0026#34;Index already passed\u0026#34;) Deferred Generation Process:\nReceive ES message with tag Look up tag to get index N Generate keys 0 through N (if not already generated) Use key N to decrypt message Chain key now positioned at index N Advantages:\nMinimal memory usage Keys generated only when needed Simple implementation Disadvantages:\nMust generate all keys from 0 to N on first use Cannot handle out-of-order messages without caching Strategy 2: Pre-generation with Tag Window (Alternative)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.keys = {} # Dictionary: index -\u0026gt; key def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Pre-generate \u0026#39;count\u0026#39; more keys\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] key = keydata[32:63] self.keys[self.index] = key def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Retrieve pre-generated key\u0026#34;\u0026#34;\u0026#34; if index in self.keys: key = self.keys[index] del self.keys[index] return key return None Pre-generation Process:\nPre-generate keys matching tag window (e.g., 32 keys) Store keys indexed by message number When tag is received, look up corresponding key Extend window as tags are used Advantages:\nHandles out-of-order messages naturally Fast key retrieval (no generation delay) Disadvantages:\nHigher memory usage (32 bytes per key vs 8 bytes per tag) Must keep keys synchronized with tags Memory Comparison:\n# Look-ahead of 160: # Tags only: 160 × 16 bytes = 2.5 KB # Tags+Keys: 160 × (16 + 32) bytes = 7.5 KB # # For 100 sessions: # Tags only: 250 KB # Tags+Keys: 750 KB Symmetric Ratchet Synchronization with Session Tags Critical Requirement: Session tag index MUST equal symmetric key index\n# Sender tag, index = outbound_tagset.get_next_tag() key = outbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) ciphertext = ENCRYPT(key, nonce, payload, tag) # Receiver index = inbound_tagset.lookup_tag(tag) key = inbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) plaintext = DECRYPT(key, nonce, ciphertext, tag) Failure Modes:\nIf synchronization breaks:\nWrong key used for decryption MAC verification fails Message rejected Prevention:\nAlways use same index for tag and key Never skip indices in either ratchet Handle out-of-order messages carefully Symmetric Ratchet Nonce Construction Nonce is derived from message number:\ndef construct_nonce(index): \u0026#34;\u0026#34;\u0026#34; Construct 12-byte nonce for ChaCha20-Poly1305 Args: index: Message number (0-65535) Returns: nonce: 12-byte nonce \u0026#34;\u0026#34;\u0026#34; # First 4 bytes are always zero nonce = bytearray(12) nonce[0:4] = b\u0026#39;\\x00\\x00\\x00\\x00\u0026#39; # Last 8 bytes are little-endian message number nonce[4:12] = index.to_bytes(8, byteorder=\u0026#39;little\u0026#39;) return bytes(nonce) Examples:\nindex = 0: nonce = 0x00000000 0000000000000000 index = 1: nonce = 0x00000000 0100000000000000 index = 255: nonce = 0x00000000 FF00000000000000 index = 256: nonce = 0x00000000 0001000000000000 index = 65535: nonce = 0x00000000 FFFF000000000000 Important Properties:\nNonces are unique for each message in a tagset Nonces never repeat (one-time-use tags ensure this) 8-byte counter allows for 2^64 messages (we only use 2^16) Nonce format matches RFC 7539 counter-based construction Session Management Session Context All inbound and outbound sessions must belong to a specific context:\nRouter Context: Sessions for the router itself Destination Context: Sessions for a specific local destination (client application) Critical Rule: Sessions MUST NOT be shared among contexts to prevent correlation attacks.\nImplementation:\nclass SessionKeyManager: \u0026#34;\u0026#34;\u0026#34;Context for managing sessions (router or destination)\u0026#34;\u0026#34;\u0026#34; def __init__(self, context_id): self.context_id = context_id self.inbound_sessions = {} # far_end_dest -\u0026gt; [sessions] self.outbound_sessions = {} # far_end_dest -\u0026gt; session self.static_keypair = generate_keypair() # Context\u0026#39;s identity def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session to destination\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: self.outbound_sessions[destination] = create_outbound_session(destination) return self.outbound_sessions[destination] def add_inbound_session(self, session, destination=None): \u0026#34;\u0026#34;\u0026#34;Add inbound session, optionally bound to destination\u0026#34;\u0026#34;\u0026#34; if destination: if destination not in self.inbound_sessions: self.inbound_sessions[destination] = [] self.inbound_sessions[destination].append(session) else: # Unbound session self.inbound_sessions[None].append(session) Java I2P Implementation:\nIn Java I2P, the SessionKeyManager class provides this functionality:\nOne SessionKeyManager per router One SessionKeyManager per local destination Separate management of ECIES and ElGamal sessions within each context Session Binding Binding associates a session with a specific far-end destination.\nBound Sessions Characteristics:\nInclude sender\u0026rsquo;s static key in NS message Recipient can identify sender\u0026rsquo;s destination Enables bidirectional communication Single outbound session per destination May have multiple inbound sessions (during transitions) Use Cases:\nStreaming connections (TCP-like) Repliable datagrams Any protocol requiring request/response Binding Process:\n# Alice creates bound outbound session outbound_session = OutboundSession( destination=bob_destination, static_key=alice_static_key, bound=True ) # Alice sends NS with static key ns_message = build_ns_message( ephemeral_key=alice_ephemeral_key, static_key=alice_static_key, # Included for binding payload=data ) # Bob receives NS bob_receives_ns(ns_message) # Bob extracts Alice\u0026#39;s static key alice_static_key = decrypt_static_key_section(ns_message) # Bob looks up Alice\u0026#39;s destination (from bundled LeaseSet) alice_destination = lookup_destination_by_static_key(alice_static_key) # Bob creates bound inbound session inbound_session = InboundSession( destination=alice_destination, bound=True ) # Bob pairs with outbound session outbound_session = OutboundSession( destination=alice_destination, bound=True ) Benefits:\nEphemeral-Ephemeral DH: Reply uses ee DH (full forward secrecy) Session Continuity: Ratchets maintain binding to same destination Security: Prevents session hijacking (authenticated by static key) Efficiency: Single session per destination (no duplication) Unbound Sessions Characteristics:\nNo static key in NS message (flags section is all zeros) Recipient cannot identify sender One-way communication only Multiple sessions to same destination allowed Use Cases:\nRaw datagrams (fire-and-forget) Anonymous publishing Broadcast-style messaging Properties:\nMore anonymous (no sender identification) More efficient (1 DH vs 2 DH in handshake) No replies possible (recipient doesn\u0026rsquo;t know where to reply) No session ratcheting (one-time or limited use) Session Pairing Pairing connects an inbound session with an outbound session for bidirectional communication.\nCreating Paired Sessions Alice\u0026rsquo;s Perspective (initiator):\n# Create outbound session to Bob outbound_session = create_outbound_session(bob_destination) # Create paired inbound session inbound_session = create_inbound_session( paired_with=outbound_session, bound_to=bob_destination ) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NS message send_ns_message(outbound_session, payload) Bob\u0026rsquo;s Perspective (responder):\n# Receive NS message ns_message = receive_ns_message() # Create inbound session inbound_session = create_inbound_session_from_ns(ns_message) # If NS contains static key (bound): if ns_message.has_static_key(): alice_destination = extract_destination(ns_message) inbound_session.bind_to(alice_destination) # Create paired outbound session outbound_session = create_outbound_session(alice_destination) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NSR send_nsr_message(inbound_session, outbound_session, payload) Session Pairing Benefits In-band ACKs: Can acknowledge messages without separate clove Efficient Ratcheting: Both directions ratchet together Flow Control: Can implement back-pressure across paired sessions State Consistency: Easier to maintain synchronized state Session Pairing Rules Outbound session may be unpaired (unbound NS) Inbound session for bound NS should be paired Pairing occurs at session creation, not after Paired sessions have same destination binding Ratchets occur independently but are coordinated Session Lifecycle Session Lifecycle: Creation Phase Outbound Session Creation (Alice):\ndef create_outbound_session(destination, bound=True): session = OutboundSession() session.destination = destination session.bound = bound session.state = SessionState.NEW session.created_time = now() # Generate keys for NS message session.ephemeral_keypair = generate_elg2_keypair() if bound: session.static_key = context.static_keypair.public_key # Will be populated after NSR received session.outbound_tagset = None session.inbound_tagset = None return session Inbound Session Creation (Bob):\ndef create_inbound_session_from_ns(ns_message): session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() # Extract from NS session.remote_ephemeral_key = ns_message.ephemeral_key session.remote_static_key = ns_message.static_key if session.remote_static_key: session.bound = True session.destination = lookup_destination(session.remote_static_key) else: session.bound = False session.destination = None # Generate keys for NSR session.ephemeral_keypair = generate_elg2_keypair() # Create tagsets from KDF session.inbound_tagset = create_tagset_from_nsr() session.outbound_tagset = create_tagset_from_nsr() return session Session Lifecycle: Active Phase State Transitions:\nNEW (outbound only) ↓ NS sent ↓ PENDING_REPLY (outbound only) ↓ NSR received ↓ ESTABLISHED ↓ ES messages exchanged ↓ ESTABLISHED (ongoing) ↓ (optional) RATCHETING ↓ ESTABLISHED Active Session Maintenance:\ndef maintain_active_session(session): # Update last activity time session.last_activity = now() # Check for ratchet needed if session.outbound_tagset.needs_ratchet(): initiate_ratchet(session) # Check for incoming ratchet if received_nextkey_block(): process_ratchet(session) # Trim old tags from inbound tagset session.inbound_tagset.expire_old_tags() # Check session health if session.idle_time() \u0026gt; SESSION_TIMEOUT: mark_session_idle(session) Session Lifecycle: Expiration Phase Session Timeout Values:\nSession Type Sender Timeout Receiver Timeout Notes NSR tagset N/A 3 minutes Short-lived ES tagset 0 8 minutes 10 minutes Initial ES tagset 1+ 8 minutes 10 minutes Ratcheted Old tagset N/A 3 minutes After ratchet Expiration Logic:\ndef check_session_expiration(): for session in active_sessions: # Outbound session expiration (sender) if session.is_outbound(): if session.idle_time() \u0026gt; 8 * 60: # 8 minutes expire_outbound_session(session) # Inbound session expiration (receiver) else: if session.idle_time() \u0026gt; 10 * 60: # 10 minutes expire_inbound_session(session) # Old tagsets (after ratchet) for tagset in old_tagsets: if tagset.age() \u0026gt; 3 * 60: # 3 minutes delete_tagset(tagset) Critical Rule: Outbound sessions MUST expire before inbound sessions to prevent desynchronization.\nGraceful Termination:\ndef terminate_session(session, reason=0): # Send Termination block (if implemented) send_termination_block(session, reason) # Mark session for deletion session.state = SessionState.TERMINATED # Keep session briefly for final messages schedule_deletion(session, delay=30) # 30 seconds # Notify paired session if session.paired_session: session.paired_session.mark_remote_terminated() Multiple NS Messages Scenario: Alice\u0026rsquo;s NS message is lost or NSR reply is lost.\nAlice\u0026rsquo;s Behavior:\nclass OutboundSession: def __init__(self): self.ns_messages_sent = [] self.ns_timer = None self.max_ns_attempts = 5 def send_ns_message(self, payload): # Generate new ephemeral key for each NS ephemeral_key = generate_elg2_keypair() ns_message = build_ns_message( ephemeral_key=ephemeral_key, static_key=self.static_key, payload=payload ) # Store state for this NS ns_state = { \u0026#39;ephemeral_key\u0026#39;: ephemeral_key, \u0026#39;chainkey\u0026#39;: compute_chainkey(ns_message), \u0026#39;hash\u0026#39;: compute_hash(ns_message), \u0026#39;tagset\u0026#39;: derive_nsr_tagset(ns_message), \u0026#39;sent_time\u0026#39;: now() } self.ns_messages_sent.append(ns_state) # Send message send_message(ns_message) # Set timer for retry if not self.ns_timer: self.ns_timer = set_timer(1.0, self.on_ns_timeout) def on_ns_timeout(self): if len(self.ns_messages_sent) \u0026gt;= self.max_ns_attempts: # Give up fail_session(\u0026#34;No NSR received after {self.max_ns_attempts} attempts\u0026#34;) return # Retry with new NS message send_ns_message(self.payload) def on_nsr_received(self, nsr_message): # Cancel timer cancel_timer(self.ns_timer) # Find which NS this NSR responds to tag = nsr_message.tag for ns_state in self.ns_messages_sent: if tag in ns_state[\u0026#39;tagset\u0026#39;]: # This NSR corresponds to this NS self.active_ns_state = ns_state break # Process NSR and complete handshake complete_handshake(nsr_message, self.active_ns_state) # Discard other NS states self.ns_messages_sent = [] Important Properties:\nUnique Ephemeral Keys: Each NS uses different ephemeral key Independent Handshakes: Each NS creates separate handshake state NSR Correlation: NSR tag identifies which NS it responds to State Cleanup: Unused NS states discarded after successful NSR Attack Prevention:\nTo prevent resource exhaustion:\n# Limit NS sending rate max_ns_rate = 5 per 10 seconds per destination # Limit total NS attempts max_ns_attempts = 5 # Limit total pending NS states max_pending_ns = 10 per context Multiple NSR Messages Scenario: Bob sends multiple NSRs (e.g., reply data split across multiple messages).\nBob\u0026rsquo;s Behavior:\nclass InboundSession: def send_nsr_replies(self, payload_chunks): # One NS received, multiple NSRs to send for chunk in payload_chunks: # Generate new ephemeral key for each NSR ephemeral_key = generate_elg2_keypair() # Get next tag from NSR tagset tag = self.nsr_tagset.get_next_tag() nsr_message = build_nsr_message( tag=tag, ephemeral_key=ephemeral_key, payload=chunk ) send_message(nsr_message) # Wait for ES message from Alice self.state = SessionState.AWAITING_ES Alice\u0026rsquo;s Behavior:\nclass OutboundSession: def on_nsr_received(self, nsr_message): if self.state == SessionState.PENDING_REPLY: # First NSR received complete_handshake(nsr_message) self.state = SessionState.ESTABLISHED # Create ES sessions self.es_outbound_tagset = derive_es_outbound_tagset() self.es_inbound_tagset = derive_es_inbound_tagset() # Send ES message (ACK) send_es_message(empty_payload) elif self.state == SessionState.ESTABLISHED: # Additional NSR received # Decrypt and process payload payload = decrypt_nsr_payload(nsr_message) process_payload(payload) # These NSRs are from other NS attempts, ignore handshake Bob\u0026rsquo;s Cleanup:\nclass InboundSession: def on_es_received(self, es_message): # First ES received from Alice # This confirms which NSR Alice used # Clean up other handshake states for other_ns_state in self.pending_ns_states: if other_ns_state != self.active_ns_state: delete_ns_state(other_ns_state) # Delete unused NSR tagsets for tagset in self.nsr_tagsets: if tagset != self.active_nsr_tagset: delete_tagset(tagset) self.state = SessionState.ESTABLISHED Important Properties:\nMultiple NSRs Allowed: Bob can send multiple NSRs per NS Different Ephemeral Keys: Each NSR should use unique ephemeral key Same NSR Tagset: All NSRs for one NS use same tagset First ES Wins: Alice\u0026rsquo;s first ES determines which NSR succeeded Cleanup After ES: Bob discards unused states after ES received Session State Machine Complete State Diagram:\nOutbound Session Inbound Session NEW | send NS | PENDING_REPLY -------------------- receive NS ---\u0026gt; ESTABLISHED | | receive NSR send NSR | | ESTABLISHED \u0026lt;---------- receive ES ------------- AWAITING_ES | | | ┌─────┴─────┐ | receive ES | | | | send ES receive ES | ESTABLISHED | | | | └─────┬─────┘ | ┌─────────┴─────────┐ | | | | | | send ES receive ES | | | | | | └─────────┬─────────┘ | | | └─────────────────────┴──────────────────────────┘ ACTIVE | idle timeout | EXPIRED State Descriptions:\nNEW: Outbound session created, no NS sent yet PENDING_REPLY: NS sent, awaiting NSR AWAITING_ES: NSR sent, awaiting first ES from Alice ESTABLISHED: Handshake complete, can send/receive ES ACTIVE: Actively exchanging ES messages RATCHETING: DH ratchet in progress (subset of ACTIVE) EXPIRED: Session timed out, pending deletion TERMINATED: Session explicitly terminated Payload Format The payload section of all ECIES messages (NS, NSR, ES) uses a block-based format similar to NTCP2.\nBlock Structure General Format:\n+----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Fields:\nblk: 1 byte - Block type number size: 2 bytes - Big-endian size of data field (0-65516) data: Variable length - Block-specific data Constraints:\nMaximum ChaChaPoly frame: 65535 bytes Poly1305 MAC: 16 bytes Maximum total blocks: 65519 bytes (65535 - 16) Maximum single block: 65519 bytes (including 3-byte header) Maximum single block data: 65516 bytes Block Types Defined Block Types:\nType Name Size Status Usage 0 DateTime 7 bytes Implemented Required in NS 1-3 Reserved - - Future use 4 Termination 9+ bytes Unimplemented Session termination 5 Options 21+ bytes Unimplemented Session options 6 MessageNumbers 5 bytes Unimplemented PN value 7 NextKey 3 or 35 bytes Implemented DH ratchet 8 ACK 4+ bytes Implemented Message acknowledgment 9 ACK Request 3 bytes Implemented Request ACK 10 Reserved - - Future use 11 Garlic Clove Variable Implemented Application data 12-223 Reserved - - Future use 224-253 Experimental Variable - Testing features 254 Padding Variable Implemented Traffic shaping 255 Reserved - - Future extension Unknown Block Handling:\nImplementations MUST ignore blocks with unknown type numbers and treat them as padding. This ensures forward compatibility.\nBlock Ordering Rules NS Message Ordering Required:\nDateTime block MUST be first Allowed:\nGarlic Clove (type 11) Options (type 5) - if implemented Padding (type 254) Prohibited:\nNextKey, ACK, ACK Request, Termination, MessageNumbers Example Valid NS Payload:\nDateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254) NSR Message Ordering Required:\nNone (payload may be empty) Allowed:\nGarlic Clove (type 11) Options (type 5) - if implemented Padding (type 254) Prohibited:\nDateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers Example Valid NSR Payload:\nGarlic Clove (11) | Garlic Clove (11) | Padding (254) or\n(empty - ACK only) ES Message Ordering Required:\nNone (payload may be empty) Allowed (any order):\nGarlic Clove (type 11) NextKey (type 7) ACK (type 8) ACK Request (type 9) Termination (type 4) - if implemented MessageNumbers (type 6) - if implemented Options (type 5) - if implemented Padding (type 254) Special Rules:\nTermination MUST be last block (except Padding) Padding MUST be last block Multiple Garlic Cloves allowed Up to 2 NextKey blocks allowed (forward and reverse) Multiple Padding blocks NOT allowed Example Valid ES Payloads:\nGarlic Clove (11) | ACK (8) | Padding (254) NextKey (7) | Garlic Clove (11) | Garlic Clove (11) NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11) ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254) DateTime Block (Type 0) Purpose: Timestamp for replay prevention and clock skew validation\nSize: 7 bytes (3 byte header + 4 byte data)\nFormat:\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Fields:\nblk: 0 size: 4 (big-endian) timestamp: 4 bytes - Unix timestamp in seconds (unsigned, big-endian) Timestamp Format:\ntimestamp = int(time.time()) # Seconds since 1970-01-01 00:00:00 UTC # Wraps around in year 2106 (4-byte unsigned maximum) Validation Rules:\nMAX_CLOCK_SKEW_PAST = 5 * 60 # 5 minutes MAX_CLOCK_SKEW_FUTURE = 2 * 60 # 2 minutes def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: return False # Too far in future if age \u0026gt; MAX_CLOCK_SKEW_PAST: return False # Too old return True Replay Prevention:\nclass ReplayFilter: def __init__(self, duration=5*60): self.duration = duration # 5 minutes self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001) self.cleanup_timer = RepeatTimer(60, self.cleanup) def check_replay(self, ephemeral_key, timestamp): # Check timestamp validity if not validate_datetime(timestamp): return False # Check if ephemeral key seen recently if ephemeral_key in self.seen_messages: return False # Replay attack # Add to seen messages self.seen_messages.add(ephemeral_key) return True def cleanup(self): # Expire old entries (Bloom filter automatically ages out) pass Implementation Notes:\nNS Messages: DateTime MUST be first block NSR/ES Messages: DateTime typically not included Replay Window: 5 minutes is minimum recommended Bloom Filter: Recommended for efficient replay detection Clock Skew: Allow 5 minutes past, 2 minutes future Garlic Clove Block (Type 11) Purpose: Encapsulates I2NP messages for delivery\nFormat:\n+----+----+----+----+----+----+----+----+ | 11 | size | | +----+----+----+ + | Delivery Instructions | ~ ~ | | +----+----+----+----+----+----+----+----+ |type| Message_ID | Expiration | +----+----+----+----+----+----+----+----+ | I2NP Message body | +----+ + ~ ~ | | +----+----+----+----+----+----+----+----+ Fields:\nblk: 11 size: Total size of clove (variable) Delivery Instructions: As specified in I2NP spec type: I2NP message type (1 byte) Message_ID: I2NP message ID (4 bytes) Expiration: Unix timestamp in seconds (4 bytes) I2NP Message body: Variable length message data Delivery Instruction Formats:\nLocal Delivery (1 byte):\n+----+ |0x00| +----+ Destination Delivery (33 bytes):\n+----+----+----+----+----+----+----+----+ |0x01| | +----+ Destination Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Router Delivery (33 bytes):\n+----+----+----+----+----+----+----+----+ |0x02| | +----+ Router Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Tunnel Delivery (37 bytes):\n+----+----+----+----+----+----+----+----+ |0x03| Tunnel ID | +----+----+----+----+----+ + | Router Hash | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ I2NP Message Header (9 bytes total):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | | type: I2NP message type (Database Store, Database Lookup, Data, etc.) msg_id: 4-byte message identifier expiration: 4-byte Unix timestamp (seconds) Important Differences from ElGamal Clove Format:\nNo Certificate: Certificate field omitted (unused in ElGamal) No Clove ID: Clove ID omitted (was always 0) No Clove Expiration: Uses I2NP message expiration instead Compact Header: 9-byte I2NP header vs larger ElGamal format Each Clove is Separate Block: No CloveSet structure Multiple Cloves:\n# Multiple Garlic Cloves in one message payload = [ build_datetime_block(), build_garlic_clove(i2np_message_1), build_garlic_clove(i2np_message_2), build_garlic_clove(i2np_message_3), build_padding_block() ] Common I2NP Message Types in Cloves:\nType Name Usage 1 DatabaseStore Publishing LeaseSet 2 DatabaseLookup Requesting LeaseSet 5 DeliveryStatus ACK (legacy, avoid in ECIES) 20 Data Streaming data 21 Garlic Nested garlic messages Clove Processing:\ndef process_garlic_clove(clove_data): # Parse delivery instructions delivery_type = clove_data[0] if delivery_type == 0x00: # Local delivery offset = 1 elif delivery_type == 0x01: # Destination delivery dest_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x02: # Router delivery router_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x03: # Tunnel delivery tunnel_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[1:5])[0] router_hash = clove_data[5:37] offset = 37 # Parse I2NP header i2np_type = clove_data[offset] msg_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+1:offset+5])[0] expiration = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+5:offset+9])[0] # Extract I2NP body i2np_body = clove_data[offset+9:] # Process message process_i2np_message(i2np_type, msg_id, expiration, i2np_body) NextKey Block (Type 7) Purpose: DH ratchet key exchange\nFormat (Key Present - 38 bytes):\n+----+----+----+----+----+----+----+----+ | 7 | 35 |flag| key ID | | +----+----+----+----+----+----+ + | | + Next DH Ratchet Public Key + | 32 bytes | + + | | + +----+----+ | | +----+----+----+----+----+----+ Format (Key ID Only - 6 bytes):\n+----+----+----+----+----+----+ | 7 | 3 |flag| key ID | +----+----+----+----+----+----+ Fields:\nblk: 7 size: 3 (ID only) or 35 (with key) flag: 1 byte - Flag bits key ID: 2 bytes - Big-endian key identifier (0-32767) Public Key: 32 bytes - X25519 public key (little-endian), if flag bit 0 = 1 Flag Bits:\nBit 7 6 5 4 3 2 1 0 | | | | | | | | | | | | | | | +-- Bit 0: Key present (1) or ID only (0) | | | | | | +---- Bit 1: Reverse key (1) or forward key (0) | | | | | +------ Bit 2: Request reverse key (1) or no request (0) | | | | | +-+-+-+-+-------- Bits 3-7: Reserved (set to 0) Flag Examples:\n# Forward key present flags = 0x01 # Binary: 00000001 # Reverse key present flags = 0x03 # Binary: 00000011 # Forward key ID only (ACK) flags = 0x00 # Binary: 00000000 # Reverse key ID only (ACK) flags = 0x02 # Binary: 00000010 # Forward key ID with reverse request flags = 0x04 # Binary: 00000100 Key ID Rules:\nIDs are sequential: 0, 1, 2, \u0026hellip;, 32767 ID increments only when new key generated Same ID used for multiple messages until next ratchet Maximum ID is 32767 (must start new session after) Usage Examples:\n# Initiating ratchet (sender generates new key) nextkey = NextKeyBlock( flags=0x01, # Key present, forward key_id=0, public_key=sender_new_pk ) # Replying to ratchet (receiver generates new key) nextkey = NextKeyBlock( flags=0x03, # Key present, reverse key_id=0, public_key=receiver_new_pk ) # Acknowledging ratchet (no new key from sender) nextkey = NextKeyBlock( flags=0x02, # ID only, reverse key_id=0 ) # Requesting reverse ratchet nextkey = NextKeyBlock( flags=0x04, # Request reverse, forward ID key_id=1 ) Processing Logic:\ndef process_nextkey_block(block): flags = block.flags key_id = block.key_id key_present = (flags \u0026amp; 0x01) != 0 is_reverse = (flags \u0026amp; 0x02) != 0 request_reverse = (flags \u0026amp; 0x04) != 0 if key_present: public_key = block.public_key if is_reverse: # Reverse key received perform_dh_ratchet(receiver_key=public_key, key_id=key_id) # Sender should ACK with own key ID else: # Forward key received perform_dh_ratchet(sender_key=public_key, key_id=key_id) # Receiver should reply with reverse key send_reverse_key(generate_new_key()) else: # Key ID only (ACK) if is_reverse: # Reverse key ACK confirm_reverse_ratchet(key_id) else: # Forward key ACK confirm_forward_ratchet(key_id) if request_reverse: # Sender requests receiver to generate new key send_reverse_key(generate_new_key()) Multiple NextKey Blocks:\nA single ES message may contain up to 2 NextKey blocks when both directions are ratcheting simultaneously:\n# Both directions ratcheting payload = [ NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key), # Forward NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key), # Reverse build_garlic_clove(data) ] ACK Block (Type 8) Purpose: Acknowledge received messages in-band\nFormat (Single ACK - 7 bytes):\n+----+----+----+----+----+----+----+ | 8 | 4 |tagsetid | N | +----+----+----+----+----+----+----+ Format (Multiple ACKs):\n+----+----+----+----+----+----+----+----+ | 8 | size |tagsetid | N | | +----+----+----+----+----+----+----+ + | more ACKs | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Fields:\nblk: 8 size: 4 * number of ACKs (minimum 4) For each ACK: tagsetid: 2 bytes - Big-endian tag set ID (0-65535) N: 2 bytes - Big-endian message number (0-65535) Tag Set ID Determination:\n# Tag set 0 (initial, after NSR) tagset_id = 0 # After first ratchet (tag set 1) # Both Alice and Bob sent key ID 0 tagset_id = 1 + 0 + 0 = 1 # After second ratchet (tag set 2) # Alice sent key ID 1, Bob still using key ID 0 tagset_id = 1 + 1 + 0 = 2 # After third ratchet (tag set 3) # Alice still using key ID 1, Bob sent key ID 1 tagset_id = 1 + 1 + 1 = 3 Single ACK Example:\n# ACK message from tag set 5, message number 127 ack_block = ACKBlock( tagset_id=5, message_number=127 ) # Wire format (7 bytes): # 08 00 04 00 05 00 7F # | | | | | | | # | | | | | | +-- N (127) # | | | | +--------- N high byte # | | | +------------ tagset_id (5) # | | +--------------- tagset_id high byte # | +------------------ size (4) # +--------------------- type (8) Multiple ACKs Example:\n# ACK three messages ack_block = ACKBlock([ (tagset_id=3, N=42), (tagset_id=3, N=43), (tagset_id=4, N=0) ]) # Wire format (15 bytes): # 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00 # (ts=3, N=42) (ts=3, N=43) (ts=4, N=0) Processing:\ndef process_ack_block(block): num_acks = block.size // 4 for i in range(num_acks): offset = i * 4 tagset_id = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset:offset+2])[0] message_num = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset+2:offset+4])[0] # Mark message as acknowledged mark_acked(tagset_id, message_num) # May trigger retransmission timeout cancellation cancel_retransmit_timer(tagset_id, message_num) When to Send ACKs:\nExplicit ACK Request: Always respond to ACK Request block LeaseSet Delivery: When sender includes LeaseSet in message Session Establishment: May ACK NS/NSR (though protocol prefers implicit ACK via ES) Ratchet Confirmation: May ACK NextKey receipt Application Layer: As required by higher layer protocol (e.g., Streaming) ACK Timing:\nclass ACKManager: def __init__(self): self.pending_acks = [] self.ack_timer = None def request_ack(self, tagset_id, message_num): self.pending_acks.append((tagset_id, message_num)) if not self.ack_timer: # Delay ACK briefly to allow higher layer to respond self.ack_timer = set_timer(0.1, self.send_acks) # 100ms def send_acks(self): if self.pending_acks and not has_outbound_data(): # No higher layer data, send explicit ACK send_es_message(build_ack_block(self.pending_acks)) # Otherwise, ACK will piggyback on next ES message self.pending_acks = [] self.ack_timer = None ACK Request Block (Type 9) Purpose: Request in-band acknowledgment of current message\nFormat:\n+----+----+----+----+ | 9 | 1 |flg | +----+----+----+----+ Fields:\nblk: 9 size: 1 flg: 1 byte - Flags (all bits currently unused, set to 0) Usage:\n# Request ACK for this message payload = [ build_ack_request_block(), build_garlic_clove(important_data) ] Receiver Response:\nWhen ACK Request is received:\nWith Immediate Data: Include ACK block in immediate response Without Immediate Data: Start timer (e.g., 100ms) and send empty ES with ACK if timer expires Tag Set ID: Use current inbound tagset ID Message Number: Use message number associated with received session tag Processing:\ndef process_ack_request(message): # Extract message identification tagset_id = message.tagset_id message_num = message.message_num # Schedule ACK schedule_ack(tagset_id, message_num) # If no data to send immediately, start timer if not has_pending_data(): set_timer(0.1, lambda: send_ack_only(tagset_id, message_num)) When to Use ACK Request:\nCritical Messages: Messages that must be acknowledged LeaseSet Delivery: When bundling a LeaseSet Session Ratchet: After sending NextKey block End of Transmission: When sender has no more data to send but wants confirmation When NOT to Use:\nStreaming Protocol: Streaming layer handles ACKs High Frequency Messages: Avoid ACK Request on every message (overhead) Unimportant Datagrams: Raw datagrams typically don\u0026rsquo;t need ACKs Termination Block (Type 4) Status: UNIMPLEMENTED\nPurpose: Gracefully terminate session\nFormat:\n+----+----+----+----+----+----+----+----+ | 4 | size | rsn| addl data | +----+----+----+----+ + ~ ... ~ +----+----+----+----+----+----+----+----+ Fields:\nblk: 4 size: 1 or more bytes rsn: 1 byte - Reason code addl data: Optional additional data (format depends on reason) Reason Codes:\nCode Meaning Additional Data 0 Normal close / unspecified None 1 Termination received None 2 Idle timeout None (implementation-specific) 3 Resource exhaustion None (implementation-specific) 4+ Reserved Implementation-specific Usage (when implemented):\n# Normal session close termination = TerminationBlock( reason=0, additional_data=b\u0026#39;\u0026#39; ) # Session termination due to received termination termination = TerminationBlock( reason=1, additional_data=b\u0026#39;\u0026#39; ) Rules:\nMUST be last block except for Padding Padding MUST follow Termination if present Not allowed in NS or NSR messages Only allowed in ES messages Options Block (Type 5) Status: UNIMPLEMENTED\nPurpose: Negotiate session parameters\nFormat:\n+----+----+----+----+----+----+----+----+ | 5 | size |ver |flg |STL |STimeout | +----+----+----+----+----+----+----+----+ | SOTW | RITW |tmin|tmax|rmin|rmax| +----+----+----+----+----+----+----+----+ | tdmy | rdmy | tdelay | rdelay | +----+----+----+----+----+----+----+----+ | more_options | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Fields:\nblk: 5 size: 21 or more bytes ver: 1 byte - Protocol version (must be 0) flg: 1 byte - Flags (all bits currently unused) STL: 1 byte - Session tag length (must be 8) STimeout: 2 bytes - Session idle timeout in seconds (big-endian) SOTW: 2 bytes - Sender Outbound Tag Window (big-endian) RITW: 2 bytes - Receiver Inbound Tag Window (big-endian) tmin, tmax, rmin, rmax: 1 byte each - Padding parameters (4.4 fixed-point) tdmy: 2 bytes - Max dummy traffic willing to send (bytes/sec, big-endian) rdmy: 2 bytes - Requested dummy traffic (bytes/sec, big-endian) tdelay: 2 bytes - Max intra-message delay willing to insert (msec, big-endian) rdelay: 2 bytes - Requested intra-message delay (msec, big-endian) more_options: Variable - Future extensions Padding Parameters (4.4 Fixed-Point):\ndef encode_padding_ratio(ratio): \u0026#34;\u0026#34;\u0026#34; Encode padding ratio as 4.4 fixed-point ratio: 0.0 to 15.9375 returns: 0x00 to 0xFF \u0026#34;\u0026#34;\u0026#34; return int(ratio * 16) def decode_padding_ratio(encoded): \u0026#34;\u0026#34;\u0026#34; Decode 4.4 fixed-point to ratio encoded: 0x00 to 0xFF returns: 0.0 to 15.9375 \u0026#34;\u0026#34;\u0026#34; return encoded / 16.0 # Examples: # 0x00 = 0.0 (no padding) # 0x01 = 0.0625 (6.25% padding) # 0x10 = 1.0 (100% padding - double traffic) # 0x80 = 8.0 (800% padding - 9x traffic) # 0xFF = 15.9375 (1593.75% padding) Tag Window Negotiation:\n# SOTW: Sender\u0026#39;s recommendation for receiver\u0026#39;s inbound window # RITW: Sender\u0026#39;s declaration of own inbound window # Receiver calculates actual inbound window: inbound_window = calculate_window( sender_suggestion=SOTW, own_constraints=MAX_INBOUND_TAGS, own_resources=available_memory() ) # Sender uses: # - RITW to know how far ahead receiver will accept # - Own SOTW to hint optimal window size Default Values (when Options not negotiated):\nDEFAULT_OPTIONS = { \u0026#39;version\u0026#39;: 0, \u0026#39;session_tag_length\u0026#39;: 8, \u0026#39;session_timeout\u0026#39;: 600, # 10 minutes \u0026#39;sender_outbound_tag_window\u0026#39;: 160, \u0026#39;receiver_inbound_tag_window\u0026#39;: 160, \u0026#39;tmin\u0026#39;: 0x00, # No minimum padding \u0026#39;tmax\u0026#39;: 0x10, # Up to 100% padding \u0026#39;rmin\u0026#39;: 0x00, # No minimum requested \u0026#39;rmax\u0026#39;: 0x10, # Up to 100% requested \u0026#39;tdmy\u0026#39;: 0, # No dummy traffic \u0026#39;rdmy\u0026#39;: 0, # No dummy traffic requested \u0026#39;tdelay\u0026#39;: 0, # No delay \u0026#39;rdelay\u0026#39;: 0 # No delay requested } MessageNumbers Block (Type 6) Status: UNIMPLEMENTED\nPurpose: Indicate last message sent in previous tag set (enables gap detection)\nFormat:\n+----+----+----+----+----+ | 6 | 2 | PN | +----+----+----+----+----+ Fields:\nblk: 6 size: 2 PN: 2 bytes - Previous tag set last message number (big-endian, 0-65535) PN (Previous Number) Definition:\nPN is the index of the last tag sent in the previous tag set.\nUsage (when implemented):\n# After ratcheting to new tag set # Old tag set: sent messages 0-4095 # New tag set: sending first message payload = [ MessageNumbersBlock(PN=4095), build_garlic_clove(data) ] Receiver Benefits:\ndef process_message_numbers(pn_value): # Receiver can now: # 1. Determine if any messages were skipped highest_received_in_old_tagset = 4090 if pn_value \u0026gt; highest_received_in_old_tagset: missing_count = pn_value - highest_received_in_old_tagset # 5 messages were never received # 2. Delete tags higher than PN from old tagset for tag_index in range(pn_value + 1, MAX_TAG_INDEX): delete_tag(old_tagset, tag_index) # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes) schedule_deletion(old_tagset, delay=120) Rules:\nMUST NOT be sent in tag set 0 (no previous tag set) Only sent in ES messages Only sent in first message(s) of new tag set PN value is from sender\u0026rsquo;s perspective (last tag sender sent) Relationship to Signal:\nIn Signal Double Ratchet, PN is in the message header. In ECIES, it\u0026rsquo;s in the encrypted payload and is optional.\nPadding Block (Type 254) Purpose: Traffic analysis resistance and message size obfuscation\nFormat:\n+----+----+----+----+----+----+----+----+ |254 | size | padding | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Fields:\nblk: 254 size: 0-65516 bytes (big-endian) padding: Random or zero data Rules:\nMUST be last block in message Multiple Padding blocks NOT allowed May be zero length (3-byte header only) Padding data may be zeros or random bytes Default Padding:\nDEFAULT_PADDING_MIN = 0 DEFAULT_PADDING_MAX = 15 def generate_default_padding(): size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX) data = random.bytes(size) # or zeros return PaddingBlock(size, data) Traffic Analysis Resistance Strategies:\nStrategy 1: Random Size (Default)\n# Add 0-15 bytes random padding to each message padding_size = random.randint(0, 15) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Strategy 2: Round to Multiple\n# Round total message size to next multiple of 64 target_size = ((message_size + 63) // 64) * 64 padding_size = target_size - message_size - 3 # -3 for block header padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Strategy 3: Fixed Message Sizes\n# Always send 1KB messages TARGET_MESSAGE_SIZE = 1024 padding_size = TARGET_MESSAGE_SIZE - message_size - 3 padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Strategy 4: Negotiated Padding (Options block)\n# Calculate padding based on negotiated parameters # tmin, tmax from Options block min_padding = int(payload_size * tmin_ratio) max_padding = int(payload_size * tmax_ratio) padding_size = random.randint(min_padding, max_padding) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Padding-Only Messages:\nMessages may consist entirely of padding (no application data):\n# Dummy traffic message payload = [ PaddingBlock(random.randint(100, 500), random.bytes(...)) ] Implementation Notes:\nAll-Zero Padding: Acceptable (will be encrypted by ChaCha20) Random Padding: Provides no additional security after encryption but uses more entropy Performance: Random padding generation may be expensive; consider using zeros Memory: Large padding blocks consume bandwidth; be cautious with maximum size Implementation Guide Prerequisites Cryptographic Libraries:\nX25519: libsodium, NaCl, or Bouncy Castle ChaCha20-Poly1305: libsodium, OpenSSL 1.1.0+, or Bouncy Castle SHA-256: OpenSSL, Bouncy Castle, or built-in language support Elligator2: Limited library support; may require custom implementation Elligator2 Implementation:\nElligator2 is not widely implemented. Options:\nOBFS4: Tor\u0026rsquo;s obfs4 pluggable transport includes Elligator2 implementation Custom Implementation: Based on Elligator2 paper kleshni/Elligator: Reference implementation on GitHub Java I2P Note: Java I2P uses net.i2p.crypto.eddsa library with custom Elligator2 additions.\nRecommended Implementation Order Phase 1: Core Cryptography\nX25519 DH key generation and exchange ChaCha20-Poly1305 AEAD encryption/decryption SHA-256 hashing and MixHash HKDF key derivation Elligator2 encoding/decoding (can use test vectors initially) Phase 2: Message Formats\nNS message (unbound) - simplest format NS message (bound) - adds static key NSR message ES message Block parsing and generation Phase 3: Session Management\nSession creation and storage Tag set management (sender and receiver) Session tag ratchet Symmetric key ratchet Tag lookup and window management Phase 4: DH Ratcheting\nNextKey block handling DH ratchet KDF Tag set creation after ratchet Multiple tag set management Phase 5: Protocol Logic\nNS/NSR/ES state machine Replay prevention (DateTime, Bloom filter) Retransmission logic (multiple NS/NSR) ACK handling Phase 6: Integration\nI2NP Garlic Clove processing LeaseSet bundling Streaming protocol integration Datagram protocol integration Sender Implementation Outbound Session Lifecycle:\nclass OutboundSession: def __init__(self, destination, bound=True): self.destination = destination self.bound = bound self.state = SessionState.NEW # Keys for NS message self.ephemeral_keypair = generate_elg2_keypair() if bound: self.static_key = context.static_keypair # Will be populated after NSR self.outbound_tagset = None self.outbound_keyratchet = None self.inbound_tagset = None self.inbound_keyratchet = None # Timing self.created_time = now() self.last_activity = now() # Retransmission self.ns_attempts = [] self.ns_timer = None def send_initial_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send NS message\u0026#34;\u0026#34;\u0026#34; # Build NS message ns_message = self.build_ns_message(payload) # Send send_to_network(self.destination, ns_message) # Track for retransmission self.ns_attempts.append({ \u0026#39;message\u0026#39;: ns_message, \u0026#39;time\u0026#39;: now(), \u0026#39;ephemeral_key\u0026#39;: self.ephemeral_keypair, \u0026#39;kdf_state\u0026#39;: self.save_kdf_state() }) # Start timer self.ns_timer = set_timer(1.0, self.on_ns_timeout) self.state = SessionState.PENDING_REPLY def build_ns_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Construct NS message\u0026#34;\u0026#34;\u0026#34; # KDF initialization chainKey, h = self.initialize_kdf() # Ephemeral key section elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key) h = SHA256(h || self.destination.static_key) h = SHA256(h || self.ephemeral_keypair.public_key) # es DH es_shared = DH(self.ephemeral_keypair.private_key, self.destination.static_key) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Encrypt static key section if self.bound: static_section = self.static_key.public_key else: static_section = bytes(32) static_ciphertext = ENCRYPT(k_static, 0, static_section, h) h = SHA256(h || static_ciphertext) # ss DH (if bound) if self.bound: ss_shared = DH(self.static_key.private_key, self.destination.static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 else: k_payload = k_static nonce = 1 # Build payload blocks payload_data = self.build_ns_payload(payload) # Encrypt payload payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h) h = SHA256(h || payload_ciphertext) # Save KDF state for NSR processing self.ns_chainkey = chainKey self.ns_hash = h # Assemble message return elg2_ephemeral + static_ciphertext + payload_ciphertext def build_ns_payload(self, application_data): \u0026#34;\u0026#34;\u0026#34;Build NS payload blocks\u0026#34;\u0026#34;\u0026#34; blocks = [] # DateTime block (required, first) blocks.append(build_datetime_block()) # Garlic Clove(s) with application data blocks.append(build_garlic_clove(application_data)) # Optionally bundle LeaseSet if should_send_leaseset(): blocks.append(build_garlic_clove(build_leaseset_store())) # Padding blocks.append(build_padding_block(random.randint(0, 15))) return encode_blocks(blocks) def on_nsr_received(self, nsr_message): \u0026#34;\u0026#34;\u0026#34;Process NSR and establish ES session\u0026#34;\u0026#34;\u0026#34; # Cancel retransmission timer cancel_timer(self.ns_timer) # Parse NSR tag = nsr_message[0:8] elg2_bob_ephemeral = nsr_message[8:40] key_section_mac = nsr_message[40:56] payload_ciphertext = nsr_message[56:] # Find corresponding NS attempt ns_state = self.find_ns_by_tag(tag) if not ns_state: raise ValueError(\u0026#34;NSR tag doesn\u0026#39;t match any NS\u0026#34;) # Restore KDF state chainKey = ns_state[\u0026#39;chainkey\u0026#39;] h = ns_state[\u0026#39;hash\u0026#39;] # Decode Bob\u0026#39;s ephemeral key bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral) # Mix tag and Bob\u0026#39;s ephemeral into hash h = SHA256(h || tag) h = SHA256(h || bob_ephemeral) # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(self.static_key.private_key, bob_ephemeral) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Verify key section MAC try: DECRYPT(k_key_section, 0, key_section_mac, h) except AuthenticationError: raise ValueError(\u0026#34;NSR key section MAC verification failed\u0026#34;) h = SHA256(h || key_section_mac) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Decrypt NSR payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) try: payload = DECRYPT(k_nsr, 0, payload_ciphertext, h) except AuthenticationError: raise ValueError(\u0026#34;NSR payload MAC verification failed\u0026#34;) # Process NSR payload blocks self.process_payload_blocks(payload) # Session established self.state = SessionState.ESTABLISHED self.last_activity = now() # Send ES message (implicit ACK) self.send_es_ack() def send_es_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send ES message\u0026#34;\u0026#34;\u0026#34; if self.state != SessionState.ESTABLISHED: raise ValueError(\u0026#34;Session not established\u0026#34;) # Get next tag and key tag, index = self.outbound_tagset.get_next_tag() key = self.outbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Build payload blocks payload_data = self.build_es_payload(payload) # AEAD encryption ciphertext = ENCRYPT(key, nonce, payload_data, tag) # Assemble message es_message = tag + ciphertext # Send send_to_network(self.destination, es_message) # Update activity self.last_activity = now() # Check if ratchet needed if self.outbound_tagset.should_ratchet(): self.initiate_ratchet() Receiver Implementation Inbound Session Lifecycle:\nclass InboundSession: def __init__(self): self.state = None self.bound = False self.destination = None # Keys self.remote_ephemeral_key = None self.remote_static_key = None self.ephemeral_keypair = None # Tagsets self.inbound_tagset = None self.outbound_tagset = None # Timing self.created_time = None self.last_activity = None # Paired session self.paired_outbound = None @staticmethod def try_decrypt_ns(message): \u0026#34;\u0026#34;\u0026#34;Attempt to decrypt as NS message\u0026#34;\u0026#34;\u0026#34; # Parse NS structure elg2_ephemeral = message[0:32] static_ciphertext = message[32:80] # 32 + 16 payload_ciphertext = message[80:] # Decode ephemeral key try: alice_ephemeral = DECODE_ELG2(elg2_ephemeral) except: return None # Not a valid Elligator2 encoding # Check replay if is_replay(alice_ephemeral): return None # KDF initialization chainKey, h = initialize_kdf() # Mix keys h = SHA256(h || context.static_keypair.public_key) h = SHA256(h || alice_ephemeral) # es DH es_shared = DH(context.static_keypair.private_key, alice_ephemeral) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Decrypt static key section try: static_data = DECRYPT(k_static, 0, static_ciphertext, h) except AuthenticationError: return None # Not a valid NS message h = SHA256(h || static_ciphertext) # Check if bound or unbound if static_data == bytes(32): # Unbound alice_static_key = None k_payload = k_static nonce = 1 else: # Bound - perform ss DH alice_static_key = static_data ss_shared = DH(context.static_keypair.private_key, alice_static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 # Decrypt payload try: payload = DECRYPT(k_payload, nonce, payload_ciphertext, h) except AuthenticationError: return None h = SHA256(h || payload_ciphertext) # Create session session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() session.last_activity = now() session.remote_ephemeral_key = alice_ephemeral session.remote_static_key = alice_static_key session.bound = (alice_static_key is not None) session.ns_chainkey = chainKey session.ns_hash = h # Extract destination if bound if session.bound: session.destination = extract_destination_from_payload(payload) # Process payload session.process_payload_blocks(payload) return session def send_nsr_reply(self, reply_payload): \u0026#34;\u0026#34;\u0026#34;Send NSR message\u0026#34;\u0026#34;\u0026#34; # Generate NSR tagset tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey) # Get tag tag, _ = nsr_tagset.get_next_tag() # Mix tag into hash h = SHA256(self.ns_hash || tag) # Generate ephemeral key self.ephemeral_keypair = generate_elg2_keypair() bob_ephemeral = self.ephemeral_keypair.public_key elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral) # Mix ephemeral key h = SHA256(h || bob_ephemeral) chainKey = self.ns_chainkey # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(context.static_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Encrypt key section (empty) key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h) h = SHA256(h || key_section_ciphertext) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Build reply payload payload_data = build_payload_blocks(reply_payload) # Encrypt payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h) # Assemble NSR nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext # Send send_to_network(self.destination, nsr_message) # Wait for ES self.state = SessionState.AWAITING_ES self.last_activity = now() def on_es_received(self, es_message): \u0026#34;\u0026#34;\u0026#34;Process first ES message\u0026#34;\u0026#34;\u0026#34; if self.state == SessionState.AWAITING_ES: # First ES received, confirms session self.state = SessionState.ESTABLISHED # Process ES message self.process_es_message(es_message) def process_es_message(self, es_message): \u0026#34;\u0026#34;\u0026#34;Decrypt and process ES message\u0026#34;\u0026#34;\u0026#34; # Extract tag tag = es_message[0:8] ciphertext = es_message[8:] # Look up tag index = self.inbound_tagset.lookup_tag(tag) if index is None: raise ValueError(\u0026#34;Tag not found\u0026#34;) # Get key key = self.inbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Decrypt try: payload = DECRYPT(key, nonce, ciphertext, tag) except AuthenticationError: raise ValueError(\u0026#34;ES MAC verification failed\u0026#34;) # Process blocks self.process_payload_blocks(payload) # Update activity self.last_activity = now() Message Classification Distinguishing Message Types:\ndef classify_message(message): \u0026#34;\u0026#34;\u0026#34;Determine message type\u0026#34;\u0026#34;\u0026#34; # Minimum lengths if len(message) \u0026lt; 24: return None # Too short # Check for session tag (8 bytes) tag = message[0:8] # Try ES decryption first (most common) session = lookup_session_by_tag(tag) if session: return (\u0026#39;ES\u0026#39;, session) # Try NSR decryption (tag + Elligator2 key) if len(message) \u0026gt;= 72: # Check if bytes 8-40 are valid Elligator2 try: nsr_ephemeral = DECODE_ELG2(message[8:40]) nsr_session = find_pending_nsr_by_tag(tag) if nsr_session: return (\u0026#39;NSR\u0026#39;, nsr_session) except: pass # Try NS decryption (starts with Elligator2 key) if len(message) \u0026gt;= 96: try: ns_ephemeral = DECODE_ELG2(message[0:32]) ns_session = InboundSession.try_decrypt_ns(message) if ns_session: return (\u0026#39;NS\u0026#39;, ns_session) except: pass # Check ElGamal/AES (for dual-key compatibility) if len(message) \u0026gt;= 514: if (len(message) - 2) % 16 == 0: # Might be ElGamal NS return (\u0026#39;ELGAMAL_NS\u0026#39;, None) elif len(message) % 16 == 0: # Might be ElGamal ES return (\u0026#39;ELGAMAL_ES\u0026#39;, None) return None # Unknown message type Session Management Best Practices Session Storage:\nclass SessionKeyManager: def __init__(self): # Outbound sessions (one per destination) self.outbound_sessions = {} # destination -\u0026gt; OutboundSession # Inbound sessions (multiple per destination during transition) self.inbound_sessions = [] # [InboundSession] # Session tag lookup (fast path for ES messages) self.tag_to_session = {} # tag -\u0026gt; InboundSession # Limits self.max_inbound_sessions = 1000 self.max_tags_per_session = 160 def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: session = OutboundSession(destination) self.outbound_sessions[destination] = session return self.outbound_sessions[destination] def add_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Add new inbound session\u0026#34;\u0026#34;\u0026#34; # Check limits if len(self.inbound_sessions) \u0026gt;= self.max_inbound_sessions: self.expire_oldest_session() self.inbound_sessions.append(session) # Add tags to lookup table self.register_session_tags(session) def register_session_tags(self, session): \u0026#34;\u0026#34;\u0026#34;Register session\u0026#39;s tags in lookup table\u0026#34;\u0026#34;\u0026#34; for tag in session.inbound_tagset.get_all_tags(): self.tag_to_session[tag] = session def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Fast tag lookup\u0026#34;\u0026#34;\u0026#34; return self.tag_to_session.get(tag) def expire_sessions(self): \u0026#34;\u0026#34;\u0026#34;Periodic session expiration\u0026#34;\u0026#34;\u0026#34; now_time = now() # Expire outbound sessions for dest, session in list(self.outbound_sessions.items()): if session.idle_time(now_time) \u0026gt; 8 * 60: del self.outbound_sessions[dest] # Expire inbound sessions expired = [] for session in self.inbound_sessions: if session.idle_time(now_time) \u0026gt; 10 * 60: expired.append(session) for session in expired: self.remove_inbound_session(session) def remove_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Remove inbound session and clean up tags\u0026#34;\u0026#34;\u0026#34; self.inbound_sessions.remove(session) # Remove tags from lookup for tag in session.inbound_tagset.get_all_tags(): if tag in self.tag_to_session: del self.tag_to_session[tag] Memory Management:\nclass TagMemoryManager: def __init__(self, max_memory_kb=10240): # 10 MB default self.max_memory = max_memory_kb * 1024 self.current_memory = 0 self.max_tags_per_session = 160 self.min_tags_per_session = 32 def calculate_tag_memory(self, session): \u0026#34;\u0026#34;\u0026#34;Calculate memory used by session tags\u0026#34;\u0026#34;\u0026#34; tag_count = len(session.inbound_tagset.tags) # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional) # + overhead bytes_per_tag = 16 if session.defer_keys else 48 return tag_count * bytes_per_tag def check_pressure(self): \u0026#34;\u0026#34;\u0026#34;Check if under memory pressure\u0026#34;\u0026#34;\u0026#34; return self.current_memory \u0026gt; (self.max_memory * 0.9) def handle_pressure(self): \u0026#34;\u0026#34;\u0026#34;Reduce memory usage when under pressure\u0026#34;\u0026#34;\u0026#34; if not self.check_pressure(): return # Strategy 1: Reduce look-ahead windows for session in all_sessions: if session.look_ahead \u0026gt; self.min_tags_per_session: session.reduce_look_ahead(self.min_tags_per_session) # Strategy 2: Trim old tags aggressively for session in all_sessions: session.inbound_tagset.trim_behind(aggressive=True) # Strategy 3: Refuse new ratchets for session in all_sessions: if session.outbound_tagset.should_ratchet(): session.defer_ratchet = True # Strategy 4: Expire idle sessions early expire_idle_sessions(threshold=5*60) # 5 min instead of 10 Testing Strategies Unit Tests:\ndef test_x25519_dh(): \u0026#34;\u0026#34;\u0026#34;Test X25519 key exchange\u0026#34;\u0026#34;\u0026#34; alice_sk = GENERATE_PRIVATE() alice_pk = DERIVE_PUBLIC(alice_sk) bob_sk = GENERATE_PRIVATE() bob_pk = DERIVE_PUBLIC(bob_sk) # Both sides compute same shared secret alice_shared = DH(alice_sk, bob_pk) bob_shared = DH(bob_sk, alice_pk) assert alice_shared == bob_shared def test_elligator2_encode_decode(): \u0026#34;\u0026#34;\u0026#34;Test Elligator2 roundtrip\u0026#34;\u0026#34;\u0026#34; sk = GENERATE_PRIVATE_ELG2() pk = DERIVE_PUBLIC(sk) encoded = ENCODE_ELG2(pk) decoded = DECODE_ELG2(encoded) assert decoded == pk def test_chacha_poly_encrypt_decrypt(): \u0026#34;\u0026#34;\u0026#34;Test ChaCha20-Poly1305 AEAD\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(42) plaintext = b\u0026#34;Hello, I2P!\u0026#34; ad = b\u0026#34;associated_data\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) decrypted = DECRYPT(key, nonce, ciphertext, ad) assert decrypted == plaintext def test_session_tag_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test session tag generation\u0026#34;\u0026#34;\u0026#34; sessTag_ck = CSRNG(32) tagset = SessionTagRatchet(sessTag_ck) # Generate 100 tags tags = [tagset.get_next_tag() for _ in range(100)] # All tags should be unique assert len(set(tags)) == 100 # Each tag should be 8 bytes for tag in tags: assert len(tag) == 8 Integration Tests:\ndef test_ns_nsr_handshake(): \u0026#34;\u0026#34;\u0026#34;Test NS/NSR handshake\u0026#34;\u0026#34;\u0026#34; # Alice creates outbound session alice_session = OutboundSession(bob_destination, bound=True) # Alice sends NS ns_message = alice_session.build_ns_message(b\u0026#34;Hello Bob\u0026#34;) # Bob receives NS bob_session = InboundSession.try_decrypt_ns(ns_message) assert bob_session is not None assert bob_session.bound == True # Bob sends NSR nsr_message = bob_session.build_nsr_message(b\u0026#34;Hello Alice\u0026#34;) # Alice receives NSR alice_session.on_nsr_received(nsr_message) assert alice_session.state == SessionState.ESTABLISHED # Both should have matching ES tagsets # (Cannot directly compare, but can test by sending ES messages) def test_es_bidirectional(): \u0026#34;\u0026#34;\u0026#34;Test ES messages in both directions\u0026#34;\u0026#34;\u0026#34; # (After NS/NSR handshake) # Alice sends ES to Bob es_alice_to_bob = alice_session.send_es_message(b\u0026#34;Data from Alice\u0026#34;) # Bob receives ES bob_session.process_es_message(es_alice_to_bob) # Bob sends ES to Alice es_bob_to_alice = bob_session.send_es_message(b\u0026#34;Data from Bob\u0026#34;) # Alice receives ES alice_session.process_es_message(es_bob_to_alice) def test_dh_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test DH ratchet\u0026#34;\u0026#34;\u0026#34; # (After established session) # Alice initiates ratchet alice_session.initiate_ratchet() nextkey_alice = build_nextkey_block( flags=0x01, key_id=0, public_key=alice_new_key ) # Send to Bob bob_session.process_nextkey_block(nextkey_alice) # Bob replies nextkey_bob = build_nextkey_block( flags=0x03, key_id=0, public_key=bob_new_key ) # Send to Alice alice_session.process_nextkey_block(nextkey_bob) # Both should now be using new tagsets assert alice_session.outbound_tagset.id == 1 assert bob_session.inbound_tagset.id == 1 Test Vectors:\nImplement test vectors from the specification:\nNoise IK Handshake: Use standard Noise test vectors HKDF: Use RFC 5869 test vectors ChaCha20-Poly1305: Use RFC 7539 test vectors Elligator2: Use test vectors from Elligator2 paper or OBFS4 Interoperability Testing:\nJava I2P: Test against Java I2P reference implementation i2pd: Test against C++ i2pd implementation Packet Captures: Use Wireshark dissector (if available) to verify message formats Cross-Implementation: Create test harness that can send/receive between implementations Performance Considerations Key Generation:\nElligator2 key generation is expensive (50% rejection rate):\nclass KeyPool: \u0026#34;\u0026#34;\u0026#34;Pre-generate keys in background thread\u0026#34;\u0026#34;\u0026#34; def __init__(self, pool_size=10): self.pool = Queue(maxsize=pool_size) self.generator_thread = Thread(target=self.generate_keys, daemon=True) self.generator_thread.start() def generate_keys(self): while True: if not self.pool.full(): keypair = generate_elg2_keypair() # Also compute encoded form encoded = ENCODE_ELG2(keypair.public_key) self.pool.put((keypair, encoded)) else: sleep(0.1) def get_keypair(self): try: return self.pool.get(timeout=1.0) except Empty: # Pool exhausted, generate inline return generate_elg2_keypair() Tag Lookup:\nUse hash tables for O(1) tag lookup:\nclass FastTagLookup: def __init__(self): self.tag_to_session = {} # Python dict is hash table def add_tag(self, tag, session, index): # 8-byte tag as bytes is hashable self.tag_to_session[tag] = (session, index) def lookup_tag(self, tag): return self.tag_to_session.get(tag) Memory Optimization:\nDefer symmetric key generation:\nclass DeferredKeyRatchet: \u0026#34;\u0026#34;\u0026#34;Only generate keys when needed\u0026#34;\u0026#34;\u0026#34; def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = LRUCache(maxsize=32) # Cache recent keys def get_key(self, index): # Check cache first if index in self.cache: return self.cache[index] # Generate keys up to index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: key = keydata[32:63] self.cache[index] = key return key Batch Processing:\nProcess multiple messages in batch:\ndef process_message_batch(messages): \u0026#34;\u0026#34;\u0026#34;Process multiple messages efficiently\u0026#34;\u0026#34;\u0026#34; results = [] # Group by type ns_messages = [] nsr_messages = [] es_messages = [] for msg in messages: msg_type = classify_message(msg) if msg_type[0] == \u0026#39;NS\u0026#39;: ns_messages.append(msg) elif msg_type[0] == \u0026#39;NSR\u0026#39;: nsr_messages.append(msg) elif msg_type[0] == \u0026#39;ES\u0026#39;: es_messages.append(msg) # Process in batches # ES messages are most common, process first for msg in es_messages: results.append(process_es_message(msg)) for msg in nsr_messages: results.append(process_nsr_message(msg)) for msg in ns_messages: results.append(process_ns_message(msg)) return results Security Considerations Threat Model Adversary Capabilities:\nPassive Observer: Can observe all network traffic Active Attacker: Can inject, modify, drop, replay messages Compromised Node: May compromise a router or destination Traffic Analysis: Can perform statistical analysis of traffic patterns Security Goals:\nConfidentiality: Message contents hidden from observer Authentication: Sender identity verified (for bound sessions) Forward Secrecy: Past messages remain secret even if keys compromised Replay Prevention: Cannot replay old messages Traffic Obfuscation: Handshakes indistinguishable from random data Cryptographic Assumptions Hardness Assumptions:\nX25519 CDH: Computational Diffie-Hellman problem is hard on Curve25519 ChaCha20 PRF: ChaCha20 is a pseudorandom function Poly1305 MAC: Poly1305 is unforgeable under chosen message attack SHA-256 CR: SHA-256 is collision-resistant HKDF Security: HKDF extracts and expands uniformly distributed keys Security Levels:\nX25519: ~128-bit security (curve order 2^252) ChaCha20: 256-bit keys, 256-bit security Poly1305: 128-bit security (collision probability) SHA-256: 128-bit collision resistance, 256-bit preimage resistance Key Management Key Generation:\n# CRITICAL: Use cryptographically secure RNG def CSRNG(length): # GOOD: os.urandom, secrets.token_bytes (Python) # GOOD: /dev/urandom (Linux) # GOOD: BCryptGenRandom (Windows) # BAD: random.random(), Math.random() (NOT cryptographically secure) return os.urandom(length) # CRITICAL: Validate keys def validate_x25519_key(pubkey): # Check for weak keys (all zeros, small order points) if pubkey == bytes(32): raise WeakKeyError(\u0026#34;All-zero public key\u0026#34;) # Perform DH to check for weak shared secrets test_shared = DH(test_private_key, pubkey) if test_shared == bytes(32): raise WeakKeyError(\u0026#34;Results in zero shared secret\u0026#34;) Key Storage:\n# CRITICAL: Protect private keys class SecureKeyStorage: def __init__(self): # Store in memory with protection self.keys = {} # Option 1: Memory locking (prevent swapping to disk) # mlock(self.keys) # Option 2: Encrypted storage # self.encryption_key = derive_from_password() def store_key(self, key_id, private_key): # Option: Encrypt before storage # encrypted = encrypt(private_key, self.encryption_key) # self.keys[key_id] = encrypted self.keys[key_id] = private_key def delete_key(self, key_id): # Securely wipe memory if key_id in self.keys: key = self.keys[key_id] # Overwrite with zeros before deletion for i in range(len(key)): key[i] = 0 del self.keys[key_id] Key Rotation:\n# CRITICAL: Rotate keys regularly class KeyRotationPolicy: def __init__(self): self.max_messages_per_tagset = 4096 # Ratchet before 65535 self.max_tagset_age = 10 * 60 # 10 minutes self.max_session_age = 60 * 60 # 1 hour def should_ratchet(self, tagset): return (tagset.messages_sent \u0026gt;= self.max_messages_per_tagset or tagset.age() \u0026gt;= self.max_tagset_age) def should_replace_session(self, session): return session.age() \u0026gt;= self.max_session_age Attack Mitigations Replay Attack Mitigations DateTime Validation:\nMAX_CLOCK_SKEW_PAST = 5 * 60 MAX_CLOCK_SKEW_FUTURE = 2 * 60 def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: raise ReplayError(\u0026#34;Timestamp too far in future\u0026#34;) if age \u0026gt; MAX_CLOCK_SKEW_PAST: raise ReplayError(\u0026#34;Timestamp too old\u0026#34;) return True Bloom Filter for NS Messages:\nclass ReplayFilter: def __init__(self, capacity=100000, error_rate=0.001, duration=5*60): self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate) self.duration = duration self.entries = [] # (timestamp, ephemeral_key) def check_replay(self, ephemeral_key, timestamp): # Validate timestamp if not validate_datetime(timestamp): return False # Check Bloom filter if ephemeral_key in self.bloom: # Potential replay (or false positive) # Check exact match in entries for ts, key in self.entries: if key == ephemeral_key: return False # Definite replay # Add to filter self.bloom.add(ephemeral_key) self.entries.append((timestamp, ephemeral_key)) # Expire old entries self.expire_old_entries() return True def expire_old_entries(self): now = int(time.time()) self.entries = [(ts, key) for ts, key in self.entries if now - ts \u0026lt; self.duration] Session Tag One-Time Use:\ndef process_session_tag(tag): # Look up tag entry = tagset.lookup_tag(tag) if entry is None: raise ValueError(\u0026#34;Invalid session tag\u0026#34;) # CRITICAL: Remove tag immediately (one-time use) tagset.remove_tag(tag) # Use associated key return entry.key, entry.index Key Compromise Impersonation (KCI) Mitigations Problem: NS message authentication is vulnerable to KCI (Authentication Level 1)\nMitigation:\nTransition to NSR (Authentication Level 2) as quickly as possible Don\u0026rsquo;t trust NS payload for security-critical operations Wait for NSR confirmation before performing irreversible actions def process_ns_message(ns_message): # NS authenticated at Level 1 (KCI vulnerable) # Do NOT perform security-critical operations yet # Extract sender\u0026#39;s static key sender_key = ns_message.static_key # Mark session as pending Level 2 authentication session.auth_level = 1 session.sender_key = sender_key # Send NSR send_nsr_reply(session) def process_first_es_message(es_message): # Now we have Level 2 authentication (KCI resistant) session.auth_level = 2 # Safe to perform security-critical operations process_security_critical_operation(es_message) Denial-of-Service Mitigations NS Flood Protection:\nclass NSFloodProtection: def __init__(self): self.ns_count = defaultdict(int) # source -\u0026gt; count self.ns_timestamps = defaultdict(list) # source -\u0026gt; [timestamps] self.max_ns_per_source = 5 self.rate_window = 10 # seconds self.max_concurrent_ns = 100 def check_ns_allowed(self, source): # Global limit total_pending = sum(self.ns_count.values()) if total_pending \u0026gt;= self.max_concurrent_ns: return False # Per-source rate limit now = time.time() timestamps = self.ns_timestamps[source] # Remove old timestamps timestamps = [ts for ts in timestamps if now - ts \u0026lt; self.rate_window] self.ns_timestamps[source] = timestamps # Check rate if len(timestamps) \u0026gt;= self.max_ns_per_source: return False # Allow NS timestamps.append(now) self.ns_count[source] += 1 return True def on_session_established(self, source): # Decrease pending count if self.ns_count[source] \u0026gt; 0: self.ns_count[source] -= 1 Tag Storage Limits:\nclass TagStorageLimit: def __init__(self, max_tags=1000000): self.max_tags = max_tags self.current_tags = 0 def can_create_session(self, look_ahead): if self.current_tags + look_ahead \u0026gt; self.max_tags: return False return True def add_tags(self, count): self.current_tags += count def remove_tags(self, count): self.current_tags -= count Adaptive Resource Management:\nclass AdaptiveResourceManager: def __init__(self): self.load_level = 0 # 0 = low, 1 = medium, 2 = high, 3 = critical def adjust_parameters(self): if self.load_level == 0: # Normal operation return { \u0026#39;max_look_ahead\u0026#39;: 160, \u0026#39;max_sessions\u0026#39;: 1000, \u0026#39;session_timeout\u0026#39;: 10 * 60 } elif self.load_level == 1: # Moderate load return { \u0026#39;max_look_ahead\u0026#39;: 80, \u0026#39;max_sessions\u0026#39;: 800, \u0026#39;session_timeout\u0026#39;: 8 * 60 } elif self.load_level == 2: # High load return { \u0026#39;max_look_ahead\u0026#39;: 32, \u0026#39;max_sessions\u0026#39;: 500, \u0026#39;session_timeout\u0026#39;: 5 * 60 } else: # load_level == 3 # Critical load return { \u0026#39;max_look_ahead\u0026#39;: 16, \u0026#39;max_sessions\u0026#39;: 200, \u0026#39;session_timeout\u0026#39;: 3 * 60 } Traffic Analysis Resistance Elligator2 Encoding:\nEnsures handshake messages are indistinguishable from random:\n# NS and NSR start with Elligator2-encoded ephemeral keys # Observer cannot distinguish from random 32-byte string Padding Strategies:\n# Resist message size fingerprinting def add_padding(payload, strategy=\u0026#39;random\u0026#39;): if strategy == \u0026#39;random\u0026#39;: # Random padding 0-15 bytes size = random.randint(0, 15) elif strategy == \u0026#39;round\u0026#39;: # Round to next 64-byte boundary target = ((len(payload) + 63) // 64) * 64 size = target - len(payload) - 3 # -3 for block header elif strategy == \u0026#39;fixed\u0026#39;: # Always 1KB messages size = 1024 - len(payload) - 3 return build_padding_block(size) Timing Attacks:\n# CRITICAL: Use constant-time operations def constant_time_compare(a, b): \u0026#34;\u0026#34;\u0026#34;Constant-time byte string comparison\u0026#34;\u0026#34;\u0026#34; if len(a) != len(b): return False result = 0 for x, y in zip(a, b): result |= x ^ y return result == 0 # CRITICAL: Constant-time MAC verification def verify_mac(computed_mac, received_mac): if not constant_time_compare(computed_mac, received_mac): # Always take same time regardless of where comparison fails raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) Implementation Pitfalls Common Mistakes:\nNonce Reuse: NEVER reuse (key, nonce) pairs\n# BAD: Reusing nonce with same key ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2) # CATASTROPHIC # GOOD: Unique nonce for each message ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2) Ephemeral Key Reuse: Generate fresh ephemeral key for each NS/NSR\n# BAD: Reusing ephemeral key ephemeral_key = generate_elg2_keypair() send_ns_message(ephemeral_key) send_ns_message(ephemeral_key) # BAD # GOOD: New key for each message send_ns_message(generate_elg2_keypair()) send_ns_message(generate_elg2_keypair()) Weak RNG: Use cryptographically secure random number generator\n# BAD: Non-cryptographic RNG import random key = bytes([random.randint(0, 255) for _ in range(32)]) # INSECURE # GOOD: Cryptographically secure RNG import os key = os.urandom(32) Timing Attacks: Use constant-time comparisons\n# BAD: Early-exit comparison if computed_mac == received_mac: # Timing leak pass # GOOD: Constant-time comparison if constant_time_compare(computed_mac, received_mac): pass Incomplete MAC Verification: Always verify before using data\n# BAD: Decrypting before verification plaintext = chacha20_decrypt(key, nonce, ciphertext) mac_ok = verify_mac(mac, plaintext) # TOO LATE if not mac_ok: return error # GOOD: AEAD verifies before decrypting try: plaintext = DECRYPT(key, nonce, ciphertext, ad) # Verifies MAC first except AuthenticationError: return error Key Deletion: Securely wipe keys from memory\n# BAD: Simple deletion del private_key # Still in memory # GOOD: Overwrite before deletion for i in range(len(private_key)): private_key[i] = 0 del private_key Security Audits Recommended Audits:\nCryptographic Review: Expert review of KDF chains and DH operations Implementation Audit: Code review for timing attacks, key management, RNG usage Protocol Analysis: Formal verification of handshake security properties Side-Channel Analysis: Timing, power, and cache attacks Fuzzing: Random input testing for parser robustness Test Cases:\n# Security-critical test cases def test_nonce_uniqueness(): \u0026#34;\u0026#34;\u0026#34;Ensure nonces are never reused\u0026#34;\u0026#34;\u0026#34; nonces = set() for i in range(10000): nonce = construct_nonce(i) assert nonce not in nonces nonces.add(nonce) def test_key_isolation(): \u0026#34;\u0026#34;\u0026#34;Ensure sessions don\u0026#39;t share keys\u0026#34;\u0026#34;\u0026#34; session1 = create_session(destination1) session2 = create_session(destination2) assert session1.key != session2.key def test_replay_prevention(): \u0026#34;\u0026#34;\u0026#34;Ensure replay attacks are detected\u0026#34;\u0026#34;\u0026#34; ns_message = create_ns_message() # First delivery succeeds assert process_ns_message(ns_message) == True # Replay fails assert process_ns_message(ns_message) == False def test_mac_verification(): \u0026#34;\u0026#34;\u0026#34;Ensure MAC verification is enforced\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(0) plaintext = b\u0026#34;test\u0026#34; ad = b\u0026#34;test_ad\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) # Correct MAC verifies assert DECRYPT(key, nonce, ciphertext, ad) == plaintext # Corrupted MAC fails corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF]) with pytest.raises(AuthenticationError): DECRYPT(key, nonce, corrupted, ad) Configuration and Deployment I2CP Configuration Enable ECIES Encryption:\n# ECIES-only (recommended for new deployments) i2cp.leaseSetEncType=4 # Dual-key (ECIES + ElGamal for compatibility) i2cp.leaseSetEncType=4,0 # ElGamal-only (legacy, not recommended) i2cp.leaseSetEncType=0 LeaseSet Type:\n# Standard LS2 (most common) i2cp.leaseSetType=3 # Encrypted LS2 (blinded destinations) i2cp.leaseSetType=5 # Meta LS2 (multiple destinations) i2cp.leaseSetType=7 Additional Options:\n# Static key for ECIES (optional, auto-generated if not specified) # 32-byte X25519 public key, base64-encoded i2cp.leaseSetPrivateKey=\u0026lt;base64-encoded-key\u0026gt; # Signature type (for LeaseSet) i2cp.leaseSetSigningPrivateKey=\u0026lt;base64-encoded-key\u0026gt; i2cp.leaseSetSigningType=7 # Ed25519 Java I2P Configuration router.config:\n# Router-to-router ECIES i2p.router.useECIES=true Build Properties:\n// For I2CP clients (Java) Properties props = new Properties(); props.setProperty(\u0026#34;i2cp.leaseSetEncType\u0026#34;, \u0026#34;4\u0026#34;); props.setProperty(\u0026#34;i2cp.leaseSetType\u0026#34;, \u0026#34;3\u0026#34;); I2PSession session = i2pClient.createSession(props); i2pd Configuration i2pd.conf:\n[limits] # ECIES sessions memory limit ecies.memory = 128M [ecies] # Enable ECIES enabled = true # ECIES-only or dual-key compatibility = true # true = dual-key, false = ECIES-only Tunnels Configuration:\n[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # ECIES-only ecies = true Compatibility Matrix Router Version Support:\nVersion ECIES Support LS2 Support Dual-Key Notes \u0026lt; 0.9.38 ❌ No ❌ No N/A Legacy only 0.9.38-0.9.45 ❌ No ✅ Yes N/A LS2 only 0.9.46-0.9.50 ✅ Yes ✅ Yes ✅ Yes Initial ECIES 1.5.0+ ✅ Yes ✅ Yes ✅ Yes Current 2.0.0+ ✅ Yes ✅ Yes ✅ Yes Current Destination Compatibility:\nDestination Type Can Connect To Notes ECIES-only ECIES-only, Dual-key Requires 0.9.46+ routers Dual-key Any Maximum compatibility ElGamal-only ElGamal-only, Dual-key Legacy FloodFill Requirements:\nECIES-only destinations: Require majority of floodfills on 0.9.46+ for encrypted lookups Dual-key destinations: Work with any floodfill version Current status: Near 100% floodfill adoption as of 2025 Migration Guide Migrating from ElGamal to ECIES:\nStep 1: Enable Dual-Key Mode\n# Add ECIES while keeping ElGamal i2cp.leaseSetEncType=4,0 Step 2: Monitor Connections\n# Check connection types i2prouter.exe status # or http://127.0.0.1:7657/peers Step 3: Switch to ECIES-Only (after testing)\n# Remove ElGamal i2cp.leaseSetEncType=4 Step 4: Restart Application\n# Restart I2P router or application systemctl restart i2p # or i2prouter.exe restart Rollback Plan:\n# Revert to ElGamal-only if issues i2cp.leaseSetEncType=0 Performance Tuning Session Limits:\n# Maximum inbound sessions i2p.router.maxInboundSessions=1000 # Maximum outbound sessions i2p.router.maxOutboundSessions=1000 # Session timeout (seconds) i2p.router.sessionTimeout=600 Memory Limits:\n# Tag storage limit (KB) i2p.ecies.maxTagMemory=10240 # 10 MB # Look-ahead window i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32 Ratchet Policy:\n# Messages before ratchet i2p.ecies.ratchetThreshold=4096 # Time before ratchet (seconds) i2p.ecies.ratchetTimeout=600 # 10 minutes Monitoring and Debugging Logging:\n# Enable ECIES debug logging logger.i2p.router.transport.ecies=DEBUG Metrics:\nMonitor these metrics:\nNS Success Rate: Percentage of NS messages receiving NSR Session Establishment Time: Time from NS to first ES Tag Storage Usage: Current memory usage for tags Ratchet Frequency: How often sessions ratchet Session Lifetime: Average session duration Common Issues:\nNS Timeout: No NSR received\nCheck destination is online Check floodfill availability Verify LeaseSet published correctly High Memory Usage: Too many tags stored\nReduce look-ahead window Decrease session timeout Implement aggressive expiration Frequent Ratchets: Sessions ratcheting too often\nIncrease ratchet threshold Check for retransmissions Session Failures: ES messages failing to decrypt\nVerify tag synchronization Check for replay attacks Validate nonce construction References Specifications ECIES Proposal: Proposal 144 I2NP: I2NP Specification Common Structures: Common Structures Specification NTCP2: NTCP2 Specification SSU2: SSU2 Specification I2CP: I2CP Specification ElGamal/AES+SessionTags: ElGamal/AES Specification Cryptographic Standards Noise Protocol Framework: Noise Specification (Revision 34, 2018-07-11) Signal Double Ratchet: Signal Specification RFC 7748: Elliptic Curves for Security (X25519) RFC 7539: ChaCha20 and Poly1305 for IETF Protocols RFC 5869: HKDF (HMAC-based Key Derivation Function) RFC 2104: HMAC: Keyed-Hashing for Message Authentication Elligator2: Elligator Paper Implementation Resources Java I2P: i2p.i2p Repository i2pd (C++): i2pd Repository OBFS4 (Elligator2): obfs4proxy Repository Additional Information I2P Website: / I2P Forum: https://i2pforum.net I2P Wiki: https://wiki.i2p-projekt.de Appendix A: KDF Summary All KDF Operations in ECIES:\nOperation Input Info String Output NS Initial ChainKey protocol_name (none - SHA256) h, chainKey NS Static Key Section chainKey, es_shared \"\" chainKey, k NS Payload Section (bound) chainKey, ss_shared \"\" chainKey, k NSR Tagset chainKey \"SessionReplyTags\" tagsetKey NSR ee DH chainKey, ee_shared \"\" chainKey NSR se DH chainKey, se_shared \"\" chainKey, k NSR Split chainKey \"\" k_ab, k_ba NSR Payload k_ba \"AttachPayloadKDF\" k_nsr DH Initialize rootKey, k \"KDFDHRatchetStep\" nextRootKey, chainKey Tag and Key Chain Keys chainKey \"TagAndKeyGenKeys\" sessTag_ck, symmKey_ck Session Tag Init sessTag_ck \"STInitialization\" chainKey, CONSTANT Session Tag Gen chainKey, CONSTANT \"SessionTagKeyGen\" chainKey, tag Symmetric Key Gen chainKey \"SymmetricRatchet\" chainKey, key DH Ratchet sharedSecret \"XDHRatchetTagSet\" tagsetKey Appendix B: Message Size Calculator Calculate message sizes for capacity planning:\ndef calculate_ns_size(payload_size, bound=True): \u0026#34;\u0026#34;\u0026#34;Calculate New Session message size\u0026#34;\u0026#34;\u0026#34; ephemeral_key = 32 static_section = 32 + 16 # encrypted + MAC payload_encrypted = payload_size + 16 # + MAC return ephemeral_key + static_section + payload_encrypted def calculate_nsr_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate New Session Reply message size\u0026#34;\u0026#34;\u0026#34; tag = 8 ephemeral_key = 32 key_section_mac = 16 payload_encrypted = payload_size + 16 # + MAC return tag + ephemeral_key + key_section_mac + payload_encrypted def calculate_es_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate Existing Session message size\u0026#34;\u0026#34;\u0026#34; tag = 8 payload_encrypted = payload_size + 16 # + MAC return tag + payload_encrypted # Examples print(\u0026#34;NS (bound, 1KB payload):\u0026#34;, calculate_ns_size(1024, bound=True), \u0026#34;bytes\u0026#34;) # Output: 1120 bytes print(\u0026#34;NSR (1KB payload):\u0026#34;, calculate_nsr_size(1024), \u0026#34;bytes\u0026#34;) # Output: 1096 bytes print(\u0026#34;ES (1KB payload):\u0026#34;, calculate_es_size(1024), \u0026#34;bytes\u0026#34;) # Output: 1048 bytes Appendix C: Glossary AEAD: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity\nAuthentication Level: Noise protocol security property indicating strength of sender identity verification\nBinding: Association of a session with a specific far-end destination\nChaCha20: Stream cipher designed by Daniel J. Bernstein\nChainKey: Cryptographic key used in HKDF chains to derive subsequent keys\nConfidentiality Level: Noise protocol security property indicating strength of forward secrecy\nDH: Diffie-Hellman key agreement protocol\nElligator2: Encoding technique to make elliptic curve points indistinguishable from random\nEphemeral Key: Short-lived key used only for a single handshake\nES: Existing Session message (used after handshake completion)\nForward Secrecy: Property ensuring past communications remain secure if keys are compromised\nGarlic Clove: I2NP message container for end-to-end delivery\nHKDF: HMAC-based Key Derivation Function\nIK Pattern: Noise handshake pattern where initiator sends static key immediately\nKCI: Key Compromise Impersonation attack\nKDF: Key Derivation Function - cryptographic function for generating keys from other keys\nLeaseSet: I2P structure containing a destination\u0026rsquo;s public keys and tunnel information\nLS2: LeaseSet version 2 with encryption type support\nMAC: Message Authentication Code - cryptographic checksum proving authenticity\nMixHash: Noise protocol function for maintaining running hash transcript\nNS: New Session message (initiates new session)\nNSR: New Session Reply message (response to NS)\nNonce: Number used once - ensures unique encryption even with same key\nPairing: Linking an inbound session with an outbound session for bidirectional communication\nPoly1305: Message authentication code designed by Daniel J. Bernstein\nRatchet: Cryptographic mechanism for deriving sequential keys\nSession Tag: 8-byte one-time identifier for existing session messages\nStatic Key: Long-term key associated with a destination\u0026rsquo;s identity\nTag Set: Collection of session tags derived from a common root\nX25519: Elliptic curve Diffie-Hellman key agreement using Curve25519\n","description":"Elliptic Curve Integrated Encryption Scheme for I2P (X25519 + AEAD)","id":"82b727dd29ed7e2e04873dac8c2acf51","section":"docs","title":"ECIES-X25519-AEAD-Ratchet Encryption Specification","url":"/en/docs/specs/ecies/"},{"categories":null,"content":"Implementation Status Current Deployment:\ni2pd (C++ implementation): Fully implemented in version 2.58.0 (September 2025) with ML-KEM-512, ML-KEM-768, and ML-KEM-1024 support. Post-quantum end-to-end encryption enabled by default when OpenSSL 3.5.0 or later is available. Java I2P: Not yet implemented as of version 0.9.67 / 2.10.0 (September 2025). Specification approved and implementation planned for future releases. This specification describes approved functionality that is currently deployed in i2pd and planned for Java I2P implementations.\nOverview This is the post-quantum hybrid variant of the ECIES-X25519-AEAD-Ratchet protocol ECIES. It represents the first phase of Proposal 169 Prop169 to be approved. See that proposal for overall goals, threat models, analysis, alternatives, and additional information.\nProposal 169 status: Open (first phase approved for hybrid ECIES implementation).\nThis specification contains only the differences from standard ECIES and must be read in conjunction with that specification.\nDesign We use the NIST FIPS 203 standard FIPS203 which is based on, but not compatible with, CRYSTALS-Kyber (versions 3.1, 3, and older).\nHybrid handshakes combine classical X25519 Diffie-Hellman with post-quantum ML-KEM key encapsulation mechanisms. This approach is based on hybrid forward secrecy concepts documented in PQNoise research and similar implementations in TLS 1.3, IKEv2, and WireGuard.\nKey Exchange We define a hybrid key exchange for Ratchet. Post-quantum KEM provides ephemeral keys only and does not directly support static-key handshakes such as Noise IK.\nWe define the three ML-KEM variants as specified in FIPS203, for 3 new encryption types total. Hybrid types are only defined in combination with X25519.\nThe new encryption types are:\nType Code Security Level ML-KEM Variant MLKEM512_X25519 5 NIST Category 1 (AES-128 equivalent) ML-KEM-512 MLKEM768_X25519 6 NIST Category 3 (AES-192 equivalent) ML-KEM-768 (Recommended) MLKEM1024_X25519 7 NIST Category 5 (AES-256 equivalent) ML-KEM-1024 Note: MLKEM768_X25519 (Type 6) is the recommended default variant, providing strong post-quantum security with reasonable overhead.\nOverhead is substantial compared to X25519-only encryption. Typical message 1 and 2 sizes (for IK pattern) are currently around 96-103 bytes (before additional payload). This will increase by approximately 9-12x for MLKEM512, 13-16x for MLKEM768, and 17-23x for MLKEM1024, depending on message type.\nNew Crypto Required ML-KEM (formerly CRYSTALS-Kyber) FIPS203 - Module-Lattice-Based Key-Encapsulation Mechanism Standard SHA3-256 (formerly Keccak-512) FIPS202 - Part of SHA-3 Standard SHAKE128 and SHAKE256 (XOF extensions to SHA3) FIPS202 - Extendable-Output Functions Test vectors for SHA3-256, SHAKE128, and SHAKE256 are available in the NIST Cryptographic Algorithm Validation Program.\nLibrary Support:\nJava: Bouncycastle library version 1.79 and later supports all ML-KEM variants and SHA3/SHAKE functions C++: OpenSSL 3.5 and later includes full ML-KEM support (released April 2025) Go: Multiple libraries available for ML-KEM and SHA3 implementation Specification Common Structures See the Common Structures Specification for key lengths and identifiers.\nHandshake Patterns Handshakes use Noise Protocol Framework handshake patterns with I2P-specific adaptations for hybrid post-quantum security.\nThe following letter mapping is used:\ne = one-time ephemeral key (X25519) s = static key p = message payload e1 = one-time ephemeral PQ key, sent from Alice to Bob (I2P-specific token) ekem1 = the KEM ciphertext, sent from Bob to Alice (I2P-specific token) Important Note: The pattern names \u0026ldquo;IKhfs\u0026rdquo; and \u0026ldquo;IKhfselg2\u0026rdquo; and the tokens \u0026ldquo;e1\u0026rdquo; and \u0026ldquo;ekem1\u0026rdquo; are I2P-specific adaptations not documented in the official Noise Protocol Framework specification. These represent custom definitions for integrating ML-KEM into the Noise IK pattern. While the hybrid X25519 + ML-KEM approach is widely recognized in post-quantum cryptography research and other protocols, the specific nomenclature used here is I2P-specific.\nThe following modifications to IK for hybrid forward secrecy are applied:\nStandard IK: I2P IKhfs (Hybrid): \u0026lt;- s \u0026lt;- s ... ... -\u0026gt; e, es, s, ss, p -\u0026gt; e, es, e1, s, ss, p \u0026lt;- e, ee, se, p \u0026lt;- e, ee, ekem1, se, p \u0026lt;- p \u0026lt;- p p -\u0026gt; p -\u0026gt; Note: e1 and ekem1 are encrypted within ChaCha20-Poly1305 AEAD blocks. Note: e1 (ML-KEM public key) and ekem1 (ML-KEM ciphertext) have different sizes. The e1 pattern is defined as follows:\nFor Alice (sender): (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) ciphertext = ENCRYPT(k, n, encap_key, ad) n++ MixHash(ciphertext) For Bob (receiver): // DecryptAndHash(ciphertext) encap_key = DECRYPT(k, n, ciphertext, ad) n++ MixHash(ciphertext) The ekem1 pattern is defined as follows:\nFor Bob (receiver of encap_key): (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) MixHash(ciphertext) // MixKey MixKey(kem_shared_key) For Alice (sender of encap_key): // DecryptAndHash(ciphertext) kem_ciphertext = DECRYPT(k, n, ciphertext, ad) MixHash(ciphertext) // MixKey kem_shared_key = DECAPS(kem_ciphertext, decap_key) MixKey(kem_shared_key) Defined ML-KEM Operations We define the following functions corresponding to the cryptographic building blocks as specified in FIPS203.\n(encap_key, decap_key) = PQ_KEYGEN() Alice creates the encapsulation and decapsulation keys. The encapsulation key is sent in the NS message. Key sizes: ML-KEM-512: encap_key = 800 bytes, decap_key = 1632 bytes ML-KEM-768: encap_key = 1184 bytes, decap_key = 2400 bytes ML-KEM-1024: encap_key = 1568 bytes, decap_key = 3168 bytes (ciphertext, kem_shared_key) = ENCAPS(encap_key) Bob calculates the ciphertext and shared key using the encapsulation key received in the NS message. The ciphertext is sent in the NSR message. Ciphertext sizes: ML-KEM-512: 768 bytes ML-KEM-768: 1088 bytes ML-KEM-1024: 1568 bytes The kem_shared_key is always 32 bytes for all three variants.\nkem_shared_key = DECAPS(ciphertext, decap_key) Alice calculates the shared key using the ciphertext received in the NSR message. The kem_shared_key is always 32 bytes. Important: Both the encap_key and the ciphertext are encrypted inside ChaCha20-Poly1305 blocks in the Noise handshake messages 1 and 2. They will be decrypted as part of the handshake process.\nThe kem_shared_key is mixed into the chaining key with MixKey(). See below for details.\nNoise Handshake KDF Overview The hybrid handshake combines classical X25519 ECDH with post-quantum ML-KEM. The first message, from Alice to Bob, contains e1 (the ML-KEM encapsulation key) before the message payload. This is treated as additional key material; call EncryptAndHash() on it (as Alice) or DecryptAndHash() (as Bob). Then process the message payload as usual.\nThe second message, from Bob to Alice, contains ekem1 (the ML-KEM ciphertext) before the message payload. This is treated as additional key material; call EncryptAndHash() on it (as Bob) or DecryptAndHash() (as Alice). Then calculate the kem_shared_key and call MixKey(kem_shared_key). Then process the message payload as usual.\nNoise Identifiers These are the Noise initialization strings (I2P-specific):\nNoise_IKhfselg2_25519+MLKEM512_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM768_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM1024_ChaChaPoly_SHA256 Alice KDF for NS Message After the \u0026rsquo;es\u0026rsquo; message pattern and before the \u0026rsquo;s\u0026rsquo; message pattern, add:\nThis is the \u0026#34;e1\u0026#34; message pattern: (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, encap_key, ad) n++ // MixHash(ciphertext) h = SHA256(h || ciphertext) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). Bob KDF for NS Message After the \u0026rsquo;es\u0026rsquo; message pattern and before the \u0026rsquo;s\u0026rsquo; message pattern, add:\nThis is the \u0026#34;e1\u0026#34; message pattern: // DecryptAndHash(encap_key_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h encap_key = DECRYPT(k, n, encap_key_section, ad) n++ // MixHash(encap_key_section) h = SHA256(h || encap_key_section) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). Bob KDF for NSR Message After the \u0026rsquo;ee\u0026rsquo; message pattern and before the \u0026lsquo;se\u0026rsquo; message pattern, add:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) // MixHash(ciphertext) h = SHA256(h || ciphertext) // MixKey(kem_shared_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. Alice KDF for NSR Message After the \u0026rsquo;ee\u0026rsquo; message pattern and before the \u0026lsquo;ss\u0026rsquo; message pattern, add:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: // DecryptAndHash(kem_ciphertext_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h kem_ciphertext = DECRYPT(k, n, kem_ciphertext_section, ad) // MixHash(kem_ciphertext_section) h = SHA256(h || kem_ciphertext_section) // MixKey(kem_shared_key) kem_shared_key = DECAPS(kem_ciphertext, decap_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. KDF for split() The split() function remains unchanged from the standard ECIES specification. After handshake completion:\nkeydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] k_ba = keydata[32:63] These are the bidirectional session keys for ongoing communication.\nMessage Format NS (New Session) Format Changes: Current ratchet contains the static key in the first ChaCha20-Poly1305 section and the payload in the second section. With ML-KEM, there are now three sections. The first section contains the encrypted ML-KEM public key (encap_key). The second section contains the static key. The third section contains the payload.\nMessage Sizes:\nType Type Code X25519 len NS len NS Enc len NS Dec len PQ key len pl len X25519 4 32 96+pl 64+pl pl -- pl MLKEM512_X25519 5 32 912+pl 880+pl 800+pl 800 pl MLKEM768_X25519 6 32 1296+pl 1264+pl 1184+pl 1184 pl MLKEM1024_X25519 7 32 1680+pl 1648+pl 1568+pl 1568 pl Note: The payload must contain a DateTime block (minimum 7 bytes: 1-byte type, 2-byte size, 4-byte timestamp). The minimum NS sizes may be calculated accordingly. Minimum practical NS size is therefore 103 bytes for X25519 and ranges from 919 to 1687 bytes for hybrid variants.\nThe size increases of 816, 1200, and 1584 bytes for the three ML-KEM variants account for the ML-KEM public key plus a 16-byte Poly1305 MAC for authenticated encryption.\nNSR (New Session Reply) Format Changes: Current ratchet has an empty payload for the first ChaCha20-Poly1305 section and the payload in the second section. With ML-KEM, there are now three sections. The first section contains the encrypted ML-KEM ciphertext. The second section has an empty payload. The third section contains the payload.\nMessage Sizes:\nType Type Code X25519 len NSR len NSR Enc len NSR Dec len PQ ct len pl len X25519 4 32 72+pl 40+pl pl -- pl MLKEM512_X25519 5 32 856+pl 824+pl 784+pl 768 pl MLKEM768_X25519 6 32 1176+pl 1144+pl 1104+pl 1088 pl MLKEM1024_X25519 7 32 1656+pl 1624+pl 1584+pl 1568 pl The size increases of 784, 1104, and 1584 bytes for the three ML-KEM variants account for the ML-KEM ciphertext plus a 16-byte Poly1305 MAC for authenticated encryption.\nOverhead Analysis Key Exchange The overhead for hybrid encryption is substantial compared to X25519-only:\nMLKEM512_X25519: Approximately 9-12x increase in handshake message size (NS: 9.5x, NSR: 11.9x) MLKEM768_X25519: Approximately 13-16x increase in handshake message size (NS: 13.5x, NSR: 16.3x) MLKEM1024_X25519: Approximately 17-23x increase in handshake message size (NS: 17.5x, NSR: 23x) This overhead is acceptable for the added post-quantum security benefits. The multipliers vary by message type because base message sizes differ (NS minimum 96 bytes, NSR minimum 72 bytes).\nBandwidth Considerations For a typical session establishment with minimal payloads:\nX25519 only: ~200 bytes total (NS + NSR) MLKEM512_X25519: ~1,800 bytes total (9x increase) MLKEM768_X25519: ~2,500 bytes total (12.5x increase) MLKEM1024_X25519: ~3,400 bytes total (17x increase) After session establishment, ongoing message encryption uses the same data transport format as X25519-only sessions, so there is no overhead for subsequent messages.\nSecurity Analysis Handshakes The hybrid handshake provides both classical (X25519) and post-quantum (ML-KEM) security. An attacker must break both the classical ECDH and the post-quantum KEM to compromise the session keys.\nThis provides:\nCurrent security: X25519 ECDH provides security against classical attackers (128-bit security level) Future security: ML-KEM provides security against quantum attackers (varies by parameter set) Hybrid security: Both must be broken to compromise the session (security level = max of both components) Security Levels Variant NIST Category Classical Security PQ Security Hybrid Security MLKEM512_X25519 Category 1 128-bit (X25519) AES-128 equivalent 128-bit MLKEM768_X25519 Category 3 128-bit (X25519) AES-192 equivalent 128-bit MLKEM1024_X25519 Category 5 128-bit (X25519) AES-256 equivalent 128-bit Note: The hybrid security level is bounded by the weaker of the two components. In all cases, X25519 provides 128-bit classical security. If a cryptographically relevant quantum computer becomes available, the security level would depend on the ML-KEM parameter set chosen.\nForward Secrecy The hybrid approach maintains forward secrecy properties. Session keys are derived from both ephemeral X25519 and ephemeral ML-KEM key exchanges. If either the X25519 or ML-KEM ephemeral private keys are destroyed after the handshake, past sessions cannot be decrypted even if long-term static keys are compromised.\nThe IK pattern provides full forward secrecy (Noise Confidentiality level 5) after the second message (NSR) is sent.\nType Preferences Implementations should support multiple hybrid types and negotiate the strongest mutually-supported variant. The preference order should be:\nMLKEM768_X25519 (Type 6) - Recommended default, best balance of security and performance MLKEM1024_X25519 (Type 7) - Highest security for sensitive applications MLKEM512_X25519 (Type 5) - Baseline post-quantum security for resource-constrained scenarios X25519 (Type 4) - Classical only, fallback for compatibility Rationale: MLKEM768_X25519 is recommended as the default because it provides NIST Category 3 security (AES-192 equivalent), which is considered sufficient protection against quantum computers while maintaining reasonable message sizes. MLKEM1024_X25519 provides higher security but at substantially increased overhead.\nImplementation Notes Library Support Java: Bouncycastle library version 1.79 (August 2024) and later supports all required ML-KEM variants and SHA3/SHAKE functions. Use org.bouncycastle.pqc.crypto.mlkem.MLKEMEngine for FIPS 203 compliance. C++: OpenSSL 3.5 (April 2025) and later includes ML-KEM support via EVP_KEM interface. This is a Long Term Support release maintained until April 2030. Go: Several third-party libraries available for ML-KEM and SHA3, including Cloudflare\u0026rsquo;s CIRCL library. Migration Strategy Implementations should:\nSupport both X25519-only and hybrid ML-KEM variants during transition period Prefer hybrid variants when both peers support them Maintain fallback to X25519-only for backward compatibility Consider network bandwidth constraints when selecting default variant Shared Tunnels The increased message sizes may impact shared tunnel usage. Implementations should consider:\nBatching handshakes when possible to amortize overhead Using shorter expiration times for hybrid sessions to reduce stored state Monitoring bandwidth usage and adjusting parameters accordingly Implementing congestion control for session establishment traffic New Session Size Considerations Due to the larger handshake messages, implementations may need to:\nIncrease buffer sizes for session negotiation (minimum 4KB recommended) Adjust timeout values for slower connections (account for ~3-17x larger messages) Consider compression for payload data in NS/NSR messages Implement fragmentation handling if required by transport layer Testing and Validation Implementations should verify:\nCorrect ML-KEM key generation, encapsulation, and decapsulation Proper integration of kem_shared_key into Noise KDF Message size calculations match specification Interoperability with other I2P router implementations Fallback behavior when ML-KEM not available Test vectors for ML-KEM operations are available in the NIST Cryptographic Algorithm Validation Program.\nVersion Compatibility I2P Version Numbering: I2P maintains two parallel version numbers:\nRouter release version: 2.x.x format (e.g., 2.10.0 released September 2025) API/protocol version: 0.9.x format (e.g., 0.9.67 corresponds to router 2.10.0) This specification references protocol version 0.9.67, which corresponds to router release 2.10.0 and later.\nCompatibility Matrix:\nImplementation Version ML-KEM Support Status i2pd 2.58.0+ Full (512/768/1024) Deployed September 2025 Java I2P 0.9.67 / 2.10.0 Not yet Planned for future release References [ECIES]: ECIES-X25519-AEAD-Ratchet specification [Prop169]: I2P Post-Quantum Cryptography Proposal [FIPS203]: NIST FIPS 203 - Module-Lattice-Based Key-Encapsulation Mechanism Standard [FIPS202]: NIST FIPS 202 - SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions [Noise]: The Noise Protocol Framework [COMMON]: I2P Common Structures Specification [RFC7539]: ChaCha20 and Poly1305 for IETF Protocols [RFC5869]: HMAC-based Extract-and-Expand Key Derivation Function (HKDF) [OpenSSL]: OpenSSL 3.5 ML-KEM Documentation [Bouncycastle]: Bouncycastle Java Cryptography Library ","description":"Post-quantum hybrid variant of the ECIES encryption protocol using ML-KEM","id":"f6a66a37875c5b108bc5a8ea027dc0e2","section":"docs","title":"ECIES-X25519-AEAD-Ratchet Hybrid Encryption","url":"/en/docs/specs/ecies-x25519-aead-ratchet-hybrid-encryption/"},{"categories":null,"content":" Status: This document describes the legacy ElGamal/AES+SessionTag encryption protocol. It remains supported only for backward compatibility, as modern I2P versions (2.10.0+) use ECIES‑X25519‑AEAD‑Ratchet. The ElGamal protocol is deprecated and retained solely for historical and interoperability purposes.\nOverview ElGamal/AES+SessionTag provided I2P’s original end‑to‑end encryption mechanism for garlic messages. It combined:\nElGamal (2048‑bit) — for key exchange AES‑256/CBC — for payload encryption SHA‑256 — for hashing and IV derivation Session Tags (32 bytes) — for single‑use message identifiers The protocol allowed routers and destinations to communicate securely without maintaining persistent connections. Each session used an asymmetric ElGamal exchange to establish a symmetric AES key, followed by lightweight “tagged” messages referencing that session.\nProtocol Operation Session Establishment (New Session) A new session began with a message containing two sections:\nSection Size Contents Purpose ElGamal‑encrypted block 514 bytes 222 bytes of plaintext encrypted using the recipient’s ElGamal public key Establishes the AES session key and IV seed AES‑encrypted block Variable (≥ 128 bytes typical) Payload data, integrity hash, and session tags Carries the actual message and new tags The plaintext inside the ElGamal block consisted of:\nField Size Description Session Key 32 bytes AES‑256 key for the session Pre‑IV 32 bytes Material for deriving the AES initialization vector (IV = first 16 bytes of SHA‑256(Pre‑IV)) Random Padding 158 bytes Filler to reach required ElGamal plaintext length Existing Session Messages Once a session was established, the sender could send existing‑session messages using cached session tags:\nField Size Description Session Tag 32 bytes Single‑use identifier tied to the existing session key AES‑Encrypted Block Variable Encrypted payload and metadata using the established AES key Routers cached delivered tags for about 15 minutes, after which unused tags expired. Each tag was valid for exactly one message to prevent correlation attacks.\nAES‑Encrypted Block Format Field Size Description Tag Count 2 bytes Number (0–200) of new session tags included Session Tags 32 × N bytes Newly generated single‑use tags Payload Size 4 bytes Length of the payload in bytes Payload Hash 32 bytes SHA‑256 digest of the payload Flag 1 byte 0x00 normal, 0x01 = new session key follows (unused) New Session Key 32 bytes (optional) Replacement AES key (rarely used) Payload Variable Encrypted message data Padding Variable (16‑byte aligned) Random padding to block boundary Routers decrypt using the session key and IV derived from either the Pre‑IV (for new sessions) or the session tag (for existing sessions). After decryption, they verify integrity by recomputing the SHA‑256 hash of the plaintext payload.\nSession Tag Management Tags are unidirectional: Alice → Bob tags cannot be reused by Bob → Alice. Tags expire after approximately 15 minutes. Routers maintain per‑destination session key managers to track tags, keys, and expiration times. Applications can control tag behavior through I2CP options: i2cp.tagThreshold — minimum cached tags before replenishment i2cp.tagCount — number of new tags per message This mechanism minimized expensive ElGamal handshakes while maintaining unlinkability between messages.\nConfiguration and Efficiency Session tags were introduced to improve efficiency across I2P’s high‑latency, unordered transport. A typical configuration delivered 40 tags per message, adding about 1.2 KB of overhead. Applications could adjust delivery behavior based on expected traffic:\nUse Case Recommended Tags Notes Short‑lived requests (HTTP, datagrams) 0 – 5 Low overhead, may trigger ElGamal fallback Persistent streams or bulk transfer 20 – 50 Higher bandwidth use, avoids session re‑establishment Long‑term services 50 + Ensures steady tag supply despite loss or delay Routers periodically purge expired tags and prune unused session state to reduce memory usage and mitigate tag‑flooding attacks.\nLimitations Category Limitation Performance 514‑byte ElGamal block adds heavy overhead for new sessions; session tags consume 32 bytes each. Security No forward secrecy – compromise of ElGamal private key exposes past sessions. Integrity AES‑CBC requires manual hash verification; no AEAD. Quantum Resistance Vulnerable to Shor’s algorithm – will not survive quantum attacks. Complexity Requires stateful tag management and careful timeout tuning. These shortcomings directly motivated the design of the ECIES‑X25519‑AEAD‑Ratchet protocol, which provides perfect forward secrecy, authenticated encryption, and efficient key exchange.\nDeprecation and Migration Status Introduced: Early I2P releases (pre‑0.6) Deprecated: With introduction of ECIES‑X25519 (0.9.46 → 0.9.48) Removed: No longer default as of 2.4.0 (December 2023) Supported: Legacy compatibility only Modern routers and destinations now advertise crypto type 4 (ECIES‑X25519) instead of type 0 (ElGamal/AES). The legacy protocol remains recognized for interoperability with outdated peers but should not be used for new deployments.\nHistorical Context ElGamal/AES+SessionTag was foundational to I2P’s early cryptographic architecture. Its hybrid design introduced innovations such as one‑time session tags and unidirectional sessions that informed subsequent protocols. Many of these ideas evolved into modern constructions like deterministic ratchets and hybrid post‑quantum key exchanges.\n","description":"Legacy end-to-end encryption combining ElGamal, AES, SHA-256, and one-time session tags","id":"092d77bf065d0f13bb2b2a470f57a902","section":"docs","title":"ElGamal/AES + SessionTag Encryption","url":"/en/docs/legacy/elgamal-aes/"},{"categories":null,"content":"Bundling I2P with your application is a powerful way to onboard users—but only if the router is configured responsibly.\n1. Coordinate with Router Teams Contact the Java I2P and i2pd maintainers before bundling. They can review your defaults and highlight compatibility concerns. Choose the router implementation that fits your stack: Java/Scala → Java I2P C/C++ → i2pd Other languages → bundle a router and integrate using SAM v3 or I2CP Verify redistribution terms for router binaries and dependencies (Java runtime, ICU, etc.). 2. Recommended Configuration Defaults Aim for “contribute more than you consume.” Modern defaults prioritize network health and stability.\nSetting Recommended Default (2025) Bandwidth share 80% for participating tunnels Tunnel quantities i2pd: 3 inbound / 3 outbound; Java I2P: 2 inbound / 2 outbound. Signature \u0026amp; encryption Use Ed25519 (SIGNATURE_TYPE=7) and advertise ECIES-X25519 + ElGamal (i2cp.leaseSetEncType=4,0). Client protocols Use SAM v3 or I2CP. API listeners Bind SAM/I2CP to 127.0.0.1 only. Disable if not needed. UI toggles Expose bandwidth controls, logs, and an opt-in checkbox for participating tunnels. Participating Tunnels Remain Essential Do not disable participating tunnels.\nRouters that don’t relay perform worse themselves. The network depends on voluntary capacity sharing. Cover traffic (relayed traffic) improves anonymity. Official minimums:\nShared bandwidth: ≥ 12 KB/s Floodfill auto-opt-in: ≥ 128 KB/s Recommended: 2 inbound / 2 outbound tunnels (Java I2P default) 3. Persistence and Reseeding Persistent state directories (netDb/, profiles, certificates) must be preserved between runs.\nWithout persistence, your users will trigger reseeds at every startup—degrading performance and increasing load on reseed servers.\nIf persistence is impossible (e.g., containers or ephemeral installs):\nBundle 1,000–2,000 router infos in the installer. Operate one or more custom reseed servers to offload public ones. Configuration variables:\nBase directory: i2p.dir.base Config directory: i2p.dir.config Include certificates/ for reseeding. 4. Security and Exposure Keep router console (127.0.0.1:7657) local-only. Use HTTPS if exposing UI externally. Disable external SAM/I2CP unless required. Review included plugins—ship only what your app supports. Always include authentication for remote console access. Security features introduced since 2.5.0:\nNetDB isolation between applications (2.4.0+) DoS mitigation and Tor blocklists (2.5.1) NTCP2 probing resistance (2.9.0) Floodfill router selection improvements (2.6.0+) 5. Supported APIs (2025) API Status Notes SAM v3 (3.3) ✅ Active Recommended bridge for non-Java apps. I2CP ✅ Active Stable protocol core, used internally by Java I2P. I2PControl ✅ Active JSON-RPC API; plugin maintained. BOB ⚠️ Deprecated Removed from Java I2P since 1.7.0; use SAM v3 instead. All official docs are located under /en/docs/api/ — the old /spec/samv3/ path does not exist.\n6. Networking and Ports Typical default ports:\n4444 – HTTP Proxy 4445 – HTTPS Proxy 7654 – I2CP 7656 – SAM Bridge 7657 – Router Console 7658 – Local I2P site 6668 – IRC Proxy 9000–31000 – Random router port (UDP/TCP inbound) Routers select a random inbound port on first run. Forwarding improves performance, but UPnP may handle this automatically.\n7. Modern Changes (2024–2025) Change Status Details SSU1 Transport Removed SSU2 is now the exclusive UDP transport. I2P-over-Tor Blocked Since 2.6.0 (July 2024). Datagram2/3 Added Authenticated, repliable datagram formats (2.9.0). LeaseSet service records Added Enables service discovery (Proposal 167). Tunnel build parameters Improved Adaptive congestion handling (2.9.0+). Post-quantum crypto Introduced (beta) ML-KEM hybrid ratchet, opt-in from 2.10.0. Java 17 requirement Announced Becomes mandatory in 2.11.0 (early 2026). 8. User Experience and Testing Communicate what I2P does and why bandwidth is shared. Provide router diagnostics (bandwidth, tunnels, reseed status). Test bundles on Windows, macOS, and Linux (low-RAM included). Verify interop with both Java I2P and i2pd peers. Test recovery from network drops and ungraceful exits. 9. Community Resources Forum: i2pforum.net or http://i2pforum.i2p inside I2P. Code: i2pgit.org/I2P_Developers/i2p.i2p. IRC (Irc2P network): #i2p-dev, #i2pd. #i2papps unverified; may not exist. Clarify which network (Irc2P vs ilita.i2p) hosts your channel. Embedding responsibly means balancing user experience, performance, and network contribution. Use these defaults, stay in sync with router maintainers, and test under real-world load before release.\n","description":"Updated practical guidance for bundling an I2P router with your app responsibly","id":"f67f27efbc9bb7bff8d34001c14105ff","section":"docs","title":"Embedding I2P in Your Application","url":"/en/docs/applications/embedding/"},{"categories":null,"content":"Overview This document specifies the blinding, encryption, and decryption of encrypted LeaseSet2 (LS2). Encrypted LeaseSets provide access-controlled publication of hidden service information in the I2P network database.\nKey Features:\nDaily key rotation for forward secrecy Two-tier client authorization (DH-based and PSK-based) ChaCha20 encryption for performance on devices without AES hardware Red25519 signatures with key blinding Privacy-preserving client membership Related Documentation:\nCommon Structures Specification - Encrypted LeaseSet structure Proposal 123: New netDB Entries - Background on encrypted LeaseSets Network Database Documentation - NetDB usage Version History and Implementation Status Protocol Development Timeline Important Note on Version Numbering:\nI2P uses two separate version numbering schemes:\nAPI/Router Version: 0.9.x series (used in technical specifications) Product Release Version: 2.x.x series (used for public releases) Technical specifications reference API versions (e.g., 0.9.41), while end users see product versions (e.g., 2.10.0).\nImplementation Milestones Version Release Date Features 0.9.38January 2019Floodfill support for standard LS2, offline keys 0.9.39March 2019Full encrypted LS2 support, Red25519 (sig type\u0026nbsp;11) 0.9.40May 2019Per-client authorization, encrypted LS2 with offline keys, B32 support 0.9.41June 2019Protocol finalized as stable 2.10.0September 2025Latest Java implementation (API version 0.9.61) i2pd 2.58.0September 2025Full C++ implementation compatibility Current Status ✅ Protocol Status: Stable and unchanged since June 2019 ✅ Java I2P: Fully implemented in version 0.9.40+ ✅ i2pd (C++): Fully implemented in version 2.58.0+ ✅ Interoperability: Complete between implementations ✅ Network Deployment: Production-ready with 6+ years of operational experience Cryptographic Definitions Notation and Conventions || denotes concatenation mod L denotes modular reduction by the Ed25519 order All byte arrays are in network byte order (big-endian) unless otherwise specified Little-endian values are explicitly noted CSRNG(n) Cryptographically Secure Random Number Generator\nProduces n bytes of cryptographically secure random data suitable for key material generation.\nSecurity Requirements:\nMust be cryptographically secure (suitable for key generation) Must be safe when adjacent byte sequences are exposed on the network Implementations should hash output from potentially untrustworthy sources References:\nPRNG Security Considerations Tor Dev Discussion H(p, d) SHA-256 Hash with Personalization\nDomain-separated hash function that takes:\np: Personalization string (provides domain separation) d: Data to hash Implementation:\nH(p, d) := SHA-256(p || d) Usage: Provides cryptographic domain separation to prevent collision attacks between different protocol uses of SHA-256.\nSTREAM: ChaCha20 Stream Cipher: ChaCha20 as specified in RFC 7539 Section 2.4\nParameters:\nS_KEY_LEN = 32 (256-bit key) S_IV_LEN = 12 (96-bit nonce) Initial counter: 1 (RFC 7539 permits 0 or 1; 1 recommended for AEAD contexts) ENCRYPT(k, iv, plaintext)\nEncrypts plaintext using:\nk: 32-byte cipher key iv: 12-byte nonce (MUST be unique for each key) Returns ciphertext same size as plaintext Security Property: Entire ciphertext must be indistinguishable from random if key is secret.\nDECRYPT(k, iv, ciphertext)\nDecrypts ciphertext using:\nk: 32-byte cipher key iv: 12-byte nonce Returns plaintext Design Rationale: ChaCha20 selected over AES because:\n2.5-3x faster than AES on devices without hardware acceleration Constant-time implementation easier to achieve Comparable security and speed when AES-NI available References:\nRFC 7539 - ChaCha20 and Poly1305 for IETF Protocols SIG: Red25519 Signature Scheme: Red25519 (SigType 11) with Key Blinding\nRed25519 is based on Ed25519 signatures over the Ed25519 curve, using SHA-512 for hashing, with support for key blinding as specified in ZCash RedDSA.\nFunctions:\nDERIVE_PUBLIC(privkey) Returns the public key corresponding to the given private key.\nUses standard Ed25519 scalar multiplication by base point SIGN(privkey, m) Returns a signature by the private key privkey over message m.\nRed25519 Signing Differences from Ed25519:\nRandom Nonce: Uses 80 bytes of additional random data\nT = CSRNG(80) // 80 random bytes r = H*(T || publickey || message) This makes every Red25519 signature unique, even for the same message and key.\nPrivate Key Generation: Red25519 private keys are generated from random numbers and reduced mod L, rather than using Ed25519\u0026rsquo;s bit-clamping approach.\nVERIFY(pubkey, m, sig) Verifies signature sig against public key pubkey and message m.\nReturns true if signature is valid, false otherwise Verification is identical to Ed25519 Key Blinding Operations:\nGENERATE_ALPHA(data, secret) Generates alpha for key blinding.\ndata: Typically contains the signing public key and signature types secret: Optional additional secret (zero-length if not used) Result is identically distributed as Ed25519 private keys (after mod L reduction) BLIND_PRIVKEY(privkey, alpha) Blinds a private key using secret alpha.\nImplementation: blinded_privkey = (privkey + alpha) mod L Uses scalar arithmetic in the field BLIND_PUBKEY(pubkey, alpha) Blinds a public key using secret alpha.\nImplementation: blinded_pubkey = pubkey + DERIVE_PUBLIC(alpha) Uses group element (point) addition on the curve Critical Property:\nBLIND_PUBKEY(pubkey, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha)) Security Considerations:\nFrom ZCash Protocol Specification Section 5.4.6.1: For security, alpha must be identically distributed as the unblinded private keys. This ensures \u0026ldquo;the combination of a re-randomized public key and signature(s) under that key do not reveal the key from which it was re-randomized.\u0026rdquo;\nSupported Signature Types:\nType 7 (Ed25519): Supported for existing destinations (backward compatibility) Type 11 (Red25519): Recommended for new destinations using encryption Blinded keys: Always use type 11 (Red25519) References:\nZCash Protocol Specification - Section 5.4.6 RedDSA [I2P Red25519 Specification](/docs/specs/red25519-signature-scheme/ DH: X25519 Elliptic Curve Diffie-Hellman: X25519\nPublic key agreement system based on Curve25519.\nParameters:\nPrivate keys: 32 bytes Public keys: 32 bytes Shared secret output: 32 bytes Functions:\nGENERATE_PRIVATE() Generates a new 32-byte private key using CSRNG.\nDERIVE_PUBLIC(privkey) Derives the 32-byte public key from the given private key.\nUses scalar multiplication on Curve25519 DH(privkey, pubkey) Performs Diffie-Hellman key agreement.\nprivkey: Local 32-byte private key pubkey: Remote 32-byte public key Returns: 32-byte shared secret Security Properties:\nComputational Diffie-Hellman assumption on Curve25519 Forward secrecy when ephemeral keys are used Constant-time implementation required to prevent timing attacks References:\nRFC 7748 - Elliptic Curves for Security HKDF HMAC-based Key Derivation Function\nExtracts and expands key material from input keying material.\nParameters:\nsalt: 32 bytes maximum (typically 32 bytes for SHA-256) ikm: Input key material (any length, should have good entropy) info: Context-specific information (domain separation) n: Output length in bytes Implementation:\nUses HKDF as specified in RFC 5869 with:\nHash Function: SHA-256 HMAC: As specified in RFC 2104 Salt Length: Maximum 32 bytes (HashLen for SHA-256) Usage Pattern:\nkeys = HKDF(salt, ikm, info, n) Domain Separation: The info parameter provides cryptographic domain separation between different uses of HKDF in the protocol.\nVerified Info Values:\n\u0026quot;ELS2_L1K\u0026quot; - Layer 1 (outer) encryption \u0026quot;ELS2_L2K\u0026quot; - Layer 2 (inner) encryption \u0026quot;ELS2_XCA\u0026quot; - DH client authorization \u0026quot;ELS2PSKA\u0026quot; - PSK client authorization \u0026quot;i2pblinding1\u0026quot; - Alpha generation References:\nRFC 5869 - HKDF Specification RFC 2104 - HMAC Specification Format Specification Encrypted LS2 consists of three nested layers:\nLayer 0 (Outer): Plaintext information for storage and retrieval Layer 1 (Middle): Client authentication data (encrypted) Layer 2 (Inner): Actual LeaseSet2 data (encrypted) Overall Structure:\nLayer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature Important: Encrypted LS2 uses blinded keys. The Destination is not in the header. DHT storage location is SHA-256(sig type || blinded public key), rotated daily.\nLayer 0 (Outer) - Plaintext Layer 0 does NOT use the standard LS2 header. It has a custom format optimized for blinded keys.\nStructure:\nField Size Description Type1 byteNot in header, from DatabaseStore message field Blinded Public Key Sig Type2 bytesBig endian, always 0x000b (Red25519 type 11) Blinded Public Key32 bytesRed25519 blinded public key Published Timestamp4 bytesBig endian, seconds since epoch (rolls over in 2106) Expires2 bytesBig endian, offset from published in seconds (max 65,535 \u0026asymp; 18.2 hours) Flags2 bytesBit flags (see below) [Optional] Transient Key DataVariablePresent if flag bit\u0026nbsp;0 is set lenOuterCiphertext2 bytesBig endian, length of outer ciphertext outerCiphertextlenOuterCiphertextEncrypted Layer\u0026nbsp;1 data Signature64 bytesRed25519 signature over all preceding data Flags Field (2 bytes, bits 15-0):\nBit 0: Offline keys indicator 0 = No offline keys 1 = Offline keys present (transient key data follows) Bits 1-15: Reserved, must be 0 for future compatibility Transient Key Data (present if flag bit 0 = 1):\nField Size Description Expires Timestamp4 bytesBig endian, seconds since epoch Transient Sig Type2 bytesBig endian, signature type Transient Signing Public KeyVariableLength implied by signature type Signature64 bytesSigned by blinded public key; covers expires timestamp, transient sig type, and transient public key Signature Verification:\nWithout offline keys: Verify with blinded public key With offline keys: Verify with transient public key The signature covers all data from Type through outerCiphertext (inclusive).\nLayer 1 (Middle) - Client Authorization Decryption: See Layer 1 Encryption section.\nStructure:\nField Size Description Flags1 byteAuthorization flags (see below) [Optional] Auth DataVariablePresent based on flags innerCiphertextVariableEncrypted Layer\u0026nbsp;2 data (remainder) Flags Field (1 byte, bits 7-0):\nBit 0: Authorization mode 0 = No per-client authorization (everybody) 1 = Per-client authorization (auth section follows) Bits 3-1: Authentication scheme (only if bit 0 = 1) 000 = DH client authentication 001 = PSK client authentication Others reserved Bits 7-4: Unused, must be 0 DH Client Authorization Data (flags = 0x01, bits 3-1 = 000):\nField Size Description ephemeralPublicKey32 bytesServer's ephemeral X25519 public key clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries authClient Entry (40 bytes):\nclientID_i: 8 bytes clientCookie_i: 32 bytes (encrypted authCookie) PSK Client Authorization Data (flags = 0x03, bits 3-1 = 001):\nField Size Description authSalt32 bytesSalt for PSK key derivation clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries authClient Entry (40 bytes):\nclientID_i: 8 bytes clientCookie_i: 32 bytes (encrypted authCookie) Layer 2 (Inner) - LeaseSet Data Decryption: See Layer 2 Encryption section.\nStructure:\nField Size Description Type1 byte3 (LS2) or 7 (Meta LS2) DataVariableComplete LeaseSet2 or MetaLeaseSet2 The inner layer contains the full LeaseSet2 structure including:\nLS2 header Lease information LS2 signature Verification Requirements: After decryption, implementations must verify:\nInner timestamp matches outer published timestamp Inner expiration matches outer expiration LS2 signature is valid Lease data is well-formed References:\nCommon Structures Specification - LeaseSet2 format details Blinding Key Derivation Overview I2P uses an additive key blinding scheme based on Ed25519 and ZCash RedDSA. Blinded keys are rotated daily (UTC midnight) for forward secrecy.\nDesign Rationale:\nI2P explicitly chose NOT to use Tor\u0026rsquo;s rend-spec-v3.txt Appendix A.2 approach. According to the specification:\n\u0026ldquo;We do not use Tor\u0026rsquo;s rend-spec-v3.txt appendix A.2, which has similar design goals, because its blinded public keys may be off the prime-order subgroup, with unknown security implications.\u0026rdquo;\nI2P\u0026rsquo;s additive blinding guarantees that blinded keys remain on the prime-order subgroup of the Ed25519 curve.\nMathematical Definitions Ed25519 Parameters:\nB: Ed25519 base point (generator) = 2^255 - 19 L: Ed25519 order = 2^252 + 27742317777372353535851937790883648493 Key Variables:\nA: Unblinded 32-byte signing public key (in Destination) a: Unblinded 32-byte signing private key A': Blinded 32-byte signing public key (used in encrypted LeaseSet) a': Blinded 32-byte signing private key alpha: 32-byte blinding factor (secret) Helper Functions:\nLEOS2IP(x) \u0026ldquo;Little-Endian Octet String to Integer\u0026rdquo;\nConverts a byte array from little-endian to integer representation.\nH*(x) \u0026ldquo;Hash and Reduce\u0026rdquo;\nH*(x) = (LEOS2IP(SHA512(x))) mod L Same operation as in Ed25519 key generation.\nAlpha Generation Daily Rotation: A new alpha and blinded keys MUST be generated each day at UTC midnight (00:00:00 UTC).\nGENERATE_ALPHA(destination, date, secret) Algorithm:\n# Input parameters A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes, big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes, big endian) # Always 0x000b (Red25519) datestring = \u0026#34;YYYYMMDD\u0026#34; (8 bytes ASCII from current UTC date) secret = optional UTF-8 encoded string (zero-length if not used) # Computation keydata = A || stA || stA\u0026#39; # 36 bytes total seed = HKDF( salt=H(\u0026#34;I2PGenerateAlpha\u0026#34;, keydata), ikm=datestring || secret, info=\u0026#34;i2pblinding1\u0026#34;, n=64 ) # Treat seed as 64-byte little-endian integer and reduce alpha = seed mod L Parameters Verified:\nSalt personalization: \u0026quot;I2PGenerateAlpha\u0026quot; HKDF info: \u0026quot;i2pblinding1\u0026quot; Output: 64 bytes before reduction Alpha distribution: Identically distributed as Ed25519 private keys after mod L Private Key Blinding BLIND_PRIVKEY(a, alpha) Algorithm:\nFor the destination owner publishing the encrypted LeaseSet:\n# For Ed25519 private key (type 7) if sigtype == 7: seed = destination\u0026#39;s signing private key (32 bytes) a = left_half(SHA512(seed)) # 32 bytes a = clamp(a) # Ed25519 clamping # For Red25519 private key (type 11) elif sigtype == 11: a = destination\u0026#39;s signing private key (32 bytes) # No clamping for Red25519 # Additive blinding using scalar arithmetic blinded_privkey = a\u0026#39; = (a + alpha) mod L # Derive blinded public key blinded_pubkey = A\u0026#39; = DERIVE_PUBLIC(a\u0026#39;) Critical: The mod L reduction is essential for maintaining the correct algebraic relationship between private and public keys.\nPublic Key Blinding BLIND_PUBKEY(A, alpha) Algorithm:\nFor clients retrieving and verifying the encrypted LeaseSet:\nalpha = GENERATE_ALPHA(destination, date, secret) A = destination\u0026#39;s signing public key (32 bytes) # Additive blinding using group elements (curve points) blinded_pubkey = A\u0026#39; = A + DERIVE_PUBLIC(alpha) Mathematical Equivalence:\nBoth methods produce identical results:\nBLIND_PUBKEY(A, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(a, alpha)) This is because:\nA\u0026#39; = A + [alpha]B = [a]B + [alpha]B = [a + alpha]B (group operation) = DERIVE_PUBLIC(a + alpha mod L) Signing with Blinded Keys Unblinded LeaseSet Signing:\nThe unblinded LeaseSet (sent directly to authenticated clients) is signed using:\nStandard Ed25519 (type 7) or Red25519 (type 11) signature Unblinded signing private key Verified with unblinded public key With Offline Keys:\nSigned by unblinded transient private key Verified with unblinded transient public key Both must be type 7 or 11 Encrypted LeaseSet Signing:\nThe outer portion of encrypted LeaseSet uses Red25519 signatures with blinded keys.\nRed25519 Signing Algorithm:\n# Generate per-signature random nonce T = CSRNG(80) # 80 random bytes # Calculate r (differs from Ed25519) r = H*(T || blinded_pubkey || message) # Rest is same as Ed25519 R = [r]B S = (r + H(R || A\u0026#39; || message) * a\u0026#39;) mod L signature = R || S # 64 bytes total Key Differences from Ed25519:\nUses 80 bytes of random data T (not hash of private key) Uses public key value directly (not hash of private key) Every signature is unique even for same message and key Verification:\nSame as Ed25519:\n# Parse signature R = signature[0:32] S = signature[32:64] # Verify equation: [S]B = R + [H(R || A\u0026#39; || message)]A\u0026#39; return [S]B == R + [H(R || A\u0026#39; || message)]A\u0026#39; Security Considerations Alpha Distribution:\nFor security, alpha must be identically distributed as unblinded private keys. When blinding Ed25519 (type 7) to Red25519 (type 11), the distributions differ slightly.\nRecommendation: Use Red25519 (type 11) for both unblinded and blinded keys to meet ZCash requirements: \u0026ldquo;the combination of a re-randomized public key and signature(s) under that key do not reveal the key from which it was re-randomized.\u0026rdquo;\nType 7 Support: Ed25519 is supported for backward compatibility with existing destinations, but type 11 is recommended for new encrypted destinations.\nDaily Rotation Benefits:\nForward secrecy: Compromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Unlinkability: Daily rotation prevents long-term tracking via DHT Key separation: Different keys for different time periods References:\nZCash Protocol Specification - Section 5.4.6.1 Tor Key Blinding Discussion Tor Ticket #8106 Encryption and Processing Subcredential Derivation Before encryption, we derive a credential and subcredential to bind encrypted layers to knowledge of the Destination\u0026rsquo;s signing public key.\nGoal: Ensure only those who know the Destination\u0026rsquo;s signing public key can decrypt the encrypted LeaseSet. The full Destination is not required.\nCredential Calculation A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes big endian) # Always 0x000b (Red25519) keydata = A || stA || stA\u0026#39; # 36 bytes credential = H(\u0026#34;credential\u0026#34;, keydata) # 32 bytes Domain Separation: The personalization string \u0026quot;credential\u0026quot; ensures this hash doesn\u0026rsquo;t collide with any DHT lookup keys or other protocol uses.\nSubcredential Calculation blindedPublicKey = A\u0026#39; (32 bytes, from blinding process) subcredential = H(\u0026#34;subcredential\u0026#34;, credential || blindedPublicKey) # 32 bytes Purpose: The subcredential binds the encrypted LeaseSet to:\nThe specific Destination (via credential) The specific blinded key (via blindedPublicKey) The specific day (via daily rotation of blindedPublicKey) This prevents replay attacks and cross-day linking.\nLayer 1 Encryption Context: Layer 1 contains client authorization data and is encrypted with a key derived from the subcredential.\nEncryption Algorithm # Prepare input outerInput = subcredential || publishedTimestamp # publishedTimestamp: 4 bytes from Layer 0 # Generate random salt outerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) outerKey = keys[0:31] # 32 bytes (indices 0-31 inclusive) outerIV = keys[32:43] # 12 bytes (indices 32-43 inclusive) # Encrypt and prepend salt outerPlaintext = [Layer 1 data] outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext) Output: outerCiphertext is 32 + len(outerPlaintext) bytes.\nSecurity Properties:\nSalt ensures unique key/IV pairs even with same subcredential Context string \u0026quot;ELS2_L1K\u0026quot; provides domain separation ChaCha20 provides semantic security (ciphertext indistinguishable from random) Decryption Algorithm # Parse salt from ciphertext outerSalt = outerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV (same process as encryption) outerInput = subcredential || publishedTimestamp keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, n=44 ) outerKey = keys[0:31] # 32 bytes outerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end]) Verification: After decryption, verify Layer 1 structure is well-formed before proceeding to Layer 2.\nLayer 2 Encryption Context: Layer 2 contains the actual LeaseSet2 data and is encrypted with a key derived from the authCookie (if per-client auth enabled) or empty string (if not).\nEncryption Algorithm # Determine authCookie based on authorization mode if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Prepare input innerInput = authCookie || subcredential || publishedTimestamp # Generate random salt innerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Encrypt and prepend salt innerPlaintext = [Layer 2 data: LS2 type byte + LeaseSet2 data] innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext) Output: innerCiphertext is 32 + len(innerPlaintext) bytes.\nKey Binding:\nIf no client auth: Bound only to subcredential and timestamp If client auth enabled: Additionally bound to authCookie (different for each authorized client) Decryption Algorithm # Determine authCookie (same as encryption) if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Parse salt from ciphertext innerSalt = innerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV innerInput = authCookie || subcredential || publishedTimestamp keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, n=44 ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end]) Verification: After decryption:\nVerify LS2 type byte is valid (3 or 7) Parse LeaseSet2 structure Verify inner timestamp matches outer published timestamp Verify inner expiration matches outer expiration Verify LeaseSet2 signature Encryption Layer Summary ┌─────────────────────────────────────────────────┐ │ Layer 0 (Plaintext) │ │ - Blinded public key │ │ - Timestamps │ │ - Signature │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ Layer 1 (Encrypted with subcredential) │ │ │ │ - Authorization flags │ │ │ │ - Client auth data (if enabled) │ │ │ │ │ │ │ │ ┌────────────────────────────────┐ │ │ │ │ │ Layer 2 (Encrypted with │ │ │ │ │ │ authCookie + subcred) │ │ │ │ │ │ - LeaseSet2 type │ │ │ │ │ │ - LeaseSet2 data │ │ │ │ │ │ - Leases │ │ │ │ │ │ - LS2 signature │ │ │ │ │ └────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ └─────────────────────────────────────────────────┘ Decryption Flow:\nVerify Layer 0 signature with blinded public key Decrypt Layer 1 using subcredential Process authorization data (if present) to obtain authCookie Decrypt Layer 2 using authCookie and subcredential Verify and parse LeaseSet2 Per-Client Authorization Overview When per-client authorization is enabled, the server maintains a list of authorized clients. Each client has key material that must be securely transmitted out-of-band.\nTwo Authorization Mechanisms:\nDH (Diffie-Hellman) Client Authorization: More secure, uses X25519 key agreement PSK (Pre-Shared Key) Authorization: Simpler, uses symmetric keys Common Security Properties:\nClient membership privacy: Observers see client count but cannot identify specific clients Anonymous client addition/revocation: Cannot track when specific clients are added or removed 8-byte client identifier collision probability: ~1 in 18 quintillion (negligible) DH Client Authorization Overview: Each client generates an X25519 keypair and sends their public key to the server via a secure out-of-band channel. The server uses ephemeral DH to encrypt a unique authCookie for each client.\nClient Key Generation # Client generates keypair csk_i = GENERATE_PRIVATE() # 32-byte X25519 private key cpk_i = DERIVE_PUBLIC(csk_i) # 32-byte X25519 public key # Client sends cpk_i to server via secure out-of-band channel # Client KEEPS csk_i secret (never transmitted) Security Advantage: The client\u0026rsquo;s private key never leaves their device. An adversary intercepting the out-of-band transmission cannot decrypt future encrypted LeaseSets without breaking X25519 DH.\nServer Processing # Server generates new auth cookie and ephemeral keypair authCookie = CSRNG(32) # 32-byte cookie esk = GENERATE_PRIVATE() # 32-byte ephemeral private key epk = DERIVE_PUBLIC(esk) # 32-byte ephemeral public key # For each authorized client i for cpk_i in authorized_clients: # Perform DH key agreement sharedSecret = DH(esk, cpk_i) # 32 bytes # Derive client-specific encryption key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, # Ephemeral public key as salt ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Layer 1 Data Structure:\nephemeralPublicKey (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Server Recommendations:\nGenerate new ephemeral keypair for each published encrypted LeaseSet Randomize client order to prevent position-based tracking Consider adding dummy entries to hide true client count Client Processing # Client has: csk_i (their private key), destination, date, secret # Client receives: encrypted LeaseSet with epk in Layer 1 # Perform DH key agreement with server\u0026#39;s ephemeral public key sharedSecret = DH(csk_i, epk) # 32 bytes # Derive expected client identifier and decryption key cpk_i = DERIVE_PUBLIC(csk_i) # Client\u0026#39;s own public key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Client Error Handling:\nIf clientID_i not found: Client has been revoked or never authorized If decryption fails: Corrupted data or wrong keys (extremely rare) Clients should periodically re-fetch to detect revocation PSK Client Authorization Overview: Each client has a pre-shared 32-byte symmetric key. The server encrypts the same authCookie using each client\u0026rsquo;s PSK.\nKey Generation # Option 1: Client generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Client sends psk_i to server via secure out-of-band channel # Option 2: Server generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Server sends psk_i to one or more clients via secure out-of-band channel Security Note: The same PSK can be shared among multiple clients if desired (creates a \u0026ldquo;group\u0026rdquo; authorization).\nServer Processing # Server generates new auth cookie and salt authCookie = CSRNG(32) # 32-byte cookie authSalt = CSRNG(32) # 32-byte salt # For each authorized client i for psk_i in authorized_clients: # Derive client-specific encryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Layer 1 Data Structure:\nauthSalt (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Client Processing # Client has: psk_i (their pre-shared key), destination, date, secret # Client receives: encrypted LeaseSet with authSalt in Layer 1 # Derive expected client identifier and decryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Comparison and Recommendations Feature DH Authorization PSK Authorization Key ExchangeAsymmetric (X25519)Symmetric (shared secret) SecurityHigher (forward secrecy)Lower (depends on PSK secrecy) Client PrivacyPrivate key never transmittedPSK must be transmitted securely PerformanceN+1 DH operationsNo DH operations Key SharingOne key per clientCan share key among multiple clients Revocation DetectionAdversary cannot tell when revokedAdversary can track revocation if PSK intercepted Use CaseHigh security requirementsPerformance-critical or group access Recommendation:\nUse DH authorization for high-security applications where forward secrecy is important Use PSK authorization when performance is critical or when managing client groups Never reuse PSKs across different services or time periods Always use secure channels for key distribution (e.g., Signal, OTR, PGP) Security Considerations Client Membership Privacy:\nBoth mechanisms provide privacy for client membership through:\nEncrypted client identifiers: 8-byte clientID derived from HKDF output Indistinguishable cookies: All 32-byte clientCookie values appear random No client-specific metadata: No way to identify which entry belongs to which client An observer can see:\nNumber of authorized clients (from clients field) Changes in client count over time An observer CANNOT see:\nWhich specific clients are authorized When specific clients are added or removed (if count stays same) Any client-identifying information Randomization Recommendations:\nServers SHOULD randomize client order each time they generate an encrypted LeaseSet:\nimport random # Before serializing auth_entries = [(clientID_i, clientCookie_i) for each client] random.shuffle(auth_entries) # Now serialize in randomized order Benefits:\nPrevents clients from learning their position in the list Prevents inference attacks based on position changes Makes client addition/revocation indistinguishable Hiding Client Count:\nServers MAY insert random dummy entries:\n# Add dummy entries num_dummies = random.randint(0, max_dummies) for _ in range(num_dummies): dummy_id = CSRNG(8) dummy_cookie = CSRNG(32) auth_entries.append((dummy_id, dummy_cookie)) # Randomize all entries (real + dummy) random.shuffle(auth_entries) Cost: Dummy entries increase encrypted LeaseSet size (40 bytes each).\nAuthCookie Rotation:\nServers SHOULD generate a new authCookie:\nEach time an encrypted LeaseSet is published (every few hours typical) Immediately after revoking a client On a regular schedule (e.g., daily) even if no client changes Benefits:\nLimits exposure if authCookie is compromised Ensures revoked clients lose access quickly Provides forward secrecy for Layer 2 Base32 Addressing for Encrypted LeaseSets Overview Traditional I2P base32 addresses contain only the hash of the Destination (32 bytes → 52 characters). This is insufficient for encrypted LeaseSets because:\nClients need the non-blinded public key to derive the blinded public key Clients need the signature types (unblinded and blinded) for proper key derivation The hash alone does not provide this information Solution: A new base32 format that includes the public key and signature types.\nAddress Format Specification Decoded Structure (35 bytes):\n┌─────────────────────────────────────────────────────┐ │ Byte 0 │ Byte 1 │ Byte 2 │ Bytes 3-34 │ │ Flags │ Unblind │ Blinded │ Public Key │ │ (XOR) │ SigType │ SigType │ (32 bytes) │ │ │ (XOR) │ (XOR) │ │ └─────────────────────────────────────────────────────┘ First 3 Bytes (XOR with Checksum):\nThe first 3 bytes contain metadata XOR\u0026rsquo;d with portions of a CRC-32 checksum:\n# Data structure before XOR flags = 0x00 # 1 byte (reserved for future use) unblinded_sigtype = 0x07 or 0x0b # 1 byte (7 or 11) blinded_sigtype = 0x0b # 1 byte (always 11) # Compute CRC-32 checksum of public key checksum = crc32(pubkey) # 4-byte CRC-32 of bytes 3-34 # XOR first 3 bytes with parts of checksum data[0] = flags XOR (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF data[1] = unblinded_sigtype XOR (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF data[2] = blinded_sigtype XOR (checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF # Bytes 3-34 contain the unmodified 32-byte public key data[3:34] = pubkey Checksum Properties:\nUses standard CRC-32 polynomial False negative rate: ~1 in 16 million Provides error detection for address typos Cannot be used as authentication (not cryptographically secure) Encoded Format:\nBase32Encode(35 bytes) || \u0026#34;.b32.i2p\u0026#34; Characteristics:\nTotal characters: 56 (35 bytes × 8 bits ÷ 5 bits per char) Suffix: \u0026ldquo;.b32.i2p\u0026rdquo; (same as traditional base32) Total length: 56 + 8 = 64 characters (excluding null terminator) Base32 Encoding:\nAlphabet: abcdefghijklmnopqrstuvwxyz234567 (standard RFC 4648) 5 unused bits at the end MUST be 0 Case-insensitive (by convention lowercase) Address Generation import struct from zlib import crc32 import base64 def generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype): \u0026#34;\u0026#34;\u0026#34; Generate base32 address for encrypted LeaseSet. Args: pubkey: 32-byte public key (bytes) unblinded_sigtype: Unblinded signature type (7 or 11) blinded_sigtype: Blinded signature type (always 11) Returns: String address ending in .b32.i2p \u0026#34;\u0026#34;\u0026#34; # Verify inputs assert len(pubkey) == 32, \u0026#34;Public key must be 32 bytes\u0026#34; assert unblinded_sigtype in [7, 11], \u0026#34;Unblinded sigtype must be 7 or 11\u0026#34; assert blinded_sigtype == 11, \u0026#34;Blinded sigtype must be 11\u0026#34; # Compute CRC-32 of public key checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Ensure 32-bit unsigned # Prepare metadata bytes flags = 0x00 # XOR metadata with checksum parts byte0 = flags ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) byte1 = unblinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) byte2 = blinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Construct 35-byte data data = bytes([byte0, byte1, byte2]) + pubkey # Base32 encode (standard alphabet) # Python\u0026#39;s base64 module uses uppercase by default b32 = base64.b32encode(data).decode(\u0026#39;ascii\u0026#39;).lower().rstrip(\u0026#39;=\u0026#39;) # Construct full address address = b32 + \u0026#34;.b32.i2p\u0026#34; return address Address Parsing import struct from zlib import crc32 import base64 def parse_encrypted_b32_address(address): \u0026#34;\u0026#34;\u0026#34; Parse base32 address for encrypted LeaseSet. Args: address: String address ending in .b32.i2p Returns: Tuple of (pubkey, unblinded_sigtype, blinded_sigtype) Raises: ValueError: If address is invalid or checksum fails \u0026#34;\u0026#34;\u0026#34; # Remove suffix if not address.endswith(\u0026#39;.b32.i2p\u0026#39;): raise ValueError(\u0026#34;Invalid address suffix\u0026#34;) b32 = address[:-8] # Remove \u0026#34;.b32.i2p\u0026#34; # Verify length (56 characters for 35 bytes) if len(b32) != 56: raise ValueError(f\u0026#34;Invalid length: {len(b32)} (expected 56)\u0026#34;) # Base32 decode # Add padding if needed padding_needed = (8 - (len(b32) % 8)) % 8 b32_padded = b32.upper() + \u0026#39;=\u0026#39; * padding_needed try: data = base64.b32decode(b32_padded) except Exception as e: raise ValueError(f\u0026#34;Invalid base32 encoding: {e}\u0026#34;) # Verify decoded length if len(data) != 35: raise ValueError(f\u0026#34;Invalid decoded length: {len(data)} (expected 35)\u0026#34;) # Extract public key pubkey = data[3:35] # Compute CRC-32 for verification checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Un-XOR metadata bytes flags = data[0] ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) unblinded_sigtype = data[1] ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) blinded_sigtype = data[2] ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Verify expected values if flags != 0x00: raise ValueError(f\u0026#34;Invalid flags: {flags:#x} (expected 0x00)\u0026#34;) if unblinded_sigtype not in [7, 11]: raise ValueError(f\u0026#34;Invalid unblinded sigtype: {unblinded_sigtype} (expected 7 or 11)\u0026#34;) if blinded_sigtype != 11: raise ValueError(f\u0026#34;Invalid blinded sigtype: {blinded_sigtype} (expected 11)\u0026#34;) return pubkey, unblinded_sigtype, blinded_sigtype Comparison with Traditional Base32 Feature Traditional B32 Encrypted LS2 B32 ContentSHA-256 hash of DestinationPublic key + signature types Decoded Size32 bytes35 bytes Encoded Length52 characters56 characters Suffix.b32.i2p.b32.i2p Total Length60 chars64 chars ChecksumNoneCRC-32 (XOR'd into first 3 bytes) Use CaseRegular destinationsEncrypted LeaseSet destinations Usage Restrictions BitTorrent Incompatibility:\nEncrypted LS2 addresses CANNOT be used with BitTorrent\u0026rsquo;s compact announce replies:\nCompact announce reply format: ┌────────────────────────────┐ │ 32-byte destination hash │ ← Only hash, no signature types │ 2-byte port │ └────────────────────────────┘ Problem: Compact format only contains the hash (32 bytes), with no room for signature types or public key information.\nSolution: Use full announce replies or HTTP-based trackers that support full addresses.\nAddress Book Integration If a client has the full Destination in an address book:\nStore full Destination (includes public key) Support reverse lookup by hash When encrypted LS2 is encountered, retrieve public key from address book No need for new base32 format if full Destination already known Address book formats that support encrypted LS2:\nhosts.txt with full destination strings SQLite databases with destination column JSON/XML formats with full destination data Implementation Examples Example 1: Generate Address\n# Ed25519 destination example pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) # 32-byte public key unblinded_type = 7 # Ed25519 blinded_type = 11 # Red25519 (always) address = generate_encrypted_b32_address(pubkey, unblinded_type, blinded_type) print(f\u0026#34;Address: {address}\u0026#34;) # Output: 56 base32 characters + .b32.i2p Example 2: Parse and Validate\naddress = \u0026#34;abc...xyz.b32.i2p\u0026#34; # 56 chars + suffix try: pubkey, unblinded, blinded = parse_encrypted_b32_address(address) print(f\u0026#34;Public Key: {pubkey.hex()}\u0026#34;) print(f\u0026#34;Unblinded SigType: {unblinded}\u0026#34;) print(f\u0026#34;Blinded SigType: {blinded}\u0026#34;) except ValueError as e: print(f\u0026#34;Invalid address: {e}\u0026#34;) Example 3: Convert from Destination\ndef destination_to_encrypted_b32(destination): \u0026#34;\u0026#34;\u0026#34; Convert full Destination to encrypted LS2 base32 address. Args: destination: I2P Destination object Returns: Base32 address string \u0026#34;\u0026#34;\u0026#34; # Extract public key and signature type from destination pubkey = destination.signing_public_key # 32 bytes sigtype = destination.sig_type # 7 or 11 # Blinded type is always 11 (Red25519) blinded_type = 11 # Generate address return generate_encrypted_b32_address(pubkey, sigtype, blinded_type) Security Considerations Privacy:\nBase32 address reveals the public key This is intentional and required for the protocol Does NOT reveal the private key or compromise security Public keys are public information by design Collision Resistance:\nCRC-32 provides only 32 bits of collision resistance Not cryptographically secure (use only for error detection) Do NOT rely on checksum for authentication Full destination verification still required Address Validation:\nAlways validate checksum before use Reject addresses with invalid signature types Verify public key is on the curve (implementation specific) References:\nProposal 149: B32 for Encrypted LS2 [B32 Addressing Specification](/docs/specs/b32-for-encrypted-leasesets/ I2P Naming Specification Offline Keys Support Overview Offline keys allow the main signing key to remain offline (cold storage) while a transient signing key is used for day-to-day operations. This is critical for high-security services.\nEncrypted LS2 Specific Requirements:\nTransient keys must be generated offline Blinded private keys must be pre-generated (one per day) Both transient and blinded keys delivered in batches No standardized file format yet defined (TODO in specification) Offline Key Structure Layer 0 Transient Key Data (when flag bit 0 = 1):\n┌───────────────────────────────────────────────────┐ │ Expires Timestamp │ 4 bytes (seconds) │ │ Transient Sig Type │ 2 bytes (big endian) │ │ Transient Signing Pubkey│ Variable (sigtype len) │ │ Signature (by blinded) │ 64 bytes (Red25519) │ └───────────────────────────────────────────────────┘ Signature Coverage: The signature in the offline key block covers:\nExpires timestamp (4 bytes) Transient sig type (2 bytes) Transient signing public key (variable) This signature is verified using the blinded public key, proving that the entity with the blinded private key authorized this transient key.\nKey Generation Process For Encrypted LeaseSet with Offline Keys:\nGenerate transient keypairs (offline, in cold storage):\n# For each day in future for date in future_dates: # Generate daily transient keypair transient_privkey = generate_red25519_privkey() # Type 11 transient_pubkey = derive_public(transient_privkey) # Store for later delivery keys[date] = (transient_privkey, transient_pubkey) Generate daily blinded keypairs (offline, in cold storage):\n# For each day for date in future_dates: # Derive alpha for this date datestring = date.strftime(\u0026#34;%Y%m%d\u0026#34;) # \u0026#34;YYYYMMDD\u0026#34; alpha = GENERATE_ALPHA(destination, datestring, secret) # Blind the signing private key a = destination_signing_privkey # Type 7 or 11 blinded_privkey = BLIND_PRIVKEY(a, alpha) # Result is type 11 blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Store for later delivery blinded_keys[date] = (blinded_privkey, blinded_pubkey) Sign transient keys with blinded keys (offline):\nfor date in future_dates: transient_pubkey = keys[date][1] blinded_privkey = blinded_keys[date][0] # Create signature data expires = int((date + timedelta(days=1)).timestamp()) sig_data = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, expires) # 4 bytes sig_data += struct.pack(\u0026#39;\u0026gt;H\u0026#39;, 11) # Transient type (Red25519) sig_data += transient_pubkey # 32 bytes # Sign with blinded private key signature = RED25519_SIGN(blinded_privkey, sig_data) # Package for delivery offline_sig_blocks[date] = { \u0026#39;expires\u0026#39;: expires, \u0026#39;transient_type\u0026#39;: 11, \u0026#39;transient_pubkey\u0026#39;: transient_pubkey, \u0026#39;signature\u0026#39;: signature } Package for delivery to router:\n# For each date delivery_package[date] = { \u0026#39;transient_privkey\u0026#39;: keys[date][0], \u0026#39;transient_pubkey\u0026#39;: keys[date][1], \u0026#39;blinded_privkey\u0026#39;: blinded_keys[date][0], \u0026#39;blinded_pubkey\u0026#39;: blinded_keys[date][1], \u0026#39;offline_sig_block\u0026#39;: offline_sig_blocks[date] } Router Usage Daily Key Loading:\n# At UTC midnight (or before publishing) date = datetime.utcnow().date() # Load keys for today today_keys = load_delivery_package(date) transient_privkey = today_keys[\u0026#39;transient_privkey\u0026#39;] transient_pubkey = today_keys[\u0026#39;transient_pubkey\u0026#39;] blinded_privkey = today_keys[\u0026#39;blinded_privkey\u0026#39;] blinded_pubkey = today_keys[\u0026#39;blinded_pubkey\u0026#39;] offline_sig_block = today_keys[\u0026#39;offline_sig_block\u0026#39;] # Use these keys for today\u0026#39;s encrypted LeaseSet Publishing Process:\n# 1. Create inner LeaseSet2 inner_ls2 = create_leaseset2( destinations, leases, expires, signing_key=transient_privkey # Use transient key ) # 2. Encrypt Layer 2 layer2_ciphertext = encrypt_layer2(inner_ls2, authCookie, subcredential, timestamp) # 3. Create Layer 1 with authorization data layer1_plaintext = create_layer1(authorization_data, layer2_ciphertext) # 4. Encrypt Layer 1 layer1_ciphertext = encrypt_layer1(layer1_plaintext, subcredential, timestamp) # 5. Create Layer 0 with offline signature block layer0 = create_layer0( blinded_pubkey, timestamp, expires, flags=0x0001, # Bit 0 set (offline keys present) offline_sig_block=offline_sig_block, layer1_ciphertext=layer1_ciphertext ) # 6. Sign Layer 0 with transient private key signature = RED25519_SIGN(transient_privkey, layer0) # 7. Append signature and publish encrypted_leaseset = layer0 + signature publish_to_netdb(encrypted_leaseset) Security Considerations Tracking via Offline Signature Block:\nThe offline signature block is in plaintext (Layer 0). An adversary scraping floodfills could:\nTrack the same encrypted LeaseSet across multiple days Correlate encrypted LeaseSets even though blinded keys change daily Mitigation: Generate new transient keys daily (in addition to blinded keys):\n# Generate BOTH new transient and new blinded keys each day for date in future_dates: # New transient keypair for this day transient_privkey = generate_red25519_privkey() transient_pubkey = derive_public(transient_privkey) # New blinded keypair for this day alpha = GENERATE_ALPHA(destination, datestring, secret) blinded_privkey = BLIND_PRIVKEY(signing_privkey, alpha) blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Sign new transient key with new blinded key sig = RED25519_SIGN(blinded_privkey, transient_pubkey || metadata) # Now offline sig block changes daily Benefits:\nPrevents tracking across days via offline signature block Provides same security as encrypted LS2 without offline keys Each day appears completely independent Cost:\nMore keys to generate and store More complex key management File Format (TODO) Current Status: No standardized file format defined for batch key delivery.\nRequirements for Future Format:\nMust support multiple dates:\nBatch delivery of 30+ days worth of keys Clear date association for each key set Must include all necessary data:\nTransient private key Transient public key Blinded private key Blinded public key Pre-computed offline signature block Expiration timestamps Should be tamper-evident:\nChecksums or signatures over entire file Integrity verification before loading Should be encrypted:\nKeys are sensitive material Encrypt file with router\u0026rsquo;s key or passphrase Proposed Format Example (JSON, encrypted):\n{ \u0026#34;version\u0026#34;: 1, \u0026#34;destination_hash\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;keys\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2025-10-15\u0026#34;, \u0026#34;transient\u0026#34;: { \u0026#34;type\u0026#34;: 11, \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;blinded\u0026#34;: { \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;offline_sig_block\u0026#34;: { \u0026#34;expires\u0026#34;: 1729123200, \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; } } ], \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; // Signature over entire structure } I2CP Protocol Enhancement (TODO) Current Status: No I2CP protocol enhancement defined for offline keys with encrypted LeaseSet.\nRequirements:\nKey delivery mechanism:\nUpload batch of keys from client to router Acknowledgment of successful key loading Key expiration notification:\nRouter notifies client when keys running low Client can generate and upload new batch Key revocation:\nEmergency revocation of future keys if compromise suspected Proposed I2CP Messages:\nUPLOAD_OFFLINE_KEYS - Batch of encrypted key material - Date range covered OFFLINE_KEY_STATUS - Number of days remaining - Next key expiration date REVOKE_OFFLINE_KEYS - Date range to revoke - New keys to replace (optional) Implementation Status Java I2P:\n✅ Offline keys for standard LS2: Fully supported (since 0.9.38) ⚠️ Offline keys for encrypted LS2: Implemented (since 0.9.40) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced i2pd (C++):\n✅ Offline keys for standard LS2: Fully supported ✅ Offline keys for encrypted LS2: Fully supported (since 2.58.0) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced References:\nOffline Signatures Proposal I2CP Specification Security Considerations Cryptographic Security Algorithm Selection:\nAll cryptographic primitives are based on well-studied algorithms:\nChaCha20: Modern stream cipher, constant-time, no timing attacks SHA-256: NIST-approved hash, 128-bit security level HKDF: RFC 5869 standard, proven security bounds Ed25519/Red25519: Curve25519-based, ~128-bit security level X25519: Diffie-Hellman over Curve25519, ~128-bit security level Key Sizes:\nAll symmetric keys: 256 bits (32 bytes) All public/private keys: 256 bits (32 bytes) All nonces/IVs: 96 bits (12 bytes) All signatures: 512 bits (64 bytes) These sizes provide adequate security margins against current and near-future attacks.\nForward Secrecy Daily Key Rotation:\nEncrypted LeaseSets rotate keys daily (UTC midnight):\nNew blinded public/private key pair New storage location in DHT New encryption keys for both layers Benefits:\nCompromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Limits exposure window to 24 hours Prevents long-term tracking via DHT Enhanced with Ephemeral Keys:\nDH client authorization uses ephemeral keys:\nServer generates new ephemeral DH keypair for each publication Compromising ephemeral key only affects that publication True forward secrecy even if long-term keys compromised Privacy Properties Destination Blinding:\nThe blinded public key:\nIs unlinkable to the original destination (without knowing the secret) Changes daily, preventing long-term correlation Cannot be reversed to find the original public key Client Membership Privacy:\nPer-client authorization provides:\nAnonymity: No way to identify which clients are authorized Untraceability: Cannot track when specific clients added/revoked Size obfuscation: Can add dummy entries to hide true count DHT Privacy:\nStorage location rotates daily:\nlocation = SHA-256(sig_type || blinded_public_key) This prevents:\nCorrelation across days via DHT lookups Long-term monitoring of service availability Traffic analysis of DHT queries Threat Model Adversary Capabilities:\nNetwork Adversary:\nCan monitor all DHT traffic Can observe encrypted LeaseSet publications Cannot decrypt without proper keys Floodfill Adversary:\nCan store and analyze all encrypted LeaseSets Can track publication patterns over time Cannot decrypt Layer 1 or Layer 2 Can see client count (but not identities) Authorized Client Adversary:\nCan decrypt specific encrypted LeaseSets Can access inner LeaseSet2 data Cannot determine other clients\u0026rsquo; identities Cannot decrypt past LeaseSets (with ephemeral keys) Out of Scope:\nMalicious router implementations Compromised router host systems Side-channel attacks (timing, power analysis) Physical access to keys Social engineering attacks Attack Scenarios 1. Offline Keys Tracking Attack:\nAttack: Adversary tracks encrypted LeaseSets via unchanging offline signature block.\nMitigation: Generate new transient keys daily (in addition to blinded keys).\nStatus: Documented recommendation, implementation-specific.\n2. Client Position Inference Attack:\nAttack: If client order is static, clients can infer their position and detect when other clients added/removed.\nMitigation: Randomize client order in authorization list for each publication.\nStatus: Documented recommendation in specification.\n3. Client Count Analysis Attack:\nAttack: Adversary monitors client count changes over time to infer service popularity or client churn.\nMitigation: Add random dummy entries to authorization list.\nStatus: Optional feature, deployment-specific trade-off (size vs. privacy).\n4. PSK Interception Attack:\nAttack: Adversary intercepts PSK during out-of-band exchange and can decrypt all future encrypted LeaseSets.\nMitigation: Use DH client authorization instead, or ensure secure key exchange (Signal, OTR, PGP).\nStatus: Known limitation of PSK approach, documented in specification.\n5. Timing Correlation Attack:\nAttack: Adversary correlates publication times across days to link encrypted LeaseSets.\nMitigation: Randomize publication times, use delayed publishing.\nStatus: Implementation-specific, not addressed in core specification.\n6. Long-term Secret Compromise:\nAttack: Adversary compromises the blinding secret and can compute all past and future blinded keys.\nMitigation:\nUse optional secret parameter (not empty) Rotate secret periodically Use different secrets for different services Status: Secret parameter is optional; using it is highly recommended.\nOperational Security Key Management:\nSigning Private Key:\nStore offline in cold storage Use only for generating blinded keys (batch process) Never expose to online router Blinded Private Keys:\nGenerate offline, deliver in batches Rotate daily automatically Delete after use (forward secrecy) Transient Private Keys (with offline keys):\nGenerate offline, deliver in batches Can be longer-lived (days/weeks) Rotate regularly for enhanced privacy Client Authorization Keys:\nDH: Client private keys never leave client device PSK: Use unique keys per client, secure exchange Revoke immediately upon client removal Secret Management:\nThe optional secret parameter in GENERATE_ALPHA:\nSHOULD be used for high-security services MUST be transmitted securely to authorized clients SHOULD be rotated periodically (e.g., monthly) CAN be different for different client groups Monitoring and Auditing:\nPublication Monitoring:\nVerify encrypted LeaseSets published successfully Monitor floodfill acceptance rates Alert on publication failures Client Access Monitoring:\nLog client authorization attempts (without identifying clients) Monitor for unusual patterns Detect potential attacks early Key Rotation Auditing:\nVerify daily key rotation occurs Check blinded key changes daily Ensure old keys are deleted Implementation Security Constant-Time Operations:\nImplementations MUST use constant-time operations for:\nAll scalar arithmetic (mod L operations) Private key comparisons Signature verification DH key agreement Memory Security:\nZero sensitive key material after use Use secure memory allocation for keys Prevent keys from being paged to disk Clear stack variables containing key material Random Number Generation:\nUse cryptographically secure RNG (CSRNG) Properly seed RNG from OS entropy source Do not use predictable RNGs for key material Verify RNG output quality periodically Input Validation:\nValidate all public keys are on the curve Check all signature types are supported Verify all lengths before parsing Reject malformed encrypted LeaseSets early Error Handling:\nDo not leak information via error messages Use constant-time comparison for authentication Do not expose timing differences in decryption Log security-relevant events properly Recommendations For Service Operators:\n✅ Use Red25519 (type 11) for new destinations ✅ Use DH client authorization for high-security services ✅ Generate new transient keys daily when using offline keys ✅ Use the optional secret parameter in GENERATE_ALPHA ✅ Randomize client order in authorization lists ✅ Monitor publication success and investigate failures ⚠️ Consider dummy entries to hide client count (size trade-off) For Client Implementers:\n✅ Validate blinded public keys are on prime-order subgroup ✅ Verify all signatures before trusting data ✅ Use constant-time operations for cryptographic primitives ✅ Zero key material immediately after use ✅ Implement proper error handling without information leaks ✅ Support both Ed25519 and Red25519 destination types For Network Operators:\n✅ Accept encrypted LeaseSets in floodfill routers ✅ Enforce reasonable size limits to prevent abuse ✅ Monitor for anomalous patterns (extremely large, frequent updates) ⚠️ Consider rate limiting encrypted LeaseSet publications Implementation Notes Java I2P Implementation Repository: https://github.com/i2p/i2p.i2p\nKey Classes:\nnet.i2p.data.LeaseSet2 - LeaseSet2 structure net.i2p.data.EncryptedLeaseSet - Encrypted LS2 implementation net.i2p.crypto.eddsa.EdDSAEngine - Ed25519/Red25519 signatures net.i2p.crypto.HKDF - HKDF implementation net.i2p.crypto.ChaCha20 - ChaCha20 cipher Configuration:\nEnable encrypted LeaseSet in clients.config:\n# Enable encrypted LeaseSet i2cp.encryptLeaseSet=true # Optional: Enable client authorization i2cp.enableAccessList=true # Optional: Use DH authorization (default is PSK) i2cp.accessListType=0 # Optional: Blinding secret (highly recommended) i2cp.blindingSecret=your-secret-here API Usage Example:\n// Create encrypted LeaseSet EncryptedLeaseSet els = new EncryptedLeaseSet(); // Set destination els.setDestination(destination); // Enable per-client authorization els.setAuthorizationEnabled(true); els.setAuthType(EncryptedLeaseSet.AUTH_DH); // Add authorized clients (DH public keys) for (byte[] clientPubKey : authorizedClients) { els.addClient(clientPubKey); } // Set blinding parameters els.setBlindingSecret(\u0026#34;your-secret\u0026#34;); // Sign and publish els.sign(signingPrivateKey); netDb.publish(els); i2pd (C++) Implementation Repository: https://github.com/PurpleI2P/i2pd\nKey Files:\nlibi2pd/LeaseSet.h/cpp - LeaseSet implementations libi2pd/Crypto.h/cpp - Cryptographic primitives libi2pd/Ed25519.h/cpp - Ed25519/Red25519 signatures libi2pd/ChaCha20.h/cpp - ChaCha20 cipher Configuration:\nEnable in tunnel configuration (tunnels.conf):\n[my-hidden-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Enable encrypted LeaseSet encryptleaseset = true # Optional: Client authorization type (0=DH, 1=PSK) authtype = 0 # Optional: Blinding secret secret = your-secret-here # Optional: Authorized clients (one per line, base64 encoded public keys) client.1 = base64-encoded-client-pubkey-1 client.2 = base64-encoded-client-pubkey-2 API Usage Example:\n// Create encrypted LeaseSet auto encryptedLS = std::make_shared\u0026lt;i2p::data::EncryptedLeaseSet\u0026gt;( destination, blindingSecret ); // Enable per-client authorization encryptedLS-\u0026gt;SetAuthType(i2p::data::AUTH_TYPE_DH); // Add authorized clients for (const auto\u0026amp; clientPubKey : authorizedClients) { encryptedLS-\u0026gt;AddClient(clientPubKey); } // Sign and publish encryptedLS-\u0026gt;Sign(signingPrivKey); netdb.Publish(encryptedLS); Testing and Debugging Test Vectors:\nGenerate test vectors for implementation verification:\n# Test vector 1: Key blinding destination_pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) sigtype = 7 blinded_sigtype = 11 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; alpha = generate_alpha(destination_pubkey, sigtype, blinded_sigtype, date, secret) print(f\u0026#34;Alpha: {alpha.hex()}\u0026#34;) # Expected: (verify against reference implementation) Unit Tests:\nKey areas to test:\nHKDF derivation with various inputs ChaCha20 encryption/decryption Red25519 signature generation and verification Key blinding (private and public) Layer 1/2 encryption/decryption Client authorization (DH and PSK) Base32 address generation and parsing Integration Tests:\nPublish encrypted LeaseSet to test network Retrieve and decrypt from client Verify daily key rotation Test client authorization (add/remove clients) Test offline keys (if supported) Common Implementation Errors:\nIncorrect mod L reduction: Must use proper modular arithmetic Endianness errors: Most fields are big-endian, but some crypto uses little-endian Off-by-one in array slicing: Verify indices are inclusive/exclusive as needed Missing constant-time comparisons: Use constant-time for all sensitive comparisons Not zeroing key material: Always zero keys after use Performance Considerations Computational Costs:\nOperation Cost Notes Key blinding (server)1 scalar multPer publication Key blinding (client)1 point add + 1 scalar multPer retrieval Layer 1 encryption1 HKDF + 1 ChaCha20Fast Layer 2 encryption1 HKDF + 1 ChaCha20Fast DH client auth (server)N+1 X25519 opsN = number of clients DH client auth (client)1 X25519 opPer retrieval PSK client auth0 DH opsOnly HKDF + ChaCha20 Signature (Red25519)1 signature opSimilar cost to Ed25519 Size Overhead:\nComponent Size Frequency Blinded public key32 bytesPer LeaseSet Layer 1 encryption overhead32 bytes (salt)Per LeaseSet Layer 2 encryption overhead32 bytes (salt)Per LeaseSet DH auth per client40 bytesPer client per LeaseSet DH ephemeral pubkey32 bytesPer LeaseSet (if DH auth) PSK auth per client40 bytesPer client per LeaseSet PSK salt32 bytesPer LeaseSet (if PSK auth) Signature64 bytesPer LeaseSet Offline sig block≈100 bytesPer LeaseSet (if offline keys) Typical Sizes:\nNo client auth: ~200 bytes overhead With 10 DH clients: ~600 bytes overhead With 100 DH clients: ~4200 bytes overhead Optimization Tips:\nBatch key generation: Generate blinded keys for multiple days in advance Cache subcredentials: Compute once per day, reuse for all publications Reuse ephemeral keys: Can reuse ephemeral DH key for short period (minutes) Parallel client encryption: Encrypt client cookies in parallel Fast path for no auth: Skip authorization layer entirely when disabled Compatibility Backward Compatibility:\nEd25519 (type 7) destinations supported for unblinded keys Red25519 (type 11) required for blinded keys Traditional LeaseSets still fully supported Encrypted LeaseSets do not break existing network Forward Compatibility:\nReserved flag bits for future features Extensible authorization scheme (3 bits allow 8 types) Version field in various structures Interoperability:\nJava I2P and i2pd fully interoperable since: Java I2P 0.9.40 (May 2019) i2pd 2.58.0 (September 2025) Encrypted LeaseSets work across implementations Client authorization works across implementations References IETF RFCs RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (February 1997) RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF) (May 2010) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols (May 2015) RFC 7748 - Elliptic Curves for Security (January 2016) I2P Specifications Common Structures Specification - LeaseSet2 and EncryptedLeaseSet structures Proposal 123: New netDB Entries - Background and design of LeaseSet2 Proposal 146: Red25519 - Red25519 signature scheme specification Proposal 149: B32 for Encrypted LS2 - Base32 addressing for encrypted LeaseSets [Red25519 Specification](/docs/specs/red25519-signature-scheme/ - Detailed Red25519 implementation [B32 Addressing Specification](/docs/specs/b32-for-encrypted-leasesets/ - Base32 address format Network Database Documentation - NetDB usage and operations I2CP Specification - I2P Client Protocol Cryptographic References Ed25519 Paper - \u0026ldquo;High-speed high-security signatures\u0026rdquo; by Bernstein et al. ZCash Protocol Specification - Section 5.4.6: RedDSA signature scheme Tor Rendezvous Specification v3 - Tor\u0026rsquo;s onion service specification (for comparison) Security References Key Blinding Security Discussion - Tor Project mailing list discussion Tor Ticket #8106 - Key blinding implementation discussion PRNG Security - Random number generator security considerations Tor PRNG Discussion - Discussion of PRNG usage in Tor Implementation References Java I2P Repository - Official Java implementation i2pd Repository - C++ implementation I2P Website - Official I2P project website I2P Specifications - Complete specification index Version History I2P Release Notes - Official release announcements Java I2P Releases - GitHub release history i2pd Releases - GitHub release history Appendix A: Cryptographic Constants Ed25519 / Red25519 Constants # Ed25519 base point (generator) B = 2**255 - 19 # Ed25519 order (scalar field size) L = 2**252 + 27742317777372353535851937790883648493 # Signature type values SIGTYPE_ED25519 = 7 # 0x0007 SIGTYPE_RED25519 = 11 # 0x000b # Key sizes PRIVKEY_SIZE = 32 # bytes PUBKEY_SIZE = 32 # bytes SIGNATURE_SIZE = 64 # bytes ChaCha20 Constants # ChaCha20 parameters CHACHA20_KEY_SIZE = 32 # bytes (256 bits) CHACHA20_NONCE_SIZE = 12 # bytes (96 bits) CHACHA20_INITIAL_COUNTER = 1 # RFC 7539 permits 0 or 1 HKDF Constants # HKDF parameters HKDF_HASH = \u0026#34;SHA-256\u0026#34; HKDF_SALT_MAX = 32 # bytes (HashLen) # HKDF info strings (domain separation) HKDF_INFO_ALPHA = b\u0026#34;i2pblinding1\u0026#34; HKDF_INFO_LAYER1 = b\u0026#34;ELS2_L1K\u0026#34; HKDF_INFO_LAYER2 = b\u0026#34;ELS2_L2K\u0026#34; HKDF_INFO_DH_AUTH = b\u0026#34;ELS2_XCA\u0026#34; HKDF_INFO_PSK_AUTH = b\u0026#34;ELS2PSKA\u0026#34; Hash Personalization Strings # SHA-256 personalization strings HASH_PERS_ALPHA = b\u0026#34;I2PGenerateAlpha\u0026#34; HASH_PERS_RED25519 = b\u0026#34;I2P_Red25519H(x)\u0026#34; HASH_PERS_CREDENTIAL = b\u0026#34;credential\u0026#34; HASH_PERS_SUBCREDENTIAL = b\u0026#34;subcredential\u0026#34; Structure Sizes # Layer 0 (outer) sizes BLINDED_SIGTYPE_SIZE = 2 # bytes BLINDED_PUBKEY_SIZE = 32 # bytes (for Red25519) PUBLISHED_TS_SIZE = 4 # bytes EXPIRES_SIZE = 2 # bytes FLAGS_SIZE = 2 # bytes LEN_OUTER_CIPHER_SIZE = 2 # bytes SIGNATURE_SIZE = 64 # bytes (Red25519) # Offline key block sizes OFFLINE_EXPIRES_SIZE = 4 # bytes OFFLINE_SIGTYPE_SIZE = 2 # bytes OFFLINE_SIGNATURE_SIZE = 64 # bytes # Layer 1 (middle) sizes AUTH_FLAGS_SIZE = 1 # byte EPHEMERAL_PUBKEY_SIZE = 32 # bytes (DH auth) AUTH_SALT_SIZE = 32 # bytes (PSK auth) NUM_CLIENTS_SIZE = 2 # bytes CLIENT_ID_SIZE = 8 # bytes CLIENT_COOKIE_SIZE = 32 # bytes AUTH_CLIENT_ENTRY_SIZE = 40 # bytes (CLIENT_ID + CLIENT_COOKIE) # Encryption overhead SALT_SIZE = 32 # bytes (prepended to each encrypted layer) # Base32 address B32_ENCRYPTED_DECODED_SIZE = 35 # bytes B32_ENCRYPTED_ENCODED_LEN = 56 # characters B32_SUFFIX = \u0026#34;.b32.i2p\u0026#34; Appendix B: Test Vectors Test Vector 1: Alpha Generation Input:\n# Destination public key (Ed25519) A = bytes.fromhex(\u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39;) stA = 0x0007 # Ed25519 stA_prime = 0x000b # Red25519 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; # Empty secret Computation:\nkeydata = A || bytes([0x00, 0x07]) || bytes([0x00, 0x0b]) # keydata = 36 bytes salt = SHA256(b\u0026#34;I2PGenerateAlpha\u0026#34; + keydata) ikm = b\u0026#34;20251015\u0026#34; info = b\u0026#34;i2pblinding1\u0026#34; seed = HKDF(salt, ikm, info, 64) alpha = LEOS2IP(seed) mod L Expected Output:\n(Verify against reference implementation) alpha = [64-byte hex value] Test Vector 2: ChaCha20 Encryption Input:\nkey = bytes([i for i in range(32)]) # 0x00..0x1f nonce = bytes([i for i in range(12)]) # 0x00..0x0b plaintext = b\u0026#34;Hello, I2P!\u0026#34; Computation:\nciphertext = ChaCha20_Encrypt(key, nonce, plaintext, counter=1) Expected Output:\nciphertext = [verify against RFC 7539 test vectors] Test Vector 3: HKDF Input:\nsalt = bytes(32) # All zeros ikm = b\u0026#34;test input keying material\u0026#34; info = b\u0026#34;ELS2_L1K\u0026#34; n = 44 Computation:\nkeys = HKDF(salt, ikm, info, n) Expected Output:\nkeys = [44-byte hex value] Test Vector 4: Base32 Address Input:\npubkey = bytes.fromhex(\u0026#39;bbbb\u0026#39; + \u0026#39;bb\u0026#39; * 30) # 32 bytes unblinded_sigtype = 11 # Red25519 blinded_sigtype = 11 # Red25519 Computation:\naddress = generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype) Expected Output:\naddress = [56 base32 characters].b32.i2p # Verify checksum validates correctly Appendix C: Glossary Alpha (α): The secret blinding factor used to blind public and private keys. Generated from the destination, date, and optional secret.\nAuthCookie: A 32-byte random value encrypted for each authorized client, used as input to Layer 2 encryption.\nB (Base Point): The generator point for the Ed25519 elliptic curve.\nBlinded Key: A public or private key that has been transformed using the alpha blinding factor. Blinded keys cannot be linked to the original keys without knowing alpha.\nChaCha20: A stream cipher providing fast, secure encryption without requiring AES hardware support.\nClientID: An 8-byte identifier derived from HKDF output, used to identify authorization entries for clients.\nClientCookie: A 32-byte encrypted value containing the authCookie for a specific client.\nCredential: A 32-byte value derived from the destination\u0026rsquo;s public key and signature types, binding encryption to knowledge of the destination.\nCSRNG: Cryptographically Secure Random Number Generator. Must provide unpredictable output suitable for key generation.\nDH (Diffie-Hellman): A cryptographic protocol for securely establishing shared secrets. I2P uses X25519.\nEd25519: An elliptic curve signature scheme providing fast signatures with 128-bit security level.\nEphemeral Key: A short-lived cryptographic key, typically used once and then discarded.\nFloodfill: I2P routers that store and serve network database entries, including encrypted LeaseSets.\nHKDF: HMAC-based Key Derivation Function, used to derive multiple cryptographic keys from a single source.\nL (Order): The order of the Ed25519 scalar field (approximately 2^252).\nLayer 0 (Outer): The plaintext portion of an encrypted LeaseSet, containing blinded key and metadata.\nLayer 1 (Middle): The first encrypted layer, containing client authorization data.\nLayer 2 (Inner): The innermost encrypted layer, containing the actual LeaseSet2 data.\nLeaseSet2 (LS2): Second version of I2P\u0026rsquo;s network database entry format, introducing encrypted variants.\nNetDB: The I2P network database, a distributed hash table storing router and destination information.\nOffline Keys: A feature allowing the main signing key to remain in cold storage while a transient key handles daily operations.\nPSK (Pre-Shared Key): A symmetric key shared in advance between two parties, used for PSK client authorization.\nRed25519: An Ed25519-based signature scheme with key blinding support, based on ZCash RedDSA.\nSalt: Random data used as input to key derivation functions to ensure unique outputs.\nSigType: A numeric identifier for signature algorithms (e.g., 7 = Ed25519, 11 = Red25519).\nSubcredential: A 32-byte value derived from the credential and blinded public key, binding encryption to a specific encrypted LeaseSet.\nTransient Key: A temporary signing key used with offline keys, with a limited validity period.\nX25519: An elliptic curve Diffie-Hellman protocol over Curve25519, providing key agreement.\nDocument Information Status: This document represents the current stable encrypted LeaseSet specification as implemented in I2P since June 2019. The protocol is mature and widely deployed.\nContributing: For corrections or improvements to this documentation, please submit issues or pull requests to the I2P specifications repository.\nSupport: For questions about implementing encrypted LeaseSets:\nI2P Forum: https://i2pforum.net/ IRC: #i2p-dev on OFTC Matrix: #i2p-dev:matrix.org Acknowledgments: This specification builds on work by the I2P development team, ZCash cryptography research, and Tor Project\u0026rsquo;s key blinding research.\n","description":"Access-controlled LeaseSet format for private Destinations","id":"14f2a4c0bb3f459df8db8dbce45508ff","section":"docs","title":"Encrypted LeaseSet","url":"/en/docs/specs/encryptedleaseset/"},{"categories":null,"content":" What systems will I2P run on? Is installing Java required to use I2P? What is an \"I2P Site\" and how do I configure my browser so I can use them? What do the Active x/y numbers mean in the router console? My router has very few active peers, is this OK? I am opposed to certain types of content. How do I keep from distributing, storing, or accessing them? Is it possible to block I2P? In wrapper.log I see an error stating Protocol family unavailable when I2P is loading Most of the I2P Sites within I2P are down? Why is I2P listening for connections on port 32000? How do I configure my browser? How do I connect to IRC within I2P? How do I set up my own I2P Site? If I host a website at I2P at home, containing only HTML and CSS, is it dangerous? How Does I2P find \".i2p\" websites? How do I add to the Address Book? What ports does I2P use? I'm missing lots of hosts in my address book. What are some good subscription links? How can I access the web console from my other machines or password protect it? How can I use applications from my other machines? Is it possible to use I2P as a SOCKS proxy? How do I access IRC, BitTorrent, or other services on the regular Internet? My router has been up for several minutes and has zero or very few connections How do I reseed manually? Is my router an \"exit node\"(outproxy) to the regular Internet? I don't want it to be. Is it easy to detect the use of I2P by analyzing network traffic? Is using I2P Safe? I see IP addresses of all other I2P nodes in the router console. Does that mean my IP address is visible by others? Is using an outproxy safe? What about \"De-Anonymizing\" attacks? Internet Access/Performance I can't access regular Internet sites through I2P. I can't access https:// or ftp:// sites through I2P. Why is my router using too much CPU? My router has very few active peers, is this OK? My active peers / known peers / participating tunnels / connections / bandwidth vary dramatically over time! Is anything wrong? What makes downloads, torrents, web browsing, and everything else slower on I2P as compared to the regular internet? Bugs and Questions I think I found a bug, where can I report it? I have a question! I2P Router Help What systems will I2P run on? I2P is written in the Java programming language. It has been tested on Windows, Linux, FreeBSD and OSX. An Android port is also available.\nIn terms of memory usage, I2P is configured to use 128 MB of RAM by default. This is sufficient for browsing and IRC usage. However, other activities may require greater memory allocation. For example, if one wishes to run a high-bandwidth router, participate in I2P torrents or serve high-traffic hidden services, a higher amount of memory is required.\nIn terms of CPU usage, I2P has been tested to run on modest systems such as the Raspberry Pi range of single-board computers. As I2P makes heavy use of cryptographic techniques, a stronger CPU will be better suited to handle the workload generated by I2P as well as tasks related to the rest of the system (i.e. Operating System, GUI, Other processes e.g. Web Browsing).\nA comparison of some of the available Java Runtime Environments (JRE) is available here: . Using Sun/Oracle Java or OpenJDK is recommended.\nIs installing Java required to use I2P? Yes, Java is required to use I2P Core. We include Java inside our easy-installers for Windows, Mac OSX, and Linux. If you’re running the I2P Android app you will also need a Java runtime like Dalvik or ART installed in most cases. What is an \"I2P Site\" and how do I configure my browser so I can use them? An I2P Site is a normal website except that it is hosted inside I2P. I2P sites have addresses that look like normal internet addresses, ending in \".i2p\" in a human- readable, non-cryptographic way, for the benefit of people. Actually connecting to an I2P Site requires cryptography, which means that I2P Site addresses are also the long “Base64” Destinations and the shorter “B32” addresses. You may need to do additional configuration to browse correctly. Browsing I2P Sites will require activating the HTTP Proxy in your I2P installation and then configuring your browser to use it. For more information, browse the “Browsers” section below or the “Browser Configuration” Guide. What do the Active x/y numbers mean in the router console? In the Peers page on your router console, you may see two numbers - Active x/y. The first number is the number of peers that you’ve sent or received a message to or from in the last few minutes. The second number is the number of peers seen recently, this will always be larger than or equal to the first number. My router has very few active peers, is this OK? Yes, this can be normal, especially when the router has just been started. New routers will need time to startup and connect to the rest of the network. To help improve network integration, uptime, and performance, review these settings:\nShare bandwidth\nIf a router is configured to share bandwidth, it will route more traffic for other routers which helps integrate it with the rest of the network, as well as improving the performance of one’s local connection. This can be configured on the http://localhost:7657/config page. Network interface\nMake sure there is not an interface specified on the http://localhost:7657/confignet page. This can reduce performance unless your computer is multi-homed with multiple external IP addresses. I2NP protocol\nMake sure the router is configured to expect connections on a valid protocol for the host’s operating system and empty network(Advanced) settings. Do not enter an IP address in the ‘Hostname’ field in the Network configuration page. The I2NP Protocol you select here will only be used if you do not already have a reachable address. Most Verizon 4G and 5G wireless connections in the United States, for example, block UDP and can’t be reached over it. Others would use UDP by force even if it is available to them. Choose a reasonable setting from the listed I2NP Protocols. I am opposed to certain types of content. How do I keep from distributing, storing, or accessing them? There is none of this material installed by default. However, since I2P is a peer-to- peer network, it’s possible that you may encounter prohibited content by accident. Here is a summary of how I2P prevents you from being unnecessarily involved in violations of your beliefs. Distribution\nTraffic is internal to the I2P network, you are not an exit node (referred to as an outproxy in our documentation). Storage\nThe I2P network does not do distributed storage of content, this has to be specifically installed and configured by the user (with Tahoe-LAFS, for example). That is a feature of a different anonymous network, Freenet. By running an I2P router, you are not storing content for anyone. Access\nYour router will not request any content without your specific instruction to do so. Is it possible to block I2P? Yes, by far the easiest and most common way is by blocking bootstrap, or \"Reseed\" servers. Completely blocking all obfuscated traffic would work as well (although it would break many, many other things that are not I2P and most are not willing to go this far). In the case of reseed blocking, there is a reseed bundle on Github, blocking it will also block Github. You can reseed over a proxy (many can be found on Internet if you do not want to use Tor) or share reseed bundles on a friend-to-friend basis offline.\nIn wrapper.log I see an error that states \"Protocol family unavailable\" when loading the Router Console Often this error will occur with any network enabled java software on some systems that are configured to use IPv6 by default. There are a few ways to solve this: On Linux based systems, you can echo 0 \u003e /proc/sys/net/ipv6/bindv6only Look for the following lines in wrapper.config.\n#wrapper.java.additional.5=-Djava.net.preferIPv4Stack=true\n#wrapper.java.additional.6=-Djava.net.preferIPv6Addresses=false\nIf the lines are there, uncomment them by removing the \"#\"s. If the lines are not there, add them without the \"#\"s. Another option would be to remove the ::1 from ~/.i2p/clients.config WARNING: For any changes to wrapper.config to take effect, you must completely stop the router and the wrapper. Clicking Restart on your router console will NOT reread this file! You must click Shutdown, wait 11 minutes, then start I2P. Most of the I2P Sites within I2P are down? If you consider every I2P Site that has ever been created, yes, most of them are down. People and I2P Sites come and go. A good way to get started in I2P is check out a list of I2P Sites that are currently up. identiguy.i2p tracks active I2P Sites. Why is I2P listening on port 32000? The Tanuki java service wrapper that we use opens this port \u0026mdash;bound to localhost\u0026mdash; in order to communicate with software running inside the JVM. When the JVM is launched it is given a key so it can connect to the wrapper. After the JVM establishes its connection to the wrapper, the wrapper refuses any additional connections. More information can be found in the wrapper documentation. How do I configure my browser? The proxy config for different browsers is on a separate page with screenshots. More advanced configs with external tools, such as the browser plug-in FoxyProxy or the proxy server Privoxy, are possible but could introduce leaks in your setup. How do I connect to IRC within I2P? A tunnel to the main IRC server within I2P, Irc2P, is created when I2P is installed (see the I2PTunnel configuration page), and is automatically started when the I2P router starts. To connect to it, tell your IRC client to connect to localhost 6668. HexChat-like client users can create a new network with the server localhost/6668 (remember to tick \"Bypass proxy server\" if you have a proxy server configured). Weechat users can use the following command to add a new network: /server add irc2p localhost/6668 How do I set up my own I2P Site? The easiest method is to click on the i2ptunnel link in the router console and create a new 'Server Tunnel'. You can serve dynamic content by setting the tunnel destination to the port of an existing webserver, such as Tomcat or Jetty. You can also serve static content. For this, set the tunnel destination to: 0.0.0.0 port 7659 and place the content in the ~/.i2p/eepsite/docroot/ directory. (On non-Linux systems, this may be in a different place. Check the router console.) The 'eepsite' software comes as part of the I2P installation package and is set to automatically start when I2P is started. The default site this creates can be accessed at http://127.0.0.1:7658. However, your 'eepsite' is also accessible to others via your eepsite key file, located at: ~/.i2p/eepsite/i2p/eepsite.keys. To find out more, read the readme file at: ~/.i2p/eepsite/README.txt. If I host a website at I2P at home, containing only HTML and CSS, is it dangerous? It depends on your adversary and your threat model. If you are only worried about corporate “privacy” violations, typical criminals and censorship, then it is not really dangerous. Law-enforcement will probably find you anyway if they really want to. Only hosting when you have a normal (internet) home user browser running will make it really tough to know who is hosting that part. Please consider the hosting of your I2P site just as hosting any other service - it is as dangerous - or safe - as you configure and manage it yourself. Note: There is already a way to separate hosting an i2p service(destination) from the i2p router. If you understand how it works, then you can just setup a separate machine as a server for the website (or service) that will be publicly accessible and forward that to the webserver over a [very] secure SSH tunnel or use a secured, shared, filesystem. How Does I2P find \".i2p\" websites? The I2P Address Book application maps human-readable names to long-term destinations, associated with services, making it more like a hosts file or a contact list than a network database or a DNS service. It's also local-first there is no recognized global namespace, you decide what any given .i2p domain maps to in the end. The middle-ground is something called a \"Jump Service\" which provides a human-readable name by redirecting you to a page where you will be asked \"Do you give the I2P router permission to call $SITE_CRYPTO_KEY the name $SITE_NAME.i2p\" or something to that effect. Once it's in your address book, you can generate your own jump URL's to help share the site with others. How do I add addresses to the Address Book? You cannot add an address without knowing at least the base32 or base64 of the site you want to visit. The \"hostname\" which is human-readable is only an alias for the cryptographic address, which corresponds to the base32 or base64. Without the cryptographic address, there is no way to access an I2P Site, this is by design. Distributing the address to people who do not know it yet is usually the responsibility of the Jump service provider. Visiting an I2P Site which is unknown will trigger the use of a Jump service. stats.i2p is the most reliable Jump service.\nIf you're hosting a site via i2ptunnel, then it won't have a registration with a jump service yet. To give it a URL locally, then visit the configuration page and click the button that says \"Add to Local Address Book.\" Then go to http://127.0.0.1:7657/dns to look up the addresshelper URL and share it.\nWhat ports does I2P use? The ports that are used by I2P can be divided into 2 sections: Internet-facing ports, which are used for communication with other I2P routers Local ports, for local connections These are described in detail below. Internet-facing ports\nNote: Since release 0.7.8, new installs do not use port 8887; a random port between 9000 and 31000 is selected when the program is run for the first time. The selected port is shown on the router configuration page.\nOUTBOUND UDP from the random port listed on the configuration page to arbitrary remote UDP ports, allowing for replies TCP from random high ports to arbitrary remote TCP ports Outbound UDP on port 123, allowing for replies. This is necessary for I2P's internal time sync (via SNTP - querying a random SNTP host in pool.ntp.org or another server you specify) INBOUND (Optional, recommended) UDP to the port noted on the configuration page from arbitrary locations (Optional, recommended) TCP to the port noted on configuration page from arbitrary locations Inbound TCP can be disabled on the configuration page Local I2P ports, listening only to local connections by default, except where noted:\nPORT PURPOSE DESCRIPTION 1900 UPnP SSDP UDP multicast listener Cannot be changed. Binds to all interfaces. May be disabled on confignet. 2827 BOB bridge A higher level socket API for clients. Disabled by default. May be enabled/disabled on configclients. May be changed in the bob.config file. 4444 HTTP proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTP Proxy to configure it. Include in your browser's proxy configuration for HTTP 4445 HTTPS proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTPS Proxy to configure it. Include in your browser's proxy configuration for HTTPS 6668 IRC proxy A tunnel to the inside-the-I2P IRC network. Disabled by default. Configured on the page irc.postman.i2p (IRC proxy) and may be enabled/disabled on the page i2ptunnel 7654 I2CP (client protocol) port For advanced client usage. Do not expose to an external network. 7656 SAM bridge A socket API for clients. Disabled by default. May be enabled/disabled on configclients and configured on sam. 7657 (or 7658 via SSL) Router console The router console provides valuable information about your router and the network, in addition to giving you access to configure your router and its associated applications. 7659 'eepsite' - an example webserver (Jetty) Included in the i2pinstall and i2pupdate packages - may be disabled if another webserver is available. May be configured on the page eepsite and disabled on the page i2ptunnel 7660 I2PTunnel UDP port for SSH Required for Grizzled's/novg's UDP support. Instances disabled by default. May be enabled/disabled and configured to use a different port on the page i2ptunnel. 123 NTP Port Used by NTP Time Sync. May be disabled/changed. I'm missing lots of hosts in my address book. What are some good subscription links? The address book is located at http://localhost:7657/dns where further information can be found.\nWhat are some good address book subscription links? You may try the following:\nhttp://stats.i2p/cgi-bin/newhosts.txt http://identiguy.i2p/hosts.txt How can I access the web console from my other machines or password protect it? For security purposes, the router's admin console by default only listens for connections on the local interface. There are two methods for accessing the console remotely:\nSSH Tunnel Configuring your console to be available on a Public IP address with a username \u0026amp; password These are detailed below:\nSSH Tunnel\nIf you are running a Unix-like Operating System, this is the easiest method for remotely accessing your I2P console. (Note: SSH server software is available for systems running Windows, for example https://github.com/PowerShell/Win32-OpenSSH)\nOnce you have configured SSH access to your system, the '-L' flag is passed to SSH with appropriate arguments - for example: ssh -L 7657:localhost:7657 (System_IP) where '(System_IP)' is replaced with your System's IP address. This command forwards port 7657 (the number before the first colon) to the remote system's (as specified by the string 'localhost' between the first and second colons) port 7657 (the number after the second colon). Your remote I2P console will now be available on your local system as 'http://localhost:7657' and will be available for as long as your SSH session is active. If you would like to start an SSH session without initiating a shell on the remote system, you can add the '-N' flag: ssh -NL 7657:localhost:7657 (System_IP) Configuring your console to be available on a Public IP address with a username \u0026amp; password\nOpen ~/.i2p/clients.config and replace clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ with clientApp.0.args=7657 ::1,127.0.0.1,(System_IP) ./webapps/ where you replace (System_IP) with your system's public IP address Go to http://localhost:7657/configui and add a console username and password if desired - Adding a username \u0026amp; password is highly recommended to secure your I2P console from tampering, which could lead to de-anonymization. Go to http://localhost:7657/index and hit \"Graceful restart\", which restarts the JVM and reloads the client applications After that fires up, you should now be able to reach your console remotely. Load the router console at http://(System_IP):7657 and you will be prompted for the username and password you specified in step 2 above if your browser supports the authentication popup. NOTE: You can specify 0.0.0.0 in the above configuration. This specifies an interface, not a network or netmask. 0.0.0.0 means \"bind to all interfaces\", so it can be reachable on 127.0.0.1:7657 as well as any LAN/WAN IP. Be careful when using this option as the console will be available on ALL addresses configured on your system. How can I use applications from my other machines? Please see the previous answer for instructions on using SSH Port Forwarding, and also see this page in your console: http://localhost:7657/configi2cp Is it possible to use I2P as a SOCKS proxy? The SOCKS proxy has been functional since release 0.7.1. SOCKS 4/4a/5 are supported. I2P does not have a SOCKS outproxy so it is limited to use within I2P only. Many applications leak sensitive information that could identify you on the Internet and this is a risk that one should be aware of when using the I2P SOCKS proxy. I2P only filters connection data, but if the program you intend to run sends this information as content, I2P has no way to protect your anonymity. For example, some mail applications will send the IP address of the machine they are running on to a mail server. We recommend I2P-specific tools or applications (such as I2PSnark for torrents), or applications that are known to be safe to use with I2P that include popular plugins found on Firefox. How do I access IRC, BitTorrent, or other services on the regular Internet? There are services called Outproxies that bridge between I2P and the Internet, like Tor Exit Nodes. Default outproxy functionality for HTTP and HTTPS is provided by exit.stormycloud.i2p and is run by StormyCloud Inc. It is configured in the HTTP Proxy. Additionally, to help protect anonymity, I2P does not permit you to make anonymous connections to the regular Internet by default. Please see the Socks Outproxy page for more information. Reseeds My router has been up for several minutes and has zero or very few connections First check the http://127.0.0.1:7657/netdb page in the Router Console \u0026ndash; your network database. If you do not see a single router listed from within I2P but the console says you should be firewalled, then you probably cannot connect to the reseed servers. If you do see other I2P routers listed then try to lower the number of max connections http://127.0.0.1:7657/config maybe your router cannot handle many connections. How do I reseed manually? Under normal circumstances, I2P will connect you to the network automatically using our bootstrap links. If disrupted internet makes bootstrapping from reseed servers fail, an easy way to bootstrap is by using Tor browser(By default it open localhost), which works very nicely with http://127.0.0.1:7657/configreseed. It is also possible to reseed an I2P router manually.\nWhen using Tor browser to reseed you can select multiple URLs at once and proceed. Though the default value which is 2(out of the multiple urls) will also work but it will be slow. Privacy-Safety Is my router an \"exit node\"(outproxy) to the regular Internet? I don't want it to be. No, your router participates in the transport of encrypted e2e traffic across the i2p network to a random tunnel endpoint, usually not an outproxy, but no traffic is passed between your router and the Internet over the transport layer. As an end-user, you should not run an outproxy if you are not skilled in system and network administration. Is it easy to detect the use of I2P by analyzing network traffic? I2P traffic usually looks like UDP traffic, and not much more \u0026ndash; and making it look like not that much more is a goal. It also supports TCP. With some effort, passive traffic analysis may be able to classify the traffic as \"I2P\", but we hope that the continued development of traffic obfuscation will reduce this further. Even a fairly simple protocol obfuscation layer like obfs4 will prevent censors from blocking I2P (it is a goal that I2P deploys). Is using I2P Safe? It depends on your personal threat model. For most people, I2P is way safer than not using any protection. Some other networks (like Tor, mixminion/mixmaster), are probably safer against certain adversaries. For example, I2P traffic does not use TLS/SSL, so it does not have the \"weakest link\" issues that Tor does. I2P was used by a lot of people in Syria at the \u0026#34;Arab spring\u0026#34;, and recently the project has seen bigger growth in smaller linguistical installations of I2P in the near- and middle east. The most important thing to note here is that I2P is a technology and you need a how-to/guide to enhance your privacy/anonymity on the Internet. Also check your browser or import the fingerprint-search-engine to block fingerprint attacks with a very big (meaning: typical long tails / very accurate diverse data structure) dataset about lot of environment things and dnnt use VPN to reduce all risk comes from it self like the own TLS cache behaviour and the technical construction of the provider business that can be hacked easier as a own desktop system. May using a isolated tor V-Browser with its great anti-fingerprint protections and an overall appguard-livetime-protection with only allow for the necessary systems communications and a last standing vm-use with anti-spy disable scripts and live-cd to remove any \"almost permanent possible risk\" and down all risks by a decreasing prpbability are a good option in public network and top individual risk model and might be the best you can do with this goal for i2p use. I see IP addresses of all other I2P nodes in the router console. Does that mean my IP address is visible by others? Yes, for other I2P nodes who know about your router. We use this to connect with the rest of the I2P network. The addresses are physically located in \"routerInfos (key,value)objects\", either remotely fetched or received from peer. The \"routerInfos\" holds some information (some optional opportunistic added), \"published by peer\", about the router itself for bootstrapping. No data is in this object about clients. Looking closer under the hood will tell you that everybody got counted with the newest type of creating ids called \"SHA-256 Hashes (low=Positive hash(-key), high=Negative hash(+key))\". The I2P network got a own database datas of routerInfos created during upload and indexing, but this depends deep into the realization of the key/value tables and networks topology and state-of-load / state-of-bandwidth and routing probabilities for storages in DB components. Is using an outproxy safe? It depends on what your definition of \"safe\" is. Outproxies are great when they work, but unfortunately they voluntary run by people who may lose interest or may not have the resources to maintain them 24/7 – please be aware that you may experience periods of time during which services are unavailable, interrupted, or unreliable, and we are not associated with this service and have no influence on it. The outproxys themselves can see your traffic come and go, with the exception of end-to-end encrypted HTTPS/SSL data, just like your ISP can see your traffic come and go from your computer. If you are comfortable with your ISP, it wouldn't be any worse with the outproxy. What about \"De-Anonymizing\" attacks? For a very long explanation, read more at our articles about Threat Model. In general, de-anonymizing is not trivial, but possible if you are not cautious enough. Internet Access/Performance I can't access regular Internet sites through I2P. Proxying to Internet sites (eepsites that are out to the Internet) is provided as a service to I2P users by non-block providers. This service is not the main focus of I2P development, and is provided on a voluntary basis. Eepsites that are hosted on I2P should always work without an outproxy. Outproxies are a convenience but they are by design not perfect nor a large part of the project. Be aware that they may not be able to provide the high-quality service other services of I2P may provide. I can't access https:// or ftp:// sites through I2P. The default HTTP proxy supports HTTP and HTTPS outproxying only. Why is my router using too much CPU? First, make sure you have the latest version of every I2P related part – older versions had\nunnecessary cpu-eating sections in code. There is also a performance Log that documents some of the improvements in I2P performance over time. My active peers / known peers / participating tunnels / connections / bandwidth vary dramatically over time! Is anything wrong? The general stability of the I2P network is an ongoing area of research. A particular amount of that research is focused on how small changes to configuration settings change the behavior of the router. As I2P is a peer-to-peer network, the actions by other peers will have an influence on your router's performance. What makes downloads, torrents, web browsing, and everything else slower on I2P as compared to the regular internet? I2P has different protections that add extra routing and additional layers of encryption. It also bounces traffic through other peers(Tunnels) that have their own speed and quality, some are slow, some fast. This adds up to lots of overhead and traffic at different paces in different directions. By design all these things will make it slower compared to a direct connection on the internet, but much more anonymous and still fast enough for most things. Below is an example presented with an explanation to help provide some context to the latency and bandwidth considerations when using I2P. Consider the diagram below. It depicts a connection between a client making a request via I2P, a server receiving the request via I2P and then responding back via I2P as well. The circuit the request travels upon is also depicted. From the diagram, consider that the boxes labelled 'P', 'Q' and 'R' represent an outbound tunnel for 'A' and that the boxes labelled 'X', 'Y' and 'Z' repres ent an outbound tunnel for 'B'. Similarly, the boxes labelled 'X', 'Y' and 'Z' represent and inbound tunnel for 'B' while the boxes labelled 'P_1', 'Q_1' and 'R_1' represent an inbound tunnel for 'A'. The arrows in between the boxes show the direction of traffic. The text above and below the arrows detail some example bandwidth between a pair of hops as well as example latencies. When both client and server are using 3-hop tunnels throughout, a total of 12 other I2P routers are involved in relaying traffic. 6 peers relay traffic from the client to the server which is split into a 3-hop outbound tunnel from 'A' ('P', 'Q', 'R') and a 3-hop inbound tunnel to 'B' ('X', 'Y', 'Z'). Similarly, 6 peers relay traffic from the server to back to the client. First, we can consider latency - the time that it takes for a request from a client to traverse the I2P network, reach the the server and traverse back to the client. Adding up all latencies we see that: 40 + 100 + 20 + 60 + 80 + 10 + 30 ms (client to server) + 60 + 40 + 80 + 60 + 100 + 20 + 40 ms (server to client) ----------------------------------- TOTAL: 740 ms The total round-trip time in our example adds up to 740 ms - certainly much higher than what one would normally see while browsing regular internet websites. Second, we can consider available bandwidth. This is determined through the slowest link between hops from the client and server as well as when traffic is being transmitted by the server to the client. For traffic going from the client to the server, we see that the available bandwidth in our example between hops 'R' \u0026amp; 'X' as well as hops 'X' \u0026amp; 'Y' is 32 KB/s. Despite higher available bandwidth between the other hops, these hops will act as a bottleneck and will limit the maximum available bandwidth for traffic from 'A' to 'B' at 32 KB/s. Similarly, tracing the path from server to client shows that there is maximum bandwidth of 64 KB/s - between hops 'Z_1' \u0026amp; 'Y_1, 'Y_1' \u0026amp; 'X_1' and 'Q_1' \u0026amp; 'P_1'. We recommend increasing your bandwidth limits. This helps the network by increasing the amount of available bandwidth which will in turn improve your I2P experience. Bandwidth settings are located on the http://localhost:7657/config page. Please be aware of your internet connection's limits as determined by your ISP, and adjust your settings accordingly. We also recommend setting a sufficient amount of shared bandwidth - this allows for participating tunnels to be routed through your I2P router. Allowing participating traffic keeps your router well-integrated in the network and improves your transfer speeds. I2P is a work in progress. Lots of improvements and fixes are being implemented, and, generally speaking, running the latest release will help your performance. If you haven't, install the latest release. I think I found a bug, where can I report it? You may report any bugs/issues that you encounter on our bugtracker, which is available over both non-private internet and I2P. We have a discussion forum, also available on I2P and non-private internet. You can join our IRC channel as well: either through our IRC network, IRC2P, or on Freenode.\nOur Bugtracker: Non-private internet: https://i2pgit.org/I2P_Developers/i2p.i2p/issues On I2P: http://git.idk.i2p/I2P_Developers/i2p.i2p/issues Our forums: i2pforum.i2p You may paste any interesting logs to a paste service such as the non-private internet services listed on the PrivateBin Wiki, or an I2P paste service such as this PrivateBin instance or this Javascript-free paste service and follow up on IRC in #i2p Join #i2p-dev Discuss with the developers on IRC Please include relevant information from the router logs page which is available at: http://127.0.0.1:7657/logs. We request that you share all of the text under the 'I2P Version and Running Environment' section as well as any errors or warnings displayed in the various logs displayed on the page. I have a question! Great! Find us on IRC: on irc.freenode.net channel #i2p on IRC2P channel #i2p or post to the forum and we'll post it here (with the answer, hopefully). ","description":"Comprehensive I2P FAQ: router help, configuration, reseeds, privacy/safety, performance, and troubleshooting","id":"b0f8e4ee3509d229b406a0b0bb933ca4","section":"docs","title":"Frequently Asked Questions","url":"/en/docs/overview/faq/"},{"categories":null,"content":" 1. Overview Garlic routing remains one of I2P’s core innovations, combining layered encryption, message bundling, and unidirectional tunnels.\nWhile conceptually similar to onion routing, it extends the model to bundle multiple encrypted messages (“cloves”) in a single envelope (“garlic”), improving efficiency and anonymity.\nThe term garlic routing was coined by Michael J. Freedman in Roger Dingledine’s Free Haven Master’s Thesis (June 2000, §8.1.1).\nI2P developers adopted the term in the early 2000s to reflect its bundling enhancements and unidirectional transport model, distinguishing it from Tor’s circuit‑switched design.\nSummary: Garlic routing = layered encryption + message bundling + anonymous delivery via unidirectional tunnels.\n2. The “Garlic” Terminology Historically, the term garlic has been used in three different contexts within I2P:\nLayered encryption – tunnel‑level onion‑style protection Bundling multiple messages – multiple “cloves” inside a “garlic message” End‑to‑end encryption – formerly ElGamal/AES+SessionTags, now ECIES‑X25519‑AEAD‑Ratchet While the architecture remains intact, the encryption scheme has been completely modernized.\n3. Layered Encryption Garlic routing shares its foundational principle with onion routing:\neach router decrypts only one layer of encryption, learning only the next hop and not the full path.\nHowever, I2P implements unidirectional tunnels, not bidirectional circuits:\nOutbound tunnel: sends messages away from the creator Inbound tunnel: carries messages back to the creator A full round trip (Alice ↔ Bob) uses four tunnels:\nAlice’s outbound → Bob’s inbound, then Bob’s outbound → Alice’s inbound.\nThis design halves correlation data exposure compared to bidirectional circuits.\nFor tunnel implementation details, see the Tunnel Specification\nand the Tunnel Creation (ECIES) specification.\n4. Bundling Multiple Messages (The “Cloves”) Freedman’s original garlic routing envisioned bundling multiple encrypted “bulbs” within one message.\nI2P implements this as cloves inside a garlic message — each clove has its own encrypted delivery instructions and target (router, destination, or tunnel).\nGarlic bundling allows I2P to:\nCombine acknowledgments and metadata with data messages Reduce observable traffic patterns Support complex message structures without extra connections Figure 1: A Garlic Message containing multiple cloves, each with its own delivery instructions.\nTypical cloves include:\nDelivery Status Message — acknowledgments confirming delivery success or failure.\nThese are wrapped in their own garlic layer to preserve confidentiality. Database Store Message — automatically bundled LeaseSets so peers can reply without re‑querying the netDb. Cloves are bundled when:\nA new LeaseSet must be published New session tags are delivered No bundle has occurred recently (~1 minute by default) Garlic messages achieve efficient end‑to‑end delivery of multiple encrypted components in a single packet.\n5. Encryption Evolution 5.1 Historical Context Early documentation (≤ v0.9.12) described ElGamal/AES+SessionTags encryption:\nElGamal 2048‑bit wrapped AES session keys AES‑256/CBC for payload encryption 32‑byte session tags used once per message That cryptosystem is deprecated.\n5.2 ECIES‑X25519‑AEAD‑Ratchet (Current Standard) Between 2019 and 2023, I2P migrated entirely to ECIES‑X25519‑AEAD‑Ratchet. The modern stack standardizes the following components:\nLayer ECIES Primitive or Concept Transport Layer (NTCP2, SSU2) Noise_NX → X25519, ChaCha20/Poly1305, BLAKE2s I2NP Delivery ECIES‑X25519‑AEAD (ChaCha20/Poly1305) Session Management Ratchet with rekey records, per-clove key material Offline Authentication EdDSA (Ed25519) with LeaseSet2/MetaLeaseSet chains Benefits of the ECIES migration:\nForward secrecy via per-message ratcheting keys Reduced payload size compared to ElGamal Resilience against cryptanalytic advances Compatibility with future post-quantum hybrids (see Proposal 169) Additional details: see the ECIES Specification and EncryptedLeaseSet specification.\n6. LeaseSets and Garlic Bundling Garlic envelopes frequently include LeaseSets to publish or update destination reachability.\nVersion Type Key Capabilities Distribution Notes 1 LeaseSet (legacy) Single encryption/signature pair Accepted for backward compatibility 3 LeaseSet2 Multiple crypto suites, offline signing keys Default for modern routers 5 EncryptedLeaseSet Access-controlled, destination hidden from floodfill Requires shared decryption key 7 MetaLeaseSet Aggregates multiple destinations or multi-homed services Extends LeaseSet2 fields recursively All LeaseSets are distributed through the floodfill DHT maintained by specialized routers. Publications are verified, timestamped, and rate-limited to reduce metadata correlation.\nSee the Network Database documentation for details.\n7. Modern “Garlic” Applications within I2P Garlic-based encryption and message bundling are used throughout the I2P protocol stack:\nTunnel creation and usage — layered encryption per hop End-to-end message delivery — bundled garlic messages with cloned-acknowledgment and LeaseSet cloves Network Database publishing — LeaseSets wrapped in garlic envelopes for privacy SSU2 and NTCP2 transports — underlay encryption using Noise framework and X25519/ChaCha20 primitives Garlic routing is thus both a method of encryption layering and a network messaging model.\n8. Current Documentation and References I2P\u0026rsquo;s documentation hub is available here, maintained continuously.\nRelevant living specifications include:\n/spec/ecies — ECIES‑X25519‑AEAD‑Ratchet /spec/tunnel-creation-ecies — modern tunnel build protocol /spec/i2np — I2NP message formats /spec/ssu2 — SSU2 UDP transport /docs/specs/common-structures — netDb and floodfill behavior Academic validation:\nHoang et al. (IMC 2018, USENIX FOCI 2019) and Muntaka et al. (2025) confirm the architectural stability and operational resilience of I2P’s design.\n9. Future Work Ongoing proposals:\nProposal 169: Hybrid post-quantum (ML-KEM 512/768/1024 + X25519) Proposal 168: Transport bandwidth optimization Datagram and streaming updates: Enhanced congestion management Future adaptations may include additional message delay strategies or multi-tunnel redundancy at the garlic-message level, building on unused delivery options originally described by Freedman.\n10. References Freedman, M. J. \u0026amp; Dingledine, R. (2000). Free Haven Master\u0026rsquo;s Thesis, § 8.1.1. Free Haven Papers Onion Router Publications Garlic Routing (Wikipedia) Tor Project Free Haven Anonbib Goldschlag, D. M., Reed, M. G., Syverson, P. F. (1996). Hiding Routing Information. NRL Publication. Summary:\nGarlic routing remains architecturally unchanged from 2014 to 2025 — continuing to define I2P’s unique approach to message confidentiality and unidirectional anonymity.\nHowever, its cryptographic foundation is now entirely ECIES-based, delivering forward secrecy, lower overhead, and compatibility with future post-quantum security standards.\n","description":"Understanding garlic routing terminology, architecture, and modern implementation in I2P","id":"ba07d93d883918641f4a69832e497bb8","section":"docs","title":"Garlic Routing","url":"/en/docs/overview/garlic-routing/"},{"categories":null,"content":"Overview NOTE: OBSOLETE - We now support three formats, in order of preference:\nMaxmind geoip2 (GeoLite2-Country.mmdb) bundled with all installs except Debian packages and Android Maxmind geoip1 (GeoIP.dat) in the Debian geoip-database package The IPv4 Tor format (geoip.txt) and the custom IPv6 format (geoipv6.dat.gz) documented below, still supported but unused. This page specifies the format of the various GeoIP files, used by the router to look up a country for an IP.\nCountry Name (countries.txt) Format This format is easily generated from data files available from many public sources. For example:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Format specifications:\nEncoding is UTF-8 \u0026lsquo;#\u0026rsquo; in column 1 specifies a comment line Entry lines are CountryCode,CountryName CountryCode is the ISO two-letter code, upper case CountryName is in English IPv4 (geoip.txt) Format This format is borrowed from Tor and is easily generated from data files available from many public sources. For example:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f3-5 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; \u0026gt; geoip.txt $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Format specifications:\nEncoding is ASCII \u0026lsquo;#\u0026rsquo; in column 1 specifies a comment line Entry lines are FromIP,ToIP,CountryCode FromIP and ToIP are unsigned integer representations of the 4-byte IP CountryCode is the ISO two-letter code, upper case Entry lines must be sorted by numeric FromIP IPv6 (geoipv6.dat.gz) Format This is a compressed binary format designed for I2P. The file is gzipped. Ungzipped format:\nBytes 0-9: Magic number \u0026#34;I2PGeoIPv6\u0026#34; Bytes 10-11: Version (0x0001) Bytes 12-15 Options (0x00000000) (future use) Bytes 16-23: Creation date (ms since 1970-01-01) Bytes 24-xx: Optional comment (UTF-8) terminated by zero byte Bytes xx-255: null padding Bytes 256-: 18 byte records: 8 byte from (/64) 8 byte to (/64) 2 byte ISO country code LOWER case (ASCII) NOTES:\nData must be sorted (SIGNED long twos complement), no overlap. So the order is 80000000 \u0026hellip; FFFFFFFF 00000000 \u0026hellip; 7FFFFFFF. The GeoIPv6.java class contains a program to generate this format from public sources such as the Maxmind GeoLite data. IPv6 GeoIP lookup is supported as of release 0.9.8. ","description":"Legacy GeoIP file format specifications for IP to country lookups","id":"b5f34a4f13210a8caf4c4d0b5e62a828","section":"docs","title":"GeoIP File Formats","url":"/en/docs/legacy/geoip-file-formats/"},{"categories":null,"content":"When network conditions make git clone unreliable, you can distribute repositories as git bundles over BitTorrent or any other file transport. A bundle is a single file containing the entire repository history. Once downloaded, you fetch from it locally and then switch back to the upstream remote.\n1. Before You Start Generating a bundle requires a complete Git clone. Shallow clones created with --depth 1 will silently produce broken bundles that appear to work but fail when others try to use them. Always fetch from a trusted source (GitHub at github.com/i2p/i2p.i2p, the I2P Gitea instance at i2pgit.org, or git.idk.i2p over I2P) and run git fetch --unshallow if necessary to convert any shallow clone to a full clone before creating bundles.\nIf you are only consuming an existing bundle, just download it. No special preparation required.\n2. Downloading a Bundle Obtaining the Bundle File Download the bundle file via BitTorrent using I2PSnark (the built-in torrent client in I2P) or other I2P-compatible clients like BiglyBT with the I2P plugin.\nImportant: I2PSnark only works with torrents specifically created for the I2P network. Standard clearnet torrents are not compatible because I2P uses Destinations (387+ byte addresses) instead of IP addresses and ports.\nThe bundle file location depends on your I2P installation type:\nUser/manual installations (installed with Java installer): ~/.i2p/i2psnark/ System/daemon installations (installed via apt-get or package manager): /var/lib/i2p/i2p-config/i2psnark/ BiglyBT users will find downloaded files in their configured downloads directory.\nCloning from the Bundle Standard method (works in most cases):\ngit clone ~/.i2p/i2psnark/i2p.i2p.bundle If you encounter fatal: multiple updates for ref errors (a known issue in Git 2.21.0 and later when global Git config contains conflicting fetch refspecs), use the manual initialization approach:\nmkdir i2p.i2p \u0026amp;\u0026amp; cd i2p.i2p git init git fetch ~/.i2p/i2psnark/i2p.i2p.bundle Alternatively, you can use the --update-head-ok flag:\ngit fetch --update-head-ok ~/.i2p/i2psnark/i2p.i2p.bundle \u0026#39;*:*\u0026#39; Switching to the Live Remote After cloning from the bundle, point your clone at the live remote so future fetches go over I2P or clearnet:\ngit remote set-url origin git@127.0.0.1:I2P_Developers/i2p.i2p Or for clearnet access:\ngit remote set-url origin https://github.com/i2p/i2p.i2p For I2P SSH access, you need an SSH client tunnel configured in your I2P router console (typically port 7670) pointing to g6u4vqiuy6bdc3dbu6a7gmi3ip45sqwgtbgrr6uupqaaqfyztrka.b32.i2p. If using a non-standard port:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7670\u0026#34; git clone git@127.0.0.1:I2P_Developers/i2p.i2p 3. Creating a Bundle Prerequisites Ensure your repository is fully up to date with a complete clone (not shallow):\ngit fetch --all If you have a shallow clone, convert it first:\ngit fetch --unshallow Generating the Bundle Using the Ant build target (recommended for I2P source tree):\nant git-bundle This creates both i2p.i2p.bundle (the bundle file) and i2p.i2p.bundle.torrent (BitTorrent metadata).\nUsing git bundle directly:\ngit bundle create i2p.i2p.bundle --all For more selective bundles:\ngit bundle create i2p.i2p.bundle --branches --tags Verifying Your Bundle Always verify the bundle before distributing:\ngit bundle verify i2p.i2p.bundle This confirms the bundle is valid and shows any prerequisite commits required.\nDistributing via I2PSnark Copy the bundle and its torrent metadata into your I2PSnark directory:\nFor user installations:\ncp i2p.i2p.bundle* ~/.i2p/i2psnark/ For system installations:\ncp i2p.i2p.bundle* /var/lib/i2p/i2p-config/i2psnark/ I2PSnark automatically detects and loads .torrent files within seconds. Access the web interface at http://127.0.0.1:7657/i2psnark to start seeding.\n4. Creating Incremental Bundles For periodic updates, create incremental bundles containing only new commits since the last bundle:\ngit tag lastBundleTag git bundle create update.bundle lastBundleTag..master Users can fetch from the incremental bundle if they already have the base repository:\ngit fetch /path/to/update.bundle Always verify incremental bundles show the expected prerequisite commits:\ngit bundle verify update.bundle 5. Updating After the Initial Clone Once you have a working repository from the bundle, treat it like any other Git clone:\ngit remote add upstream git@127.0.0.1:I2P_Developers/i2p.i2p git fetch upstream git merge upstream/master Or for simpler workflows:\ngit fetch origin git pull origin master 6. Why Bundles Help Resilient distribution: Large repositories can be shared over BitTorrent, which handles retries, piece verification, and resume automatically. Peer-to-peer bootstrap: New contributors can bootstrap their clone from nearby peers on the I2P network, then fetch incremental changes directly from Git hosts. Reduced server load: Mirrors can publish periodic bundles to relieve pressure on live Git hosts, especially useful for large repositories or slow network conditions. Offline transport: Bundles work on any file transport (USB drives, direct transfers, sneakernet), not just BitTorrent. Bundles do not replace live remotes. They simply provide a more resilient bootstrapping method for initial clones or major updates.\n7. Troubleshooting Shallow Clone Issues Problem: Bundle creation succeeds but others cannot clone from the bundle.\nCause: Your source clone is shallow (created with --depth).\nSolution: Convert to full clone before creating bundles:\ngit fetch --unshallow Multiple Updates for Ref Error Problem: fatal: multiple updates for ref when cloning from bundle.\nCause: Git 2.21.0+ conflicts with global fetch refspecs in ~/.gitconfig.\nSolutions:\nUse manual initialization: mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init \u0026amp;\u0026amp; git fetch /path/to/bundle Use --update-head-ok flag: git fetch --update-head-ok /path/to/bundle '*:*' Remove conflicting config: git config --global --unset remote.origin.fetch Bundle Verification Fails Problem: git bundle verify reports missing prerequisites.\nCause: Incremental bundle or incomplete source clone.\nSolution: Either fetch prerequisite commits or use the base bundle first, then apply incremental updates.\nAdditional Resources For comprehensive Git over I2P setup, SSH tunnel configuration, and hosting your own repositories, see the Git over I2P guide at the official I2P documentation site.\nFor I2P installation and setup, visit geti2p.net.\n","description":"Fetching and distributing large repositories with git bundle and BitTorrent","id":"555586cb7b43c73ad912bbb01f20326b","section":"docs","title":"Git Bundles for I2P","url":"/en/docs/applications/git-bundle/"},{"categories":null,"content":"Cloning and pushing repositories inside I2P uses the same Git commands you already know—your client simply connects through I2P tunnels instead of TCP/IP. This guide walks through setting up an account, configuring tunnels, and dealing with slow links.\nQuick start: Read-only access works through the HTTP proxy: http_proxy=http://127.0.0.1:4444 git clone http://example.i2p/project.git. Follow the steps below for SSH read/write access.\n1. Create an Account Choose an I2P Git service and register:\nInside I2P: http://git.idk.i2p Clearnet mirror: https://i2pgit.org Registration may require manual approval; check the landing page for instructions. Once approved, fork or create a repository so you have something to test with.\n2. Configure an I2PTunnel Client (SSH) Open the router console → I2PTunnel and add a new Client tunnel. Enter the service’s destination (Base32 or Base64). For git.idk.i2p you’ll find both HTTP and SSH destinations on the project home page. Choose a local port (for example localhost:7442). Enable autostart if you plan to use the tunnel frequently. The UI will confirm the new tunnel and show its status. When it is running, SSH clients can connect to 127.0.0.1 on the chosen port.\n3. Clone via SSH Use the tunnel port with GIT_SSH_COMMAND or an SSH config stanza:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone git@127.0.0.1:your-project/example.git If the first attempt fails (tunnels can be slow), try a shallow clone:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone --depth 1 git@127.0.0.1:your-project/example.git cd example git fetch --unshallow Configure Git to fetch all branches:\ngit config remote.origin.fetch \u0026#34;+refs/heads/*:refs/remotes/origin/*\u0026#34; git fetch origin Performance Tips Add one or two backup tunnels in the tunnel editor to improve resilience. For testing or low-risk repos you may reduce tunnel length to 1 hop, but be aware of the anonymity trade-off. Keep GIT_SSH_COMMAND in your environment or add an entry to ~/.ssh/config: Host git.i2p HostName 127.0.0.1 Port 7442 User git Then clone using git clone git@git.i2p:namespace/project.git.\n4. Workflow Suggestions Adopt a fork-and-branch workflow common on GitLab/GitHub:\nSet an upstream remote: git remote add upstream git@git.i2p:I2P_Developers/i2p.i2p Keep your master in sync: git pull upstream master Create feature branches for changes: git checkout -b feature/new-thing Push branches to your fork: git push origin feature/new-thing Submit a merge request, then fast-forward your fork’s master from upstream. 5. Privacy Reminders Git stores commit timestamps in your local timezone. To force UTC timestamps: git config --global alias.utccommit \u0026#39;!git commit --date=\u0026#34;$(date --utc +%Y-%m-%dT%H:%M:%S%z)\u0026#34;\u0026#39; Use git utccommit instead of git commit when privacy matters.\nAvoid embedding clearnet URLs or IPs in commit messages or repository metadata if anonymity is a concern. 6. Troubleshooting Symptom Fix connection closed during clone Retry with --depth 1, add backup tunnels, or increase tunnel quantities. ssh: connect to host 127.0.0.1 port …: Connection refused Ensure the I2PTunnel client is running and SAM is enabled. Slow performance Lower tunnel length, increase bandwidth limits, or schedule large fetches during off-peak hours. For advanced scenarios (mirroring external repos, seeding bundles), see the companion guides: Git bundle workflows and Hosting GitLab over I2P.\n","description":"Connecting Git clients to I2P-hosted services such as i2pgit.org","id":"17704a86e8676ba273355af4fa703c15","section":"docs","title":"Git over I2P","url":"/en/docs/applications/git/"},{"categories":null,"content":"This glossary defines common terms used throughout I2P documentation and discussions.\nB Blockchain A distributed ledger that can record transactions between multiple parties efficiently and in a verifiable and permanent way.\nD Decentralization Network architecture that avoids reliance on a single party. Encompasses peer-to-peer, blockchain, federated, and distributed technologies.\nDestination The cryptographic identity of a tunnel. These are the identities of clients and servers within the I2P network.\nDHT (Distributed Hash Table) Used in some projects to connect peers to each other by storing information in the form of key-value pairs in a distributed manner.\nDistributed Systems Academic topic within Computer Science concerned with the design of computer systems that consist of many individual computers connected over a network.\nF Federated Federation allows separate deployments of a service to communicate with each other through a common protocol.\nH Hash A number, usually displayed as a string of letters and numbers. It can serve as a \u0026ldquo;fingerprint\u0026rdquo; uniquely identifying data.\nI I2P Invisible Internet Project: a project meant to provide an anonymity layer, so users can communicate anonymously using a range of applications.\nIP Address A number of a computer or network which is unique and thus can be used to address it.\nL LeaseSet A collection of information required to communicate with a client or server at a particular Destination.\nP Peer-to-Peer (P2P) Peers make a portion of their resources directly available to other network participants, without the need for central coordination by servers or stable hosts.\nR Router The core I2P software, which routes encrypted packets on the I2P network.\nRouterIdentity A collection of information required to communicate directly with a router.\nT TCP/UDP The two foundational transport protocols used on the Internet.\nTunnel An anonymous communication pathway between a client or server and the I2P network.\nU UX User experience, the overall experience of a person using a product or service.\nW WebRTC A protocol standard for establishing connections in a web browser where data passes directly between users.\n","description":"Common terms and definitions used in I2P documentation","id":"2235ec8f316773700ef08dd43b19a1c0","section":"docs","title":"Glossary","url":"/en/docs/overview/glossary/"},{"categories":null,"content":"Overview I2CP is the low-level control protocol between an I2P router and any client process. It defines a strict separation of responsibilities:\nRouter: Manages routing, cryptography, tunnel lifecycles, and network database operations Client: Selects anonymity properties, configures tunnels, and submits/receives messages All communication flows over a single TCP socket (optionally TLS-wrapped), enabling asynchronous, full-duplex operations.\nProtocol Version: I2CP uses a protocol version byte 0x2A (42 decimal) sent during initial connection establishment. This version byte has remained stable since the protocol\u0026rsquo;s inception.\nCurrent Status: This specification is accurate for router version 0.9.67 (API version 0.9.67), released 2025-09.\nImplementation Context Java Implementation The reference implementation is in Java I2P:\nClient SDK: i2p.jar package Router implementation: router.jar package Javadocs: http://docs.i2p-projekt.de/javadoc/ When client and router run in the same JVM, I2CP messages are passed as Java objects without serialization. External clients use the serialized protocol over TCP.\nC++ Implementation i2pd (the C++ I2P router) also implements I2CP externally for client connections.\nNon-Java Clients There are no known non-Java implementations of a complete I2CP client library. Non-Java applications should use higher-level protocols instead:\nSAM (Simple Anonymous Messaging) v3: Socket-based interface with libraries in multiple languages BOB (Basic Open Bridge): Simpler alternative to SAM These higher-level protocols handle I2CP complexity internally and also provide the streaming library (for TCP-like connections) and datagram library (for UDP-like connections).\nConnection Establishment 1. TCP Connection Connect to the router\u0026rsquo;s I2CP port:\nDefault: 127.0.0.1:7654 Configurable via router settings Optional TLS wrapper (strongly recommended for remote connections) 2. Protocol Handshake Step 1: Send protocol version byte 0x2A\nStep 2: Clock Synchronization\nClient → Router: GetDateMessage Router → Client: SetDateMessage The router returns its current timestamp and I2CP API version string (since 0.8.7).\nStep 3: Authentication (if enabled)\nAs of 0.9.11, authentication may be included in GetDateMessage via a Mapping containing:\ni2cp.username i2cp.password As of 0.9.16, when authentication is enabled, it must be completed via GetDateMessage before any other messages are sent.\nStep 4: Session Creation\nClient → Router: CreateSessionMessage (contains SessionConfig) Router → Client: SessionStatusMessage (status=Created) Step 5: Tunnel Ready Signal\nRouter → Client: RequestVariableLeaseSetMessage This message signals that inbound tunnels have been built. The router will NOT send this until at least one inbound AND one outbound tunnel exist.\nStep 6: LeaseSet Publication\nClient → Router: CreateLeaseSet2Message At this point, the session is fully operational for sending and receiving messages.\nMessage Flow Patterns Outgoing Message (Client sends to remote destination) With i2cp.messageReliability=none:\nClient → Router: SendMessageMessage (nonce=0) [No acknowledgments] With i2cp.messageReliability=BestEffort:\nClient → Router: SendMessageMessage (nonce\u0026gt;0) Router → Client: MessageStatusMessage (status=Accepted) Router → Client: MessageStatusMessage (status=Success or Failure) Incoming Message (Router delivers to client) With i2cp.fastReceive=true (default since 0.9.4):\nRouter → Client: MessagePayloadMessage [No acknowledgment required] With i2cp.fastReceive=false (DEPRECATED):\nRouter → Client: MessageStatusMessage (status=Available) Client → Router: ReceiveMessageBeginMessage Router → Client: MessagePayloadMessage Client → Router: ReceiveMessageEndMessage Modern clients should always use fast receive mode.\nCommon Data Structures I2CP Message Header All I2CP messages use this common header:\n+----+----+----+----+----+----+----+----+ | Body Length (4 bytes) | +----+----+----+----+----+----+----+----+ |Type| Message Body (variable) | +----+----+----+----+----+----+----+----+ Body Length: 4-byte integer, length of message body only (excludes header) Type: 1-byte integer, message type identifier Message Body: 0+ bytes, format varies by message type Message Size Limit: Approximately 64 KB maximum.\nSession ID 2-byte integer uniquely identifying a session on a router.\nSpecial Value: 0xFFFF indicates \u0026ldquo;no session\u0026rdquo; (used for hostname lookups without an established session).\nMessage ID 4-byte integer generated by the router to uniquely identify a message within a session.\nImportant: Message IDs are not globally unique, only unique within a session. They are also distinct from the nonce generated by the client.\nPayload Format Message payloads are gzip-compressed with a standard 10-byte gzip header:\nStarts with: 0x1F 0x8B 0x08 (RFC 1952) Since 0.7.1: Unused portions of gzip header contain protocol, from-port, and to-port information This enables streaming and datagrams on the same destination Compression Control: Set i2cp.gzip=false to disable compression (sets gzip effort to 0). The gzip header is still included, but with minimal compression overhead.\nSessionConfig Structure Defines configuration for a client session:\n+----------------------------------+ | Destination | +----------------------------------+ | Mapping (configuration options) | +----------------------------------+ | Creation Date | +----------------------------------+ | Signature | +----------------------------------+ Critical Requirements:\nMapping must be sorted by key for signature validation Creation Date must be within ±30 seconds of router\u0026rsquo;s current time Signature is created by the SigningPrivateKey of the Destination Offline Signatures (as of 0.9.38):\nIf using offline signing, the Mapping must contain:\ni2cp.leaseSetOfflineExpiration i2cp.leaseSetTransientPublicKey i2cp.leaseSetOfflineSignature The Signature is then generated by the transient SigningPrivateKey.\nCore Configuration Options Tunnel Configuration Option Default Description inbound.length 3 Number of hops for inbound tunnels outbound.length 3 Number of hops for outbound tunnels inbound.lengthVariance 0 Random variance in hop count (since 0.7.6) outbound.lengthVariance 0 Random variance in hop count (since 0.7.6) inbound.quantity 2 Number of concurrent inbound tunnels outbound.quantity 2 Number of concurrent outbound tunnels inbound.backupQuantity 0 Standby inbound tunnels (hot spares) outbound.backupQuantity 0 Standby outbound tunnels (hot spares) inbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) outbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) Notes:\nValues for quantity \u0026gt; 6 require peers running 0.9.0+ and significantly increase resource usage Set backupQuantity to 1-2 for high-availability services Zero-hop tunnels sacrifice anonymity for latency but are useful for testing Message Handling Option Default Description clientMessageTimeout 60000\u0026nbsp;ms Legacy timeout for message delivery i2cp.messageReliability BestEffort None, BestEffort, or Guaranteed i2cp.fastReceive true Skip ReceiveMessageBegin/End handshake (default since 0.9.4) i2cp.gzip true Enable gzip compression of message payloads outbound.priority 0 Priority for outbound scheduling (-25 to +25) Message Reliability:\nNone: No router acknowledgments (streaming library default since 0.8.1) BestEffort: Router sends acceptance + success/failure notifications Guaranteed: Unimplemented (currently behaves like BestEffort) Per-Message Override (since 0.9.14):\nIn a session with messageReliability=none, setting a nonzero nonce requests delivery notification for that specific message Setting nonce=0 in a BestEffort session disables notifications for that message LeaseSet Configuration Option Default Description i2cp.dontPublishLeaseSet false Disable automatic LeaseSet publication (for client-only destinations) i2cp.leaseSetType 1 LeaseSet variant: 1 = standard, 3 = LS2, 5 = encrypted, 7 = meta i2cp.leaseSetEncType 0 Comma-separated encryption type codes (see below) Legacy ElGamal/AES Session Tags These options are relevant only for legacy ElGamal encryption:\nOption Default Description crypto.lowTagThreshold 30 Minimum session tags before replenishing crypto.tagsToSend 40 Number of tags to send in a batch Note: ECIES-X25519 clients use a different ratchet mechanism and ignore these options.\nEncryption Types I2CP supports multiple end-to-end encryption schemes via the i2cp.leaseSetEncType option. Multiple types can be specified (comma-separated) to support both modern and legacy peers.\nSupported Encryption Types Type Algorithm Key Size Since Status 0 ElGamal/AES+SessionTags 2048-bit ElGamal Original Legacy 1-3 Reserved - - Unused 4 ECIES-X25519-AEAD-Ratchet 32-byte X25519 0.9.46 Current Standard 5 ECIES-X25519-AEAD-Ratchet + ML-KEM-768 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 6 ECIES-X25519-AEAD-Ratchet + ML-KEM-1024 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 7 Reserved (likely ML-KEM-512 hybrid) 32\u0026nbsp;+\u0026nbsp;PQ Future Planned Recommended Configuration:\ni2cp.leaseSetEncType=4,0 This provides X25519 (preferred) with ElGamal fallback for compatibility.\nEncryption Type Details Type 0 - ElGamal/AES+SessionTags:\n2048-bit ElGamal public keys (256 bytes) AES-256 symmetric encryption 32-byte session tags sent in batches High CPU, bandwidth, and memory overhead Being phased out network-wide Type 4 - ECIES-X25519-AEAD-Ratchet:\nX25519 key exchange (32-byte keys) ChaCha20/Poly1305 AEAD Signal-style double ratchet 8-byte session tags (vs 32-byte for ElGamal) Tags generated via synchronized PRNG (not sent in advance) ~92% overhead reduction vs ElGamal Standard for modern I2P (most routers use this) Types 5-6 - Post-Quantum Hybrid:\nCombines X25519 with ML-KEM (NIST FIPS 203) Provides quantum-resistant security ML-KEM-768 for balanced security/performance ML-KEM-1024 for maximum security Larger message sizes due to PQ key material Network support still being deployed Migration Strategy The I2P network is actively migrating from ElGamal (type 0) to X25519 (type 4):\nNTCP → NTCP2 (complete) SSU → SSU2 (complete) ElGamal tunnels → X25519 tunnels (complete) ElGamal end-to-end → ECIES-X25519 (majority complete) LeaseSet2 and Advanced Features LeaseSet2 Options (since 0.9.38) Option Since Purpose i2cp.leaseSetType 0.9.38 Specifies LeaseSet variant (1, 3, 5, 7) i2cp.leaseSetEncType 0.9.38 Encryption types supported (comma-separated) i2cp.leaseSetAuthType 0.9.41 Per-client authentication: 0 = none, 1 = DH, 2 = PSK i2cp.leaseSetPrivKey 0.9.41 X25519 private key for decrypting LS2 with auth i2cp.leaseSetSecret 0.9.39 Base64 secret for blinded addresses i2cp.leaseSetTransientPublicKey 0.9.38 Transient signing key for offline signatures i2cp.leaseSetPrivateKey 0.9.18 Persistent LeaseSet encryption keys (type:key pairs) i2cp.leaseSetOption.nnn 0.9.66 Service records (proposal 167) i2cp.leaseSetClient.dh.nnn 0.9.41 DH client auth material (indexed from 0) i2cp.leaseSetClient.psk.nnn 0.9.41 PSK client auth material (indexed from 0) Blinded Addresses As of 0.9.39, destinations can use \u0026ldquo;blinded\u0026rdquo; addresses (b33 format) that change periodically:\nRequires i2cp.leaseSetSecret for password protection Optional per-client authentication See proposals 123 and 149 for details Service Records (since 0.9.66) LeaseSet2 supports service record options (proposal 167):\ni2cp.leaseSetOption.0=_smtp._tcp=1 86400 0 0 25 mail.example.b32.i2p Format follows DNS SRV record style but adapted for I2P.\nMultiple Sessions (since 0.9.21) A single I2CP connection can maintain multiple sessions:\nPrimary Session: The first session created on a connection Subsessions: Additional sessions sharing the primary\u0026rsquo;s tunnel pool\nSubsession Characteristics Shared Tunnels: Use the same inbound/outbound tunnel pools as primary Shared Encryption Keys: Must use identical LeaseSet encryption keys Different Signing Keys: Must use distinct Destination signing keys No Anonymity Guarantee: Clearly linked to primary session (same router, same tunnels) Subsession Use Case Enable communication with destinations using different signature types:\nPrimary: EdDSA signature (modern) Subsession: DSA signature (legacy compatibility) Subsession Lifecycle Creation:\nClient → Router: CreateSessionMessage Router → Client: SessionStatusMessage (unique Session ID) Router → Client: RequestVariableLeaseSetMessage (separate for each destination) Client → Router: CreateLeaseSet2Message (separate for each destination) Destruction:\nDestroying a subsession: Leaves primary session intact Destroying primary session: Destroys all subsessions and closes connection DisconnectMessage: Destroys all sessions Session ID Handling Most I2CP messages contain a Session ID field. Exceptions:\nDestLookup / DestReply (deprecated, use HostLookup / HostReply) GetBandwidthLimits / BandwidthLimits (response not session-specific) Important: Clients should not have multiple CreateSession messages outstanding simultaneously, as responses cannot be definitively correlated to requests.\nMessage Catalog Message Type Summary Type Name Direction Since Status 1 CreateSession C → R Original Current 2 ReconfigureSession C → R 0.7.1 Current 3 DestroySession C → R Original Current 4 CreateLeaseSet C → R Original Deprecated 5 SendMessage C → R Original Current 6 ReceiveMessageBegin C → R Original Deprecated 7 ReceiveMessageEnd C → R Original Deprecated 8 GetBandwidthLimits C → R 0.7.2 Current 20 SessionStatus R → C Original Current 21 RequestLeaseSet R → C Original Deprecated 22 MessageStatus R → C Original Current 23 BandwidthLimits R → C 0.7.2 Current 29 ReportAbuse Bidirectional Original Unused 30 Disconnect Bidirectional Original Current 31 MessagePayload R → C Original Current 32 GetDate C → R Original Current 33 SetDate R → C Original Current 34 DestLookup C → R 0.7 Deprecated 35 DestReply R → C 0.7 Deprecated 36 SendMessageExpires C → R 0.7.1 Current 37 RequestVariableLeaseSet R → C 0.9.7 Current 38 HostLookup C → R 0.9.11 Current 39 HostReply R → C 0.9.11 Current 41 CreateLeaseSet2 C → R 0.9.39 Current 42 BlindingInfo C → R 0.9.43 Current Legend: C = Client, R = Router\nKey Message Details CreateSessionMessage (Type 1) Purpose: Initiate a new I2CP session\nContent: SessionConfig structure\nResponse: SessionStatusMessage (status=Created or Invalid)\nRequirements:\nDate in SessionConfig must be within ±30 seconds of router time Mapping must be sorted by key for signature validation Destination must not already have an active session RequestVariableLeaseSetMessage (Type 37) Purpose: Router requests client authorization for inbound tunnels\nContent:\nSession ID Number of leases Array of Lease structures (each with individual expiration) Response: CreateLeaseSet2Message\nSignificance: This is the signal that the session is operational. The router sends this only after:\nAt least one inbound tunnel is built At least one outbound tunnel is built Timeout Recommendation: Clients should destroy the session if this message is not received within 5+ minutes of session creation.\nCreateLeaseSet2Message (Type 41) Purpose: Client publishes LeaseSet to network database\nContent:\nSession ID LeaseSet type byte (1, 3, 5, or 7) LeaseSet or LeaseSet2 or EncryptedLeaseSet or MetaLeaseSet Number of private keys Private key list (one per public key in LeaseSet, same order) Private Keys: Required for decrypting incoming garlic messages. Format:\nEncryption type (2 bytes) Key length (2 bytes) Private key data (variable) Note: Replaces deprecated CreateLeaseSetMessage (type 4), which cannot handle:\nLeaseSet2 variants Non-ElGamal encryption Multiple encryption types Encrypted LeaseSets Offline signing keys SendMessageExpiresMessage (Type 36) Purpose: Send message to destination with expiration and advanced options\nContent:\nSession ID Destination Payload (gzipped) Nonce (4 bytes) Flags (2 bytes) - see below Expiration Date (6 bytes, truncated from 8) Flags Field (2 bytes, bit order 15\u0026hellip;0):\nBits 15-11: Unused, must be 0\nBits 10-9: Message Reliability Override (unused, use nonce instead)\nBit 8: Don\u0026rsquo;t bundle LeaseSet\n0: Router may bundle LeaseSet in garlic 1: Don\u0026rsquo;t bundle LeaseSet Bits 7-4: Low tag threshold (ElGamal only, ignored for ECIES)\n0000 = Use session settings 0001 = 2 tags 0010 = 3 tags ... 1111 = 192 tags Bits 3-0: Tags to send if needed (ElGamal only, ignored for ECIES)\n0000 = Use session settings 0001 = 2 tags 0010 = 4 tags ... 1111 = 160 tags MessageStatusMessage (Type 22) Purpose: Notify client of message delivery status\nContent:\nSession ID Message ID (router-generated) Status code (1 byte) Size (4 bytes, only relevant for status=0) Nonce (4 bytes, matches client\u0026rsquo;s SendMessage nonce) Status Codes (Outgoing Messages):\nCode Name Meaning Result 1 Accepted Router accepted message Success 2 Best Effort Success Probable delivery Success 4 Guaranteed Success Probable delivery Success 6 Local Success Delivered to local client Success 3 Best Effort Failure Probable failure Failure 5 Guaranteed Failure Generic failure Failure 7 Local Failure Local delivery failed Failure 8 Router Failure Router shutdown/error Failure 9 Network Failure No network connectivity Failure 10 Bad Session Invalid/closed session Failure 11 Bad Message Invalid payload Failure 12 Bad Options Invalid options/expiration Failure 13 Overflow Failure Queue/buffer full Failure 14 Message Expired Expired before send Failure 15 Bad Local LeaseSet Local LeaseSet problem Failure 16 No Local Tunnels No tunnels available Failure 17 Unsupported Encryption Incompatible encryption Failure 18 Bad Destination Invalid remote destination Failure 19 Bad Leaseset Invalid remote LeaseSet Failure 20 Expired Leaseset Remote LeaseSet expired Failure 21 No Leaseset Remote LeaseSet not found Failure 22 Meta Leaseset Cannot send to meta LS Failure 23 Loopback Denied Same source and destination Failure Success codes: 1, 2, 4, 6 Failure codes: All others\nStatus Code 0 (DEPRECATED): Available message (incoming, fast receive disabled)\nHostLookupMessage (Type 38) Purpose: Lookup destination by hostname or hash (replaces DestLookup)\nContent:\nSession ID (or 0xFFFF for no session) Request ID (4 bytes) Timeout in milliseconds (4 bytes, min recommended: 10000) Request type (1 byte) Lookup key (Hash, hostname String, or Destination) Request Types:\nType Lookup Key Returns Since 0 Hash Destination Original 1 Hostname String Destination Original 2 Hash Destination + Options 0.9.66 3 Hostname String Destination + Options 0.9.66 4 Destination Destination + Options 0.9.66 Types 2-4 return LeaseSet options (proposal 167) if available.\nResponse: HostReplyMessage\nHostReplyMessage (Type 39) Purpose: Response to HostLookupMessage\nContent:\nSession ID Request ID Result code (1 byte) Destination (present on success, sometimes on specific failures) Mapping (only for lookup types 2-4, may be empty) Result Codes:\nCode Name Meaning 0 Success Lookup succeeded 1 Failure Generic failure 2 Lookup Password Required Blinded address requires password 3 Private Key Required Blinded address requires private key 4 Password and Key Required Blinded address requires both 5 LeaseSet Decryption Failure Cannot decrypt LeaseSet 6 LeaseSet Lookup Failure LeaseSet not found in netdb 7 Lookup Type Unsupported Router doesn't support this type BlindingInfoMessage (Type 42) Purpose: Inform router about blinded destination authentication requirements (since 0.9.43)\nContent:\nSession ID Flags (1 byte) Endpoint type (1 byte): 0=Hash, 1=hostname, 2=Destination, 3=SigType+Key Blinded signature type (2 bytes) Expiration (4 bytes, seconds since epoch) Endpoint data (varies by type) Private key (32 bytes, only if flag bit 0 set) Lookup password (String, only if flag bit 4 set) Flags (bit order 76543210):\nBit 0: 0=everybody, 1=per-client Bits 3-1: Auth scheme (if bit 0=1): 000=DH, 001=PSK Bit 4: 1=secret required Bits 7-5: Unused, set to 0 No Response: Router processes silently\nUse Case: Before sending to a blinded destination (b33 address), client must either:\nLookup the b33 via HostLookup, OR Send BlindingInfo message If the destination requires authentication, BlindingInfo is mandatory.\nReconfigureSessionMessage (Type 2) Purpose: Update session configuration after creation\nContent:\nSession ID SessionConfig (only changed options needed) Response: SessionStatusMessage (status=Updated or Invalid)\nNotes:\nRouter merges new config with existing config Tunnel options (inbound.*, outbound.*) are always applied Some options may be immutable after session creation Date must be within ±30 seconds of router time Mapping must be sorted by key DestroySessionMessage (Type 3) Purpose: Terminate a session\nContent: Session ID\nExpected Response: SessionStatusMessage (status=Destroyed)\nActual Behavior (Java I2P through 0.9.66):\nRouter never sends SessionStatus(Destroyed) If no sessions remain: Sends DisconnectMessage If subsessions remain: No reply Important: Java I2P behavior deviates from specification. Implementations should be cautious when destroying individual subsessions.\nDisconnectMessage (Type 30) Purpose: Notify that connection is about to be terminated\nContent: Reason String\nEffect: All sessions on the connection are destroyed, socket closes\nImplementation: Primarily router → client in Java I2P\nProtocol Version History Version Detection The I2CP protocol version is exchanged in Get/SetDate messages (since 0.8.7). For older routers, version information is unavailable.\nVersion String: Indicates \u0026ldquo;core\u0026rdquo; API version, not necessarily router version.\nFeature Timeline Version Key Features 0.9.67 PQ Hybrid ML-KEM (enc types 5-7) in LeaseSet 0.9.66 Host lookup/reply extensions (proposal 167), service records 0.9.62 MessageStatus loopback error code 0.9.46 X25519 (enc type 4) in LeaseSet, ECIES end-to-end 0.9.43 BlindingInfo message, extended HostReply failure codes 0.9.41 EncryptedLeaseSet options, Meta LS error code 0.9.39 CreateLeaseSet2 message, RedDSA Ed25519 support 0.9.38 Preliminary LS2 support (format changed in 0.9.39) 0.9.21 Multiple sessions on single connection 0.9.20 Additional SetDate messages for clock shifts 0.9.16 Authentication required before other messages (when enabled) 0.9.15 EdDSA Ed25519 signature type 0.9.14 Per-message reliability override with nonzero nonce 0.9.12 ECDSA P-256/384/521 signature types, RSA support 0.9.11 HostLookup/HostReply messages, auth in GetDate 0.9.7 RequestVariableLeaseSet message 0.9.5 Additional MessageStatus codes 0.9.4 Fast receive mode default, nonce=0 allowed 0.9.2 SendMessageExpires flag tag bits 0.9 16 leases per LeaseSet (up from 6) 0.8.7 Version strings in Get/SetDate 0.8.4 SendMessageExpires flag bits 0.8.3 DestLookup in standard session, concurrent lookups 0.8.1 messageReliability=none 0.7.2 GetBandwidthLimits, BandwidthLimits 0.7.1 SendMessageExpires, ReconfigureSession, ports in gzip header 0.7 DestLookup, DestReply 0.6.5- Original protocol features Security Considerations Authentication Default: No authentication required Optional: Username/password authentication (since 0.9.11) Required: When enabled, auth must complete before other messages (since 0.9.16)\nRemote Connections: Always use TLS (i2cp.SSL=true) to protect credentials and private keys.\nClock Skew SessionConfig Date must be within ±30 seconds of router time, or session will be rejected. Use Get/SetDate to synchronize.\nPrivate Key Handling CreateLeaseSet2Message contains private keys for decrypting incoming messages. These keys must be:\nTransmitted securely (TLS for remote connections) Stored securely by the router Rotated when compromised Message Expiration Always use SendMessageExpires (not SendMessage) to set explicit expiration. This:\nPrevents messages from being queued indefinitely Reduces resource consumption Improves reliability Session Tag Management ElGamal (deprecated):\nTags must be transmitted in batches Lost tags cause decryption failures High memory overhead ECIES-X25519 (current):\nTags generated via synchronized PRNG No advance transmission needed Resilient to message loss Significantly lower overhead Best Practices For Client Developers Use Fast Receive Mode: Always set i2cp.fastReceive=true (or rely on default)\nPrefer ECIES-X25519: Configure i2cp.leaseSetEncType=4,0 for best performance with compatibility\nSet Explicit Expiration: Use SendMessageExpires, not SendMessage\nHandle Subsessions Carefully: Be aware that subsessions offer no anonymity between destinations\nTimeout Session Creation: Destroy session if RequestVariableLeaseSet not received within 5 minutes\nSort Configuration Mappings: Always sort Mapping keys before signing SessionConfig\nUse Appropriate Tunnel Counts: Don\u0026rsquo;t set quantity \u0026gt; 6 unless necessary\nConsider SAM/BOB for Non-Java: Implement SAM rather than I2CP directly\nFor Router Developers Validate Dates: Enforce ±30 second window on SessionConfig dates\nLimit Message Size: Enforce ~64 KB maximum message size\nSupport Multiple Sessions: Implement subsession support per 0.9.21 spec\nSend RequestVariableLeaseSet Promptly: Only after both inbound and outbound tunnels exist\nHandle Deprecated Messages: Accept but discourage ReceiveMessageBegin/End\nSupport ECIES-X25519: Prioritize type 4 encryption for new deployments\nDebugging and Troubleshooting Common Issues Session Rejected (Invalid):\nCheck clock skew (must be within ±30 seconds) Verify Mapping is sorted by key Ensure Destination not already in use No RequestVariableLeaseSet:\nRouter may be building tunnels (wait up to 5 minutes) Check for network connectivity issues Verify sufficient peer connections Message Delivery Failures:\nCheck MessageStatus codes for specific failure reason Verify remote LeaseSet is published and current Ensure compatible encryption types Subsession Problems:\nVerify primary session created first Confirm same encryption keys Check for distinct signing keys Diagnostic Messages GetBandwidthLimits: Query router capacity HostLookup: Test name resolution and LeaseSet availability MessageStatus: Track message delivery end-to-end\nRelated Specifications Common Structures: /docs/specs/common-structures/ I2NP (Network Protocol): /docs/specs/i2np/ ECIES-X25519: /docs/specs/ecies/ Tunnel Creation: /docs/specs/implementation/ Streaming Library: /docs/specs/streaming/ Datagram Library: /docs/api/datagrams/ SAM v3: /docs/api/samv3/ Proposals Referenced Proposal 123: Encrypted LeaseSets and authentication Proposal 144: ECIES-X25519-AEAD-Ratchet Proposal 149: Blinded address format (b33) Proposal 152: X25519 tunnel creation Proposal 154: Database lookups from ECIES destinations Proposal 156: Router migration to ECIES-X25519 Proposal 161: Destination padding compression Proposal 167: LeaseSet service records Proposal 169: Post-quantum hybrid cryptography (ML-KEM) Javadocs Reference I2CP Package: http://docs.i2p-projekt.de/javadoc/net/i2p/data/i2cp/package-summary.html MessageStatusMessage: http://docs.i2p-projekt.de/javadoc/net/i2p/data/i2cp/MessageStatusMessage.html Client API: http://docs.i2p-projekt.de/javadoc/net/i2p/client/package-summary.html Deprecation Summary Deprecated Messages (Do Not Use) CreateLeaseSetMessage (type 4): Use CreateLeaseSet2Message RequestLeaseSetMessage (type 21): Use RequestVariableLeaseSetMessage ReceiveMessageBeginMessage (type 6): Use fast receive mode ReceiveMessageEndMessage (type 7): Use fast receive mode DestLookupMessage (type 34): Use HostLookupMessage DestReplyMessage (type 35): Use HostReplyMessage ReportAbuseMessage (type 29): Never implemented Deprecated Options ElGamal encryption (type 0): Migrate to ECIES-X25519 (type 4) DSA signatures: Migrate to EdDSA or ECDSA i2cp.fastReceive=false: Always use fast receive mode ","description":"How applications negotiate sessions, tunnels, and LeaseSets with the I2P router.","id":"ed43fc9da2a03819fd3c8f71e9e9a5a3","section":"docs","title":"I2P Client Protocol (I2CP)","url":"/en/docs/specs/i2cp/"},{"categories":null,"content":"Purpose: Maintain consistency, accuracy, and accessibility across I2P technical documentation\nCore Principles 1. Verify Everything Never assume or guess. All technical statements must be verified against:\nCurrent I2P source code (https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master) Official API documentation (https://i2p.github.io/i2p.i2p/ Configuration specifications /docs/specs/ Recent release notes /releases/ Example of proper verification:\n❌ BAD: \u0026#34;The ClientApp interface probably requires three constructor parameters.\u0026#34; ✅ GOOD: \u0026#34;The ClientApp interface requires this constructor signature: public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)\u0026#34; 2. Clarity Over Brevity Write for developers who may be encountering I2P for the first time. Explain concepts fully rather than assuming knowledge.\nExample:\n❌ BAD: \u0026#34;Use the port mapper for service discovery.\u0026#34; ✅ GOOD: \u0026#34;The port mapper offers a simple directory for internal TCP services. Register loopback ports so other applications can discover your service without hardcoded addresses.\u0026#34; 3. Accessibility First Documentation must be accessible to developers on the clearnet (regular internet) even though I2P is a network overlay. Always provide clearnet-accessible alternatives to I2P-internal resources.\nTechnical Accuracy API and Interface Documentation Always include:\nFull package names on first mention: net.i2p.app.ClientApp Complete method signatures with return types Parameter names and types Required vs optional parameters Example:\nThe `startup()` method has signature `void startup() throws IOException` and must execute without blocking. The method must call `ClientAppManager.notify()` at least once to transition from INITIALIZED state. Configuration Properties When documenting configuration files:\nShow exact property names Specify file encoding (UTF-8 for I2P configs) Provide complete examples Document default values Note version when properties were introduced/changed Example:\n### clients.config Properties **Required:** - `clientApp.N.main` - Full class name (no default) **Optional:** - `clientApp.N.delay` - Seconds before starting (default: 120) - `clientApp.N.onBoot` - Forces delay=0 if true (default: false, added in 0.9.4) Constants and Enumerations When documenting constants, use actual code names:\n❌ BAD: \u0026#34;Common registrations include console, i2ptunnel, Jetty, sam, and bob\u0026#34; ✅ GOOD: \u0026#34;Common port mapper service constants from `net.i2p.util.PortMapper`: - `SVC_CONSOLE` - Router console (default port 7657) - `SVC_HTTP_PROXY` - HTTP proxy (default port 4444) - `SVC_SAM` - SAM bridge (default port 7656)\u0026#34; Distinguish Between Similar Concepts I2P has several overlapping systems. Always clarify which system you\u0026rsquo;re documenting:\nExample:\nNote that client registry and port mapper are separate systems: - **ClientAppManager registry** enables inter-application communication by name lookup - **PortMapper** maps service names to host:port combinations for service discovery - **i2ptunnel tunnel types** are configuration values (tunnel.N.type), not service registrations Documentation URLs and References URL Accessibility Rules Primary references should use clearnet-accessible URLs I2P-internal URLs (.i2p domains) must include accessibility notes Always provide alternatives when linking I2P-internal resources Template for I2P-internal URLs:\n\u0026gt; **Note:** The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ \u0026gt; which requires an I2P router for access. For clearnet access, use the GitHub Pages \u0026gt; mirror at https://eyedeekay.github.io/javadoc-i2p/ Recommended I2P Reference URLs Official specifications:\nConfiguration Plugin Documentment Index API documentation (choose most current):\nMost current: https://i2p.github.io/i2p.i2p/ (API 0.9.66 as of I2P 2.10.0) Clearnet mirror: https://eyedeekay.github.io/javadoc-i2p/ Source code:\nGitLab (official): https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master GitHub mirror: https://github.com/i2p/i2p.i2p Link Format Standards ✅ GOOD: [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) ✅ GOOD: [Configuration Specification](https://geti2p.net/spec/configuration) ❌ BAD: See the ClientApp docs at http://idk.i2p/... ❌ BAD: [link](url) with no descriptive text Version Tracking Document Metadata Every technical document should include version metadata in frontmatter:\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Field definitions:\nlastUpdated: Year-month when document was last reviewed/updated accurateFor: I2P version the document was verified against reviewStatus: One of \u0026ldquo;draft\u0026rdquo;, \u0026ldquo;needs-review\u0026rdquo;, \u0026ldquo;verified\u0026rdquo;, \u0026ldquo;outdated\u0026rdquo; Version References in Content When mentioning versions:\nUse bold for current version: \u0026ldquo;version 2.10.0 (September 2025)\u0026rdquo; Specify both version number and date for historical references Note API version separately from I2P version when relevant Example:\nManaged clients were introduced in **version 0.9.4** (December 17, 2012) and remain the recommended architecture as of **version 2.10.0** (September 9, 2025). The current API version is **0.9.66**. Documenting Changes Over Time For features that evolved:\n**Version history:** - **0.9.4 (December 2012)** - Managed clients introduced - **0.9.42 (2019)** - clients.config.d/ directory structure added - **1.7.0 (2021)** - ShellService added for external program tracking - **2.10.0 (September 2025)** - Current release, no API changes to managed clients Deprecation Notices If documenting deprecated features:\n\u0026gt; **Deprecated:** This feature was deprecated in version X.Y.Z and will be removed \u0026gt; in version A.B.C. Use [alternative feature](link) instead. Terminology Standards Official I2P Terms Use these exact terms consistently:\nCorrect Term Avoid I2P router I2P node, I2P client (ambiguous) eepsite I2P website, hidden service (Tor term) tunnel connection, circuit (Tor term) netDb network database, DHT lease set destination info destination address, endpoint base64 destination I2P address, .i2p address Managed Client Terminology When documenting managed clients:\nUse This Not This managed client managed application unmanaged client legacy client, static client ClientAppManager application manager, client manager lifecycle methods state methods, control methods client registry application registry, name service port mapper port registry, service directory Configuration Terminology Correct Incorrect clients.config clients.cfg, client.config clients.config.d/ clients.d/, config.d/ router.config router.cfg i2ptunnel.config tunnel.config Package and Class Names Always use fully qualified names on first mention, short names thereafter:\nThe `net.i2p.app.ClientApp` interface requires implementation of three lifecycle methods. When a ClientApp starts, the manager calls `startup()`... Code Examples and Formatting Java Code Examples Use proper syntax highlighting and complete examples:\n### Example: Registering with Port Mapper \\`\\`\\`java // Register HTTP proxy service context.portMapper().register( PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444 ); // Later, retrieve the port int port = context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY); if (port == -1) { // Service not registered } \\`\\`\\` Code example requirements:\nInclude comments explaining key lines Show error handling where relevant Use realistic variable names Match I2P coding conventions (4-space indent) Show imports if not obvious from context Configuration Examples Show complete, valid configuration examples:\n### Example: clients.config.d/ Entry File: `clients.config.d/00-console.config` \\`\\`\\`properties # Router console configuration clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true \\`\\`\\` Command Line Examples Use $ for user commands, # for root:\n\\`\\`\\`bash # Install I2P on Debian/Ubuntu $ sudo apt-get install i2p # Start the router $ i2prouter start \\`\\`\\` Inline Code Use backticks for:\nMethod names: startup() Class names: ClientApp Property names: clientApp.0.main File names: clients.config Constants: SVC_HTTP_PROXY Package names: net.i2p.app Tone and Voice Professional but Accessible Write for a technical audience without being condescending:\n❌ BAD: \u0026#34;Obviously, you should implement the startup() method.\u0026#34; ✅ GOOD: \u0026#34;Managed clients must implement the startup() method to initialize resources.\u0026#34; ❌ BAD: \u0026#34;Even a junior dev knows you need to call notify().\u0026#34; ✅ GOOD: \u0026#34;The manager requires at least one notify() call during startup to track state transitions.\u0026#34; Active Voice Use active voice for clarity:\n❌ PASSIVE: \u0026#34;The ClientAppManager is notified by the client when state changes.\u0026#34; ✅ ACTIVE: \u0026#34;The client notifies ClientAppManager when state changes.\u0026#34; Imperatives for Instructions Use direct imperatives in procedural content:\n✅ \u0026#34;Implement these three lifecycle methods:\u0026#34; ✅ \u0026#34;Call manager.notify() after changing state.\u0026#34; ✅ \u0026#34;Register services using context.portMapper().register()\u0026#34; Avoid Unnecessary Jargon Explain terms on first use:\n✅ GOOD: \u0026#34;The netDb (network database) stores information about I2P routers and destinations.\u0026#34; ❌ BAD: \u0026#34;Query the netDb for peer info.\u0026#34; (no explanation) Punctuation Guidelines No em-dashes - use regular dashes, commas, or semicolons instead Use Oxford comma in lists: \u0026ldquo;console, i2ptunnel, and Jetty\u0026rdquo; Periods inside code blocks only when grammatically necessary Serial lists use semicolons when items contain commas Document Structure Standard Section Order For API documentation:\nOverview - what the feature does, why it exists Implementation - how to implement/use it Configuration - how to configure it API Reference - detailed method/property descriptions Examples - complete working examples Best Practices - tips and recommendations Version History - when introduced, changes over time References - links to related documentation Heading Hierarchy Use semantic heading levels:\n# Document Title (h1 - only one per document) ## Major Section (h2) ### Subsection (h3) #### Detail Section (h4) **Bold text for emphasis within sections** Information Boxes Use blockquotes for special notices:\n\u0026gt; **Note:** Additional information that clarifies the main content. \u0026gt; **Warning:** Important information about potential issues or breaking changes. \u0026gt; **Deprecated:** This feature is deprecated and will be removed in version X.Y.Z. \u0026gt; **Status:** Current implementation status or version information. Lists and Organization Unordered lists for non-sequential items:\n- First item - Second item - Third item Ordered lists for sequential steps:\n1. First step 2. Second step 3. Third step Definition lists for term explanations:\n**Term One** : Explanation of term one **Term Two** : Explanation of term two Common Pitfalls to Avoid 1. Confusing Similar Systems Don\u0026rsquo;t confuse:\nClientAppManager registry vs. PortMapper i2ptunnel tunnel types vs. port mapper service constants ClientApp vs. RouterApp (different contexts) Managed vs. unmanaged clients Always clarify which system you\u0026rsquo;re discussing:\n✅ \u0026#34;Register with ClientAppManager using manager.register(this) for name-based lookup.\u0026#34; ✅ \u0026#34;Register with PortMapper using context.portMapper().register() for port discovery.\u0026#34; 2. Outdated Version References Don\u0026rsquo;t:\nReference old versions as \u0026ldquo;current\u0026rdquo; Link to outdated API documentation Use deprecated method signatures in examples Do:\nCheck release notes before publishing Verify API documentation matches current version Update examples to use current best practices 3. Inaccessible URLs Don\u0026rsquo;t:\nLink only to .i2p domains without clearnet alternatives Use broken or outdated documentation URLs Link to local file:// paths Do:\nProvide clearnet alternatives for all I2P-internal links Verify URLs are accessible before publishing Use persistent URLs (geti2p.net, not temporary hosting) 4. Incomplete Code Examples Don\u0026rsquo;t:\nShow fragments without context Omit error handling Use undefined variables Skip import statements when not obvious Do:\nShow complete, compilable examples Include necessary error handling Explain what each significant line does Test examples before publishing 5. Ambiguous Statements ❌ \u0026#34;Some applications register services.\u0026#34; ✅ \u0026#34;Applications implementing ClientApp may register with ClientAppManager using manager.register(this) to enable name-based lookup.\u0026#34; ❌ \u0026#34;Configuration files go in the config directory.\u0026#34; ✅ \u0026#34;Modern I2P installations store client configurations in $I2P/clients.config.d/ as individual files.\u0026#34; Markdown Conventions File Naming Use kebab-case for file names:\nmanaged-clients.md port-mapper-guide.md configuration-reference.md Frontmatter Format Always include YAML frontmatter:\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description under 160 characters\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Link Formatting Internal links (within documentation):\nSee [clients.config specification](https://geti2p.net/spec/configuration#clients-config) External links (to other resources):\nFor more details, see [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) Code repository links:\nView source: [ClientApp.java](https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master/core/java/src/net/i2p/app/ClientApp.java) Table Formatting Use GitHub-flavored Markdown tables:\n| Property | Type | Default | Description | |----------|------|---------|-------------| | `main` | String | (required) | Full class name | | `delay` | Integer | 120 | Seconds before start | | `onBoot` | Boolean | false | Force immediate start | Code Block Language Tags Always specify language for syntax highlighting:\n\\`\\`\\`java // Java code \\`\\`\\` \\`\\`\\`bash # Shell commands \\`\\`\\` \\`\\`\\`properties # Configuration files \\`\\`\\` \\`\\`\\`xml \u0026lt;!-- XML files --\u0026gt; \\`\\`\\` Review Checklist Before publishing documentation, verify:\nAll technical claims verified against source code or official documentation Version numbers and dates are current All URLs are accessible from clearnet (or alternatives provided) Code examples are complete and tested Terminology follows I2P conventions No em-dashes (use regular dashes or other punctuation) Frontmatter is complete and accurate Heading hierarchy is semantic (h1 → h2 → h3) Lists and tables are properly formatted References section includes all cited sources Document follows the structure guidelines Tone is professional but accessible Similar concepts are clearly distinguished No broken links or references Configuration examples are valid and current Feedback: If you find issues or have suggestions for these guidelines, please submit them through the official I2P development channels.\n","description":"Maintain consistency, accuracy, and accessibility across I2P technical documentation","id":"797e1cb5256ec022a3d99eefd7eda1f4","section":"docs","title":"I2P Documentation Writing Guidelines","url":"/en/docs/writing-guidelines/"},{"categories":null,"content":"Introduction I2P provides private email-style messaging through Postman\u0026rsquo;s Mail.i2p service combined with SusiMail, a built-in webmail client. This system allows users to send and receive emails both within the I2P network and to/from the regular internet (clearnet) via a gateway bridge.\nPostman / Mail.i2p + SusiMail What it is Mail.i2p is a hosted email provider inside I2P, run by \u0026ldquo;Postman\u0026rdquo; SusiMail is the webmail client integrated in the I2P router console. It is designed to avoid leaking metadata (e.g. hostname) to external SMTP servers. Through this setup, I2P users can send/receive messages both within I2P and to/from the clearnet (e.g. Gmail) via the Postman bridge. How Addressing Works I2P email uses a dual-address system:\nInside I2P network: username@mail.i2p (e.g., idk@mail.i2p) From clearnet: username@i2pmail.org (e.g., idk@i2pmail.org) The i2pmail.org gateway allows regular internet users to send emails to I2P addresses, and I2P users to send to clearnet addresses. Internet emails are routed through the gateway before being forwarded through I2P to your SusiMail inbox.\nClearnet sending quota: 20 emails per day when sending to regular internet addresses.\nGetting Started To register for a mail.i2p account:\nEnsure your I2P router is running Visit http://hq.postman.i2p inside I2P Follow the registration process Access your email through SusiMail in the router console Note: hq.postman.i2p is an I2P network address (eepsite) and can only be accessed while connected to I2P. For more information about email setup, security, and usage, visit Postman HQ.\nPrivacy Features Automatic removal of identifying headers (User-Agent:, X-Mailer:) for privacy Metadata sanitization to prevent leaks to external SMTP servers End-to-end encryption for internal I2P-to-I2P emails Strengths Interoperability with \u0026ldquo;normal\u0026rdquo; email (SMTP/POP) via the Postman bridge Simple user experience (webmail built into router console) Integrated with I2P core distribution (SusiMail ships with Java I2P) Header stripping for privacy protection Considerations The bridge to external email requires trust in Postman infrastructure Clearnet bridge reduces privacy compared to purely internal I2P communication Reliant on the Postman mail server\u0026rsquo;s availability and security Technical Details SMTP Service: localhost:7659 (provided by Postman) POP3 Service: localhost:7660 Webmail Access: Built into router console at http://127.0.0.1:7657/susimail/\nImportant: SusiMail is only for reading and sending email. Account creation and management must be done at hq.postman.i2p.\nBest Practices Change your password after registering your mail.i2p account Use I2P-to-I2P email whenever possible for maximum privacy (no clearnet bridge) Be mindful of the 20/day limit when sending to clearnet addresses Understand the tradeoffs: Clearnet bridging provides convenience but reduces anonymity compared to purely internal I2P communications Keep I2P updated to benefit from security improvements in SusiMail ","description":"An overview of email systems inside the I2P network — history, options, and current status","id":"31217ea91c11f98bd1997466684f9fb3","section":"docs","title":"I2P Mail (Anonymous Email over I2P)","url":"/en/docs/applications/i2p-mail/"},{"categories":null,"content":"Overview The I2P Network Protocol (I2NP) defines how routers exchange messages, select transports, and mix traffic while preserving anonymity. It operates between I2CP (client API) and the transport protocols (NTCP2 and SSU2).\nI2NP is the layer above the I2P transport protocols. It is a router-to-router protocol used for:\nNetwork database lookups and replies Creating tunnels Encrypted router and client data messages I2NP messages may be sent point-to-point to another router, or sent anonymously through tunnels to that router.\nRouters queue outbound work using local priorities. Higher priority numbers are processed first. Anything above the standard tunnel data priority (400) is treated as urgent.\nCurrent Transports I2P now uses NTCP2 (TCP) and SSU2 (UDP) for both IPv4 and IPv6. Both transports employ:\nX25519 key exchange (Noise protocol framework) ChaCha20/Poly1305 authenticated encryption (AEAD) SHA-256 hashing Legacy transports removed:\nNTCP (original TCP) was removed from the Java router in release 0.9.50 (May 2021) SSU v1 (original UDP) was removed from the Java router in release 2.4.0 (December 2023) SSU v1 was removed from i2pd in release 2.44.0 (November 2022) As of 2025, the network has fully transitioned to Noise-based transports with zero legacy transport support.\nVersion Numbering System IMPORTANT: I2P uses a dual versioning system that must be clearly understood:\nRelease Versions (User-Facing) These are the versions users see and download:\n0.9.50 (May 2021) - Last 0.9.x release 1.5.0 (August 2021) - First 1.x release 1.6.0, 1.7.0, 1.8.0, 1.9.0 (through 2021-2022) 2.0.0 (November 2022) - First 2.x release 2.1.0 through 2.9.0 (through 2023-2025) 2.10.0 (September 8, 2025) - Current release API Versions (Protocol Compatibility) These are internal version numbers published in the \u0026ldquo;router.version\u0026rdquo; field in RouterInfo properties:\n0.9.50 (May 2021) 0.9.51 (August 2021) - API version for release 1.5.0 0.9.52 through 0.9.66 (continuing through 2.x releases) 0.9.67 (September 2025) - API version for release 2.10.0 Key Point: There were NO releases numbered 0.9.51 through 0.9.67. These numbers exist only as API version identifiers. I2P jumped from release 0.9.50 directly to 1.5.0.\nVersion Mapping Table Release Version API Version Date Key Features 0.9.50 0.9.50 May 2021 Last 0.9.x release, removed NTCP1 1.5.0 0.9.51 August 2021 Short tunnel build messages (218 bytes) 1.6.0 0.9.52 November 2021 Various improvements 1.7.0 0.9.53 January 2022 Performance enhancements 1.8.0 0.9.54 May 2022 SSU2 introduced 1.9.0 0.9.55 August 2022 SSU2 improvements 2.0.0 0.9.56 November 2022 SSU2 enabled by default 2.1.0 0.9.57 January 2023 Stability improvements 2.2.0 0.9.58 March 2023 ElGamal routers deprecated 2.3.0 0.9.59 May 2023 Various improvements 2.4.0 0.9.61 December 2023 Removed SSU1 support 2.5.0 0.9.62 February 2024 Performance improvements 2.6.0 0.9.63 May 2024 Network optimizations 2.7.0 0.9.64 October 2024 Post-quantum preparation work 2.8.0 0.9.65 February 2025 Tunnel bandwidth parameters 2.9.0 0.9.66 June 2025 LeaseSet service records 2.10.0 0.9.67 September 2025 Post-quantum hybrid cryptography (beta) Upcoming: Release 2.11.0 (planned December 2025) will require Java 17+ and enable post-quantum cryptography by default.\nProtocol Versions All routers must publish their I2NP protocol version in the \u0026ldquo;router.version\u0026rdquo; field in the RouterInfo properties. This version field is the API version, indicating the level of support for various I2NP protocol features, and is not necessarily the actual router version.\nIf alternative (non-Java) routers wish to publish any version information about the actual router implementation, they must do so in another property. Versions other than those listed below are allowed. Support will be determined through a numeric comparison; for example, 0.9.13 implies support for 0.9.12 features.\nNote: The \u0026ldquo;coreVersion\u0026rdquo; property is no longer published in the router info and was never used for determination of the I2NP protocol version.\nAPI Version Feature Summary API Version Required I2NP Features 0.9.67Post-quantum hybrid cryptography (MLKEM ratchet) support (beta), UDP tracker support 0.9.66LeaseSet2 service record options (see proposal 167) 0.9.65Tunnel build bandwidth parameters (see proposal 168) 0.9.59Minimum peers will build tunnels through (as of 0.9.63), minimum floodfill peers will send DSM to (as of 0.9.63) 0.9.58Minimum peers will build tunnels through (as of 0.9.62), ElGamal routers deprecated 0.9.55SSU2 transport support (if published in router info) 0.9.51Short tunnel build messages for ECIES-X25519 routers, minimum peers will build tunnels through (as of 0.9.58), minimum floodfill peers will send DSM to (as of 0.9.58) 0.9.49Garlic messages to ECIES-X25519 routers 0.9.48ECIES-X25519 routers, ECIES-X25519 build request/response records 0.9.46DatabaseLookup flag bit 4 for AEAD reply 0.9.44ECIES-X25519 keys in LeaseSet2 0.9.40MetaLeaseSet may be sent in a DSM 0.9.39EncryptedLeaseSet may be sent in a DSM, RedDSA_SHA512_Ed25519 signature type supported 0.9.38DSM type bits 3-0 now contain the type; LeaseSet2 may be sent in a DSM 0.9.36NTCP2 transport support (if published in router info), minimum peers will build tunnels through (as of 0.9.46) 0.9.28RSA signature types disallowed, minimum floodfill peers will send DSM to (as of 0.9.34) 0.9.18DSM type bits 7-1 ignored 0.9.16RI key certs / ECDSA and EdDSA signature types, DLM lookup types (flag bits 3-2), minimum version compatible with the current network 0.9.15Destination/LeaseSet key certificates with EdDSA Ed25519 signature type (if floodfill) 0.9.12Destination/LeaseSet key certificates with ECDSA P-256, P-384, and P-521 signature types (if floodfill); non-zero expiration allowed in RouterAddress 0.9.7Encrypted DSM/DSRM replies supported (DLM flag bit 1) for floodfill routers 0.9.6Non-zero DLM flag bits 7-1 allowed 0.9.3Requires zero expiration in RouterAddress 0.9Supports up to 16 leases in a DSM LeaseSet store (previously 6) 0.7.12VTBM and VTBRM message support 0.7.10Floodfill supports encrypted DSM stores 0.6.1.10TBM and TBRM messages introduced; minimum version compatible with the current network Note: There are also transport-related features and compatibility issues. See the NTCP2 and SSU2 transport documentation for details.\nMessage Header I2NP uses a logical 16-byte header structure, while modern transports (NTCP2 and SSU2) use a shortened 9-byte header omitting redundant size and checksum fields. The fields remain conceptually identical.\nHeader Format Comparison Standard Format (16 bytes):\nUsed in legacy NTCP transport and when I2NP messages are embedded within other messages (TunnelData, TunnelGateway, GarlicClove).\nBytes 0-15: +----+----+----+----+----+----+----+----+ |type| msg_id | expiration +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ type :: Integer (1 byte) Identifies the message type (see message type table) msg_id :: Integer (4 bytes) Uniquely identifies this message (for some time at least) Usually a locally-generated random number, but for outgoing tunnel build messages may be derived from the incoming message expiration :: Date (8 bytes) Unix timestamp in milliseconds when this message expires size :: Integer (2 bytes) Length of the payload (0 to ~61.2 KB for tunnel messages) chks :: Integer (1 byte) SHA256 hash of payload truncated to first byte Deprecated - NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity Short Format for SSU (Obsolete, 5 bytes):\n+----+----+----+----+----+ |type| short_expiration | +----+----+----+----+----+ type :: Integer (1 byte) short_expiration :: Integer (4 bytes, seconds since epoch) Short Format for NTCP2, SSU2, and ECIES-Ratchet Garlic Cloves (9 bytes):\nUsed in modern transports and ECIES encrypted garlic messages.\n+----+----+----+----+----+----+----+----+ |type| msg_id | short_expira- +----+----+----+----+----+----+----+----+ tion| +----+ type :: Integer (1 byte) msg_id :: Integer (4 bytes) short_expiration :: Integer (4 bytes, seconds since epoch, unsigned) Header Field Details Field Bytes Description Type 1 Identifies the message class (0\u0026ndash;255, see message types below) Unique ID 4 Locally unique identifier for matching replies Expiration 8 (standard) / 4 (short) Timestamp when the message expires. Routers discard expired messages. Short format uses seconds since epoch (unsigned, wraps February 7, 2106) Payload Length 2 Size in bytes (0 to ~61.2 KB for tunnel messages). NTCP2 and SSU2 encode this in their frame headers Checksum 1 Deprecated. First byte of SHA-256 hash of the payload. NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity Implementation Notes When transmitted over SSU (obsolete), only type and 4-byte expiration were included When transmitted over NTCP2 or SSU2, the 9-byte short format is used The standard 16-byte header is required for I2NP messages contained in other messages (Data, TunnelData, TunnelGateway, GarlicClove) As of release 0.8.12, checksum verification is disabled at some points in the protocol stack for efficiency, but checksum generation is still required for compatibility The short expiration is unsigned and will wrap around on February 7, 2106. After that date, an offset must be added to get the correct time For compatibility with older versions, always generate checksums even though they may not be verified Size Constraints Tunnel messages fragment I2NP payloads into fixed-size pieces:\nFirst fragment: approximately 956 bytes Subsequent fragments: approximately 996 bytes each Maximum fragments: 64 (numbered 0-63) Maximum payload: approximately 61,200 bytes (61.2 KB) Calculation: 956 + (63 × 996) = 63,704 bytes theoretical maximum, with practical limit around 61,200 bytes due to overhead.\nHistorical Context Old transports had stricter frame size limits:\nNTCP: 16 KB frames SSU: approximately 32 KB frames NTCP2 supports approximately 65 KB frames, but the tunnel fragmentation limit still applies.\nApplication Data Considerations Garlic messages may bundle LeaseSets, Session Tags, or encrypted LeaseSet2 variants, reducing space for payload data.\nRecommendation: Datagrams should stay ≤ 10 KB to ensure reliable delivery. Messages approaching the 61 KB limit may experience:\nIncreased latency due to fragmentation reassembly Higher probability of delivery failure Greater exposure to traffic analysis Fragmentation Technical Details Each tunnel message is exactly 1,024 bytes (1 KB) and contains:\n4-byte tunnel ID 16-byte initialization vector (IV) 1,004 bytes of encrypted data Within the encrypted data, tunnel messages carry fragmented I2NP messages with fragment headers indicating:\nFragment number (0-63) Whether this is the first or follow-on fragment Total message ID for reassembly The first fragment includes the full I2NP message header (16 bytes), leaving approximately 956 bytes for payload. Follow-on fragments do not include the message header, allowing approximately 996 bytes of payload per fragment.\nCommon Message Types Routers use the message type and priority to schedule outbound work. Higher priority values are processed first. The values below match current Java I2P defaults (as of API version 0.9.67).\nNote: Priorities are implementation-dependent. For authoritative priority values, consult OutNetMessage class documentation in the Java I2P source code.\nMessage Type Priority Typical Size Purpose DatabaseStore 1 460 Varies (LeaseSet ≈ 898\u0026nbsp;B, RouterInfo ≈ 2\u0026ndash;4\u0026nbsp;KB compressed) Publishes RouterInfo or LeaseSet objects. Supports LeaseSet2, EncryptedLeaseSet, and MetaLeaseSet DatabaseLookup 2 500 Varies Queries the network database for RouterInfo or LeaseSet entries DatabaseSearchReply 3 300 ≈161\u0026nbsp;B (5 hashes) Returns candidate floodfill router hashes (typically 3\u0026ndash;16 hashes, recommended maximum 16) DeliveryStatus 10 Varies 12\u0026nbsp;B Receipts for tunnel tests or acknowledgements inside GarlicMessages GarlicMessage 11 100 (local) Varies Bundles multiple message cloves (e.g., DataMessage, LeaseSets). Supports ElGamal/AES (deprecated) and ECIES-X25519-AEAD-Ratchet encryption TunnelData 18 400 1,028\u0026nbsp;B (fixed) Encrypted tunnel message exchanged between hops. Contains a 4-byte tunnel ID, 16-byte IV, and 1,004 bytes of encrypted data TunnelGateway 19 300\u0026ndash;400 Varies Encapsulates messages at the tunnel gateway before fragmentation DataMessage 20 425 4\u0026ndash;62\u0026nbsp;KB Carries end-to-end garlic payloads (application traffic) TunnelBuild (deprecated) 21 500 4,224\u0026nbsp;B Requests tunnel participation from routers (8 × 528-byte records). Replaced by VariableTunnelBuild for ECIES TunnelBuildReply (deprecated) 22 300 4,224\u0026nbsp;B Replies to TunnelBuild with accept/reject status per hop VariableTunnelBuild 23 500 1,057\u0026ndash;4,225\u0026nbsp;B Variable-length tunnel build for ElGamal or ECIES-X25519 routers (1\u0026ndash;8 records, API 0.9.12+) VariableTunnelBuildReply 24 300 1,057\u0026ndash;4,225\u0026nbsp;B Replies to VariableTunnelBuild ShortTunnelBuild 25 500 873\u0026ndash;1,745\u0026nbsp;B Short tunnel build messages for ECIES-X25519 routers only (1\u0026ndash;8 × 218-byte records, API 0.9.51+) OutboundTunnelBuildReply 26 300 873\u0026ndash;1,745\u0026nbsp;B Sent from outbound endpoint to originator for ECIES-X25519 routers (API 0.9.51+) Reserved message types:\nType 0: Reserved Types 4-9: Reserved for future use Types 12-17: Reserved for future use Types 224-254: Reserved for experimental messages Type 255: Reserved for future expansion Message Type Notes Control-plane messages (DatabaseLookup, TunnelBuild, etc.) typically travel through exploratory tunnels, not client tunnels, allowing independent prioritization Priority values are approximate and may vary by implementation TunnelBuild (21) and TunnelBuildReply (22) are deprecated but still implemented for compatibility with very long tunnels (\u0026gt;8 hops) The standard tunnel data priority is 400; anything above this is treated as urgent Typical tunnel length in today\u0026rsquo;s network is 3-4 hops, so most tunnel builds use ShortTunnelBuild (218-byte records) or VariableTunnelBuild (528-byte records) Encryption and Message Wrapping Routers frequently encapsulate I2NP messages before transmission, creating multiple encryption layers. A DeliveryStatus message may be:\nWrapped in a GarlicMessage (encrypted) Inside a DataMessage Within a TunnelData message (encrypted again) Each hop only decrypts its layer; the final destination reveals the innermost payload.\nEncryption Algorithms Legacy (Being Phased Out):\nElGamal/AES + SessionTags ElGamal-2048 for asymmetric encryption AES-256 for symmetric encryption 32-byte session tags Current (Standard as of API 0.9.48):\nECIES-X25519 + ChaCha20/Poly1305 AEAD with ratcheting forward secrecy Noise protocol framework (Noise_IK_25519_ChaChaPoly_SHA256 for destinations) 8-byte session tags (reduced from 32 bytes) Signal Double Ratchet algorithm for forward secrecy Introduced in API version 0.9.46 (2020) Mandatory for all routers as of API version 0.9.58 (2023) Future (Beta as of 2.10.0):\nPost-quantum hybrid cryptography using MLKEM (ML-KEM-768) combined with X25519 Hybrid ratchet combining classical and post-quantum key agreement Backward compatible with ECIES-X25519 Will become default in release 2.11.0 (December 2025) ElGamal Router Deprecation CRITICAL: ElGamal routers were deprecated as of API version 0.9.58 (release 2.2.0, March 2023). As the recommended minimum floodfill version to query is now 0.9.58, implementations need not implement encryption for ElGamal floodfill routers.\nHowever: ElGamal destinations are still supported for backward compatibility. Clients using ElGamal encryption can still communicate through ECIES routers.\nECIES-X25519-AEAD-Ratchet Details This is crypto type 4 in I2P\u0026rsquo;s cryptography specification. It provides:\nKey Features:\nForward secrecy through ratcheting (new keys for each message) Reduced session tag storage (8 bytes vs. 32 bytes) Multiple session types (New Session, Existing Session, One-Time) Based on Noise protocol Noise_IK_25519_ChaChaPoly_SHA256 Integrated with Signal\u0026rsquo;s Double Ratchet algorithm Cryptographic Primitives:\nX25519 for Diffie-Hellman key agreement ChaCha20 for stream encryption Poly1305 for message authentication (AEAD) SHA-256 for hashing HKDF for key derivation Session Management:\nNew Session: Initial connection using static destination key Existing Session: Subsequent messages using session tags One-Time Session: Single-message sessions for lower overhead See ECIES Specification and Proposal 144 for complete technical details.\nCommon Structures The following structures are elements of multiple I2NP messages. They are not complete messages.\nBuildRequestRecord (ElGamal) DEPRECATED. Only used in the current network when a tunnel contains an ElGamal router. See ECIES Tunnel Creation for modern format.\nPurpose: One record in a set of multiple records to request the creation of one hop in the tunnel.\nFormat:\nElGamal and AES encrypted (528 bytes total):\n+----+----+----+----+----+----+----+----+ | encrypted data (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ ElGamal encrypted structure (528 bytes):\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ElGamal encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity encrypted_data :: ElGamal-2048 encrypted (bytes 1-256 and 258-513 of the 514-byte ElGamal block, with padding bytes at positions 0 and 257 removed) Cleartext structure (222 bytes before encryption):\n+----+----+----+----+----+----+----+----+ | receive_tunnel (4) | our_ident (32) | +----+----+----+----+ + | | + +----+----+----+----+ | | next_tunnel (4) | +----+----+----+----+----+----+----+----+ | next_ident (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | layer_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | iv_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_iv (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ |flag| request_time (4) | send_msg_id | +----+----+----+----+----+----+----+----+ (4) | padding (29) | +----+----+----+----+----+ + | | + +----+----+ | | +----+----+----+----+----+----+ receive_tunnel :: TunnelId (4 bytes, nonzero) our_ident :: Hash (32 bytes) next_tunnel :: TunnelId (4 bytes, nonzero) next_ident :: Hash (32 bytes) layer_key :: SessionKey (32 bytes) iv_key :: SessionKey (32 bytes) reply_key :: SessionKey (32 bytes) reply_iv :: 16 bytes flag :: Integer (1 byte) request_time :: Integer (4 bytes, hours since epoch = time / 3600) send_message_id :: Integer (4 bytes) padding :: 29 bytes random data Notes:\nThe ElGamal-2048 encryption produces a 514-byte block, but the two padding bytes (at positions 0 and 257) are removed, resulting in 512 bytes See Tunnel Creation Specification for field details Source code: net.i2p.data.i2np.BuildRequestRecord Constant: EncryptedBuildRecord.RECORD_SIZE = 528 BuildRequestRecord (ECIES-X25519 Long) For ECIES-X25519 routers, introduced in API version 0.9.48. Uses 528 bytes for backward compatibility with mixed tunnels.\nFormat:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (464 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (464 bytes) mac :: Poly1305 message authentication code (16 bytes) Total size: 528 bytes (same as ElGamal for compatibility)\nSee ECIES Tunnel Creation for cleartext structure and encryption details.\nBuildRequestRecord (ECIES-X25519 Short) For ECIES-X25519 routers only, as of API version 0.9.51 (release 1.5.0). This is the current standard format.\nFormat:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (154 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (154 bytes) mac :: Poly1305 message authentication code (16 bytes) Total size: 218 bytes (59% reduction from 528 bytes)\nKey Difference: Short records derive ALL keys via HKDF (key derivation function) rather than including them explicitly in the record. This includes:\nLayer keys (for tunnel encryption) IV keys (for tunnel encryption) Reply keys (for build reply) Reply IVs (for build reply) All keys are derived using the Noise protocol\u0026rsquo;s HKDF mechanism based on the shared secret from the X25519 key exchange.\nBenefits:\n4 short records fit in one tunnel message (873 bytes) 3 message tunnel builds instead of separate messages for each record Reduced bandwidth and latency Same security properties as long format See Proposal 157 for rationale and ECIES Tunnel Creation for complete specification.\nSource code:\nnet.i2p.data.i2np.ShortEncryptedBuildRecord Constant: ShortEncryptedBuildRecord.RECORD_SIZE = 218 BuildResponseRecord (ElGamal) DEPRECATED. Only used when tunnel contains an ElGamal router.\nPurpose: One record in a set of multiple records with responses to a build request.\nFormat:\nEncrypted (528 bytes, same size as BuildRequestRecord):\nbytes 0-527 :: AES-encrypted record Unencrypted structure:\n+----+----+----+----+----+----+----+----+ | SHA-256 hash (32 bytes) | + + | (hash of bytes 32-527) | + + | | +----+----+----+----+----+----+----+----+ | random data (495 bytes) | ~ ~ | |ret | +----+----+----+----+----+----+----+----+ bytes 0-31 :: SHA-256 hash of bytes 32-527 bytes 32-526 :: Random data (could be used for congestion info) byte 527 :: Reply code (0 = accept, 30 = reject) Reply Codes:\n0 - Accept 30 - Reject (bandwidth exceeded) See Tunnel Creation Specification for details on the reply field.\nBuildResponseRecord (ECIES-X25519) For ECIES-X25519 routers, API version 0.9.48+. Same size as corresponding request (528 for long, 218 for short).\nFormat:\nLong format (528 bytes):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Short format (218 bytes):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (202 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Cleartext structure (both formats):\nContains a Mapping structure (I2P\u0026rsquo;s key-value format) with:\nReply status code (required) Bandwidth available parameter (\u0026ldquo;b\u0026rdquo;) (optional, added in API 0.9.65) Other optional parameters for future extensions Reply Status Codes:\n0 - Success 30 - Reject: bandwidth exceeded See ECIES Tunnel Creation for complete specification.\nGarlicClove (ElGamal/AES) WARNING: This is the format used for garlic cloves within ElGamal-encrypted garlic messages. The format for ECIES-AEAD-X25519-Ratchet garlic messages and garlic cloves is significantly different. See ECIES Specification for the modern format.\nDeprecated for routers (API 0.9.58+), still supported for destinations.\nFormat:\nUnencrypted:\n+----+----+----+----+----+----+----+----+ | Delivery Instructions (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (8) |Cert| +----+----+----+----+----+----+----+----+ (3) | +----+----+----+----+----+----+----+----+ Delivery Instructions :: Variable length (typically 1, 33, or 37 bytes) I2NP Message :: Any I2NP message Clove ID :: 4-byte Integer (random, checked for duplicates) Expiration :: Date (8 bytes) Certificate :: Always NULL (3 bytes total, all zeroes) Notes:\nCloves are never fragmented When the first bit of the Delivery Instructions flag byte is 0, the clove is not encrypted When the first bit is 1, the clove is encrypted (unimplemented feature) Maximum length is a function of total clove lengths and maximum GarlicMessage length The certificate could possibly be used for HashCash to \u0026ldquo;pay\u0026rdquo; for routing (future possibility) Messages used in practice: DataMessage, DeliveryStatusMessage, DatabaseStoreMessage GarlicMessage can contain GarlicMessage (nested garlic), but this is not used in practice See Garlic Routing for conceptual overview.\nGarlicClove (ECIES-X25519-AEAD-Ratchet) For ECIES-X25519 routers and destinations, API version 0.9.46+. This is the current standard format.\nCRITICAL DIFFERENCE: ECIES garlic uses a completely different structure based on Noise protocol blocks rather than explicit clove structures.\nFormat:\nECIES garlic messages contain a series of blocks:\nBlock structure: +----+----+----+----+----+----+----+----+ |type| length | data ... +----+----+----+----+----+-//- type :: 1 byte block type length :: 2 bytes block length data :: variable length data Block Types:\n0 - Garlic Clove Block (contains an I2NP message) 1 - DateTime Block (timestamp) 2 - Options Block (delivery options) 3 - Padding Block 254 - Termination Block (unimplemented) Garlic Clove Block (type 0):\n+----+----+----+----+----+----+----+----+ | 0 | length | Delivery Instructions | +----+----+----+----+ + ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (4) | +----+----+----+----+----+----+----+----+ Key Differences from ElGamal format:\nUses 4-byte expiration (seconds since epoch) instead of 8-byte Date No certificate field Wrapped in block structure with type and length Entire message encrypted with ChaCha20/Poly1305 AEAD Session management via ratcheting See ECIES Specification for complete details on the Noise protocol framework and block structures.\nGarlic Clove Delivery Instructions This format is used for both ElGamal and ECIES garlic cloves. It specifies how to deliver the enclosed message.\nCRITICAL WARNING: This specification is for Delivery Instructions inside Garlic Cloves ONLY. \u0026ldquo;Delivery Instructions\u0026rdquo; are also used inside Tunnel Messages, where the format is significantly different. See the Tunnel Message Specification for tunnel delivery instructions. DO NOT confuse these two formats.\nFormat:\nSession key and delay are unused and never present, so the three possible lengths are:\n1 byte (LOCAL) 33 bytes (ROUTER and DESTINATION) 37 bytes (TUNNEL) +----+----+----+----+----+----+----+----+ |flag| | +----+ + | Session Key (optional, 32) | + + | | + +----+----+----+----+--------------+ | | | +----+ + | To Hash (optional, 32) | + + | | + +----+----+----+----+--------------+ | | Tunnel ID (4, opt)| Delay (4, opt)| +----+----+----+----+----+----+----+----+ flag :: 1 byte Bit order: 76543210 bit 7: encrypted? (Unimplemented, always 0) If 1, a 32-byte encryption session key follows bits 6-5: delivery type 0x0 = LOCAL (0) 0x1 = DESTINATION (1) 0x2 = ROUTER (2) 0x3 = TUNNEL (3) bit 4: delay included? (Not fully implemented, always 0) If 1, four delay bytes are included bits 3-0: reserved, set to 0 for compatibility Session Key :: 32 bytes (Optional, unimplemented) Present if encrypt flag bit is set To Hash :: 32 bytes (Optional) Present if delivery type is DESTINATION, ROUTER, or TUNNEL - DESTINATION: SHA256 hash of the destination - ROUTER: SHA256 hash of the router identity - TUNNEL: SHA256 hash of the gateway router identity Tunnel ID :: 4 bytes (Optional) Present if delivery type is TUNNEL The destination tunnel ID (nonzero) Delay :: 4 bytes (Optional, unimplemented) Present if delay included flag is set Specifies delay in seconds Typical Lengths:\nLOCAL delivery: 1 byte (flag only) ROUTER / DESTINATION delivery: 33 bytes (flag + hash) TUNNEL delivery: 37 bytes (flag + hash + tunnel ID) Delivery Type Descriptions:\nType Value Description LOCAL 0 Deliver to the local router (this router) DESTINATION 1 Deliver to a destination (client) identified by hash ROUTER 2 Deliver to another router identified by hash TUNNEL 3 Deliver to a tunnel gateway router Implementation Notes:\nSession key encryption is unimplemented and the flag bit is always 0 Delay is not fully implemented and the flag bit is always 0 For TUNNEL delivery, the hash identifies the gateway router and the tunnel ID specifies which inbound tunnel For DESTINATION delivery, the hash is the SHA-256 of the destination\u0026rsquo;s public key For ROUTER delivery, the hash is the SHA-256 of the router\u0026rsquo;s identity I2NP Messages Complete message specifications for all I2NP message types.\nMessage Type Summary Message Type Since Status DatabaseStore10.6.1.10Active DatabaseLookup20.6.1.10Active DatabaseSearchReply30.6.1.10Active DeliveryStatus100.6.1.10Active Garlic110.6.1.10Active TunnelData180.6.1.10Active TunnelGateway190.6.1.10Active Data200.6.1.10Active TunnelBuild210.6.1.10Deprecated TunnelBuildReply220.6.1.10Deprecated VariableTunnelBuild230.7.12Active VariableTunnelBuildReply240.7.12Active ShortTunnelBuild250.9.51Active OutboundTunnelBuildReply260.9.51Active Reserved:\nType 0: Reserved Types 4-9: Reserved for future use Types 12-17: Reserved for future use Types 224-254: Reserved for experimental messages Type 255: Reserved for future expansion DatabaseStore (Type 1) Purpose: An unsolicited database store, or the response to a successful DatabaseLookup message.\nContents: An uncompressed LeaseSet, LeaseSet2, MetaLeaseSet, or EncryptedLeaseSet, or a compressed RouterInfo.\nFormat with reply token:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |type| reply token (4) | reply_tunnelId +----+----+----+----+----+----+----+----+ (4) | reply gateway | +----+----+----+----+----+ + | SHA256 hash (32 bytes) | + + | | + +----+ | | +----+----+----+----+----+----+----+ | data ... +----+-// key :: 32 bytes SHA256 hash (the \u0026#34;real\u0026#34; hash, not routing key) type :: 1 byte Type identifier bit 0: 0 = RouterInfo 1 = LeaseSet or variants bits 3-1: (as of 0.9.38) 0: RouterInfo or LeaseSet (types 0 or 1) 1: LeaseSet2 (type 3) 2: EncryptedLeaseSet (type 5) 3: MetaLeaseSet (type 7) 4-7: Unsupported, invalid bits 7-4: Reserved, set to 0 reply token :: 4 bytes If greater than zero, a DeliveryStatusMessage is requested with the Message ID set to the reply token A floodfill router is also expected to flood the data to the closest floodfill peers reply_tunnelId :: 4 bytes (only if reply token \u0026gt; 0) TunnelId of the inbound gateway of the tunnel for the response If 0, reply is sent directly to reply gateway reply gateway :: 32 bytes (only if reply token \u0026gt; 0) SHA256 hash of the RouterInfo If reply_tunnelId is nonzero: inbound gateway router If reply_tunnelId is zero: router to send reply to data :: Variable length If type == 0: 2-byte Integer length + gzip-compressed RouterInfo If type == 1: Uncompressed LeaseSet If type == 3: Uncompressed LeaseSet2 If type == 5: Uncompressed EncryptedLeaseSet If type == 7: Uncompressed MetaLeaseSet Format with reply token == 0:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ |type| 0 | data ... +----+----+----+----+----+-// Notes:\nFor security, the reply fields are ignored if the message is received down a tunnel The key is the \u0026ldquo;real\u0026rdquo; hash of the RouterIdentity or Destination, NOT the routing key Types 3, 5, and 7 (LeaseSet2 variants) were added in release 0.9.38 (API 0.9.38). See Proposal 123 for details These types should only be sent to routers with API version 0.9.38 or higher As an optimization to reduce connections, if the type is a LeaseSet, the reply token is included, the reply tunnel ID is nonzero, and the reply gateway/tunnelID pair is found in the LeaseSet as a lease, the recipient may reroute the reply to any other lease in the LeaseSet RouterInfo gzip format: To hide the router OS and implementation, match the Java router implementation by setting the modification time to 0 and the OS byte to 0xFF, and set XFL to 0x02 (max compression, slowest algorithm) per RFC 1952. First 10 bytes: 1F 8B 08 00 00 00 00 00 02 FF Source code:\nnet.i2p.data.i2np.DatabaseStoreMessage net.i2p.data.RouterInfo (for RouterInfo structure) net.i2p.data.LeaseSet (for LeaseSet structure) DatabaseLookup (Type 2) Purpose: A request to look up an item in the network database. The response is either a DatabaseStore or a DatabaseSearchReply.\nFormat:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as the key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | SHA256 hash of the from router (32) | + or reply tunnel gateway + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |flag| reply_tunnelId (4)| size (2)| | +----+----+----+----+----+----+----+ + | SHA256 of key1 to exclude (32 bytes) | + + | | + +----+ | | | +----+----+----+----+----+----+----+ + | SHA256 of key2 to exclude (32) | + + ~ ~ | | + +----+ | | | +----+----+----+----+----+----+----+ + | Session key if reply encryption | + requested (32 bytes) + | | + +----+ | |tags| +----+----+----+----+----+----+----+----+ | Session tags if reply encryption | + requested (variable) + ~ ~ | | +----+----+----+----+----+----+----+----+ key :: 32 bytes SHA256 hash of the object to lookup from :: 32 bytes If deliveryFlag == 0: SHA256 hash of RouterInfo (sender) If deliveryFlag == 1: SHA256 hash of reply tunnel gateway flags :: 1 byte Bit order: 76543210 bit 0: deliveryFlag 0 = send reply directly 1 = send reply to some tunnel bit 1: encryptionFlag Through 0.9.5: must be 0 As of 0.9.6: ignored As of 0.9.7: 0 = send unencrypted reply 1 = send AES encrypted reply using key and tag bits 3-2: lookup type flags Through 0.9.5: must be 00 As of 0.9.6: ignored As of 0.9.16: 00 = ANY (deprecated, use LS or RI as of 0.9.16) 01 = LS lookup (LeaseSet or variants) 10 = RI lookup (RouterInfo) 11 = exploration lookup (RouterInfo, non-floodfill) bit 4: ECIESFlag Before 0.9.46: ignored As of 0.9.46: 0 = send unencrypted or ElGamal reply 1 = send ChaCha/Poly encrypted reply using key bits 7-5: Reserved, set to 0 reply_tunnelId :: 4 bytes (only if deliveryFlag == 1) TunnelId of the tunnel to send reply to (nonzero) size :: 2 bytes Integer (valid range: 0-512) Number of peers to exclude from DatabaseSearchReply excludedPeers :: $size SHA256 hashes of 32 bytes each If lookup fails, exclude these peers from the reply If includes a hash of all zeroes, the request is exploratory (return non-floodfill routers only) reply_key :: 32 bytes (conditional, see encryption modes below) reply_tags :: 1 byte count + variable length tags (conditional) Reply Encryption Modes:\nNOTE: ElGamal routers are deprecated as of API 0.9.58. As the recommended minimum floodfill version to query is now 0.9.58, implementations need not implement encryption for ElGamal floodfill routers. ElGamal destinations are still supported.\nFlag bit 4 (ECIESFlag) is used in combination with bit 1 (encryptionFlag) to determine the reply encryption mode:\nFlag bits 4,1 From To Router Reply DH? Notes 0 0 Any Any No encryption n/a No encryption 0 1 ElG ElG AES No As of 0.9.7, deprecated 0.9.58 1 0 ECIES ElG AEAD No As of 0.9.46, deprecated 0.9.58 1 0 ECIES ECIES AEAD No As of 0.9.49, current standard 1 1 ElG ECIES AES Yes TBD, future 1 1 ECIES ECIES AEAD Yes TBD, future No Encryption (flags 0,0):\nreply_key, tags, and reply_tags are not present.\nElG to ElG (flags 0,1) - DEPRECATED:\nSupported as of 0.9.7, deprecated as of 0.9.58.\nreply_key :: 32 byte SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (1-32, typically 1) Number of reply tags that follow reply_tags :: One or more 32-byte SessionTags Each is CSRNG(32) random data ECIES to ElG (flags 1,0) - DEPRECATED:\nSupported as of 0.9.46, deprecated as of 0.9.58.\nreply_key :: 32 byte ECIES SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (required value: 1) Number of reply tags that follow reply_tags :: One 8-byte ECIES SessionTag CSRNG(8) random data The reply is an ECIES Existing Session message as defined in ECIES Specification:\n+----+----+----+----+----+----+----+----+ | Session Tag (8 bytes) | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted payload | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ tag :: 8 byte reply_tag k :: 32 byte session key (the reply_key) n :: 0 (nonce) ad :: The 8 byte reply_tag payload :: Plaintext data (DSM or DSRM) ciphertext = ENCRYPT(k, n, payload, ad) ECIES to ECIES (flags 1,0) - CURRENT STANDARD:\nECIES destination or router sends a lookup to an ECIES router. Supported as of 0.9.49.\nSame format as \u0026ldquo;ECIES to ElG\u0026rdquo; above. The lookup message encryption is specified in ECIES Routers. The requester is anonymous.\nECIES to ECIES with DH (flags 1,1) - FUTURE:\nNot yet fully defined. See Proposal 156.\nNotes:\nPrior to 0.9.16, the key could be for a RouterInfo or LeaseSet (same key space, no flag to distinguish) Encrypted replies are only useful when the response is through a tunnel The number of included tags could be greater than one if alternative DHT lookup strategies are implemented The lookup key and exclude keys are the \u0026ldquo;real\u0026rdquo; hashes, NOT routing keys Types 3, 5, and 7 (LeaseSet2 variants) may be returned as of 0.9.38. See Proposal 123 Exploratory lookup notes: An exploratory lookup is defined to return a list of non-floodfill hashes close to the key. However, implementations vary: Java does look up the search key for an RI and returns a DatabaseStore if present; i2pd does not. Therefore, it is not recommended to use an exploratory lookup for previously-received hashes Source code:\nnet.i2p.data.i2np.DatabaseLookupMessage Encryption: net.i2p.crypto.SessionKeyManager DatabaseSearchReply (Type 3) Purpose: The response to a failed DatabaseLookup message.\nContents: A list of router hashes closest to the requested key.\nFormat:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as query key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | num| peer_hashes (variable) | +----+ + | | ~ ~ | | + +----+----+----+----+----+----+----+ | | from (32 bytes) | +----+ + | | + + | | + + | | + +----+----+----+----+----+----+----+ | | +----+ key :: 32 bytes SHA256 of the object being searched num :: 1 byte Integer Number of peer hashes that follow (0-255) peer_hashes :: $num SHA256 hashes of 32 bytes each (total $num*32 bytes) SHA256 of the RouterIdentity that the sender thinks is close to the key from :: 32 bytes SHA256 of the RouterInfo of the router this reply was sent from Notes:\nThe \u0026lsquo;from\u0026rsquo; hash is unauthenticated and cannot be trusted The returned peer hashes are not necessarily closer to the key than the router being queried. For replies to regular lookups, this facilitates discovery of new floodfills and \u0026ldquo;backwards\u0026rdquo; searching (further-from-the-key) for robustness For exploration lookups, the key is usually generated randomly. The response\u0026rsquo;s non-floodfill peer_hashes may be selected using an optimized algorithm (e.g., close but not necessarily closest peers) to avoid inefficient sorting of the entire local database. Caching strategies may also be used. This is implementation-dependent Typical number of hashes returned: 3 Recommended maximum number of hashes to return: 16 The lookup key, peer hashes, and from hash are \u0026ldquo;real\u0026rdquo; hashes, NOT routing keys If num is 0, this indicates no closer peers were found (dead end) Source code:\nnet.i2p.data.i2np.DatabaseSearchReplyMessage DeliveryStatus (Type 10) Purpose: A simple message acknowledgment. Generally created by the message originator and wrapped in a Garlic Message with the message itself, to be returned by the destination.\nContents: The ID of the delivered message and the creation or arrival time.\nFormat:\n+----+----+----+----+----+----+----+----+----+----+----+----+ | msg_id (4) | time_stamp (8) | +----+----+----+----+----+----+----+----+----+----+----+----+ msg_id :: Integer (4 bytes) Unique ID of the message we deliver the DeliveryStatus for (see I2NP Message Header for details) time_stamp :: Date (8 bytes) Time the message was successfully created or delivered Notes:\nThe time stamp is always set by the creator to the current time. However, there are several uses of this in the code, and more may be added in the future This message is also used as a session established confirmation in SSU. In this case, the message ID is set to a random number, and the \u0026ldquo;arrival time\u0026rdquo; is set to the current network-wide ID, which is 2 (i.e., 0x0000000000000002) DeliveryStatus is typically wrapped in a GarlicMessage and sent through a tunnel to provide acknowledgment without revealing the sender Used for tunnel testing to measure latency and reliability Source code:\nnet.i2p.data.i2np.DeliveryStatusMessage Used in: net.i2p.router.tunnel.InboundEndpointProcessor for tunnel testing GarlicMessage (Type 11) WARNING: This is the format used for ElGamal-encrypted garlic messages. The format for ECIES-AEAD-X25519-Ratchet garlic messages is significantly different. See ECIES Specification for the modern format.\nPurpose: Used to wrap multiple encrypted I2NP messages.\nContents: When decrypted, a series of Garlic Cloves and additional data, also known as a Clove Set.\nEncrypted Format:\n+----+----+----+----+----+----+----+----+ | length (4) | data | +----+----+----+----+----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ length :: 4 byte Integer Number of bytes that follow (0 to 64 KB) data :: $length bytes ElGamal encrypted data Decrypted Data (Clove Set):\n+----+----+----+----+----+----+----+----+ | num| clove 1 (variable) | +----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ | clove 2 (variable) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Certificate (3) | Message_ID (4) | +----+----+----+----+----+----+----+----+ Expiration (8) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Number of GarlicCloves to follow clove :: GarlicClove (see GarlicClove structure above) Certificate :: Always NULL (3 bytes total, all zeroes) Message_ID :: 4 byte Integer Expiration :: Date (8 bytes) Notes:\nWhen unencrypted, data contains one or more Garlic Cloves The AES encrypted block is padded to a minimum of 128 bytes; with the 32-byte Session Tag, the minimum size of the encrypted message is 160 bytes; with the 4-byte length field, the minimum size of the Garlic Message is 164 bytes Actual max length is less than 64 KB (practical limit around 61.2 KB for tunnel messages) See ElGamal/AES Specification for encryption details See Garlic Routing for conceptual overview The 128 byte minimum size of the AES encrypted block is not currently configurable The message ID is generally set to a random number on transmit and appears to be ignored on receive The certificate could possibly be used for HashCash to \u0026ldquo;pay\u0026rdquo; for routing (future possibility) ElGamal encryption structure: 32-byte session tag + ElGamal-encrypted session key + AES-encrypted payload For ECIES-X25519-AEAD-Ratchet format (current standard for routers):\nSee ECIES Specification and Proposal 144.\nSource code:\nnet.i2p.data.i2np.GarlicMessage Encryption: net.i2p.crypto.elgamal.ElGamalAESEngine (deprecated) Modern encryption: net.i2p.crypto.ECIES packages TunnelData (Type 18) Purpose: A message sent from a tunnel\u0026rsquo;s gateway or participant to the next participant or endpoint. The data is of fixed length, containing I2NP messages that are fragmented, batched, padded, and encrypted.\nFormat:\n+----+----+----+----+----+----+----+----+ | tunnelID (4) | data (1024) | +----+----+----+----+----+ + | | ~ ~ | | + +----+----+----+----+ | | +----+----+----+----+ tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero data :: 1024 bytes Payload data, fixed to 1024 bytes Payload Structure (1024 bytes):\nBytes 0-15: Initialization Vector (IV) for AES encryption Bytes 16-1023: Encrypted tunnel message data (1008 bytes) Notes:\nThe I2NP message ID for TunnelData is set to a new random number at each hop The tunnel message format (within the encrypted data) is specified in Tunnel Message Specification Each hop decrypts one layer using AES-256 in CBC mode The IV is updated at each hop using the decrypted data Total size is exactly 1,028 bytes (4 tunnelId + 1024 data) This is the fundamental unit of tunnel traffic TunnelData messages carry fragmented I2NP messages (GarlicMessage, DatabaseStore, etc.) Source code:\nnet.i2p.data.i2np.TunnelDataMessage Constant: TunnelDataMessage.DATA_LENGTH = 1024 Processing: net.i2p.router.tunnel.InboundGatewayProcessor TunnelGateway (Type 19) Purpose: Wraps another I2NP message to be sent into a tunnel at the tunnel\u0026rsquo;s inbound gateway.\nFormat:\n+----+----+----+----+----+----+----+-// | tunnelId (4) | length (2)| data... +----+----+----+----+----+----+----+-// tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero length :: 2 byte Integer Length of the payload data :: $length bytes Actual payload of this message Notes:\nThe payload is an I2NP message with a standard 16-byte header Used to inject messages into tunnels from the local router The gateway fragments the enclosed message if necessary After fragmentation, the fragments are wrapped in TunnelData messages TunnelGateway is never sent over the network; it\u0026rsquo;s an internal message type used before tunnel processing Source code:\nnet.i2p.data.i2np.TunnelGatewayMessage Processing: net.i2p.router.tunnel.OutboundGatewayProcessor DataMessage (Type 20) Purpose: Used by Garlic Messages and Garlic Cloves to wrap arbitrary data (typically end-to-end encrypted application data).\nFormat:\n+----+----+----+----+----+----+-//-+ | length (4) | data... | +----+----+----+----+----+----+-//-+ length :: 4 bytes Length of the payload data :: $length bytes Actual payload of this message Notes:\nThis message contains no routing information and will never be sent \u0026ldquo;unwrapped\u0026rdquo; Only used inside Garlic messages Typically contains end-to-end encrypted application data (HTTP, IRC, email, etc.) The data is usually an ElGamal/AES or ECIES-encrypted payload Maximum practical length is around 61.2 KB due to tunnel message fragmentation limits Source code:\nnet.i2p.data.i2np.DataMessage TunnelBuild (Type 21) DEPRECATED. Use VariableTunnelBuild (type 23) or ShortTunnelBuild (type 25).\nPurpose: Fixed-length tunnel build request for 8 hops.\nFormat:\n+----+----+----+----+----+----+----+----+ | Record 0 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 1 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 7 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Just 8 BuildRequestRecords attached together Record size: 528 bytes Total size: 8 × 528 = 4,224 bytes Notes:\nAs of 0.9.48, may contain ECIES-X25519 BuildRequestRecords. See ECIES Tunnel Creation See Tunnel Creation Specification for details The I2NP message ID for this message must be set according to the tunnel creation specification While rarely seen in today\u0026rsquo;s network (replaced by VariableTunnelBuild), it may still be used for very long tunnels and has not been formally deprecated Routers must still implement this for compatibility Fixed 8-record format is inflexible and wastes bandwidth for shorter tunnels Source code:\nnet.i2p.data.i2np.TunnelBuildMessage Constant: TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 TunnelBuildReply (Type 22) DEPRECATED. Use VariableTunnelBuildReply (type 24) or OutboundTunnelBuildReply (type 26).\nPurpose: Fixed-length tunnel build reply for 8 hops.\nFormat:\nSame format as TunnelBuildMessage, with BuildResponseRecords instead of BuildRequestRecords.\nTotal size: 8 × 528 = 4,224 bytes Notes:\nAs of 0.9.48, may contain ECIES-X25519 BuildResponseRecords. See ECIES Tunnel Creation See Tunnel Creation Specification for details The I2NP message ID for this message must be set according to the tunnel creation specification While rarely seen in today\u0026rsquo;s network (replaced by VariableTunnelBuildReply), it may still be used for very long tunnels and has not been formally deprecated Routers must still implement this for compatibility Source code:\nnet.i2p.data.i2np.TunnelBuildReplyMessage VariableTunnelBuild (Type 23) Purpose: Variable-length tunnel build for 1-8 hops. Supports both ElGamal and ECIES-X25519 routers.\nFormat:\n+----+----+----+----+----+----+----+----+ | num| BuildRequestRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildRequestRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Notes:\nAs of 0.9.48, may contain ECIES-X25519 BuildRequestRecords. See ECIES Tunnel Creation Introduced in router version 0.7.12 (2009) May not be sent to tunnel participants earlier than version 0.7.12 See Tunnel Creation Specification for details The I2NP message ID must be set according to the tunnel creation specification Typical number of records: 4 (for a 4-hop tunnel) Typical total size: 1 + (4 × 528) = 2,113 bytes This is the standard tunnel build message for ElGamal routers ECIES routers typically use ShortTunnelBuild (type 25) instead Source code:\nnet.i2p.data.i2np.VariableTunnelBuildMessage VariableTunnelBuildReply (Type 24) Purpose: Variable-length tunnel build reply for 1-8 hops. Supports both ElGamal and ECIES-X25519 routers.\nFormat:\nSame format as VariableTunnelBuildMessage, with BuildResponseRecords instead of BuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| BuildResponseRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildResponseRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Notes:\nAs of 0.9.48, may contain ECIES-X25519 BuildResponseRecords. See ECIES Tunnel Creation Introduced in router version 0.7.12 (2009) May not be sent to tunnel participants earlier than version 0.7.12 See Tunnel Creation Specification for details The I2NP message ID must be set according to the tunnel creation specification Typical number of records: 4 Typical total size: 2,113 bytes Source code:\nnet.i2p.data.i2np.VariableTunnelBuildReplyMessage ShortTunnelBuild (Type 25) Purpose: Short tunnel build messages for ECIES-X25519 routers only. Introduced in API version 0.9.51 (release 1.5.0, August 2021). This is the current standard for ECIES tunnel builds.\nFormat:\n+----+----+----+----+----+----+----+----+ | num| ShortBuildRequestRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildRequestRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Notes:\nIntroduced in router version 0.9.51 (release 1.5.0, August 2021) May not be sent to tunnel participants earlier than API version 0.9.51 See ECIES Tunnel Creation for complete specification See Proposal 157 for rationale Typical number of records: 4 Typical total size: 1 + (4 × 218) = 873 bytes Bandwidth savings: 59% smaller than VariableTunnelBuild (873 vs 2,113 bytes) Performance benefit: 4 short records fit in one tunnel message; VariableTunnelBuild requires 3 tunnel messages This is now the standard tunnel build format for pure ECIES-X25519 tunnels Records derive keys via HKDF instead of including them explicitly Source code:\nnet.i2p.data.i2np.ShortTunnelBuildMessage Constant: ShortEncryptedBuildRecord.RECORD_SIZE = 218 OutboundTunnelBuildReply (Type 26) Purpose: Sent from the outbound endpoint of a new tunnel to the originator. For ECIES-X25519 routers only. Introduced in API version 0.9.51 (release 1.5.0, August 2021).\nFormat:\nSame format as ShortTunnelBuildMessage, with ShortBuildResponseRecords instead of ShortBuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| ShortBuildResponseRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildResponseRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Notes:\nIntroduced in router version 0.9.51 (release 1.5.0, August 2021) See ECIES Tunnel Creation for complete specification Typical number of records: 4 Typical total size: 873 bytes This reply is sent from the outbound endpoint (OBEP) back to the tunnel creator through the newly-created outbound tunnel Provides confirmation that all hops accepted the tunnel build Source code:\nnet.i2p.data.i2np.OutboundTunnelBuildReplyMessage References Official Specifications I2NP Specification - Complete I2NP message format specification Common Structures - Data types and structures used throughout I2P Tunnel Creation - ElGamal tunnel creation (deprecated) ECIES Tunnel Creation - ECIES-X25519 tunnel creation (current) Tunnel Message - Tunnel message format and delivery instructions NTCP2 Specification - TCP transport protocol SSU2 Specification - UDP transport protocol ECIES Specification - ECIES-X25519-AEAD-Ratchet encryption Cryptography Specification - Low-level cryptographic primitives I2CP Specification - Client protocol specification Datagram Specification - Datagram2 and Datagram3 formats Proposals Proposal 123 - New netDB entries (LeaseSet2, EncryptedLeaseSet, MetaLeaseSet) Proposal 144 - ECIES-X25519-AEAD-Ratchet encryption Proposal 154 - Encrypted database lookup Proposal 156 - ECIES routers Proposal 157 - Smaller tunnel build messages (short format) Proposal 159 - SSU2 transport Proposal 161 - Compressible padding Proposal 163 - Datagram2 and Datagram3 Proposal 167 - LeaseSet service record parameters Proposal 168 - Tunnel build bandwidth parameters Proposal 169 - Post-quantum hybrid cryptography Documentation Garlic Routing - Layered message bundling ElGamal/AES - Deprecated encryption scheme Tunnel Implementation - Fragmentation and processing Network Database - Distributed hash table NTCP2 Transport - TCP transport specification SSU2 Transport - UDP transport specification Technical Introduction - I2P architecture overview Source Code Java I2P Repository - Official Java implementation GitHub Mirror - GitHub mirror of Java I2P i2pd Repository - C++ implementation Key Source Code Locations Java I2P (i2pgit.org/I2P_Developers/i2p.i2p):\ncore/java/src/net/i2p/data/i2np/ - I2NP message implementations core/java/src/net/i2p/crypto/ - Cryptographic implementations router/java/src/net/i2p/router/tunnel/ - Tunnel processing router/java/src/net/i2p/router/transport/ - Transport implementations Constants and Values:\nI2NPMessage.MAX_SIZE = 65536 - Maximum I2NP message size I2NPMessageImpl.HEADER_LENGTH = 16 - Standard header size TunnelDataMessage.DATA_LENGTH = 1024 - Tunnel message payload EncryptedBuildRecord.RECORD_SIZE = 528 - Long build record ShortEncryptedBuildRecord.RECORD_SIZE = 218 - Short build record TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 - Max records per build Appendix A: Network Statistics and Current State Network Composition (as of October 2025) Total routers: Approximately 60,000-70,000 (varies) Floodfill routers: Approximately 500-700 active Encryption types: ECIES-X25519: \u0026gt;95% of routers ElGamal: \u0026lt;5% of routers (deprecated, legacy only) Transport adoption: SSU2: \u0026gt;60% primary transport NTCP2: ~40% primary transport Legacy transports (SSU1, NTCP): 0% (removed) Signature types: EdDSA (Ed25519): Vast majority ECDSA: Small percentage RSA: Disallowed (removed) Minimum Router Requirements API version: 0.9.16+ (for EdDSA compatibility with network) Recommended minimum: API 0.9.51+ (ECIES short tunnel builds) Current minimum for floodfills: API 0.9.58+ (ElGamal router deprecation) Upcoming requirement: Java 17+ (as of release 2.11.0, December 2025) Bandwidth Requirements Minimum: 128 KBytes/sec (N flag or higher) for floodfill Recommended: 256 KBytes/sec (O flag) or higher Floodfill requirements: Minimum 128 KB/sec bandwidth Stable uptime (\u0026gt;95% recommended) Low latency (\u0026lt;500ms to peers) Pass health tests (queue time, job lag) Tunnel Statistics Typical tunnel length: 3-4 hops Maximum tunnel length: 8 hops (theoretical, rarely used) Typical tunnel lifetime: 10 minutes Tunnel build success rate: \u0026gt;85% for well-connected routers Tunnel build message format: ECIES routers: ShortTunnelBuild (218-byte records) Mixed tunnels: VariableTunnelBuild (528-byte records) Performance Metrics Tunnel build time: 1-3 seconds (typical) End-to-end latency: 0.5-2 seconds (typical, 6-8 hops total) Throughput: Limited by tunnel bandwidth (typically 10-50 KB/sec per tunnel) Maximum datagram size: 10 KB recommended (61.2 KB theoretical maximum) Appendix B: Deprecated and Removed Features Completely Removed (No Longer Supported) NTCP transport - Removed in release 0.9.50 (May 2021) SSU v1 transport - Removed from Java I2P in release 2.4.0 (December 2023) SSU v1 transport - Removed from i2pd in release 2.44.0 (November 2022) RSA signature types - Disallowed as of API 0.9.28 Deprecated (Supported but Not Recommended) ElGamal routers - Deprecated as of API 0.9.58 (March 2023) ElGamal destinations still supported for backward compatibility New routers should use ECIES-X25519 exclusively TunnelBuild (type 21) - Deprecated in favor of VariableTunnelBuild and ShortTunnelBuild Still implemented for very long tunnels (\u0026gt;8 hops) TunnelBuildReply (type 22) - Deprecated in favor of VariableTunnelBuildReply and OutboundTunnelBuildReply ElGamal/AES encryption - Deprecated in favor of ECIES-X25519-AEAD-Ratchet Still used for legacy destinations Long ECIES BuildRequestRecords (528 bytes) - Deprecated in favor of short format (218 bytes) Still used for mixed tunnels with ElGamal hops Legacy Support Timeline Feature Introduced Deprecated Removed Notes NTCP 2003 2018 (0.9.36) 2021 (0.9.50) Replaced by NTCP2 SSU v1 2004 2022 (0.9.54) 2023 (Java) / 2022 (i2pd) Replaced by SSU2 ElGamal routers 2003 2023 (0.9.58) TBD Destinations still supported RSA signatures 2015 2017 2017 (0.9.28) Never widely used TunnelBuild 2004 2009 (0.7.12) Not removed Still supported for long tunnels Appendix C: Future Developments Post-Quantum Cryptography Status: Beta as of release 2.10.0 (September 2025), will become default in 2.11.0 (December 2025)\nImplementation:\nHybrid approach combining classical X25519 and post-quantum MLKEM (ML-KEM-768) Backward compatible with existing ECIES-X25519 infrastructure Uses Signal Double Ratchet with both classical and PQ key material See Proposal 169 for details Migration Path:\nRelease 2.10.0 (September 2025): Available as beta option Release 2.11.0 (December 2025): Enabled by default Future releases: Eventually required Planned Features IPv6 improvements - Better IPv6 support and transition mechanisms Per-tunnel throttling - Fine-grained bandwidth control per tunnel Enhanced metrics - Better performance monitoring and diagnostics Protocol optimizations - Reduced overhead and improved efficiency Improved floodfill selection - Better network database distribution Research Areas Tunnel length optimization - Dynamic tunnel length based on threat model Advanced padding - Traffic analysis resistance improvements New encryption schemes - Preparation for quantum computing threats Congestion control - Better handling of network load Mobile support - Optimizations for mobile devices and networks Appendix D: Implementation Guidelines For New Implementations Minimum Requirements:\nSupport API version 0.9.51+ features Implement ECIES-X25519-AEAD-Ratchet encryption Support NTCP2 and SSU2 transports Implement ShortTunnelBuild messages (218-byte records) Support LeaseSet2 variants (types 3, 5, 7) Use EdDSA signatures (Ed25519) Recommended:\nSupport post-quantum hybrid cryptography (as of 2.11.0) Implement per-tunnel bandwidth parameters Support Datagram2 and Datagram3 formats Implement service record options in LeaseSets Follow official specifications at /docs/specs/ Not Required:\nElGamal router support (deprecated) Legacy transport support (SSU1, NTCP) Long ECIES BuildRequestRecords (528 bytes for pure ECIES tunnels) TunnelBuild/TunnelBuildReply messages (use Variable or Short variants) Testing and Validation Protocol Compliance:\nTest interoperability with official Java I2P router Test interoperability with i2pd C++ router Validate message formats against specifications Test tunnel build/tear-down cycles Verify encryption/decryption with test vectors Performance Testing:\nMeasure tunnel build success rates (should be \u0026gt;85%) Test with various tunnel lengths (2-8 hops) Validate fragmentation and reassembly Test under load (multiple simultaneous tunnels) Measure end-to-end latency Security Testing:\nVerify encryption implementation (use test vectors) Test replay attack prevention Validate message expiration handling Test against malformed messages Verify proper random number generation Common Implementation Pitfalls Confusing delivery instruction formats - Garlic clove vs tunnel message Incorrect key derivation - HKDF usage for short build records Message ID handling - Not setting correctly for tunnel builds Fragmentation issues - Not respecting 61.2 KB practical limit Endianness errors - Java uses big-endian for all integers Expiration handling - Short format wraps on February 7, 2106 Checksum generation - Still required even if not verified Document History Version Date Changes 1.0 October 2025 Initial corrected version based on research Fixed release date: 2.10.0 = September 8, 2025 Added version numbering system explanation Added release-to-API version mapping table Verified all technical specifications Added source code references Added appendices with network statistics ","description":"Router-to-router message formats, priorities, and size limits inside I2P.","id":"917124900b0896942323b4effccf9b55","section":"docs","title":"I2P Network Protocol (I2NP)","url":"/en/docs/specs/i2np/"},{"categories":null,"content":"I2P routers fail most commonly due to port forwarding issues, insufficient bandwidth allocation, and inadequate bootstrap time. These three factors account for over 70% of reported problems. The router requires at least 10-15 minutes after startup to fully integrate into the network, 128 KB/sec minimum bandwidth (256 KB/sec recommended), and proper UDP/TCP port forwarding to achieve non-firewalled status. New users often expect immediate connectivity and restart prematurely, which resets integration progress and creates a frustrating cycle. This guide provides detailed solutions for all major I2P issues affecting versions 2.10.0 and later.\nI2P\u0026rsquo;s anonymity architecture inherently trades speed for privacy through multi-hop encrypted tunneling. Understanding this fundamental design helps users set realistic expectations and troubleshoot effectively rather than misinterpreting normal behavior as problems.\nRouter won\u0026rsquo;t start or crashes immediately The most common startup failures stem from port conflicts, Java version incompatibility, or corrupted configuration files. Check if another I2P instance is already running before investigating deeper issues.\nVerify no conflicting processes:\nLinux: ps aux | grep i2p or netstat -tulpn | grep 7657\nWindows: Task Manager → Details → look for java.exe with i2p in command line\nmacOS: Activity Monitor → search for \u0026ldquo;i2p\u0026rdquo;\nIf a zombie process exists, kill it: pkill -9 -f i2p (Linux/Mac) or taskkill /F /IM javaw.exe (Windows)\nCheck Java version compatibility:\nI2P 2.10.0+ requires Java 8 minimum, with Java 11 or later recommended. Verify your installation shows \u0026ldquo;mixed mode\u0026rdquo; (not \u0026ldquo;interpreted mode\u0026rdquo;):\njava -version Should display: OpenJDK or Oracle Java, version 8+, \u0026ldquo;mixed mode\u0026rdquo;\nAvoid: GNU GCJ, outdated Java implementations, interpreted-only modes\nCommon port conflicts occur when multiple services compete for I2P\u0026rsquo;s default ports. The router console (7657), I2CP (7654), SAM (7656), and HTTP proxy (4444) must be available. Check for conflicts: netstat -ano | findstr \u0026quot;7657 4444 7654\u0026quot; (Windows) or lsof -i :7657,4444,7654 (Linux/Mac).\nConfiguration file corruption manifests as immediate crashes with parse errors in logs. Router.config requires UTF-8 encoding without BOM, uses = as separator (not :), and forbids certain special characters. Back up then examine: ~/.i2p/router.config (Linux), %LOCALAPPDATA%\\I2P\\router.config (Windows), ~/Library/Application Support/i2p/router.config (macOS).\nTo reset configuration while preserving identity: Stop I2P, backup router.keys and keyData directory, delete router.config, restart. The router regenerates default configuration.\nJava heap allocation too low causes OutOfMemoryError crashes. Edit wrapper.config and increase wrapper.java.maxmemory from default 128 or 256 to 512 minimum (1024 for high-bandwidth routers). This requires complete shutdown, waiting 11 minutes, then restart - clicking \u0026ldquo;Restart\u0026rdquo; in console won\u0026rsquo;t apply the change.\nResolving \u0026ldquo;Network: Firewalled\u0026rdquo; status Firewalled status means the router cannot receive direct inbound connections, forcing reliance on introducers. While the router functions in this state, performance degrades significantly and network contribution remains minimal. Achieving non-firewalled status requires proper port forwarding.\nThe router randomly selects a port between 9000-31000 for communications. Find your port at http://127.0.0.1:7657/confignet - look for \u0026ldquo;UDP Port\u0026rdquo; and \u0026ldquo;TCP Port\u0026rdquo; (typically the same number). You must forward both UDP and TCP for optimal performance, though UDP alone enables basic functionality.\nEnable UPnP automatic forwarding (simplest method):\nAccess http://127.0.0.1:7657/confignet Check \u0026ldquo;Enable UPnP\u0026rdquo; Save changes and restart router Wait 5-10 minutes and verify status changes from \u0026ldquo;Network: Firewalled\u0026rdquo; to \u0026ldquo;Network: OK\u0026rdquo; UPnP requires router support (enabled by default on most consumer routers manufactured after 2010) and proper network configuration.\nManual port forwarding (required when UPnP fails):\nNote your I2P port from http://127.0.0.1:7657/confignet (e.g., 22648) Find your local IP address: ipconfig (Windows), ip addr (Linux), System Preferences → Network (macOS) Access your router\u0026rsquo;s admin interface (typically 192.168.1.1 or 192.168.0.1) Navigate to Port Forwarding (may be under Advanced, NAT, or Virtual Servers) Create two rules: External Port: [your I2P port] → Internal IP: [your computer] → Internal Port: [same] → Protocol: UDP External Port: [your I2P port] → Internal IP: [your computer] → Internal Port: [same] → Protocol: TCP Save configuration and restart your router if required Verify port forwarding using online checkers after configuring. If detection fails, check firewall settings - both system firewall and any antivirus firewall must allow the I2P port.\nHidden mode alternative for restrictive networks where port forwarding is impossible: Enable at http://127.0.0.1:7657/confignet → check \u0026ldquo;Hidden mode\u0026rdquo;. The router remains firewalled but optimizes for this state by using SSU introducers exclusively. Performance will be slower but functional.\nRouter stuck in \u0026ldquo;Starting\u0026rdquo; or \u0026ldquo;Testing\u0026rdquo; states These transient states during initial bootstrap typically resolve within 10-15 minutes for new installations or 3-5 minutes for established routers. Premature intervention often worsens problems.\n\u0026ldquo;Network: Testing\u0026rdquo; indicates the router is probing reachability through various connection types (direct, introducers, multiple protocol versions). This is normal for the first 5-10 minutes after startup. The router tests multiple scenarios to determine optimal configuration.\n\u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; appears during bootstrap while the router lacks sufficient peer information. The router won\u0026rsquo;t participate in relay traffic until adequately integrated. This message should disappear after 10-20 minutes once netDb populates with 50+ routers.\nClock skew kills reachability testing. I2P requires system time within ±60 seconds of network time. A difference exceeding 90 seconds causes automatic connection rejection. Sync your system clock:\nLinux: sudo timedatectl set-ntp true \u0026amp;\u0026amp; sudo systemctl restart systemd-timesyncd\nWindows: Control Panel → Date and Time → Internet Time → Update now → Enable automatic sync\nmacOS: System Preferences → Date \u0026amp; Time → Enable \u0026ldquo;Set date and time automatically\u0026rdquo;\nAfter correcting clock skew, restart I2P completely for proper integration.\nInsufficient bandwidth allocation prevents successful testing. The router needs adequate capacity to build test tunnels. Configure at http://127.0.0.1:7657/config:\nMinimum viable: Inbound 96 KB/sec, Outbound 64 KB/sec Recommended standard: Inbound 256 KB/sec, Outbound 128 KB/sec Optimal performance: Inbound 512+ KB/sec, Outbound 256+ KB/sec Share percentage: 80% (allows router to contribute bandwidth to network) Lower bandwidth may work but extends integration time from minutes to hours.\nCorrupted netDb from improper shutdown or disk errors causes perpetual testing loops. The router can\u0026rsquo;t complete testing without valid peer data:\n# Stop I2P completely i2prouter stop # or systemctl stop i2p # Delete corrupted database (safe - will reseed automatically) rm -rf ~/.i2p/netDb/* # Restart and allow 10-15 minutes for reseed i2prouter start Windows: Delete contents of %APPDATA%\\I2P\\netDb\\ or %LOCALAPPDATA%\\I2P\\netDb\\\nFirewall blocking reseed prevents acquiring initial peers. During bootstrap, I2P fetches router information from HTTPS reseed servers. Corporate/ISP firewalls may block these connections. Configure reseed proxy at http://127.0.0.1:7657/configreseed if operating behind restrictive networks.\nSlow speeds, timeouts, and tunnel building failures I2P\u0026rsquo;s design inherently produces 3-10x slower speeds than clearnet due to multi-hop encryption, packet overhead, and route unpredictability. A tunnel build traverses multiple routers, each adding latency. Understanding this prevents misdiagnosing normal behavior as problems.\nTypical performance expectations:\nWeb browsing .i2p sites: 10-30 second page loads initially, faster after tunnel establishment Torrenting via I2PSnark: 10-100 KB/sec per torrent depending on seeders and network conditions Large file downloads: Patience required - megabyte files may take minutes, gigabytes take hours First connection slowest: Tunnel building takes 30-90 seconds; subsequent connections use existing tunnels Tunnel build success rate indicates network health. Check at http://127.0.0.1:7657/tunnels:\nAbove 60%: Normal, healthy operation 40-60%: Marginal, consider bandwidth increase or reducing load Below 40%: Problematic - indicates insufficient bandwidth, network issues, or poor peer selection Increase bandwidth allocation as first optimization. Most slow performance stems from bandwidth starvation. At http://127.0.0.1:7657/config, increase limits incrementally and monitor graphs at http://127.0.0.1:7657/graphs.\nFor DSL/Cable (1-10 Mbps connections):\nInbound: 400 KB/sec Outbound: 200 KB/sec Share: 80% Memory: 384 MB (edit wrapper.config) For high-speed (10-100+ Mbps connections):\nInbound: 1500 KB/sec Outbound: 1000 KB/sec Share: 80-100% Memory: 512-1024 MB Consider: Increase participating tunnels to 2000-5000 at http://127.0.0.1:7657/configadvanced Optimize tunnel configuration for better performance. Access specific tunnel settings at http://127.0.0.1:7657/i2ptunnel and edit each tunnel:\nTunnel quantity: Increase from 2 to 3-4 (more paths available) Backup quantity: Set to 1-2 (rapid failover if tunnel fails) Tunnel length: Default 3 hops provides good balance; reducing to 2 improves speed but decreases anonymity Native crypto library (jbigi) provides 5-10x better performance than pure Java encryption. Verify loaded at http://127.0.0.1:7657/logs - look for \u0026ldquo;jbigi loaded successfully\u0026rdquo; or \u0026ldquo;Using native CPUID implementation\u0026rdquo;. If absent:\nLinux: Usually auto-detected and loaded from ~/.i2p/jbigi-*.so Windows: Check for jbigi.dll in I2P installation directory If missing: Install build tools and compile from source, or download pre-compiled binaries from official repositories\nKeep router running continuously. Every restart resets integration, requiring 30-60 minutes to rebuild tunnel network and peer relationships. Stable routers with high uptime receive preferential selection for tunnel building, creating positive feedback for performance.\nHigh CPU and memory consumption Excessive resource usage typically indicates inadequate memory allocation, missing native crypto libraries, or overcommitment to network participation. Well-configured routers should consume 10-30% CPU during active use and maintain stable memory below 80% of allocated heap.\nMemory problems manifest as:\nFlat-top memory graphs (pegged at maximum) Frequent garbage collection (saw-tooth pattern with steep drops) OutOfMemoryError in logs Router becoming unresponsive under load Automatic shutdown due to resource exhaustion Increase Java heap allocation in wrapper.config (requires complete shutdown):\n# Linux: ~/.i2p/wrapper.config # Windows: %APPDATA%\\I2P\\wrapper.config # Find and modify: wrapper.java.maxmemory=512 # Recommendations by usage: # Light browsing only: 256 # Standard use (browsing + light torrenting): 512 # Heavy use (multiple applications, active torrenting): 768-1024 # Floodfill or very high bandwidth: 1024-2048 Critical: After editing wrapper.config, you must completely shutdown (not restart), wait 11 minutes for graceful termination, then start fresh. Router console \u0026ldquo;Restart\u0026rdquo; button does not reload wrapper settings.\nCPU optimization requires native crypto library. Pure Java BigInteger operations consume 10-20x more CPU than native implementations. Verify jbigi status at http://127.0.0.1:7657/logs during startup. Without jbigi, CPU will spike to 50-100% during tunnel building and encryption operations.\nReduce participating tunnel load if router overwhelmed:\nAccess http://127.0.0.1:7657/configadvanced Set router.maxParticipatingTunnels=1000 (default 8000) Lower share percentage at http://127.0.0.1:7657/config from 80% to 50% Disable floodfill mode if enabled: router.floodfillParticipant=false Limit I2PSnark bandwidth and concurrent torrents. Torrenting consumes significant resources. At http://127.0.0.1:7657/i2psnark:\nLimit active torrents to 3-5 maximum Set \u0026ldquo;Up BW Limit\u0026rdquo; and \u0026ldquo;Down BW Limit\u0026rdquo; to reasonable values (50-100 KB/sec each) Stop torrents when not actively needed Avoid seeding dozens of torrents simultaneously Monitor resource usage through built-in graphs at http://127.0.0.1:7657/graphs. Memory should show headroom, not flat-top. CPU spikes during tunnel building are normal; sustained high CPU indicates configuration problems.\nFor severely resource-constrained systems (Raspberry Pi, old hardware), consider i2pd (C++ implementation) as alternative. i2pd requires ~130 MB RAM versus 350+ MB for Java I2P, and uses ~7% CPU versus 70% under similar loads. Note that i2pd lacks built-in applications and requires external tools.\nI2PSnark torrent issues I2PSnark\u0026rsquo;s integration with I2P router architecture requires understanding that torrenting depends entirely on router tunnel health. Torrents won\u0026rsquo;t start until the router achieves adequate integration with 10+ active peers and functioning tunnels.\nTorrents stuck at 0% typically indicate:\nRouter not fully integrated: Wait 10-15 minutes after I2P startup before expecting torrent activity DHT disabled: Enable at http://127.0.0.1:7657/i2psnark → Configuration → check \u0026ldquo;Enable DHT\u0026rdquo; (default enabled since version 0.9.2) Invalid or dead trackers: I2P torrents require I2P-specific trackers - clearnet trackers won\u0026rsquo;t work Insufficient tunnel configuration: Increase tunnels at I2PSnark Configuration → Tunnels section Configure I2PSnark tunnels for better performance:\nInbound tunnels: 3-5 (default 2 for Java I2P, 5 for i2pd) Outbound tunnels: 3-5 Tunnel length: 3 hops (reduce to 2 for speed, less anonymity) Tunnel quantity: 3 (provides consistent performance) Essential I2P torrent trackers to include:\ntracker2.postman.i2p (primary, most reliable) w7tpbzncbcocrqtwwm3nezhnnsw4ozadvi2hmvzdhrqzfxfum7wa.b32.i2p/a Remove any clearnet (non-.i2p) trackers - they provide no value and create connection attempts that timeout.\n\u0026ldquo;Torrent not registered\u0026rdquo; errors occur when tracker communication fails. Right-click torrent → \u0026ldquo;Start\u0026rdquo; forces re-announcement. If persistent, verify tracker accessibility by browsing to http://tracker2.postman.i2p in I2P-configured browser. Dead trackers should be replaced with working alternatives.\nNo peers connecting despite tracker success suggests:\nRouter firewalled (improves with port forwarding but not required) Insufficient bandwidth (increase to 256+ KB/sec) Swarm too small (some torrents have 1-2 seeders; patience required) DHT disabled (enable for trackerless peer discovery) Enable DHT and PEX (Peer Exchange) at I2PSnark Configuration. DHT allows finding peers without tracker dependency. PEX discovers peers from connected peers, accelerating swarm discovery.\nDownloaded files corruption rarely occurs with I2PSnark\u0026rsquo;s built-in integrity checking. If detected:\nRight-click torrent → \u0026ldquo;Check\u0026rdquo; forces rehash of all pieces Delete corrupted torrent data (keeps .torrent file) Right-click → \u0026ldquo;Start\u0026rdquo; to redownload with piece verification Check disk for errors if corruption persists: chkdsk (Windows), fsck (Linux) Watch directory not working requires proper configuration:\nI2PSnark Configuration → \u0026ldquo;Watch directory\u0026rdquo;: Set absolute path (e.g., /home/user/torrents/watch) Ensure I2P process has read permissions: chmod 755 /path/to/watch Place .torrent files in watch directory - I2PSnark auto-adds them Configure \u0026ldquo;Auto start\u0026rdquo;: Check if torrents should start immediately upon addition Performance optimization for torrenting:\nLimit concurrent active torrents: 3-5 maximum for standard connections Prioritize important downloads: Stop low-priority torrents temporarily Increase router bandwidth allocation: More bandwidth = better torrent performance Be patient: I2P torrenting is inherently slower than clearnet BitTorrent Seed after downloading: Network thrives on reciprocity Git over I2P configuration and troubleshooting Git operations over I2P require either SOCKS proxy configuration or dedicated I2P tunnels for SSH/HTTP access. Git\u0026rsquo;s design assumes low-latency connections, making I2P\u0026rsquo;s high-latency architecture challenging.\nConfigure Git to use I2P SOCKS proxy:\nEdit ~/.ssh/config (create if absent):\nHost *.i2p ProxyCommand nc -X 5 -x 127.0.0.1:4447 %h %p ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes This routes all SSH connections to .i2p hosts through I2P\u0026rsquo;s SOCKS proxy (port 4447). The ServerAlive settings maintain connection during I2P latency.\nFor HTTP/HTTPS git operations, configure git globally:\ngit config --global http.proxy socks5h://127.0.0.1:4447 git config --global https.proxy socks5h://127.0.0.1:4447 Note: socks5h performs DNS resolution through proxy - crucial for .i2p domains.\nCreate dedicated I2P tunnel for Git SSH (more reliable than SOCKS):\nAccess http://127.0.0.1:7657/i2ptunnel \u0026ldquo;New client tunnel\u0026rdquo; → \u0026ldquo;Standard\u0026rdquo; Configure: Name: Git-SSH Type: Client Port: 2222 (local port for Git access) Destination: [your-git-server].i2p:22 Auto start: Enabled Tunnel count: 3-4 (higher for reliability) Save and start tunnel Configure SSH to use tunnel: ssh -p 2222 git@127.0.0.1 SSH authentication errors over I2P usually stem from:\nKey not added to ssh-agent: ssh-add ~/.ssh/id_rsa Wrong key file permissions: chmod 600 ~/.ssh/id_rsa Tunnel not running: Verify at http://127.0.0.1:7657/i2ptunnel shows green status Git server requires specific key type: Generate ed25519 key if RSA fails Git operations timing out relates to I2P\u0026rsquo;s latency characteristics:\nIncrease Git timeout: git config --global http.postBuffer 524288000 (500MB buffer) Increase low-speed limit: git config --global http.lowSpeedLimit 1000 and git config --global http.lowSpeedTime 600 (waits 10 minutes) Use shallow clone for initial checkout: git clone --depth 1 [url] (fetches only latest commit, faster) Clone during low-activity periods: Network congestion affects I2P performance Slow git clone/fetch operations are inherent to I2P\u0026rsquo;s architecture. A 100MB repository may take 30-60 minutes over I2P versus seconds on clearnet. Strategies:\nUse shallow clones: --depth 1 dramatically reduces initial data transfer Fetch incrementally: Instead of full clone, fetch specific branches: git fetch origin branch:branch Consider rsync over I2P: For very large repositories, rsync may perform better Increase tunnel quantity: More tunnels provide better throughput for sustained large transfers \u0026ldquo;Connection refused\u0026rdquo; errors indicate tunnel misconfiguration:\nVerify I2P router running: Check http://127.0.0.1:7657 Confirm tunnel active and green at http://127.0.0.1:7657/i2ptunnel Test tunnel: nc -zv 127.0.0.1 2222 (should connect if tunnel working) Check destination reachable: Browse to destination\u0026rsquo;s HTTP interface if available Review tunnel logs at http://127.0.0.1:7657/logs for specific errors Git over I2P best practices:\nKeep I2P router running continuously for stable Git access Use SSH keys rather than password authentication (fewer interactive prompts) Configure persistent tunnels rather than ephemeral SOCKS connections Consider hosting your own I2P git server for better control Document your .i2p git endpoints for collaborators Accessing eepsites and resolving .i2p domains The most frequent reason users cannot access .i2p sites is incorrect browser proxy configuration. I2P sites exist only within the I2P network and require routing through I2P\u0026rsquo;s HTTP proxy.\nConfigure browser proxy settings exactly:\nFirefox (recommended for I2P):\nMenu → Settings → Network Settings → Settings button Select \u0026ldquo;Manual proxy configuration\u0026rdquo; HTTP Proxy: 127.0.0.1 Port: 4444 SSL Proxy: 127.0.0.1 Port: 4444 SOCKS Proxy: 127.0.0.1 Port: 4447 (optional, for SOCKS apps) Check \u0026ldquo;Proxy DNS when using SOCKS v5\u0026rdquo; OK to save Critical Firefox about:config settings:\nNavigate to about:config and modify:\nmedia.peerconnection.ice.proxy_only = true (prevents WebRTC IP leaks) keyword.enabled = false (prevents .i2p addresses redirecting to search engines) network.proxy.socks_remote_dns = true (DNS through proxy) Chrome/Chromium limitations:\nChrome uses system-wide proxy settings rather than application-specific. On Windows: Settings → search \u0026ldquo;proxy\u0026rdquo; → \u0026ldquo;Open your computer\u0026rsquo;s proxy settings\u0026rdquo; → Configure HTTP: 127.0.0.1:4444 and HTTPS: 127.0.0.1:4445.\nBetter approach: Use FoxyProxy or Proxy SwitchyOmega extensions for selective .i2p routing.\n\u0026ldquo;Website Not Found In Address Book\u0026rdquo; errors mean the router lacks the .i2p domain\u0026rsquo;s cryptographic address. I2P uses local addressbooks rather than centralized DNS. Solutions:\nMethod 1: Use jump services (easiest for new sites):\nBrowse to http://stats.i2p and search for the site. Click the addresshelper link: http://example.i2p/?i2paddresshelper=base64destination. Your browser shows \u0026ldquo;Save to addressbook?\u0026rdquo; - confirm to add.\nMethod 2: Update addressbook subscriptions:\nNavigate to http://127.0.0.1:7657/dns (SusiDNS) Click \u0026ldquo;Subscriptions\u0026rdquo; tab Verify active subscriptions (default: http://i2p-projekt.i2p/hosts.txt) Add recommended subscriptions: http://stats.i2p/cgi-bin/newhosts.txt http://notbob.i2p/hosts.txt http://reg.i2p/export/hosts.txt Click \u0026ldquo;Update Now\u0026rdquo; to force immediate subscription update Wait 5-10 minutes for processing Method 3: Use base32 addresses (always works if site online):\nEvery .i2p site has a base32 address: 52 random characters followed by .b32.i2p (e.g., ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p). Base32 addresses bypass addressbook - the router performs direct cryptographic lookup.\nCommon browser configuration mistakes:\nAttempting HTTPS on HTTP-only sites: Most .i2p sites use HTTP only - trying https://example.i2p fails Forgetting http:// prefix: Browser may search instead of connecting - always use http://example.i2p WebRTC enabled: Can leak real IP address - disable via Firefox settings or extensions DNS not proxied: Clearnet DNS cannot resolve .i2p - must proxy DNS queries Wrong proxy port: 4444 for HTTP (not 4445, which is HTTPS outproxy to clearnet) Router not fully integrated prevents accessing any sites. Verify adequate integration:\nCheck http://127.0.0.1:7657 shows \u0026ldquo;Network: OK\u0026rdquo; or \u0026ldquo;Network: Firewalled\u0026rdquo; (not \u0026ldquo;Network: Testing\u0026rdquo;) Active peers shows 10+ minimum (50+ optimal) No \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; message Wait full 10-15 minutes after router startup before expecting .i2p access IRC and email client configuration follows similar proxy patterns:\nIRC: Clients connect to 127.0.0.1:6668 (I2P\u0026rsquo;s IRC proxy tunnel). Disable IRC client\u0026rsquo;s proxy settings - connection to localhost:6668 is already proxied through I2P.\nEmail (Postman):\nSMTP: 127.0.0.1:7659 POP3: 127.0.0.1:7660 No SSL/TLS (encryption handled by I2P tunnel) Credentials from postman.i2p account registration All these tunnels must show \u0026ldquo;running\u0026rdquo; (green) status at http://127.0.0.1:7657/i2ptunnel.\nInstallation failures and package problems Package-based installations (Debian, Ubuntu, Arch) occasionally fail due to repository changes, GPG key expiration, or dependency conflicts. The official repositories changed from deb.i2p2.de/deb.i2p2.no (end-of-life) to deb.i2p.net in recent versions.\nUpdate Debian/Ubuntu repository to current:\n# Remove old repository entries sudo rm /etc/apt/sources.list.d/i2p.list # Add current repository echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list # Download and install current signing key curl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg sudo cp i2p-archive-keyring.gpg /usr/share/keyrings/ # Update and install sudo apt update sudo apt install i2p i2p-keyring GPG signature verification failures occur when repository keys expire or change:\n# Error: \u0026#34;The following signatures were invalid\u0026#34; # Solution: Install current keyring package sudo apt install i2p-keyring # Manual key import if package unavailable wget https://geti2p.net/_static/i2p-debian-repo.key.asc sudo apt-key add i2p-debian-repo.key.asc Service won\u0026rsquo;t start after package installation most commonly stems from AppArmor profile issues on Debian/Ubuntu:\n# Check service status sudo systemctl status i2p.service # Common error: \u0026#34;Failed at step APPARMOR spawning\u0026#34; # Solution: Reconfigure without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; for AppArmor when prompted # Alternative: Set profile to complain mode sudo aa-complain /usr/sbin/wrapper # Check logs for specific errors sudo journalctl -xe -u i2p.service Permission problems on package-installed I2P:\n# Fix ownership (package install uses \u0026#39;i2psvc\u0026#39; user) sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p # Set file descriptor limits (add to /etc/security/limits.conf) i2psvc soft nofile 4096 i2psvc hard nofile 8192 Java compatibility issues:\nI2P 2.10.0 requires Java 8 minimum. Older systems may have Java 7 or earlier:\n# Check Java version java -version # Install appropriate Java (Debian/Ubuntu) sudo apt install openjdk-11-jre-headless # Set default Java if multiple versions installed sudo update-alternatives --config java Wrapper configuration errors prevent service startup:\nWrapper.config location varies by installation method:\nUser install: ~/.i2p/wrapper.config Package install: /etc/i2p/wrapper.config or /var/lib/i2p/wrapper.config Common wrapper.config problems:\nIncorrect paths: wrapper.java.command must point to valid Java installation Insufficient memory: wrapper.java.maxmemory set too low (increase to 512+) Wrong pidfile location: wrapper.pidfile must be writable location Missing wrapper binary: Some platforms lack precompiled wrapper (use runplain.sh fallback) Update failures and corrupted updates:\nRouter console updates occasionally fail mid-download due to network interruptions. Manual update procedure:\nDownload i2pupdate_X.X.X.zip from https://geti2p.net/en/download Verify SHA256 checksum matches published hash Copy to I2P install directory as i2pupdate.zip Restart router - automatically detects and extracts update Wait 5-10 minutes for update installation Verify new version at http://127.0.0.1:7657 Migration from very old versions (pre-0.9.47) to current versions may fail due to incompatible signing keys or removed features. Incremental updates required:\nVersions older than 0.9.9: Cannot verify current signatures - manual update needed Versions on Java 6/7: Must upgrade Java before updating I2P to 2.x Major version gaps: Update to intermediate version first (0.9.47 recommended waypoint) When to use installer vs package:\nPackages (apt/yum): Best for servers, automatic security updates, system integration, systemd management Installer (.jar): Best for user-level install, Windows, macOS, custom installations, latest version availability Configuration file corruption and recovery I2P\u0026rsquo;s configuration persistence relies on several critical files. Corruption typically results from improper shutdown, disk errors, or manual editing mistakes. Understanding file purposes enables surgical repair rather than complete reinstallation.\nCritical files and their purposes:\nrouter.keys (516+ bytes): Router\u0026rsquo;s cryptographic identity - losing this creates new identity router.info (auto-generated): Published router information - safe to delete, regenerates router.config (text): Main configuration - bandwidth, network settings, preferences i2ptunnel.config (text): Tunnel definitions - client/server tunnels, keys, destinations netDb/ (directory): Peer database - router information for network participants peerProfiles/ (directory): Performance statistics on peers - influences tunnel selection keyData/ (directory): Destination keys for eepsites and services - losing changes addresses addressbook/ (directory): Local .i2p hostname mappings Complete backup procedure before modifications:\n# Stop I2P first i2prouter stop # or: systemctl stop i2p # Backup directory BACKUP_DIR=~/i2p-backup-$(date +%Y%m%d-%H%M) mkdir -p $BACKUP_DIR # Copy critical files cp -r ~/.i2p/router.keys $BACKUP_DIR/ cp -r ~/.i2p/*.config $BACKUP_DIR/ cp -r ~/.i2p/keyData $BACKUP_DIR/ cp -r ~/.i2p/addressbook $BACKUP_DIR/ cp -r ~/.i2p/eepsite $BACKUP_DIR/ # if hosting sites # Optional but recommended tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR Router.config corruption symptoms:\nRouter won\u0026rsquo;t start with parse errors in logs Settings don\u0026rsquo;t persist after restart Unexpected default values appearing Garbled characters when viewing file Repair corrupted router.config:\nBackup existing: cp router.config router.config.broken Check file encoding: Must be UTF-8 without BOM Validate syntax: Keys use = separator (not :), no trailing spaces on keys, # for comments only Common corruption: Non-ASCII characters in values, line ending issues (CRLF vs LF) If unfixable: Delete router.config - router generates default, preserving identity Essential router.config settings to preserve:\ni2np.bandwidth.inboundKBytesPerSecond=512 i2np.bandwidth.outboundKBytesPerSecond=256 router.updatePolicy=notify routerconsole.lang=en router.hiddenMode=false Lost or invalid router.keys creates new router identity. This is acceptable unless:\nRunning floodfill (loses floodfill status) Hosting eepsites with published address (loses continuity) Established reputation in network No recovery possible without backup - generate new: delete router.keys, restart I2P, new identity created.\nCritical distinction: router.keys (identity) vs keyData/* (services). Losing router.keys changes router identity. Losing keyData/mysite-keys.dat changes your eepsite\u0026rsquo;s .i2p address - catastrophic if address published.\nBackup eepsite/service keys separately:\n# Identify your service keys ls -la ~/.i2p/keyData/ # Backup with descriptive names cp ~/.i2p/keyData/myservice-keys.dat ~/backups/myservice-keys-$(date +%Y%m%d).dat # Store securely (encrypted if sensitive) gpg -c ~/backups/myservice-keys-*.dat NetDb and peerProfiles corruption:\nSymptoms: Zero active peers, can\u0026rsquo;t build tunnels, \u0026ldquo;Database corruption detected\u0026rdquo; in logs\nSafe fix (all will reseed/rebuild automatically):\ni2prouter stop rm -rf ~/.i2p/netDb/* rm -rf ~/.i2p/peerProfiles/* i2prouter start # Wait 10-15 minutes for reseed and integration These directories contain only cached network information - deleting forces fresh bootstrap but loses no critical data.\nPrevention strategies:\nGraceful shutdown always: Use i2prouter stop or router console \u0026ldquo;Shutdown\u0026rdquo; button - never force kill Automated backups: Cron job weekly backup of ~/.i2p to separate disk Disk health monitoring: Check SMART status periodically - failing disks corrupt data Sufficient disk space: Maintain 1+ GB free - full disks cause corruption UPS recommended: Power failures during writes corrupt files Version control critical configs: Git repository for router.config, i2ptunnel.config enables rollback File permissions matter:\n# Correct permissions (user install) chmod 600 ~/.i2p/router.keys chmod 600 ~/.i2p/*.config chmod 700 ~/.i2p/keyData chmod 755 ~/.i2p # Never run as root - creates permission problems Common error messages decoded I2P\u0026rsquo;s logging provides specific error messages that pinpoint problems. Understanding these messages accelerates troubleshooting.\n\u0026ldquo;No tunnels available\u0026rdquo; appears when router hasn\u0026rsquo;t built sufficient tunnels for operation. This is normal during the first 5-10 minutes after startup. If persistent beyond 15 minutes:\nVerify Active Peers \u0026gt; 10 at http://127.0.0.1:7657 Check bandwidth allocation adequate (128+ KB/sec minimum) Examine tunnel success rate at http://127.0.0.1:7657/tunnels (should be \u0026gt;40%) Review logs for tunnel build rejection reasons \u0026ldquo;Clock skew detected\u0026rdquo; or \u0026ldquo;NTCP2 disconnect code 7\u0026rdquo; indicates system time differs from network consensus by more than 90 seconds. I2P requires ±60 second accuracy. Connections with time-divergent routers get automatically rejected.\nFix immediately:\n# Linux sudo timedatectl set-ntp true sudo systemctl restart systemd-timesyncd date # Verify correct time # Windows # Control Panel → Date and Time → Internet Time → Update now # Verify after sync http://127.0.0.1:7657/logs # Should no longer show clock skew warnings \u0026ldquo;Build timeout\u0026rdquo; or \u0026ldquo;Tunnel build timeout exceeded\u0026rdquo; means tunnel construction through peer chain didn\u0026rsquo;t complete within timeout window (typically 60 seconds). Causes:\nSlow peers: Router selected unresponsive participants for tunnel Network congestion: I2P network experiencing high load Insufficient bandwidth: Your bandwidth limits prevent timely tunnel building Overloaded router: Too many participating tunnels consuming resources Solutions: Increase bandwidth, reduce participating tunnels (router.maxParticipatingTunnels at http://127.0.0.1:7657/configadvanced), enable port forwarding for better peer selection.\n\u0026ldquo;Router is shutting down\u0026rdquo; or \u0026ldquo;Graceful shutdown in progress\u0026rdquo; appears during normal shutdown or crash recovery. Graceful shutdown can take up to 10 minutes as router closes tunnels, notifies peers, and persists state.\nIf stuck in shutdown state beyond 11 minutes, force termination:\n# Linux kill -9 $(pgrep -f i2p) # Windows taskkill /F /IM javaw.exe \u0026ldquo;java.lang.OutOfMemoryError: Java heap space\u0026rdquo; signals heap exhaustion. Immediate solutions:\nEdit wrapper.config: wrapper.java.maxmemory=512 (or higher) Complete shutdown required - restart won\u0026rsquo;t apply change Wait 11 minutes for full shutdown Start router fresh Verify memory allocation at http://127.0.0.1:7657/graphs - should show headroom Related memory errors:\n\u0026ldquo;GC overhead limit exceeded\u0026rdquo;: Spending too much time in garbage collection - increase heap \u0026ldquo;Metaspace\u0026rdquo;: Java class metadata space exhausted - add wrapper.java.additional.X=-XX:MaxMetaspaceSize=256M Windows-specific: Kaspersky Antivirus limits Java heap to 512MB regardless of wrapper.config settings - uninstall or add I2P to exclusions.\n\u0026ldquo;Connection timeout\u0026rdquo; or \u0026ldquo;I2CP Error - port 7654\u0026rdquo; when applications try connecting to router:\nVerify router running: http://127.0.0.1:7657 should respond Check I2CP port: netstat -an | grep 7654 should show LISTENING Ensure localhost firewall allows: sudo ufw allow from 127.0.0.1 Verify application using correct port (I2CP=7654, SAM=7656) \u0026ldquo;Certificate validation failed\u0026rdquo; or \u0026ldquo;RouterInfo corrupt\u0026rdquo; during reseed:\nRoot causes: Clock skew (fix first), corrupted netDb, invalid reseed certificates\n# After fixing clock: i2prouter stop rm -rf ~/.i2p/netDb/* # Delete corrupted database i2prouter start # Auto-reseeds with fresh data \u0026ldquo;Database corruption detected\u0026rdquo; indicates disk-level data corruption in netDb or peerProfiles:\n# Safe fix - all will rebuild i2prouter stop rm -rf ~/.i2p/netDb/* ~/.i2p/peerProfiles/* i2prouter start Check disk health with SMART tools - recurring corruption suggests failing storage.\nPlatform-specific challenges Different operating systems present unique I2P deployment challenges related to permissions, security policies, and system integration.\nLinux permission and service issues Package-installed I2P runs as system user i2psvc (Debian/Ubuntu) or i2p (other distributions), requiring specific permissions:\n# Fix package install permissions sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p sudo chmod 644 /var/lib/i2p/*.config # User install permissions (should be your user) chown -R $USER:$USER ~/.i2p chmod 700 ~/.i2p chmod 600 ~/.i2p/router.keys ~/.i2p/*.config File descriptor limits affect router capacity for connections. Default limits (1024) insufficient for high-bandwidth routers:\n# Check current limits ulimit -n # Temporary increase ulimit -n 4096 # Permanent fix: Edit /etc/security/limits.conf i2psvc soft nofile 4096 i2psvc hard nofile 8192 # Systemd override sudo mkdir -p /etc/systemd/system/i2p.service.d/ sudo nano /etc/systemd/system/i2p.service.d/override.conf # Add: [Service] LimitNOFILE=8192 sudo systemctl daemon-reload sudo systemctl restart i2p AppArmor conflicts common on Debian/Ubuntu prevent service startup:\n# Error: \u0026#34;Failed at step APPARMOR spawning /usr/sbin/wrapper\u0026#34; # Cause: AppArmor profile missing or misconfigured # Solution 1: Disable AppArmor for I2P sudo aa-complain /usr/sbin/wrapper # Solution 2: Reconfigure package without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; when asked about AppArmor # Solution 3: LXC/Proxmox containers - disable AppArmor in container config lxc.apparmor.profile: unconfined SELinux issues on RHEL/CentOS/Fedora:\n# Temporary: Set permissive mode sudo setenforce 0 # Permanent: Generate custom policy sudo ausearch -c \u0026#39;java\u0026#39; --raw | audit2allow -M i2p_policy sudo semodule -i i2p_policy.pp # Or disable SELinux for I2P process (less secure) sudo semanage permissive -a i2p_t SystemD service troubleshooting:\n# Detailed service status sudo systemctl status i2p.service -l # Full logs sudo journalctl -xe -u i2p.service # Follow logs live sudo journalctl -f -u i2p.service # Restart with logging sudo systemctl restart i2p.service \u0026amp;\u0026amp; sudo journalctl -f -u i2p.service Windows firewall and antivirus interference Windows Defender and third-party antivirus products frequently flag I2P due to network behavior patterns. Proper configuration prevents unnecessary blocks while maintaining security.\nConfigure Windows Defender Firewall:\n# Run PowerShell as Administrator # Find Java path (adjust for your Java installation) $javaPath = \u0026#34;C:\\Program Files\\Eclipse Adoptium\\jdk-11.0.16.101-hotspot\\bin\\javaw.exe\u0026#34; # Create inbound rules New-NetFirewallRule -DisplayName \u0026#34;I2P Java\u0026#34; -Direction Inbound -Program $javaPath -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P UDP\u0026#34; -Direction Inbound -Protocol UDP -LocalPort 22648 -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P TCP\u0026#34; -Direction Inbound -Protocol TCP -LocalPort 22648 -Action Allow # Add exclusions to Windows Defender Add-MpPreference -ExclusionPath \u0026#34;C:\\Program Files\\i2p\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:APPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:LOCALAPPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionProcess \u0026#34;javaw.exe\u0026#34; Replace port 22648 with your actual I2P port from http://127.0.0.1:7657/confignet.\nKaspersky Antivirus specific issue: Kaspersky\u0026rsquo;s \u0026ldquo;Application Control\u0026rdquo; limits Java heap to 512MB regardless of wrapper.config settings. This causes OutOfMemoryError on high-bandwidth routers.\nSolutions:\nAdd I2P to Kaspersky exclusions: Settings → Additional → Threats and Exclusions → Manage Exclusions Or uninstall Kaspersky (recommended for I2P operation) Third-party antivirus general guidance:\nAdd I2P installation directory to exclusions Add %APPDATA%\\I2P and %LOCALAPPDATA%\\I2P to exclusions Exclude javaw.exe from behavioral analysis Disable \u0026ldquo;Network Attack Protection\u0026rdquo; features that may interfere with I2P protocols macOS Gatekeeper blocking installation macOS Gatekeeper prevents unsigned applications from running. I2P installers aren\u0026rsquo;t signed with Apple Developer ID, triggering security warnings.\nBypass Gatekeeper for I2P installer:\n# Method 1: Remove quarantine attribute xattr -d com.apple.quarantine ~/Downloads/i2pinstall_*.jar java -jar ~/Downloads/i2pinstall_*.jar # Method 2: Use System Settings (macOS 13+) # Try to open installer → macOS blocks it # System Settings → Privacy \u0026amp; Security → scroll down # Click \u0026#34;Open Anyway\u0026#34; next to I2P warning # Confirm in dialog # Method 3: Control-click installer # Control-click (right-click) i2pinstall_*.jar # Select \u0026#34;Open\u0026#34; from menu → \u0026#34;Open\u0026#34; again in dialog # Bypasses Gatekeeper for this specific file After installation running may still trigger warnings:\n# If I2P won\u0026#39;t start due to Gatekeeper: xattr -dr com.apple.quarantine ~/i2p/ Never permanently disable Gatekeeper - security risk for other applications. Use file-specific bypasses only.\nmacOS firewall configuration:\nSystem Preferences → Security \u0026amp; Privacy → Firewall → Firewall Options Click \u0026ldquo;+\u0026rdquo; to add application Navigate to Java installation (e.g., /Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/java) Add and set to \u0026ldquo;Allow incoming connections\u0026rdquo; Android I2P application issues Android version constraints and resource limitations create unique challenges.\nMinimum requirements:\nAndroid 5.0+ (API level 21+) required for current versions 512MB RAM minimum, 1GB+ recommended 100MB storage for app + router data Background app restrictions disabled for I2P App crashes immediately:\nCheck Android version: Settings → About Phone → Android version (must be 5.0+) Uninstall all I2P versions: Only install one variant: net.i2p.android (Google Play) net.i2p.android.router (F-Droid)\nMultiple installs conflict Clear app data: Settings → Apps → I2P → Storage → Clear Data Reinstall from clean state Battery optimization killing router:\nAndroid aggressively kills background apps to save battery. I2P needs exclusion:\nSettings → Battery → Battery optimization (or App battery usage) Find I2P → Don\u0026rsquo;t optimize (or Allow background activity) Settings → Apps → I2P → Battery → Allow background activity + Remove restrictions Connection issues on mobile:\nBootstrap requires WiFi: Initial reseed downloads significant data - use WiFi, not cellular Network changes: I2P doesn\u0026rsquo;t handle network switches gracefully - restart app after WiFi/cellular transition Bandwidth for mobile: Configure conservatively at 64-128 KB/sec to avoid cellular data exhaustion Performance optimization for mobile:\nI2P app → Menu → Settings → Bandwidth Set appropriate limits: 64 KB/sec inbound, 32 KB/sec outbound for cellular Reduce participating tunnels: Settings → Advanced → Max participating tunnels: 100-200 Enable \u0026ldquo;Stop I2P when screen off\u0026rdquo; for battery conservation Torrenting on Android:\nLimit to 2-3 concurrent torrents maximum Reduce DHT aggressiveness Use WiFi only for torrenting Accept slower speeds on mobile hardware Reseed and bootstrap problems New I2P installations require reseeding - fetching initial peer information from public HTTPS servers to join the network. Reseed problems trap users with zero peers and no network access.\n\u0026ldquo;No active peers\u0026rdquo; after fresh install typically indicates reseed failure. Symptoms:\nKnown peers: 0 or stays below 5 \u0026ldquo;Network: Testing\u0026rdquo; persists beyond 15 minutes Logs show \u0026ldquo;Reseed failed\u0026rdquo; or connection errors to reseed servers Why reseed fails:\nFirewall blocking HTTPS: Corporate/ISP firewalls block reseed server connections (port 443) SSL certificate errors: System lacks up-to-date root certificates Proxy requirement: Network requires HTTP/SOCKS proxy for external connections Clock skew: SSL certificate validation fails when system time wrong Geographic censorship: Some countries/ISPs block known reseed servers Force manual reseed:\nAccess http://127.0.0.1:7657/configreseed Click \u0026ldquo;Save changes and reseed now\u0026rdquo; Monitor http://127.0.0.1:7657/logs for \u0026ldquo;Reseed got XX router infos\u0026rdquo; Wait 5-10 minutes for processing Check http://127.0.0.1:7657 - Known peers should increase to 50+ Configure reseed proxy for restrictive networks:\nhttp://127.0.0.1:7657/configreseed → Proxy Configuration:\nHTTP Proxy: [proxy-server]:[port] Or SOCKS5: [socks-server]:[port] Enable \u0026ldquo;Use proxy for reseed only\u0026rdquo; Credentials if required Save and force reseed Alternative: Tor proxy for reseed:\nIf Tor Browser or Tor daemon running:\nProxy type: SOCKS5 Host: 127.0.0.1 Port: 9050 (default Tor SOCKS port) Enable and reseed Manual reseed via su3 file (last resort):\nWhen all automated reseed fails, obtain reseed file out-of-band:\nDownload i2pseeds.su3 from trusted source on unrestricted connection (https://reseed.i2p.rocks/i2pseeds.su3, https://reseed-fr.i2pd.xyz/i2pseeds.su3) Stop I2P completely Copy i2pseeds.su3 to ~/.i2p/ directory Start I2P - automatically extracts and processes file Delete i2pseeds.su3 after processing Verify peers increase at http://127.0.0.1:7657 SSL certificate errors during reseed:\nError: \u0026#34;Reseed: Certificate verification failed\u0026#34; Cause: System root certificates outdated or missing Solutions:\n# Linux - update certificates sudo apt install ca-certificates sudo update-ca-certificates # Windows - install KB updates for root certificate trust # Or install .NET Framework (includes certificate updates) # macOS - update system # Software Update includes certificate trust updates Stuck at 0 known peers beyond 30 minutes:\nIndicates complete reseed failure. Troubleshooting sequence:\nVerify system time accurate (most common issue - fix FIRST) Test HTTPS connectivity: Try accessing https://reseed.i2p.rocks in browser - if fails, network issue Check I2P logs at http://127.0.0.1:7657/logs for specific reseed errors Try different reseed URL: http://127.0.0.1:7657/configreseed → add custom reseed URL: https://reseed-fr.i2pd.xyz/ Use manual su3 file method if automated attempts exhausted Reseed servers occasionally offline: I2P includes multiple hardcoded reseed servers. If one fails, router tries others automatically. Complete failure of all reseed servers extremely rare but possible.\nCurrent active reseed servers (as of October 2025):\nhttps://reseed.i2p.rocks/ https://reseed-fr.i2pd.xyz/ https://i2p.novg.net/ https://i2p-projekt.de/ Add as custom URLs if having issues with defaults.\nFor users in heavily censored regions:\nConsider using Snowflake/Meek bridges through Tor for initial reseed, then switching to direct I2P once integrated. Or obtain i2pseeds.su3 via steganography, email, or USB from outside the censorship zone.\nWhen to seek additional help This guide covers the vast majority of I2P issues, but some problems require developer attention or community expertise.\nSeek help from I2P community when:\nRouter crashes consistently after following all troubleshooting steps Memory leaks causing steady growth beyond allocated heap Tunnel success rate remains below 20% despite adequate configuration New errors in logs not covered by this guide Security vulnerabilities discovered Feature requests or enhancement suggestions Before requesting help, gather diagnostics:\nI2P version: http://127.0.0.1:7657 (e.g., \u0026ldquo;2.10.0\u0026rdquo;) Java version: java -version output Operating system and version Router status: Network state, Active peers count, Participating tunnels Bandwidth configuration: Inbound/outbound limits Port forwarding status: Firewalled or OK Relevant log excerpts: Last 50 lines showing errors from http://127.0.0.1:7657/logs Official support channels:\nForum: https://i2pforum.net (clearnet) or http://i2pforum.i2p (within I2P) IRC: #i2p on Irc2P (irc.postman.i2p via I2P) or irc.freenode.net (clearnet) Reddit: https://reddit.com/r/i2p for community discussion Bug tracker: https://i2pgit.org/i2p-hackers/i2p.i2p/-/issues for confirmed bugs Mailing list: i2p-dev@lists.i2p-projekt.de for development questions Realistic expectations matter. I2P is slower than clearnet by fundamental design - multi-hop encrypted tunneling creates inherent latency. A working I2P router with 30-second page loads and 50 KB/sec torrent speeds is functioning correctly, not broken. Users expecting clearnet speeds will be disappointed regardless of configuration optimization.\nConclusion Most I2P problems stem from three categories: insufficient patience during bootstrap (10-15 minutes required), inadequate resource allocation (512 MB RAM, 256 KB/sec bandwidth minimum), or misconfigured port forwarding. Understanding I2P\u0026rsquo;s distributed architecture and anonymity-focused design helps users distinguish expected behavior from actual problems.\nThe router\u0026rsquo;s \u0026ldquo;Firewalled\u0026rdquo; status, while suboptimal, doesn\u0026rsquo;t prevent I2P usage - only limits network contribution and slightly degrades performance. New users should prioritize stability over optimization: run the router continuously for several days before adjusting advanced settings, as integration improves naturally with uptime.\nWhen troubleshooting, always verify fundamentals first: correct system time, adequate bandwidth, router running continuously, and 10+ active peers. Most issues resolve by addressing these basics rather than adjusting obscure configuration parameters. I2P rewards patience and continuous operation with improved performance as the router builds reputation and optimizes peer selection over days and weeks of uptime.\n","description":"Comprehensive troubleshooting guide for common I2P router issues including connectivity, performance, and configuration problems","id":"2ff67fee0173608876ccc012bf3ff6ce","section":"docs","title":"I2P Router Troubleshooting Guide","url":"/en/docs/troubleshooting/"},{"categories":null,"content":" As required by our threat model (among other reasons), the software developed to support the anonymous communication network we call I2P must be freely available, open source, and user modifiable. To meet these criteria, we make use of a variety of legal and software engineering techniques so as to remove as many barriers to entry for those considering making use of or contributing to the I2P effort. While the information below may be more confusing than just simply stating \"I2P is BSD\", \"I2P is GPL\", or \"I2P is public domain\", the short answer to the question \"How is I2P licensed?\" is this: All software bundled in the I2P distributions will allow: use without fee use with no restrictions on how, when, where, why, or by whom is running it access to the source code without fee modifications to the source Most of the software guarantees much more - the ability of anyone to distribute the modified source however they choose. However, not all of the software bundled provides this freedom - the GPL restricts the ability of developers who wish to integrate I2P with their own applications that are not themselves open source applications. While we applaud the noble goals of increasing the resources in the commons, I2P is best served by removing any barriers that stand in the way of its adoption - if a developer considering whether they can integrate I2P with their application has to stop and check with their lawyer, or conduct a code audit to make sure their own source can be released as GPL-compatible, we lose out. Component licenses The I2P distribution contains several resources, reflecting the partitioning of the source code into components. Each component has its own license, which all developers who contribute to it agree to - either by explicitly declaring the release of code committed under a license compatible with that component, or by implicitly releasing the code committed under the component's primary license. Each of these components has a lead developer who has the final say as to what license is compatible with the component's primary license, and the I2P project manager has the final say as to what licenses meet the above four guarantees for inclusion in the I2P distribution. Component Source path Resource Primary license Alternate licenses Lead developer I2P SDK core i2p.jar Public domain BSD\nCryptix\nMIT zzz I2P Router router router.jar Public domain BSD\nCryptix\nMIT zzz Ministreaming apps/ministreaming mstreaming.jar BSD Public domain\nCryptix\nMIT zzz Streaming apps/streaming streaming.jar Public domain BSD\nCryptix\nMIT zzz I2PTunnel apps/i2ptunnel i2ptunnel.jar GPL + exception Public domain\nBSD\nCryptix\nMIT zzz Routerconsole apps/routerconsole routerconsole.war Public domain \u0026nbsp; zzz Address Book apps/addressbook addressbook.war MIT Public domain\nCryptix\nBSD \u0026nbsp; Susidns apps/susidns susidns.war GPL + exception \u0026nbsp; \u0026nbsp; Susimail apps/susimail susimail.war GPL + exception \u0026nbsp; \u0026nbsp; I2PSnark apps/i2psnark i2psnark.jar GPL + exception \u0026nbsp; zzz BOB Bridge apps/BOB BOB.jar WTFPL \u0026nbsp; sponge SAM Bridge apps/sam sam.jar Public domain Cryptix\nBSD\nMIT zzz SAM v1 Perl library apps/sam/perl SAM.pm GPL Public domain\nCryptix\nBSD\nMIT BrianR SAM v1 C library apps/sam/c libSAM BSD Public domain\nCryptix\nMIT Nightblade SAM v1 Python library apps/sam/python i2p.py Public domain BSD\nCryptix\nMIT Connelly SAM v1 C# library apps/sam/csharp/ n/a Public domain BSD\nCryptix\nMIT smeghead Other apps not mentioned apps/ ... Probably Public domain but check the source \u0026nbsp; \u0026nbsp; Installer installer install.jar, guiinstall.jar Public domain GPL + exception\nBSD\nCryptix\nMIT \u0026nbsp; While it may be redundant, just for clarity the GPL'ed code included within I2PTunnel and other apps must be released under the GPL with an additional \"exception\" explicitly authorizing the use of Java's standard libraries: In addition, as a special exception, XXXX gives permission to link the code of this program with the proprietary Java implementation provided by Sun (or other vendors as well), and distribute linked combinations including the two. You must obey the GNU General Public License in all respects for all of the code used other than the proprietary Java implementation. If you modify this file, you may extend this exception to your version of the file, but you are not obligated to do so. If you do not wish to do so, delete this exception statement from your version.\nAll source code under each component will by default be licensed under the primary license, unless marked otherwise in the code. All of the above is summary of the license terms - please see the specific license for the component or source code in question for authoritative terms. Component source locations and resource packaging may be changed if the repository is reorganized. Except where otherwise noted, content on this site is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. Developers may push changes to a distributed git repository if you receive permission from the person running that repository. See the Git Page for details. However, to have changes included in a release, developers must be trusted by the release manager (currently zzz). In addition, they must explicitly agree with the above terms to be trusted. That means that they must send one of the release managers a signed message affirming that: Unless marked otherwise, all code I commit is implicitly licensed under the component's primary license If specified in the source, the code may be explicitly licensed under one of the component's alternate licenses I have the right to release the code I commit under the terms I am committing it If anyone is aware of any instances where the above conditions are not met, please contact the component lead and/or an I2P release manager with further information. See developers' license agreements. ","description":"License policy and component licenses for software bundled with I2P","id":"74bb6af167b1176b4058e46e5f8ca568","section":"docs","title":"I2P Software Licenses","url":"/en/docs/develop/licenses/"},{"categories":null,"content":" Status:\nThis document supersedes the historical 0.8.x-era threat model.\nIt reflects I2P’s current design as of October 2025.\nLegacy cryptographic and transport protocols (ElGamal, AES, NTCP1, SSU1) are now fully deprecated.\nAll modern communication is based on the Noise Protocol Framework using X25519 + ChaCha20/Poly1305.\nThe goal remains unchanged: preserve anonymity and resilience against realistic adversaries while maintaining backward compatibility.\n1 What “Anonymous” Means I2P provides practical anonymity—not invisibility.\nAnonymity is defined as the difficulty for an adversary to learn information you wish to keep private: who you are, where you are, or who you talk to.\nAbsolute anonymity is impossible; instead, I2P aims for sufficient anonymity under global passive and active adversaries.\nYour anonymity depends on how you configure I2P, how you choose peers and subscriptions, and what applications you expose.\n2 Cryptographic and Transport Evolution (2003 → 2025) Era Primary Algorithms Notes 0.3 – 0.9 ElGamal + AES-256 + DSA-SHA1 Legacy stack (2003–2015) 0.9.15 Ed25519 signatures Replaced DSA 0.9.36 (2018) NTCP2 introduced Noise XK_25519_ChaChaPoly_SHA256 0.9.56 (2022) SSU2 enabled by default Noise-based UDP transport 2.4.0 (2023) NetDB Sub-DB isolation Prevents router↔client linkage 2.8.0+ (2025) Congestion-aware routing / observability reductions DoS hardening 2.10.0 (2025) Post-quantum hybrid ML-KEM support (optional) Experimental Current cryptographic suite (Noise XK):\nX25519 for key exchange ChaCha20/Poly1305 AEAD for encryption Ed25519 (EdDSA-SHA512) for signatures SHA-256 for hashing and HKDF Optional ML-KEM hybrids for post-quantum testing All ElGamal and AES-CBC usages have been retired.\nTransport is entirely NTCP2 ( TCP ) and SSU2 ( UDP ); both support IPv4/IPv6, forward secrecy, and DPI obfuscation.\n3 Network Architecture Summary Free-route mixnet: Senders and receivers each define their own tunnels. No central authority: Routing and naming are decentralized; each router maintains local trust. Unidirectional tunnels: Inbound and outbound are separate (10 min lifetimes). Exploratory tunnels: 2 hops by default; client tunnels 2–3 hops. Floodfill routers: ~1 700 of ~55 000 nodes (~6 %) maintain the distributed NetDB. NetDB rotation: Keyspace rotates daily at UTC midnight. Sub-DB isolation: Since 2.4.0, each client and router use separate databases to prevent linking. 4 Attack Categories and Current Defenses Category Current Status (2025) Primary Defenses Brute Force / Cryptanalysis Impractical with modern primitives (X25519, ChaCha20). Strong crypto, key rotation, Noise handshakes. Timing Attacks Still unsolved for low-latency systems. Unidirectional tunnels, 1024\u0026nbsp;B cells, profile recalc (45\u0026nbsp;s). Research continues for non-trivial delays (3.0+). Intersection Attacks Inherent weakness of low latency mixnets. Tunnel rotation (10\u0026nbsp;min), leaseset expirations, multihoming. Predecessor Attacks Partially mitigated. Tiered peer selection, strict XOR ordering, variable length tunnels. Sybil Attacks No comprehensive defense. IP /16 limits, profiling, diversity rules; HashCash infra exists but not required. Floodfill / NetDB Attacks Improved but still a concern. One /16 per lookup, limit 500 active, daily rotation, randomized verification delay, Sub-DB isolation. DoS / Flooding Frequent (esp. 2023 incidents). Congestion-aware routing (2.4+), aggressive leaseset removal (2.8+). Traffic ID / Fingerprinting Greatly reduced. Noise obfuscation, random padding, no plaintext headers. Censorship / Partitioning Possible with state-level blocking. Hidden mode, IPv6, multiple reseeds, mirrors. Development / Supply Chain Mitigated. Open source, signed SU3 releases (RSA-4096), multi-signer trust model. 5 Modern Network Database (NetDB) Core facts (still accurate):\nModified Kademlia DHT stores RouterInfo and LeaseSets. SHA-256 key hashing; parallel queries to 2 closest floodfills with 10 s timeout. LeaseSet lifetime ≈ 10 min (LeaseSet2) or 18 h (MetaLeaseSet). New types (since 0.9.38):\nLeaseSet2 (Type 3) – multiple encryption types, timestamped. EncryptedLeaseSet2 (Type 5) – blinded destination for private services (DH or PSK auth). MetaLeaseSet (Type 7) – multihoming and extended expirations. Major security upgrade – Sub-DB Isolation (2.4.0):\nPrevents router↔client association. Each client and router use separate netDb segments. Verified and audited (2.5.0). 6 Hidden Mode and Restricted Routes Hidden Mode: Implemented (automatic in strict countries per Freedom House scores).\nRouters don’t publish RouterInfo or route traffic. Restricted Routes: Partially implemented (basic trust-only tunnels).\nComprehensive trusted-peer routing remains planned (3.0+). Trade-off: Better privacy ↔ reduced contribution to network capacity.\n7 DoS and Floodfill Attacks Historical: 2013 UCSB research showed Eclipse and Floodfill takeovers possible.\nModern defenses include:\nDaily keyspace rotation. Floodfill cap ≈ 500, one per /16. Randomized storage verification delays. Newer-router preference (2.6.0). Automatic enrollment fix (2.9.0). Congestion-aware routing and lease throttling (2.4.0+). Floodfill attacks remain theoretically possible but practically harder.\n8 Traffic Analysis and Censorship I2P traffic is hard to identify: no fixed port, no plaintext handshake, and random padding.\nNTCP2 and SSU2 packets mimic common protocols and use ChaCha20 header obfuscation.\nPadding strategies are basic (random sizes), dummy traffic is not implemented (costly).\nConnections from Tor exit nodes are blocked since 2.6.0 (to protect resources).\n9 Persistent Limitations (acknowledged) Timing correlation for low-latency apps remains a fundamental risk. Intersection attacks still powerful against known public destinations. Sybil attacks lack complete defense (HashCash not enforced). Constant-rate traffic and nontrivial delays remain unimplemented (planned 3.0). Transparency about these limits is intentional — it prevents users from over-estimating anonymity.\n10 Network Statistics (2025) ~55 000 active routers worldwide (↑ from 7 000 in 2013) ~1 700 floodfill routers (~6 %) 95 % participate in tunnel routing by default Bandwidth tiers: K (\u0026lt;12 KB/s) → X (\u0026gt;2 MB/s) Minimum floodfill rate: 128 KB/s Router console Java 8+ (required), Java 17+ planned next cycle 11 Development and Central Resources Official site: \u0026lt;/\u0026gt; Docs: \u0026lt;//en/docs\u0026gt; Debian repository: https://deb.i2pgit.org ( replaced deb.i2p2.de in Oct 2023 ) Source code: https://i2pgit.org/I2P_Developers/i2p.i2p (Gitea) + GitHub mirror All releases are signed SU3 containers (RSA-4096, zzz/str4d keys) No active mailing lists; community via https://i2pforum.net and IRC2P. Update cycle: 6–8 weeks stable releases. 12 Summary of Security Improvements Since 0.8.x Year Feature Effect 2015 Ed25519 signatures Removed SHA1/DSA weakness 2018 NTCP2 Noise-based TCP transport 2019 LeaseSet2 / EncryptedLeaseSet2 Hidden services privacy 2022 SSU2 Noise-based UDP transport 2023 Sub-DB Isolation + Congestion-Aware Routing Stopped NetDB linkage / improved resilience 2024 Floodfill selection improvements Reduced long-term node influence 2025 Observability reductions + PQ hybrid crypto Harder timing analysis / future-proofing 13 Known Unsolved or Planned Work Comprehensive restricted routes (trusted-peer routing) → planned 3.0. Non-trivial delay/batching for timing resistance → planned 3.0. Advanced padding and dummy traffic → unimplemented. HashCash identity verification → infrastructure exists but inactive. R5N DHT replacement → proposal only. 14 Key References (Verified 2025) Practical Attacks Against the I2P Network (Egger et al., RAID 2013) Privacy Implications of Performance-Based Peer Selection (Herrmann \u0026amp; Grothoff, PETS 2011) Resilience of the Invisible Internet Project (Muntaka et al., Wiley 2025) I2P official documentation \u0026lt;/docs/overview/threat-model/\u0026gt; 15 Conclusion I2P’s core anonymity model has stood for two decades: sacrifice global uniqueness for local trust and security.\nFrom ElGamal to X25519, NTCP to NTCP2, and from manual reseeds to Sub-DB isolation, the project has evolved while maintaining its philosophy of defense in depth and transparency.\nMany attacks remain theoretically possible against any low-latency mixnet, but I2P’s continuous hardening makes them increasingly impractical.\nThe network is larger, faster, and more secure than ever — yet still honest about its limits.\n","description":"Catalogue of attacks considered in I2P’s design and the mitigations in place","id":"8433fa179e266d091a906a9059db53f4","section":"docs","title":"I2P Threat Model","url":"/en/docs/overview/threat-model/"},{"categories":null,"content":"Overview Several major privacy and anonymity networks exist today, each with different design goals and threat models.\nWhile Tor, Lokinet, GNUnet, and Freenet all contribute valuable approaches to privacy-preserving communication, I2P stands out as the only production-ready, packet-switched network fully optimized for in-network hidden services and peer-to-peer applications.\nThe table below summarizes key architectural and operational distinctions across these networks as of 2025.\nPrivacy Network Comparison (2025) Feature / Network I2P Tor Lokinet Freenet (Hyphanet) GNUnet Primary Focus Hidden services, P2P applications Clearnet anonymity via exits Hybrid VPN + hidden services Distributed storage \u0026 publishing Research framework, F2F privacy Architecture Fully distributed, packet-switched Centralized directory, circuit-switched Packet-switched LLARP with blockchain coordination DHT-based content routing DHT \u0026 F2F topology (R5N) Routing Model Unidirectional tunnels (inbound/outbound) Bidirectional circuits (3 hops) Packet-switched over staked nodes Key-based routing Random walk + DHT hybrid Directory / Peer Discovery Distributed Kademlia netDB with floodfills 9 hardcoded directory authorities Blockchain + Oxen staking Heuristic routing Distributed hash routing (R5N) Encryption ECIES-X25519-AEAD-Ratchet (ChaCha20/Poly1305) AES + RSA/ECDH Curve25519/ChaCha20 Custom symmetric encryption Ed25519/Curve25519 Participation Model All routers route traffic (democratic) Small relay subset, majority are clients Only staked nodes User-selectable trust mesh Optional F2F restriction Traffic Handling Packet-switched, multi-path, load-balanced Circuit-switched, fixed path per circuit Packet-switched, incentivized File chunk propagation Message batching and proof-of-work Garlic Routing ✅ Yes (message bundling \u0026 tagging) ❌ No Partial (message batches) ❌ No ❌ No Exit to Clearnet Limited (discouraged) Core design goal Supported (VPN-style exits) Not applicable Not applicable Built-In Apps I2PSnark, I2PTunnel, SusiMail, I2PBote Tor Browser, OnionShare Lokinet GUI, SNApps Freenet UI GNUnet CLI tools Performance Optimized for internal services, 1–3s RTT Optimized for exits, ~200–500ms RTT Low latency, staked node QoS High latency (minutes) Experimental, inconsistent Anonymity Set Size ~55,000 active routers Millions of daily users \u0026lt;1,000 service nodes Thousands (small core) Hundreds (research only) Scalability Horizontal via floodfill rotation Centralized bottleneck (directory) Dependent on token economics Limited by routing heuristics Research-scale only Funding Model Volunteer-driven nonprofit Major institutional grants Crypto-incentivized (OXEN) Volunteer community Academic research License / Codebase Open source (Java/C++/Go) Open source (C) Open source (C++) Open source (Java) Open source (C) Why I2P Leads in Privacy-First Design 1. Packet Switching \u0026gt; Circuit Switching Tor’s circuit-switched model binds traffic to fixed three-hop paths—efficient for browsing, but brittle for long-lived internal services.\nI2P’s packet-switched tunnels send messages across multiple concurrent paths, automatically routing around congestion or failure for better uptime and load distribution.\n2. Unidirectional Tunnels I2P separates inbound and outbound traffic. This means each participant only ever sees half of a communication flow, making timing correlation attacks significantly harder.\nTor, Lokinet, and others use bidirectional circuits where requests and responses share the same path—simpler, but more traceable.\n3. Fully Distributed netDB Tor’s nine directory authorities define its network topology. I2P uses a self-organizing Kademlia DHT maintained by rotating floodfill routers, eliminating any central control points or coordination servers.\n4. Garlic Routing and Bundling I2P extends onion routing with garlic routing, bundling multiple encrypted messages into one container. This reduces metadata leakage and bandwidth overhead while improving efficiency for acknowledgment, data, and control messages.\n5. Universal Participation Every I2P router routes for others. There are no dedicated relay operators or privileged nodes—bandwidth and reliability automatically determine how much routing a node contributes.\nThis democratic approach builds resilience and scales naturally as the network grows.\n6. Optimized for Hidden Services I2P’s 12-hop round-trip (6 inbound + 6 outbound) creates stronger unlinkability than Tor’s 6-hop hidden service circuits.\nBecause both parties are internal, connections avoid the exit bottleneck entirely, providing faster internal hosting and native application integration (I2PSnark, I2PTunnel, I2PBote).\nArchitectural Takeaways Design Principle I2P Advantage Decentralization No trusted authorities; netDB managed by floodfill peers Traffic Separation Unidirectional tunnels prevent request/response correlation Adaptability Packet-switching allows per-message load balancing Efficiency Garlic routing reduces metadata and increases throughput Inclusiveness All peers route traffic, strengthening anonymity set Focus Built specifically for hidden services and in-network communication When to Use Each Network Use Case Recommended Network Anonymous web browsing (clearnet access) I2P Anonymous hosting, P2P, or DApps I2P Anonymous file publishing and storage Freenet (Hyphanet) VPN-style private routing with staking Lokinet Academic experimentation and research GNUnet Summary I2P’s architecture is uniquely privacy-first—no directory servers, no blockchain dependencies, no centralized trust.\nIts combination of unidirectional tunnels, packet-switched routing, garlic message bundling, and distributed peer discovery makes it the most technically advanced system for anonymous hosting and peer-to-peer communication today.\nI2P is not “a Tor alternative.” It’s a different class of network—built for what happens inside the privacy network, not outside of it.\n","description":"A modern technical and philosophical comparison highlighting I2P’s unique design advantages","id":"bc3abab13910824c59b1550aa1ce69df","section":"docs","title":"I2P vs Other Privacy Networks","url":"/en/docs/overview/comparison/"},{"categories":null,"content":"Introduction I2P is a scalable, self-organizing, resilient packet-switched anonymous network layer, upon which any number of different anonymity or security-conscious applications can operate. Each of these applications may make their own anonymity, latency, and throughput tradeoffs without worrying about the proper implementation of a free route mixnet, allowing them to blend their activity with the larger anonymity set of users already running on top of I2P.\nApplications already available provide the full range of typical Internet activities — anonymous web browsing, web hosting, chat, file sharing, e-mail, blogging, and content syndication, as well as several other applications under development.\nWeb browsing: using any existing browser that supports a proxy Chat: IRC and other protocols File sharing: I2PSnark and other applications E-mail: Susimail and other applications Blog: using any local web server, or available plugins Unlike websites hosted within content distribution networks like Freenet or GNUnet, the services hosted on I2P are fully interactive — there are traditional web-style search engines, bulletin boards, blogs you can comment on, database-driven sites, and bridges to query static systems like Freenet without needing to install them locally.\nWith all of these anonymity-enabled applications, I2P acts as message-oriented middleware — applications specify data to send to a cryptographic identifier (a “destination”), and I2P ensures it arrives securely and anonymously. I2P also includes a simple streaming library to allow I2P’s anonymous best-effort messages to transfer as reliable, in-order streams, offering TCP-based congestion control tuned for the network’s high bandwidth-delay product.\nWhile simple SOCKS proxies have been developed to connect existing applications, their value is limited since most applications leak sensitive information in an anonymous context. The safest approach is to audit and adapt the application to use I2P’s APIs directly.\nI2P is not a research project — academic, commercial, or governmental — but an engineering effort aimed at providing usable anonymity. It has been in continuous development since early 2003 by a distributed group of contributors worldwide. All I2P work is open source on the official website, primarily released into the public domain, with some components under permissive BSD-style licenses. Several GPL-licensed client applications are available, such as I2PTunnel, Susimail, and I2PSnark.\nFunding comes solely from user donations.\nOperation Overview I2P distinguishes clearly between routers (nodes participating in the network) and destinations (anonymous endpoints for applications). Running I2P itself is not secret; what’s hidden is what the user is doing and which router their destinations use. End users typically run several destinations (e.g., one for web browsing, another for hosting, another for IRC).\nA key concept in I2P is the tunnel — a unidirectional encrypted path through a series of routers. Each router only decrypts one layer and only learns the next hop. Tunnels expire every 10 minutes and must be rebuilt.\nFigure 1: Two types of tunnels exist — inbound and outbound.\nOutbound tunnels send messages away from the creator. Inbound tunnels bring messages back to the creator. Combining these enables two-way communication. For example, “Alice” uses an outbound tunnel to send to “Bob’s” inbound tunnel. Alice encrypts her message with routing instructions to Bob’s inbound gateway.\nAnother key concept is the network database or netDb, which distributes metadata about routers and destinations:\nRouterInfo: Contains router contact and key material. LeaseSet: Contains information needed to contact a destination (tunnel gateways, expiry times, encryption keys). Routers publish their RouterInfo directly to the netDb; LeaseSets are sent through outbound tunnels for anonymity.\nTo build tunnels, Alice queries the netDb for RouterInfo entries to choose peers, and sends encrypted tunnel build messages hop-by-hop until the tunnel is complete.\nFigure 2: Router information is used to build tunnels.\nTo send to Bob, Alice looks up Bob’s LeaseSet and uses one of her outbound tunnels to route data through to Bob’s inbound tunnel gateway.\nFigure 3: LeaseSets connect outbound and inbound tunnels.\nBecause I2P is message-based, it adds end-to-end garlic encryption to protect messages even from the outbound endpoint or inbound gateway. A garlic message wraps multiple encrypted “cloves” (messages) to hide metadata and improve anonymity.\nApplications can either use the message interface directly or rely on the streaming library for reliable connections.\nTunnels Both inbound and outbound tunnels use layered encryption, but differ in construction:\nIn inbound tunnels, the creator (the endpoint) decrypts all layers. In outbound tunnels, the creator (the gateway) pre-decrypts layers to ensure clarity at the endpoint. I2P profiles peers via indirect metrics such as latency and reliability without direct probing. Based on these profiles, peers are grouped dynamically into four tiers:\nFast and high capacity High capacity Not failing Failing Tunnel peer selection typically prefers high-capacity peers, randomly chosen to balance anonymity and performance, with additional XOR-based ordering strategies to mitigate predecessor attacks and netDb harvesting.\nFor deeper details, see the Tunnel Specification.\nNetwork Database (netDb) Routers participating in the floodfill distributed hash table (DHT) store and respond to LeaseSet lookups. The DHT uses a variant of Kademlia.\nFloodfill routers are selected automatically if they have enough capacity and stability, or may be configured manually.\nRouterInfo: Describes a router’s capabilities and transports. LeaseSet: Describes a destination’s tunnels and encryption keys. All data in the netDb is signed by the publisher and timestamped to prevent replay or stale entry attacks. Timing synchronization is maintained through SNTP and transport-layer skew detection.\nAdditional concepts Unpublished and encrypted LeaseSets:\nA destination may remain private by not publishing its LeaseSet, sharing it only with trusted peers. Access requires the appropriate decryption key.\nBootstrapping (reseeding):\nTo join the network, a new router fetches signed RouterInfo files from trusted HTTPS reseed servers.\nLookup scalability:\nI2P uses iterative, not recursive, lookups to improve DHT scalability and security.\nTransport Protocols Modern I2P communication uses two fully encrypted transports:\nNTCP2: Encrypted TCP-based protocol SSU2: Encrypted UDP-based protocol Both are built on the modern Noise Protocol Framework, providing strong authentication and resistance to traffic fingerprinting. They replaced legacy NTCP and SSU protocols (fully retired since 2023).\nNTCP2 offers encrypted, efficient streaming over TCP.\nSSU2 provides UDP-based reliability, NAT traversal, and optional hole punching.\nSSU2 is conceptually similar to WireGuard or QUIC, balancing reliability and anonymity.\nRouters may support both IPv4 and IPv6, publishing their transport addresses and costs in the netDb. A connection’s transport is selected dynamically by a bidding system that optimizes for conditions and existing links.\nCryptography I2P uses layered cryptography for all components: transports, tunnels, garlic messages, and the network database.\nCurrent primitives include:\nX25519 for key exchange EdDSA (Ed25519) for signatures ChaCha20-Poly1305 for authenticated encryption SHA-256 for hashing AES256 for tunnel layer encryption Legacy algorithms (ElGamal, DSA-SHA1, ECDSA) remain for backward compatibility.\nI2P is currently introducing hybrid post-quantum (PQ) cryptographic schemes combining X25519 with ML-KEM to resist “harvest-now, decrypt-later” attacks.\nGarlic Messages Garlic messages extend onion routing by grouping multiple encrypted “cloves” with independent delivery instructions. These allow message-level routing flexibility and uniform traffic padding.\nSession Tags Two cryptographic systems are supported for end-to-end encryption:\nElGamal/AES+SessionTags (legacy):\nUses pre-delivered session tags as 32-byte nonces. Now deprecated due to inefficiency.\nECIES-X25519-AEAD-Ratchet (current):\nUses ChaCha20-Poly1305 and synchronized HKDF-based PRNGs to generate ephemeral session keys and 8-byte tags dynamically, reducing CPU, memory, and bandwidth overhead while maintaining forward secrecy.\nFuture of the Protocol Key research areas focus on maintaining security against state-level adversaries and introducing post-quantum protections. Two early design concepts — restricted routes and variable latency — have been superseded by modern developments.\nRestricted Route Operation Original restricted routing concepts aimed to obscure IP addresses.\nThis need has been largely mitigated by:\nUPnP for automatic port forwarding Robust NAT traversal in SSU2 IPv6 support Cooperative introducers and NAT hole-punching Optional overlay (e.g., Yggdrasil) connectivity Thus, modern I2P achieves the same goals more practically without complex restricted routing.\nSimilar Systems I2P integrates concepts from message-oriented middleware, DHTs, and mixnets. Its innovation lies in combining these into a usable, self-organizing anonymity platform.\nTor Website\nTor and I2P share goals but differ architecturally:\nTor: Circuit-switched; relies on trusted directory authorities. (~10k relays) I2P: Packet-switched; fully distributed DHT-driven network. (~50k routers) I2P’s unidirectional tunnels expose less metadata and allow flexible routing paths, while Tor focuses on anonymous Internet access (outproxying).\nI2P instead supports anonymous in-network hosting.\nFreenet Website\nFreenet focuses on anonymous, persistent file publishing and retrieval.\nI2P, in contrast, provides a real-time communications layer for interactive use (web, chat, torrents).\nTogether, the two systems complement each other — Freenet provides censorship-resistant storage; I2P provides transport anonymity.\nOther Networks Lokinet: IP-based overlay using incentivized service nodes. Nym: Next-generation mixnet emphasizing metadata protection with cover traffic at higher latency. Appendix A: Application Layer I2P itself only handles message transport. Application-layer functionality is implemented externally through APIs and libraries.\nStreaming Library The streaming library functions as I2P’s TCP analog, with a sliding window protocol and congestion control tuned for high-latency anonymous transport.\nTypical HTTP request/response patterns can often complete in a single round-trip due to message bundling optimizations.\nNaming Library and Address Book Developed by: mihi, Ragnarok\nSee the Naming and Address Book page.\nI2P’s naming system is local and decentralized, avoiding DNS-style global names. Each router maintains a local mapping of human-readable names to destinations. Optional web-of-trust-based address books can be shared or imported from trusted peers.\nThis approach avoids centralized authorities and circumvents Sybil vulnerabilities inherent in global or voting-style naming systems.\nI2PTunnel Developed by: mihi\nI2PTunnel is the main client layer interface enabling anonymous TCP proxying.\nIt supports:\nClient tunnels (outbound to I2P destinations) HTTP client (eepproxy) for \u0026ldquo;.i2p\u0026rdquo; domains Server tunnels (inbound from I2P to a local service) HTTP server tunnels (securely proxy web services) Outproxying (to the regular Internet) is optional, implemented by volunteer-run “server” tunnels.\nI2PSnark Developed by: jrandom, et al — ported from Snark\nBundled with I2P, I2PSnark is an anonymous multi-torrent BitTorrent client with DHT and UDP support, accessible via a web interface.\nI2Pmail / Susimail Developed by: postman, susi23, mastiejaner\nI2Pmail provides anonymous email through I2PTunnel connections.\nSusimail is a web-based client built specifically to prevent information leaks common in traditional email clients.\nThe mail.i2p service features virus filtering, hashcash quotas, and outproxy separation for additional protection.\n","description":"Technical introduction to I2P architecture and operation","id":"75218044125880755dabbc53c9ce4b06","section":"docs","title":"I2P: A scalable framework for anonymous communication","url":"/en/docs/overview/tech-intro/"},{"categories":null,"content":"I2PControl API Documentation I2PControl is a JSON-RPC 2.0 API bundled with the I2P router (since version 0.9.39). It enables authenticated monitoring and control of the router via structured JSON requests.\nDefault password: itoopie — this is the factory default and should be changed immediately for security.\n1. Overview \u0026amp; Access Implementation Default Endpoint Protocol Enabled by Default Notes Java I2P (2.10.0+) http://127.0.0.1:7657/jsonrpc/ HTTP ❌ Must be enabled via WebApps (Router Console) Bundled webapp i2pd (C++ implementation) https://127.0.0.1:7650/ HTTPS ✅ Enabled by default Legacy plugin behavior In the Java I2P case, you must go to Router Console → WebApps → I2PControl and enable it (set to start automatically).\nOnce active, all methods require that you first authenticate and receive a session token.\n2. JSON-RPC Format All requests follow the JSON-RPC 2.0 structure:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;MethodName\u0026#34;, \u0026#34;params\u0026#34;: { /* named parameters */ } } A successful response includes a result field; on failure, an error object is returned:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { /* data */ } } or\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: -32001, \u0026#34;message\u0026#34;: \u0026#34;Invalid password\u0026#34; } } 3. Authentication Flow Request (Authenticate) curl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;Authenticate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;API\u0026#34;: 1, \u0026#34;Password\u0026#34;: \u0026#34;itoopie\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Successful Response { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;API\u0026#34;: 1 } } You must include that Token in all subsequent requests in the params.\n4. Methods \u0026amp; Endpoints 4.1 RouterInfo Fetches key telemetry about the router.\nRequest Example\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterInfo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.version\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.tunnels.participating\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.inbound.1s\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.outbound.1s\u0026#34;: \u0026#34;\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Response Fields (result)\nAccording to the official docs (GetI2P):\ni2p.router.status (String) — a human-readable status i2p.router.uptime (long) — milliseconds (or string for older i2pd) :contentReference[oaicite:0]{index=0} i2p.router.version (String) — version string :contentReference[oaicite:1]{index=1} i2p.router.net.bw.inbound.1s, i2p.router.net.bw.inbound.15s (double) — inbound bandwidth in B/s :contentReference[oaicite:2]{index=2} i2p.router.net.bw.outbound.1s, i2p.router.net.bw.outbound.15s (double) — outbound bandwidth in B/s :contentReference[oaicite:3]{index=3} i2p.router.net.status (long) — numeric status code (see enum below) :contentReference[oaicite:4]{index=4} i2p.router.net.tunnels.participating (long) — number of participating tunnels :contentReference[oaicite:5]{index=5} i2p.router.netdb.activepeers, fastpeers, highcapacitypeers (long) — netDB peer stats :contentReference[oaicite:6]{index=6} i2p.router.netdb.isreseeding (boolean) — whether reseed is active :contentReference[oaicite:7]{index=7} i2p.router.netdb.knownpeers (long) — total known peers :contentReference[oaicite:8]{index=8} Status Code Enum (i2p.router.net.status) Code Meaning 0 OK 1 TESTING 2 FIREWALLED 3 HIDDEN 4 WARN_FIREWALLED_AND_FAST 5 WARN_FIREWALLED_AND_FLOODFILL 6 WARN_FIREWALLED_WITH_INBOUND_TCP 7 WARN_FIREWALLED_WITH_UDP_DISABLED 8 ERROR_I2CP 9 ERROR_CLOCK_SKEW 10 ERROR_PRIVATE_TCP_ADDRESS 11 ERROR_SYMMETRIC_NAT 12 ERROR_UDP_PORT_IN_USE 13 ERROR_NO_ACTIVE_PEERS_CHECK_CONNECTION_AND_FIREWALL 14 ERROR_UDP_DISABLED_AND_TCP_UNSET 4.2 GetRate Used to fetch rate metrics (e.g. bandwidth, tunnel success) over a given time window.\nRequest Example\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GetRate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Stat\u0026#34;: \u0026#34;bw.combined\u0026#34;, \u0026#34;Period\u0026#34;: 60000 } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Sample Response\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Rate\u0026#34;: 12345.67 } } 4.3 RouterManager Perform administrative actions.\nAllowed parameters / methods\nRestart, RestartGraceful Shutdown, ShutdownGraceful Reseed, FindUpdates, Update :contentReference[oaicite:10]{index=10} Request Example\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterManager\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Restart\u0026#34;: true } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Successful Response\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Restart\u0026#34;: null } } 4.4 NetworkSetting Get or set network configuration parameters (ports, upnp, bandwidth share, etc.)\nRequest Example (get current values)\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;NetworkSetting\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.net.ntcp.port\u0026#34;: null, \u0026#34;i2p.router.net.ssu.port\u0026#34;: null, \u0026#34;i2p.router.net.bw.share\u0026#34;: null, \u0026#34;i2p.router.net.upnp\u0026#34;: null } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Sample Response\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;i2p.router.net.ntcp.port\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;i2p.router.net.ssu.port\u0026#34;: \u0026#34;5678\u0026#34;, \u0026#34;i2p.router.net.bw.share\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;i2p.router.net.upnp\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;SettingsSaved\u0026#34;: true, \u0026#34;RestartNeeded\u0026#34;: false } } Note: i2pd versions prior to 2.41 may return numeric types instead of strings — clients should handle both. :contentReference[oaicite:11]{index=11}\n4.5 AdvancedSettings Allows manipulating internal router parameters.\nRequest Example\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;AdvancedSettings\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Response Example\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } } 5. Error Codes In addition to standard JSON-RPC errors (-32700, -32600, etc.), I2PControl defines:\nCode Meaning -32001 Invalid password -32002 Missing token -32003 Token does not exist -32004 Token expired -32005 API version missing -32006 API version unsupported 6. Usage \u0026amp; Best Practices Always include the Token parameter (except when authenticating). Change the default password (itoopie) upon first use. For Java I2P, ensure the I2PControl webapp is enabled via WebApps. Be prepared for slight variations: some fields may be numbers or strings, depending on I2P version. Wrap long status strings for display-friendly output. ","description":"Remote router management API via the I2PControl webapp","id":"f0e7aa57ce714931128f06f6bdb94db3","section":"docs","title":"I2PControl JSON-RPC","url":"/en/docs/api/i2pcontrol/"},{"categories":null,"content":"Overview I2PTunnel is a core I2P component for interfacing with and providing services on the I2P network. It enables TCP-based and media streaming applications to operate anonymously through tunnel abstraction. A tunnel’s destination can be defined by a hostname, Base32, or a full destination key.\nEach established tunnel listens locally (e.g., localhost:port) and connects internally to I2P destinations. To host a service, create a tunnel pointing to the desired IP and port. A corresponding I2P destination key is generated, allowing the service to become globally reachable within the I2P network. The I2PTunnel web interface is available at localhost:7657/i2ptunnel/.\nDefault Services Server tunnel I2P Webserver – A tunnel to a Jetty webserver at localhost:7658 for easy hosting on I2P. Unix: $HOME/.i2p/eepsite/docroot Windows: %LOCALAPPDATA%\\I2P\\I2P Site\\docroot → C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\I2P\\I2P Site\\docroot Client tunnels I2P HTTP Proxy – localhost:4444 – Used for browsing I2P and the Internet through outproxies. I2P HTTPS Proxy – localhost:4445 – Secure variant of the HTTP proxy. Irc2P – localhost:6668 – Default anonymous IRC network tunnel. Git SSH (gitssh.idk.i2p) – localhost:7670 – Client tunnel for repository SSH access. Postman SMTP – localhost:7659 – Client tunnel for outgoing mail. Postman POP3 – localhost:7660 – Client tunnel for incoming mail. Note: Only the I2P Webserver is a default server tunnel; all others are client tunnels connecting to external I2P services.\nConfiguration The I2PTunnel configuration specification is documented at /spec/configuration.\nClient Modes Standard Opens a local TCP port that connects to a service on an I2P destination. Supports multiple destination entries separated by commas for redundancy.\nHTTP A proxy tunnel for HTTP/HTTPS requests. Supports local and remote outproxies, header stripping, caching, authentication, and transparent compression.\nPrivacy protections:\nStrips headers: Accept-*, Referer, Via, From Replaces host headers with Base32 destinations Enforces RFC-compliant hop-by-hop stripping Adds support for transparent decompression Provides internal error pages and localized responses Compression behavior:\nRequests may use custom header X-Accept-Encoding: x-i2p-gzip Responses with Content-Encoding: x-i2p-gzip are transparently decompressed Compression evaluated by MIME type and response length for efficiency Persistence (new since 2.5.0):\nHTTP Keepalive and persistent connections are now supported for I2P-hosted services through the Hidden Services Manager. This reduces latency and connection overhead but does not yet enable full RFC 2616-compliant persistent sockets across all hops.\nPipelining:\nRemains unsupported and unnecessary; modern browsers have deprecated it.\nUser-Agent behavior:\nOutproxy: Uses a current Firefox ESR User-Agent. Internal: MYOB/6.66 (AN/ON) for anonymity consistency. IRC Client Connects to I2P-based IRC servers. Allows a safe subset of commands while filtering identifiers for privacy.\nSOCKS 4/4a/5 Provides SOCKS proxy capability for TCP connections. UDP remains unimplemented in Java I2P (only in i2pd).\nCONNECT Implements HTTP CONNECT tunneling for SSL/TLS connections.\nStreamr Enables UDP-style streaming via TCP-based encapsulation. Supports media streaming when paired with a corresponding Streamr server tunnel.\nServer Modes Standard Server Creates a TCP destination mapped to a local IP:port.\nHTTP Server Creates a destination that interfaces with a local web server. Supports compression (x-i2p-gzip), header stripping, and DDoS protections. Now benefits from persistent connection support (v2.5.0+) and thread pooling optimization (v2.7.0–2.9.0).\nHTTP Bidirectional Deprecated – Still functional but discouraged. Acts as both HTTP server and client without outproxying. Primarily used for diagnostic loopback tests.\nIRC Server Creates a filtered destination for IRC services, passing client destination keys as hostnames.\nStreamr Server Couples with a Streamr client tunnel to handle UDP-style data streams over I2P.\nNew Features (2.4.0–2.10.0) Feature Introduced Summary Keepalive/Persistent Connections 2.5.0 HTTP tunnels now support persistent sockets for I2P-hosted services, improving performance. Thread Pooling Optimization 2.7.0-2.9.0 Reduced CPU overhead and latency by improving thread management. Post-Quantum Encryption (ML-KEM) 2.10.0 Optional hybrid X25519+ML-KEM encryption to resist future quantum attacks. NetDB Segmentation 2.4.0 Isolates I2PTunnel contexts for improved security and privacy. SSU1 Removal / SSU2 Adoption 2.4.0-2.6.0 Upgraded transport layer; transparent to users. I2P-over-Tor Blocking 2.6.0 Prevents inefficient and unstable I2P-over-Tor routing. Browser Proxy (Proposal 166) 2.7.0 Introduced identity-aware proxy mode; details pending confirmation. Java 17 Requirement (upcoming) 2.11.0 Future release will require Java 17+. Security Features Header stripping for anonymity (Accept, Referer, From, Via) User-Agent randomization depending on in/outproxy POST rate limiting and Slowloris protection Connection throttling in streaming subsystems Network congestion handling at tunnel layer NetDB isolation preventing cross-application leaks Technical Details Default destination key size: 516 bytes (may exceed for extended LS2 certificates) Base32 addresses: {52–56+ chars}.b32.i2p Server tunnels remain compatible with both Java I2P and i2pd Deprecated feature: httpbidirserver only; no removals since 0.9.59 Verified correct default ports and document roots for all platforms Summary I2PTunnel remains the backbone of application integration with I2P. Between 0.9.59 and 2.10.0, it gained persistent connection support, post-quantum encryption, and major threading improvements. Most configurations remain compatible, but developers should verify their setups to ensure compliance with modern transport and security defaults.\n","description":"Tool for interfacing with and providing services on I2P","id":"7e5d426e3eead28c1767764107b1f3d1","section":"docs","title":"I2PTunnel","url":"/en/docs/api/i2ptunnel/"},{"categories":null,"content":"I2P’s plugin framework lets you extend the router without touching the core installation. Available plugins cover mail, blogs, IRC, storage, wikis, monitoring tools, and more.\nSecurity note: Plugins run with the same permissions as the router. Treat third-party downloads the same way you would treat any signed software update—verify the source before installing.\n1. Install a Plugin Copy the plugin’s download URL from the project page.\nOpen the router console’s Plugin Configuration page.\nPaste the URL into the install field and click Install Plugin.\nThe router fetches the signed archive, verifies the signature, and activates the plugin immediately. Most plugins add console links or background services without requiring a router restart.\n2. Why Plugins Matter One-click distribution for end users—no manual edits to wrapper.config or clients.config Keeps the core i2pupdate.su3 bundle small while delivering large or niche features on demand Optional per-plugin JVMs provide process isolation when required Automatic compatibility checks against the router version, Java runtime, and Jetty Update mechanism mirrors the router: signed packages and incremental downloads Console integrations, language packs, UI themes, and non-Java apps (via scripts) are all supported Enables curated “app store” directories such as plugins.i2p 3. Manage Installed Plugins Use the controls on configclients.jsp#plugin to:\nCheck a single plugin for updates Check every plugin at once (triggered automatically after router upgrades) Install any available updates with one click\nEnable/disable autostart for plugins that register services Uninstall plugins cleanly 4. Build Your Own Plugin Review the plugin specification for packaging, signing, and metadata requirements. Use makeplugin.sh to wrap an existing binary or webapp into an installable archive. Publish both install and update URLs so the router can distinguish first-time installs from incremental upgrades. Provide checksums and signing keys prominently on your project page to help users verify authenticity. Looking for examples? Browse the source of community plugins on plugins.i2p (for instance, the snowman sample).\n5. Known Limitations Updating a plugin that ships plain JAR files may require a router restart because the Java class loader caches classes. The console may display a Stop button even if the plugin has no active process. Plugins launched in a separate JVM create a logs/ directory in the current working directory. The first time a signer key appears it is trusted automatically; there is no central signing authority. Windows sometimes leaves empty directories behind after uninstalling a plugin. Installing a Java 6–only plugin on a Java 5 JVM reports “plugin is corrupt” due to Pack200 compression. Theme and translation plugins remain largely untested. Autostart flags do not always persist for unmanaged plugins. 6. Requirements \u0026amp; Best Practices Plugin support is available in I2P 0.7.12 and newer. Keep your router and plugins up to date to receive security fixes. Ship concise release notes so users understand what changes between versions. When possible, host plugin archives over HTTPS inside I2P to minimise clear-net metadata exposure. 7. Further Reading Plugin specification Client application framework I2P scripts repository for packaging utilities ","description":"Installing, updating, and developing router plugins","id":"f8687b90431c32a8ee7e10be9f7c44e0","section":"docs","title":"Installing Custom Plugins","url":"/en/docs/guides/plugins/"},{"categories":null,"content":"The I2P project maintains official packages for Debian, Ubuntu, and their derivative distributions. This guide provides comprehensive instructions for installing I2P using our official repositories.\n🚀 Beta: Automatic Installation (Experimental) For advanced users who want a quick automated installation:\nThis one-liner will automatically detect your distribution and install I2P. Use with caution - review the installation script before running.\ncurl -fsSL https://i2p.net/installlinux.sh | sudo bash What this does:\nDetects your Linux distribution (Ubuntu/Debian) Adds the appropriate I2P repository Installs GPG keys and required packages Installs I2P automatically ⚠️ This is a beta feature. If you prefer manual installation or want to understand each step, use the manual installation methods below.\nSupported Platforms The Debian packages are compatible with:\nUbuntu 18.04 (Bionic) and newer Linux Mint 19 (Tara) and newer Debian Buster (10) and newer Knoppix Other Debian-based distributions (LMDE, ParrotOS, Kali Linux, etc.) Supported architectures: amd64, i386, armhf, arm64, powerpc, ppc64el, s390x\nThe I2P packages may work on other Debian-based systems not explicitly listed above. If you encounter issues, please report them on our GitLab.\nInstallation Methods Choose the installation method that matches your distribution:\nOption 1: Ubuntu and derivatives (Linux Mint, elementary OS, Pop!_OS, etc.) Option 2: Debian and Debian-based distributions (including LMDE, Kali, ParrotOS) Ubuntu Installation Ubuntu and its official derivatives (Linux Mint, elementary OS, Trisquel, etc.) can use the I2P PPA (Personal Package Archive) for easy installation and automatic updates.\nMethod 1: Command Line Installation (Recommended) This is the fastest and most reliable method for installing I2P on Ubuntu-based systems.\nStep 1: Add the I2P PPA\nOpen a terminal and run:\nsudo apt-add-repository ppa:i2p-maintainers/i2p This command adds the I2P PPA to /etc/apt/sources.list.d/ and automatically imports the GPG key that signs the repository. The GPG signature ensures packages haven\u0026rsquo;t been tampered with since they were built.\nStep 2: Update the package list\nRefresh your system\u0026rsquo;s package database to include the new PPA:\nsudo apt-get update This retrieves the latest package information from all enabled repositories, including the I2P PPA you just added.\nStep 3: Install I2P\nNow install I2P:\nsudo apt-get install i2p That\u0026rsquo;s it! Skip to the Post-Installation Configuration section to learn how to start and configure I2P.\nMethod 2: Using the Software Center GUI If you prefer a graphical interface, you can add the PPA using Ubuntu\u0026rsquo;s Software Center.\nStep 1: Open Software and Updates\nLaunch \u0026ldquo;Software and Updates\u0026rdquo; from your applications menu.\nStep 2: Navigate to Other Software\nSelect the \u0026ldquo;Other Software\u0026rdquo; tab and click the \u0026ldquo;Add\u0026rdquo; button at the bottom to configure a new PPA.\nStep 3: Add the I2P PPA\nIn the PPA dialog box, enter:\nppa:i2p-maintainers/i2p Step 4: Reload repository information\nClick the \u0026ldquo;Reload\u0026rdquo; button to download the updated repository information.\nStep 5: Install I2P\nOpen the \u0026ldquo;Software\u0026rdquo; application from your applications menu, search for \u0026ldquo;i2p\u0026rdquo;, and click Install.\nOnce installation completes, proceed to Post-Installation Configuration.\nDebian Installation Debian and its downstream distributions (LMDE, Kali Linux, ParrotOS, Knoppix, etc.) should use the official I2P Debian repository at deb.i2p.net.\nImportant Notice Our old repositories at deb.i2p2.de and deb.i2p2.no are end-of-life. If you\u0026rsquo;re using these legacy repositories, please follow the instructions below to migrate to the new repository at deb.i2p.net.\nPrerequisites All steps below require root access. Either switch to the root user with su, or prefix each command with sudo.\nInstallation Steps Step 1: Install required packages\nEnsure you have the necessary tools installed:\nsudo apt-get update sudo apt-get install apt-transport-https lsb-release curl These packages enable secure HTTPS repository access, distribution detection, and file downloads.\nStep 2: Add the I2P repository\nThe command you use depends on your Debian version. First, determine which version you\u0026rsquo;re running:\ncat /etc/debian_version Cross-reference this with the Debian release information to identify your distribution codename (e.g., Bookworm, Bullseye, Buster).\nFor Debian Bullseye (11) or newer:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list For Debian derivatives (LMDE, Kali, ParrotOS, etc.) on Bullseye-equivalent or newer:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list For Debian Buster (10) or older:\necho \u0026#34;deb https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list For Debian derivatives on Buster-equivalent or older:\necho \u0026#34;deb https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Step 3: Download the repository signing key\ncurl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg Step 4: Verify the key fingerprint\nBefore trusting the key, verify its fingerprint matches the official I2P signing key:\ngpg --keyid-format long --import --import-options show-only --with-fingerprint i2p-archive-keyring.gpg Verify the output shows this fingerprint:\n7840 E761 0F28 B904 7535 49D7 67EC E560 5BCF 1346 ⚠️ Do not proceed if the fingerprint doesn\u0026rsquo;t match. This could indicate a compromised download.\nStep 5: Install the repository key\nCopy the verified keyring to the system keyrings directory:\nsudo cp i2p-archive-keyring.gpg /usr/share/keyrings For Debian Buster or older only, you also need to create a symlink:\nsudo ln -sf /usr/share/keyrings/i2p-archive-keyring.gpg /etc/apt/trusted.gpg.d/i2p-archive-keyring.gpg Step 6: Update package lists\nRefresh your system\u0026rsquo;s package database to include the I2P repository:\nsudo apt-get update Step 7: Install I2P\nInstall both the I2P router and the keyring package (which ensures you receive future key updates):\nsudo apt-get install i2p i2p-keyring Great! I2P is now installed. Continue to the Post-Installation Configuration section.\nPost-Installation Configuration After installing I2P, you\u0026rsquo;ll need to start the router and perform some initial configuration.\nStarting I2P The I2P packages provide three ways to run the I2P router:\nOption 1: On-Demand (Basic) Start I2P manually when needed using the i2prouter script:\ni2prouter start Important: Do not use sudo or run this as root! I2P should run as your regular user.\nTo stop I2P:\ni2prouter stop Option 2: On-Demand (Without Java Service Wrapper) If you\u0026rsquo;re on a non-x86 system or the Java Service Wrapper doesn\u0026rsquo;t work on your platform, use:\ni2prouter-nowrapper Again, do not use sudo or run as root.\nOption 3: System Service (Recommended) For the best experience, configure I2P to start automatically when your system boots, even before login:\nsudo dpkg-reconfigure i2p This opens a configuration dialog. Select \u0026ldquo;Yes\u0026rdquo; to enable I2P as a system service.\nThis is the recommended method because:\nI2P starts automatically on boot Your router maintains better network integration You contribute to network stability I2P is available immediately when you need it Initial Router Configuration After starting I2P for the first time, it will take several minutes to integrate into the network. Meanwhile, configure these essential settings:\n1. Configure NAT/Firewall For optimal performance and network participation, forward the I2P ports through your NAT/firewall:\nOpen the I2P router console at http://127.0.0.1:7657/ Navigate to the Network Configuration page Note the port numbers listed (usually random ports between 9000-31000) Forward these UDP and TCP ports in your router/firewall If you need help with port forwarding, portforward.com provides router-specific guides.\n2. Adjust Bandwidth Settings The default bandwidth settings are conservative. Adjust them based on your internet connection:\nVisit the Configuration page Find the bandwidth settings section The defaults are 96 KB/s download / 40 KB/s upload Increase these if you have faster internet (e.g., 250 KB/s down / 100 KB/s up for a typical broadband connection) Note: Setting higher limits helps the network and improves your own performance.\n3. Configure Your Browser To access I2P sites (eepsites) and services, configure your browser to use I2P\u0026rsquo;s HTTP proxy:\nSee our Browser Configuration Guide for detailed setup instructions for Firefox, Chrome, and other browsers.\nTroubleshooting I2P won\u0026rsquo;t start Ensure you\u0026rsquo;re not running I2P as root: ps aux | grep i2p Check logs: tail -f ~/.i2p/wrapper.log Verify Java is installed: java -version Repository key errors If you receive GPG key errors during installation:\nRe-download and verify the key fingerprint (Step 3-4 above) Ensure the keyring file has correct permissions: sudo chmod 644 /usr/share/keyrings/i2p-archive-keyring.gpg Updates aren\u0026rsquo;t working If I2P isn\u0026rsquo;t receiving updates:\nVerify the repository is configured: cat /etc/apt/sources.list.d/i2p.list Update package lists: sudo apt-get update Check for I2P updates: sudo apt-get upgrade Migrating from old repositories If you\u0026rsquo;re using the old deb.i2p2.de or deb.i2p2.no repositories:\nRemove the old repository: sudo rm /etc/apt/sources.list.d/i2p.list Follow the Debian Installation steps above Update: sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install i2p i2p-keyring Next Steps Now that I2P is installed and running:\nConfigure your browser to access I2P sites Explore the I2P router console to monitor your router Learn about I2P applications you can use Read about how I2P works to understand the network Welcome to the Invisible Internet!\n","description":"Complete guide to installing I2P on Debian, Ubuntu, and their derivatives using official repositories","id":"88fb5f6d2f5129ce7be2a42b1e9fb9af","section":"docs","title":"Installing I2P on Debian and Ubuntu","url":"/en/docs/guides/installing-i2p-on-debian-and-ubuntu/"},{"categories":null,"content":"This guide walks you through manually installing I2P on macOS by separately installing Java and the I2P router. If you prefer a simpler installation method, check out the Easy Install Bundle.\nWhat You\u0026rsquo;ll Need A Mac running macOS 10.14 (Mojave) or later Administrator access to install applications About 15-20 minutes of time Internet connection for downloading installers Overview This installation process has four main steps:\nInstall Java - Download and install Oracle Java Runtime Environment Install I2P - Download and run the I2P installer Configure I2P App - Set up the launcher and add to your dock Configure I2P Bandwidth - Run the setup wizard to optimize your connection Part One: Install Java I2P requires Java to run. If you already have Java 8 or later installed, you can skip to Part Two.\nStep 1: Download Java Visit the Oracle Java download page and download the macOS installer for Java 8 or later.\nStep 2: Run the Installer Locate the downloaded .dmg file in your Downloads folder and double-click to open it.\nStep 3: Allow Installation macOS may display a security prompt because the installer is from an identified developer. Click Open to proceed.\nStep 4: Install Java Click Install to begin the Java installation process.\nStep 5: Wait for Installation The installer will copy files and configure Java on your system. This usually takes 1-2 minutes.\nStep 6: Installation Complete When you see the success message, Java is installed! Click Close to finish.\nPart Two: Download and Install I2P Now that Java is installed, you can install the I2P router.\nStep 1: Download I2P Visit the Downloads page and download the I2P for Unix/Linux/BSD/Solaris installer (the .jar file).\nStep 2: Run the Installer Double-click the downloaded i2pinstall_X.X.X.jar file. The installer will launch and ask you to select your preferred language.\nStep 3: Welcome Screen Read the welcome message and click Next to continue.\nStep 4: Important Notice The installer will display an important notice about updates. I2P updates are end-to-end signed and verified, even though this installer itself is unsigned. Click Next.\nStep 5: License Agreement Read the I2P license agreement (BSD-style license). Click Next to accept.\nStep 6: Select Installation Directory Choose where to install I2P. The default location (/Applications/i2p) is recommended. Click Next.\nStep 7: Select Components Leave all components selected for a complete installation. Click Next.\nStep 8: Start Installation Review your choices and click Next to begin installing I2P.\nStep 9: Installing Files The installer will copy I2P files to your system. This takes about 1-2 minutes.\nStep 10: Generate Launch Scripts The installer creates launch scripts for starting I2P.\nStep 11: Installation Shortcuts The installer offers to create desktop shortcuts and menu entries. Make your selections and click Next.\nStep 12: Installation Complete Success! I2P is now installed. Click Done to finish.\nPart Three: Configure I2P App Now let\u0026rsquo;s make I2P easy to launch by adding it to your Applications folder and Dock.\nStep 1: Open Applications Folder Open Finder and navigate to your Applications folder.\nStep 2: Find I2P Launcher Look for the I2P folder or the Start I2P Router application inside /Applications/i2p/.\nStep 3: Add to Dock Drag the Start I2P Router application to your Dock for easy access. You can also create an alias on your desktop.\nTip: Right-click the I2P icon in the Dock and select Options → Keep in Dock to make it permanent.\nPart Four: Configure I2P Bandwidth When you first launch I2P, you\u0026rsquo;ll run through a setup wizard to configure your bandwidth settings. This helps optimize I2P\u0026rsquo;s performance for your connection.\nStep 1: Launch I2P Click the I2P icon in your Dock (or double-click the launcher). Your default web browser will open to the I2P Router Console.\nStep 2: Welcome Wizard The setup wizard will greet you. Click Next to begin configuring I2P.\nStep 3: Language and Theme Select your preferred interface language and choose between light or dark theme. Click Next.\nStep 4: Bandwidth Test Information The wizard will explain the bandwidth test. This test connects to the M-Lab service to measure your internet speed. Click Next to proceed.\nStep 5: Run Bandwidth Test Click Run Test to measure your upload and download speeds. The test takes about 30-60 seconds.\nStep 6: Test Results Review your test results. I2P will recommend bandwidth settings based on your connection speed.\nStep 7: Configure Bandwidth Sharing Choose how much bandwidth you want to share with the I2P network:\nAutomatic (Recommended): I2P manages bandwidth based on your usage Limited: Set specific upload/download limits Unlimited: Share as much as possible (for fast connections) Click Next to save your settings.\nStep 8: Configuration Complete Your I2P router is now configured and running! The router console will show your connection status and allow you to browse I2P sites.\nGetting Started with I2P Now that I2P is installed and configured, you can:\nBrowse I2P sites: Visit the I2P homepage to see links to popular I2P services Configure your browser: Set up a browser profile to access .i2p sites Explore services: Check out I2P email, forums, file sharing, and more Monitor your router: The console shows your network status and statistics Useful Links Router Console: http://127.0.0.1:7657/ Configuration: http://127.0.0.1:7657/config Address Book: http://127.0.0.1:7657/susidns/addressbook Bandwidth Settings: http://127.0.0.1:7657/config Re-running the Setup Wizard If you want to change your bandwidth settings or re-configure I2P later, you can re-run the welcome wizard from the Router Console:\nGo to http://127.0.0.1:7657/welcome Follow the wizard steps again Troubleshooting I2P Won\u0026rsquo;t Start Check Java: Make sure Java is installed by running java -version in Terminal Check permissions: Ensure the I2P folder has the correct permissions Check logs: Look at ~/.i2p/wrapper.log for error messages Browser Can\u0026rsquo;t Access I2P Sites Make sure I2P is running (check the Router Console) Configure your browser\u0026rsquo;s proxy settings to use HTTP proxy 127.0.0.1:4444 Wait 5-10 minutes after starting for I2P to integrate into the network Slow Performance Run the bandwidth test again and adjust your settings Make sure you\u0026rsquo;re sharing some bandwidth with the network Check your connection status in the Router Console Uninstalling I2P To remove I2P from your Mac:\nQuit the I2P router if it\u0026rsquo;s running Delete the /Applications/i2p folder Delete the ~/.i2p folder (your I2P configuration and data) Remove the I2P icon from your Dock Next Steps Join the community: Visit i2pforum.net or check out I2P on Reddit Learn more: Read the I2P documentation to understand how the network works Get involved: Consider contributing to I2P development or running infrastructure Congratulations! You\u0026rsquo;re now part of the I2P network. Welcome to the invisible internet!\nThis guide was adapted from the original I2P macOS installation documentation.\n","description":"Step-by-step guide to manually installing I2P and its dependencies on macOS","id":"f88100195c365b18735e1ea12826a97e","section":"docs","title":"Installing I2P on macOS (The Long Way)","url":"/en/docs/guides/installing-i2p-on-macos-the-long-way/"},{"categories":null,"content":"Choose Your Installation Method There are two ways to install I2P on Windows. Choose the method that best fits your needs:\n🚀 Easy Install Bundle (Recommended) Best for most users\n✅ All-in-one installer ✅ Java included (no separate install) ✅ Firefox profiles included ✅ Fastest setup\nChoose this if:\nYou want the simplest installation You don\u0026rsquo;t have Java installed You\u0026rsquo;re new to I2P Easy Install Guide →\n⚙️ Standard Installation For advanced users\n📦 Java-based JAR installer 🔧 More control over installation 💾 Smaller download size\nChoose this if:\nYou already have Java installed You want more control You prefer the traditional method Standard Install Guide →\nEasy Install Bundle What is the Easy Install Bundle? The I2P Easy Install Bundle is the recommended installation method for Windows users. This all-in-one installer includes everything you need to get started with I2P:\nI2P Router - The core I2P software Embedded Java Runtime - No separate Java installation required Firefox profiles and extensions - I2P-optimized browser profiles and extensions for secure browsing Simple installer - No manual configuration required Automatic updates - Keep your I2P software current This beta installer simplifies the installation process by bundling Java directly, so you don\u0026rsquo;t need to download or configure Java separately.\nStep 1: Select Your Language After launching the Easy Install Bundle installer, you\u0026rsquo;ll be greeted with the language selection screen.\nChoose your preferred language from the dropdown menu Available languages include English, German, Spanish, French, and many others Click OK to continue The installer interface will use your selected language for all subsequent steps.\nStep 2: Accept the License Agreement Next, you\u0026rsquo;ll be presented with the I2P license information. The Easy Install Bundle includes components under various free and open-source licenses.\nTo continue installation:\nReview the license information (optional but recommended) Click I Agree to accept the licenses and proceed Click Cancel if you do not wish to install Step 3: Choose Installation Folder Now you\u0026rsquo;ll select where to install I2P on your computer.\nInstallation options:\nUse the default location (recommended)\nDefault path: C:\\Users\\[YourUsername]\\AppData\\Local\\I2peasy\\ This installs I2P in your user profile directory No administrator privileges required for updates Choose a custom location\nClick Browse\u0026hellip; to select a different folder Useful if you want to install on a different drive Make sure you have write permissions to the selected folder Space requirements:\nThe installer shows how much space is required (typically less than 1 GB) Verify you have enough free space available on the selected drive Click Install to begin the installation process The installer will now copy all necessary files to your chosen location. This may take a few minutes.\nStep 4: Complete Installation and Start I2P Once the installation finishes, you\u0026rsquo;ll see the completion screen.\nThe setup wizard confirms that \u0026ldquo;I2P - i2peasy has been installed on your computer.\u0026rdquo;\nImportant: Make sure the \u0026ldquo;Start I2P?\u0026rdquo; checkbox is checked (it should be checked by default).\nChecked (recommended): I2P will start automatically when you click Finish Unchecked: You\u0026rsquo;ll need to manually start I2P later from the Start Menu or desktop shortcut Click Finish to complete the installation and launch I2P.\nWhat Happens Next After clicking Finish with \u0026ldquo;Start I2P?\u0026rdquo; checked:\nI2P Router starts - The I2P router begins running in the background System tray icon appears - Look for the I2P icon in your Windows system tray (bottom-right corner) Router console opens - Your default web browser will automatically open to the I2P Router Console (typically at http://127.0.0.1:7657) Initial connection - I2P will begin connecting to the network and building tunnels (this can take 5-10 minutes on first launch) Congratulations! I2P is now installed and running on your Windows computer.\nRecommended: Port Forwarding (Optional but Important) While not strictly required, port forwarding significantly improves your I2P experience by allowing your router to communicate more effectively with other I2P routers. Without port forwarding, you\u0026rsquo;ll still be able to use I2P, but with reduced performance and contribution to the network.\nWhy Forward a Port? Better connectivity: Allows incoming connections from other I2P routers Faster integration: Helps you integrate into the network more quickly Network contribution: Makes you a better participant in the I2P network Improved performance: Generally results in better tunnel reliability and speed Finding Your I2P Port First, you need to identify which port I2P is using (it\u0026rsquo;s randomly assigned by default).\nLocate the I2P icon in your Windows system tray (notification area) at the bottom-right of your screen Right-click the I2P icon to open the context menu Click \u0026ldquo;Launch I2P Browser\u0026rdquo; to open the I2P router console The menu also shows useful options like:\nNetwork: Firewalled - Shows your current network status Configure I2P System Tray - Customize tray icon settings Stop I2P / Stop I2P Immediately - Shutdown options Finding Your Port Numbers Once the I2P browser opens, you need to check which ports I2P is using:\nNavigate to the network configuration page:\nGo to http://127.0.0.1:7657/confignet in your browser Or from the router console sidebar: Configuration → Network Scroll down to the port configuration section\nNote the port numbers shown:\nUDP Configuration:\nUDP port: The port shown here (example: 13697) By default, this is set to \u0026ldquo;Specify Port\u0026rdquo; with a randomly assigned number TCP Configuration:\nExternally reachable TCP port: Usually set to use the same port as UDP In the example above: \u0026ldquo;Use the same port configured for UDP (currently 13697)\u0026rdquo; Important: You need to forward both UDP and TCP on the same port number (in this example, port 13697) in your router/firewall.\nHow to Forward Your Port Since every router and firewall is different, we cannot provide universal instructions. However, portforward.com has detailed guides for thousands of router models:\nVisit portforward.com Select your router manufacturer and model Follow the step-by-step guide to forward your port Forward both UDP and TCP protocols on the port number shown in your I2P configuration General steps (varies by router):\nLog into your router\u0026rsquo;s admin interface (usually at 192.168.1.1 or 192.168.0.1) Find the \u0026ldquo;Port Forwarding\u0026rdquo; or \u0026ldquo;Virtual Servers\u0026rdquo; section Create a new port forwarding rule for your I2P port number Set both UDP and TCP protocols Point the rule to your computer\u0026rsquo;s local IP address Save the configuration After forwarding your port, I2P should change from \u0026ldquo;Network: Firewalled\u0026rdquo; to \u0026ldquo;Network: OK\u0026rdquo; in the system tray menu (this may take a few minutes).\nNext Steps Wait for integration: Give I2P 5-10 minutes to integrate into the network and build tunnels Configure your browser: Use the included Firefox profile for I2P browsing Forward your port: See portforward.com for router-specific instructions on how to forward the port I2P is using Explore the router console: Learn about I2P\u0026rsquo;s features, services, and configuration options Visit eepsites: Try accessing .i2p websites through the I2P network Read the documentation: Check out the I2P documentation for more information Welcome to the I2P network! 🎉\nStandard Installation What is the Standard Installation? The standard I2P installation is the traditional method of installing I2P on Windows. Unlike the Easy Install Bundle, this method requires you to:\nInstall Java separately - Download and install Java Runtime Environment (JRE) before installing I2P Run the JAR installer - Use the Java-based graphical installer Configure manually - Set up browser configurations yourself (optional) This method is recommended for:\nUsers who already have Java installed Advanced users who want more control over the installation Users who prefer the traditional installation method Systems where the Easy Install Bundle is not compatible Prerequisites Before installing I2P, you need to have Java installed on your system.\nJava Requirements Java Version: Java 8 (1.8) or higher required Recommended: Java 11 or later (LTS version) Type: Java Runtime Environment (JRE) or Java Development Kit (JDK) Installing Java If you don\u0026rsquo;t already have Java installed, you can download it from several sources:\nOption 1: Oracle Java\nOfficial source: java.com/download Most widely used distribution Option 2: OpenJDK\nOpen-source implementation: openjdk.org Free and open-source Option 3: Adoptium (Eclipse Temurin)\nRecommended alternative: adoptium.net Free, open-source, and well-maintained LTS releases To verify Java is installed:\nOpen Command Prompt (press Windows + R, type cmd, press Enter) Type: java -version You should see output showing your Java version Step 1: Install Java Before installing I2P, you need to install Java on your system.\nChoose a Java distribution:\nOracle Java: java.com/download OpenJDK: openjdk.org Adoptium: adoptium.net Download the Windows installer for your chosen distribution\nRun the installer and follow the installation prompts\nVerify the installation:\nOpen Command Prompt Type java -version and press Enter Confirm that Java 8 or higher is installed Once Java is installed, you\u0026rsquo;re ready to install I2P.\nStep 2: Download and Launch the I2P Installer Download the I2P installer:\nVisit the I2P downloads page Download the Windows installer (JAR file): i2pinstall_X.X.X.jar Save it to a location you can easily find (e.g., Downloads folder) Launch the installer:\nDouble-click the downloaded JAR file to launch the installer If double-clicking doesn\u0026rsquo;t work, right-click the file and select \u0026ldquo;Open with → Java(TM) Platform SE binary\u0026rdquo; Alternatively, open Command Prompt and run: java -jar i2pinstall_X.X.X.jar Step 3: Select Your Language After launching the installer, you\u0026rsquo;ll see the Language Selection dialog.\nSelect your preferred language from the dropdown menu Available languages include English, German, Spanish, French, and many others Click OK to continue The installer will use your selected language for all subsequent steps.\nStep 4: Welcome to I2P Installation This is Step 1 of 8 in the installation process.\nClick Next to continue with the installation.\nStep 5: Accept the License Agreement This is Step 2 of 8 in the installation process.\nClick Next to accept the license and continue.\nStep 6: Select Installation Path Choose where you want to install I2P on your computer.\nDefault installation path: C:\\Program Files (x86)\\i2p\\\nYou can either:\nUse the default location (recommended) Click Browse\u0026hellip; to select a different folder This is Step 3 of 8 in the installation process.\nClick Next to continue.\nNote: If this is your first time installing I2P, you\u0026rsquo;ll see a popup confirming directory creation:\nClick OK to create the installation directory.\nStep 7: Select Installation Packs Choose which components to install.\nImportant: Make sure both packs are selected:\nBase (required) - Core I2P software (27.53 MB) Windows Service (recommended) - Automatically start I2P on boot The Windows Service option ensures I2P starts automatically when your computer boots, so you don\u0026rsquo;t need to manually start it each time.\nThis is Step 4 of 8 in the installation process.\nClick Next to continue.\nStep 8: Installation Progress The installer will now copy files to your system.\nYou\u0026rsquo;ll see two progress bars:\nPack installation progress: Shows the current pack being installed Overall installation progress: Shows overall progress (e.g., \u0026ldquo;2 / 2\u0026rdquo;) This is Step 5 of 8 in the installation process.\nWait for the installation to complete, then click Next.\nStep 9: Setup Shortcuts Configure where you want I2P shortcuts created.\nShortcut options:\n✓ Create shortcuts in the Start-Menu (recommended) ✓ Create additional shortcuts on the desktop (optional) Program Group: Select or create a folder name for the shortcuts\nDefault: I2P You can choose an existing program group or create a new one Create shortcut for:\nCurrent user - Only you can access the shortcuts All users - All users on the system can access the shortcuts (requires administrator privileges) This is Step 6 of 8 in the installation process.\nClick Next to continue.\nStep 10: Installation Complete The installation is now finished!\nYou\u0026rsquo;ll see:\n✓ Installation has completed successfully An uninstaller will be created in: C:\\Program Files (x86)\\i2p\\Uninstaller This is Step 8 of 8 - the final step in the installation process.\nClick Done to finish.\nWhat Happens Next After clicking Done:\nI2P Router starts - If you installed the Windows Service, I2P will start automatically Router console opens - Your default web browser will open to the I2P Router Console at http://127.0.0.1:7657 Initial connection - I2P will begin connecting to the network and building tunnels (this can take 5-10 minutes on first launch) Congratulations! I2P is now installed on your Windows computer.\nStarting I2P Manually If I2P doesn\u0026rsquo;t start automatically, or if you need to start it manually in the future, you have two options:\nOption 1: Start Menu Open the Windows Start Menu Navigate to the I2P folder Choose one of the start options: I2P router console - Opens the router console in your browser Start I2P (no window) - Starts I2P silently in the background Start I2P (restartable) - Starts I2P with automatic restart capability You can also access the Open I2P Profile Folder (service) to view I2P\u0026rsquo;s configuration files.\nOption 2: Windows Services Press Windows + R to open Run dialog Type services.msc and press Enter Scroll down to find I2P Service Right-click on I2P Service and select: Start - Start the I2P service Stop - Stop the I2P service Restart - Restart the I2P service Properties - Configure service settings (startup type, etc.) The Windows Services method is useful for managing I2P as a background service, especially if you installed it as a Windows Service.\nNext Steps Wait for integration: Give I2P 5-10 minutes to integrate into the network and build tunnels Configure port forwarding: See the port forwarding guide for instructions Configure your browser: Set up your web browser to use I2P\u0026rsquo;s HTTP proxy Explore the router console: Learn about I2P\u0026rsquo;s features, services, and configuration options Visit eepsites: Try accessing .i2p websites through the I2P network Read the documentation: Check out the I2P documentation for more information Welcome to the I2P network! 🎉\n","description":"Choose your Windows installation method: Easy Install Bundle or Standard Installation","id":"4aa0b74199a71c11718a9986e74b3a26","section":"docs","title":"Installing I2P on Windows","url":"/en/docs/guides/installing-i2p-on-windows/"},{"categories":null,"content":"What is I2P? The Invisible Internet Project (I2P) is an anonymous network layer that allows for censorship-resistant, peer-to-peer communication. Anonymous connections are achieved by encrypting the user\u0026rsquo;s traffic and sending it through a distributed network run by volunteers around the world.\nKey Features Anonymity I2P hides both the sender and receiver of messages. Unlike traditional internet connections where your IP address is visible to websites and services, I2P uses multiple layers of encryption and routing to keep your identity private.\nDecentralization There is no central authority in I2P. The network is maintained by volunteers who donate bandwidth and computing resources. This makes it resistant to censorship and single points of failure.\nEnd-to-End Encryption All traffic within I2P is encrypted end-to-end. Messages are encrypted multiple times as they pass through the network, similar to how Tor works but with important differences in implementation.\nHow It Works Tunnels I2P uses \u0026ldquo;tunnels\u0026rdquo; to route traffic. When you send or receive data:\nYour router creates an outbound tunnel (for sending) Your router creates an inbound tunnel (for receiving) Messages are encrypted and sent through multiple routers Each router only knows the previous and next hop, not the full path Garlic Routing I2P improves on traditional onion routing with \u0026ldquo;garlic routing\u0026rdquo;:\nMultiple messages can be bundled together (like cloves in a bulb of garlic) This provides better performance and additional anonymity Makes traffic analysis more difficult Network Database I2P maintains a distributed network database containing:\nRouter information Destination addresses (similar to .i2p websites) Encrypted routing data Common Use Cases Anonymous Websites (Eepsites) Host or visit websites that end in .i2p - these are only accessible within the I2P network and provide strong anonymity guarantees for both hosts and visitors.\nFile Sharing Share files anonymously using BitTorrent over I2P. Many torrent applications have I2P support built-in.\nEmail Send and receive anonymous email using I2P-Bote or other email applications designed for I2P.\nMessaging Use IRC, instant messaging, or other communication tools privately over the I2P network.\nGetting Started Ready to try I2P? Check out our downloads page to install I2P on your system.\nFor more technical details, see the Technical Introduction or explore the full documentation.\nLearn More Technical Introduction - Deeper technical concepts Threat Model - Understanding I2P\u0026rsquo;s security model Comparison to Tor - How I2P differs from Tor Cryptography - Details on I2P\u0026rsquo;s cryptographic algorithms ","description":"A less-technical introduction to the I2P anonymous network","id":"b4dafae75d4a04b2eac73ebf531f1d1b","section":"docs","title":"Introduction to I2P","url":"/en/docs/overview/intro/"},{"categories":null,"content":"Overview Key points\nI2P provides end-to-end encryption for IRC traffic through its tunnels. Disable SSL/TLS in IRC clients unless you are outproxying to clearnet. The preconfigured Irc2P client tunnel listens on 127.0.0.1:6668 by default. Connect your IRC client to that address and port. Do not use the term “router‑provided TLS.” Use “I2P’s native encryption” or “end‑to‑end encryption.” Quick start (Java I2P) Open Hidden Services Manager at http://127.0.0.1:7657/i2ptunnel/ and make sure the Irc2P tunnel is running. In your IRC client, set server = 127.0.0.1, port = 6668, SSL/TLS = off. Connect and join channels like #i2p, #i2p-dev, #i2p-help. For i2pd users (C++ router), create a client tunnel in tunnels.conf (see examples below).\nNetworks and servers IRC2P (main community network) Federated servers: irc.postman.i2p:6667, irc.echelon.i2p:6667, irc.dg.i2p:6667. The Irc2P tunnel at 127.0.0.1:6668 connects to one of these automatically. Typical channels: #i2p, #i2p-chat, #i2p-dev, #i2p-help. Ilita network Servers: irc.ilita.i2p:6667, irc.r4sas.i2p:6667, irc.acetone.i2p:6667, rusirc.ilita.i2p:6667. Primary languages: Russian and English. Web front‑ends exist on some hosts. Client setup Recommended, actively maintained WeeChat (terminal) — strong SOCKS support; easy to script. Pidgin (desktop) — still maintained; works well for Windows/Linux. Thunderbird Chat (desktop) — supported in ESR 128+. The Lounge (self‑hosted web) — modern web client. macOS options LimeChat (free, open source). Textual (paid on App Store; source available to build). Example configurations WeeChat via SOCKS5 /proxy add i2p socks5 127.0.0.1 4447 /set irc.server.i2p.addresses \u0026#34;127.0.0.1/6668\u0026#34; /set irc.server.i2p.proxy \u0026#34;i2p\u0026#34; /connect i2p Pidgin Protocol: IRC Server: 127.0.0.1 Port: 6668 Encryption: off Username/nick: any Thunderbird Chat Account type: IRC Server: 127.0.0.1 Port: 6668 SSL/TLS: off Optional: auto‑join channels on connect Dispatch (SAM v3) config.toml defaults example:\n[defaults] name = \u0026#34;Irc2P\u0026#34; host = \u0026#34;irc.postman.i2p\u0026#34; port = 6667 channels = [\u0026#34;#i2p\u0026#34;,\u0026#34;#i2p-dev\u0026#34;] ssl = false Tunnel configuration Java I2P defaults Irc2P client tunnel: 127.0.0.1:6668 → upstream server on port 6667. Hidden Services Manager: http://127.0.0.1:7657/i2ptunnel/. i2pd client tunnels ~/.i2pd/tunnels.conf:\n[IRC-IRC2P] type = client address = 127.0.0.1 port = 6668 destination = irc.postman.i2p destinationport = 6667 keys = irc-keys.dat Separate tunnel for Ilita (example):\n[IRC-ILITA] type = client address = 127.0.0.1 port = 6669 destination = irc.ilita.i2p destinationport = 6667 keys = irc-ilita-keys.dat SAM‑based apps (advanced) Enable SAM in Java I2P (off by default) at /configclients or clients.config. Defaults: 127.0.0.1:7656/TCP and 127.0.0.1:7655/UDP. Recommended crypto: SIGNATURE_TYPE=7 (Ed25519) and i2cp.leaseSetEncType=4,0 (ECIES‑X25519 with ElGamal fallback) or just 4 for modern‑only. Tunnel quantities Java I2P default: 2 inbound / 2 outbound. i2pd default: 5 inbound / 5 outbound. For IRC: 2–3 each is sufficient; set explicitly for consistent behavior across routers. Security guidance Do not enable SSL/TLS for internal I2P IRC connections. I2P already provides end‑to‑end encryption. Extra TLS adds overhead without anonymity gains. Use persistent keys for stable identity; avoid regenerating keys on every restart unless testing. If multiple apps use IRC, prefer separate tunnels (non‑shared) to reduce cross‑service correlation. If you must allow remote control (SAM/I2CP), bind to localhost and secure access with SSH tunnels or authenticated reverse proxies. Alternative connection method: SOCKS5 Some clients can connect via I2P’s SOCKS5 proxy: 127.0.0.1:4447. For best results, prefer a dedicated IRC client tunnel on 6668; SOCKS cannot sanitize application‑layer identifiers and may leak info if the client is not designed for anonymity.\nTroubleshooting Cannot connect — ensure the Irc2P tunnel is running and the router is fully bootstrapped. Hangs at resolve/join — double‑check that SSL is disabled and the client points to 127.0.0.1:6668. High latency — I2P is higher‑latency by design. Keep tunnel quantities modest (2–3) and avoid rapid reconnect loops. Using SAM apps — confirm SAM is enabled (Java) or not firewalled (i2pd). Long‑lived sessions are recommended. Appendix: Ports and naming Common IRC tunnel ports: 6668 (Irc2P default), 6667 and 6669 as alternates. .b32.i2p hostnames: 52‑character standard form; extended 56+ character forms exist for LS2/advanced certs. Use .i2p hostnames unless you explicitly need b32 addresses. ","description":"Complete guide to I2P IRC networks, clients, tunnels, and server setup (updated 2025)","id":"f8c49a6509b36124b90dbaa1d0fbbc4b","section":"docs","title":"IRC over I2P","url":"/en/docs/applications/irc/"},{"categories":null,"content":" Status: This page condenses the legacy \u0026ldquo;Low-level Cryptography Specification\u0026rdquo;. Modern I2P releases (2.10.0, October 2025) have completed the migration to new cryptographic primitives. Use specialized specs such as ECIES, Encrypted LeaseSets, NTCP2, Red25519, SSU2, and Tunnel Creation (ECIES) for implementation details.\nEvolution Snapshot Functional Area Legacy Primitive Current / Planned Primitive Migration Status Transport key exchange Diffie–Hellman over 2048-bit prime (NTCP / SSU) X25519 (NTCP2 / SSU2) Completed (NTCP2 and SSU2 fully deployed) End-to-end encryption ElGamal/AES+SessionTags ECIES-X25519-AEAD-Ratchet Completed (2.4.0+) Symmetric cipher AES-256/CBC + HMAC-MD5 ChaCha20/Poly1305 (AEAD) Active (tunnel layer remains AES-256) Default signatures DSA-SHA1 (1024-bit) EdDSA/RedDSA on Ed25519 Fully migrated Experimental / future — Hybrid post-quantum encryption (opt-in) In testing (2.10.0) Asymmetric Encryption X25519 Used for NTCP2, ECIES-X25519-AEAD-Ratchet, SSU2, and X25519-based tunnel creation. Provides compact keys, constant-time operations, and forward secrecy via the Noise protocol framework. Offers 128-bit security with 32-byte keys and efficient key exchange. ElGamal (Legacy) Retained for backward compatibility with older routers. Operates over the 2048-bit Oakley Group 14 prime (RFC 3526) with generator 2. Encrypts AES session keys plus IVs in 514-byte ciphertexts. Lacks authenticated encryption and forward secrecy; all modern endpoints have migrated to ECIES. Symmetric Encryption ChaCha20/Poly1305 Default authenticated encryption primitive across NTCP2, SSU2, and ECIES. Provides AEAD security and high performance without AES hardware support. Implemented per RFC 7539 (256‑bit key, 96‑bit nonce, 128‑bit tag). AES‑256/CBC (Legacy) Still used for tunnel layer encryption, where its block‑cipher structure fits I2P’s layered encryption model. Uses PKCS#5 padding and per‑hop IV transformations. Scheduled for long‑term review but remains cryptographically sound. Signatures Signature Type Usage Notes Status DSA‑SHA1 (1024‑bit) Original default; still accepted for legacy Destinations. Deprecated ECDSA‑SHA256/384/512 Used during 2014–2015 transition. Supported EdDSA‑SHA512‑Ed25519 Default for Router and Destination identities (since 0.9.15). Default RedDSA‑SHA512‑Ed25519 Used for encrypted LeaseSet signatures (0.9.39+). Specialized RSA‑SHA512‑4096 For out‑of‑band signing (su3 updates, reseeds, plugins). Application‑layer Hash and Key Derivation SHA‑256: Used for DHT keys, HKDF, and legacy signatures. SHA‑512: Used by EdDSA/RedDSA and in Noise HKDF derivations. HKDF‑SHA256: Derives session keys in ECIES, NTCP2, and SSU2. Daily‑rotating SHA‑256 derivations secure RouterInfo and LeaseSet storage locations in the netDb. Transport Layer Summary Transport Key Exchange Encryption Authentication Status NTCP2 X25519 ChaCha20/Poly1305 AEAD Default TCP transport SSU2 X25519 ChaCha20/Poly1305 AEAD Default UDP transport SSU (Legacy) DH‑2048 AES‑256/CBC + HMAC‑MD5 Legacy Removed (2.4.0) Both transports provide link‑level forward secrecy and replay protection, using the Noise_XK handshake pattern.\nTunnel Layer Encryption Continues to use AES‑256/CBC for per‑hop layered encryption. Outbound gateways perform iterative AES decryption; each hop re‑encrypts using its layer key and IV key. Double‑IV encryption mitigates correlation and confirmation attacks. Migration to AEAD is under study but not currently planned. Post‑Quantum Cryptography I2P 2.10.0 introduces experimental hybrid post‑quantum encryption. Enabled manually via Hidden Service Manager for testing. Combines X25519 with a quantum‑resistant KEM (hybrid mode). Not default; intended for research and performance evaluation. Extensibility Framework Encryption and signature type identifiers allow parallel support for multiple primitives. Current mappings include: Encryption types: 0 = ElGamal/AES+SessionTags, 4 = ECIES‑X25519‑AEAD‑Ratchet. Signature types: 0 = DSA‑SHA1, 7 = EdDSA‑SHA512‑Ed25519, 11 = RedDSA‑SHA512‑Ed25519. This framework enables future upgrades, including post‑quantum schemes, without network splits. Cryptographic Composition Transport layer: X25519 + ChaCha20/Poly1305 (Noise framework). Tunnel layer: AES‑256/CBC layered encryption for anonymity. End‑to‑end: ECIES‑X25519‑AEAD‑Ratchet for confidentiality and forward secrecy. Database layer: EdDSA/RedDSA signatures for authenticity. These layers combine to provide defense‑in‑depth: even if one layer is compromised, others maintain confidentiality and unlinkability.\nSummary I2P 2.10.0’s cryptographic stack centers on:\nCurve25519 (X25519) for key exchange ChaCha20/Poly1305 for symmetric encryption EdDSA / RedDSA for signatures SHA‑256 / SHA‑512 for hashing and derivation Experimental post‑quantum hybrid modes for forward compatibility Legacy ElGamal, AES‑CBC, and DSA remain for backward compatibility but are no longer used in active transports or encryption paths.\n","description":"Summary of the symmetric, asymmetric, and signature primitives used across I2P","id":"c0dbec852751cc0a476bef069bffde08","section":"docs","title":"Low-level Cryptography","url":"/en/docs/specs/cryptography/"},{"categories":null,"content":"1. Overview Entries in clients.config tell the router which applications to launch on startup. Each entry may run as a managed client (preferred) or as an unmanaged client. Managed clients collaborate with ClientAppManager, which:\nInstantiates the application and tracks lifecycle state for the router console Exposes start/stop controls to the user and enforces clean shutdowns at router exit Hosts a lightweight client registry and port mapper so applications can discover each other\u0026rsquo;s services Unmanaged clients simply invoke a main() method; use them only for legacy code that cannot be modernized.\n2. Implementing a Managed Client Managed clients must implement either net.i2p.app.ClientApp (for user-facing apps) or net.i2p.router.app.RouterApp (for router extensions). Provide one of the constructors below so the manager can supply context and configuration arguments:\npublic MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args) public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args) The args array contains the values configured in clients.config or individual files in clients.config.d/. Extend ClientApp / RouterApp helper classes when possible to inherit default lifecycle wiring.\n2.1 Lifecycle Methods Managed clients are expected to implement:\nstartup() - perform initialization and return promptly. Must call manager.notify() at least once to transition from INITIALIZED state. shutdown(String[] args) - release resources and stop background threads. Must call manager.notify() at least once to change state to STOPPING or STOPPED. getState() - inform the console whether the app is running, starting, stopping, or failed The manager calls these methods as users interact with the console.\n2.2 Advantages Accurate status reporting in the router console Clean restarts without leaking threads or static references Lower memory footprint once the application stops Centralized logging and error reporting via the injected context 3. Unmanaged Clients (Fallback Mode) If the configured class does not implement a managed interface, the router launches it by invoking main(String[] args) and cannot track the resulting process. The console shows limited information and shutdown hooks may not run. Reserve this mode for scripts or one-off utilities that cannot adopt the managed APIs.\n4. Client Registry Managed and unmanaged clients may register themselves with the manager so other components can retrieve a reference by name:\nmanager.register(this); The registration uses the client\u0026rsquo;s getName() return value as the registry key. Known registrations include console, i2ptunnel, Jetty, outproxy, and update. Retrieve a client with ClientAppManager.getRegisteredApp(String name) to coordinate features (for example, the console querying Jetty for status details).\nNote that client registry and port mapper are separate systems. The client registry enables inter-application communication by name lookup, while the port mapper maps service names to host:port combinations for service discovery.\n5. Port Mapper The port mapper offers a simple directory for internal TCP services. Register loopback ports so collaborators avoid hardcoded addresses:\ncontext.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445); Or with explicit host specification:\ncontext.portMapper().register(PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444); Look up services using PortMapper.getPort(String name) (returns -1 if not found) or getPort(String name, int defaultPort) (returns default if not found). Check registration status with isRegistered(String name) and retrieve the registered host with getActualHost(String name).\nCommon port mapper service constants from net.i2p.util.PortMapper:\nSVC_CONSOLE - Router console (default port 7657) SVC_HTTP_PROXY - HTTP proxy (default port 4444) SVC_HTTPS_PROXY - HTTPS proxy (default port 4445) SVC_I2PTUNNEL - I2PTunnel manager SVC_SAM - SAM bridge (default port 7656) SVC_SAM_SSL - SAM bridge SSL SVC_SAM_UDP - SAM UDP SVC_BOB - BOB bridge (default port 2827) SVC_EEPSITE - Standard eepsite (default port 7658) SVC_HTTPS_EEPSITE - HTTPS eepsite SVC_IRC - IRC tunnel (default port 6668) SVC_SUSIDNS - SusiDNS Note: httpclient, httpsclient, and httpbidirclient are i2ptunnel tunnel types (used in tunnel.N.type configuration), not port mapper service constants.\n6. Configuration Format 6.1 Modern Structure (0.9.42 and later) As of version 0.9.42, the router supports splitting configuration into individual files within clients.config.d/ directory. Each file contains properties for a single client with all properties prefixed clientApp.0.:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true This is the recommended approach for new installations and plugins.\n6.2 Legacy Format (monolithic clients.config) For backward compatibility, the traditional format uses sequential numbering:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.1.main=net.i2p.apps.systray.UrlLauncher clientApp.1.name=URL Launcher clientApp.1.delay=5 6.3 Configuration Properties Required:\nmain - Full class name implementing ClientApp or RouterApp, or containing static main(String[] args) Optional:\nname - Display name for router console (defaults to class name) args - Space or tab-separated arguments (supports quoted strings) delay - Seconds before starting (default 120) onBoot - Forces delay=0 if true startOnLoad - Enables/disables the client (default true) Plugin-specific:\nstopargs - Arguments passed during shutdown uninstallargs - Arguments passed during plugin uninstall classpath - Comma-separated additional classpath entries Variable substitution for plugins:\n$I2P - I2P base directory $CONFIG - User configuration directory (e.g., ~/.i2p) $PLUGIN - Plugin directory $OS - Operating system name $ARCH - Architecture name 7. Best Practices Prefer managed clients; fall back to unmanaged only when absolutely necessary. Keep initialization and shutdown lightweight so console operations remain responsive. Use descriptive registry and port names so diagnostic tools (and end users) understand what a service does. Avoid static singletons - rely on the injected context and manager to share resources. Call manager.notify() on all state transitions to maintain accurate console status. If you must run in a separate JVM, document how logs and diagnostics are surfaced to the main console. For external programs, consider using ShellService (added in version 1.7.0) to gain managed client benefits. 8. API Stability and Version History Managed clients were introduced in version 0.9.4 (December 17, 2012) and remain the recommended architecture as of version 2.10.0 (September 9, 2025). The core APIs have remained stable with zero breaking changes across this period:\nConstructor signatures unchanged Lifecycle methods (startup, shutdown, getState) unchanged ClientAppManager registration methods unchanged PortMapper registration and lookup methods unchanged Notable enhancements:\n0.9.42 (2019) - clients.config.d/ directory structure for individual configuration files 1.7.0 (2021) - ShellService added for external program state tracking 2.10.0 (2025) - Current release with no managed client API changes The next major release will require Java 17+ as a minimum (infrastructure requirement, not an API change).\nReferences clients.config specification Configuration File Specification I2P Technical Documentation Index ClientAppManager Javadoc (API 0.9.66) PortMapper Javadoc (API 0.9.66) ClientApp interface (API 0.9.66) RouterApp interface (API 0.9.66) Alternative Javadoc (stable) Alternative Javadoc (clearnet mirror) Note: The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ which requires an I2P router for access. For clearnet access, use the GitHub Pages mirror above.\n","description":"How router-managed applications integrate with ClientAppManager and the port mapper","id":"f9e2324a49e9ed9bf413b4c636d5d1b6","section":"docs","title":"Managed Clients","url":"/en/docs/applications/managed-clients/"},{"categories":null,"content":" Deprecated: The ministreaming library predates today’s streaming library. Modern applications must use the full streaming API or SAM v3. The information below is retained for developers reviewing legacy source code shipped in ministreaming.jar.\nOverview Ministreaming sits on top of I2CP to provide reliable, in-order delivery across I2P’s message layer—much like TCP over IP. It was originally factored out of the early I2PTunnel application (BSD licensed) so alternative transports could evolve independently.\nKey design constraints:\nClassic two-phase (SYN/ACK/FIN) connection setup borrowed from TCP Fixed window size of 1 packet No per-packet IDs or selective acknowledgements These choices kept the implementation small but limit throughput—each packet usually waits almost two RTTs before the next is sent. For long-lived streams the penalty is acceptable, but short HTTP-style exchanges suffer noticeably.\nRelationship to the Streaming Library The current streaming library extends the same Java package (net.i2p.client.streaming). Deprecated classes and methods remain in the Javadocs, clearly annotated so developers can identify ministreaming-era APIs. When the streaming library superseded ministreaming it added:\nSmarter connection setup with fewer round trips Adaptive congestion windows and retransmission logic Better performance over lossy tunnels When Was Ministreaming Useful? Despite its limits, ministreaming delivered reliable transport in the earliest deployments. The API was intentionally small and future-proof so that alternate streaming engines could be swapped in without breaking callers. Java applications linked it directly; non-Java clients accessed the same functionality through SAM support for streaming sessions.\nToday, treat ministreaming.jar as a compatibility layer only. New development should:\nTarget the full streaming library (Java) or SAM v3 (STREAM style) Remove any lingering fixed-window assumptions when modernising code Prefer higher window sizes and optimised connect handshakes to improve latency-sensitive workloads Reference Streaming Library documentation Streaming Javadoc – includes deprecated ministreaming classes SAM v3 specification – streaming support for non-Java applications If you encounter code that still depends on ministreaming, plan to port it to the modern streaming API—the network and its tooling expect the newer behaviour.\n","description":"Historical notes on I2P's first TCP-like transport layer","id":"3a258127f502d1974fadc514a60bf831","section":"docs","title":"Ministreaming Library","url":"/en/docs/legacy/ministreaming/"},{"categories":null,"content":"I2P addresses are long cryptographic keys. The naming system provides a friendlier layer on top of those keys without introducing a central authority.\nAll names are local—each router independently decides which destination a hostname refers to.\nNeed background? The naming discussion documents the original design debates, alternative proposals, and philosophical foundations behind I2P\u0026rsquo;s decentralized naming.\n1. Components I2P’s naming layer is composed of several independent but cooperating subsystems:\nNaming service – resolves hostnames to destinations and handles Base32 hostnames. HTTP proxy – passes .i2p lookups to the router and suggests jump services when a name is unknown. Host-add services – CGI-style forms that append new entries into the local address book. Jump services – remote helpers that return the destination for a supplied hostname. Address book – periodically fetches and merges remote host lists using a locally trusted “web of trust”. SusiDNS – a web-based UI for managing address books, subscriptions, and local overrides. This modular design lets users define their own trust boundaries and automate as much or as little of the naming process as they prefer.\n2. Naming Services The router’s naming API (net.i2p.client.naming) supports multiple backends through the configurable property\ni2p.naming.impl=\u0026lt;class\u0026gt;. Each implementation may offer different lookup strategies, but all share the same trust and resolution model.\n2.1 Hosts.txt (legacy format) The legacy model used three plain-text files checked in order:\nprivatehosts.txt userhosts.txt hosts.txt Each line stores a hostname=base64-destination mapping.\nThis simple text format remains fully supported for import/export, but it’s no longer the default due to poor performance once the host list exceeds a few thousand entries.\n2.2 Blockfile Naming Service (default backend) Introduced in release 0.8.8, the Blockfile Naming Service is now the default backend.\nIt replaces flat files with a high-performance skiplist-based on-disk key/value store (hostsdb.blockfile) that delivers roughly 10× faster lookups.\nKey characteristics:\nStores multiple logical address books (private, user, and hosts) in one binary database. Maintains compatibility with legacy hosts.txt import/export. Supports reverse lookups, metadata (added date, source, comments), and efficient caching. Uses the same three-tier search order: private → user → hosts. This approach preserves backwards compatibility while dramatically improving resolution speed and scalability.\n2.3 Alternative Backends and Plug-ins Developers can implement custom backends such as:\nMeta – aggregates multiple naming systems. PetName – supports petnames stored in a petnames.txt. AddressDB, Exec, Eepget, and Dummy – for external or fallback resolution. The blockfile implementation remains the recommended backend for general use due to performance and reliability.\n3. Base32 Hostnames Base32 hostnames (*.b32.i2p) function similarly to Tor’s .onion addresses.\nWhen you access a .b32.i2p address:\nThe router decodes the Base32 payload. It reconstructs the destination directly from the key—no address-book lookup required. This guarantees reachability even if no human-readable hostname exists.\nExtended Base32 names introduced in release 0.9.40 support LeaseSet2 and encrypted destinations.\n4. Address Book \u0026amp; Subscriptions The address book application retrieves remote host lists over HTTP and merges them locally according to user-configured trust rules.\n4.1 Subscriptions Subscriptions are standard .i2p URLs pointing to hosts.txt or incremental update feeds. Updates are fetched periodically (hourly by default) and validated before merging. Conflicts are resolved first-come, first-served, following the priority order:\nprivatehosts.txt → userhosts.txt → hosts.txt. Default Providers Since I2P 2.3.0 (June 2023), two default subscription providers are included:\nhttp://i2p-projekt.i2p/hosts.txt http://notbob.i2p/hosts.txt This redundancy improves reliability while preserving the local trust model.\nUsers may add or remove subscriptions through SusiDNS.\nIncremental Updates Incremental updates are fetched via newhosts.txt (replacing the older recenthosts.cgi concept).\nThis endpoint provides efficient, ETag-based delta updates—returning only new entries since the last request or 304 Not Modified when unchanged.\n4.2 Host-Add and Jump Services Host-add services (add*.cgi) allow manual submission of name-to-destination mappings. Always verify the destination before accepting. Jump services respond with the appropriate key and can redirect through the HTTP proxy with an ?i2paddresshelper= parameter.\nCommon examples: stats.i2p, identiguy.i2p, and notbob.i2p.\nThese services are not trusted authorities—users must decide which to use. 5. Managing Entries Locally (SusiDNS) SusiDNS is available at:\nhttp://127.0.0.1:7657/susidns/\nYou can:\nView and edit local address books. Manage and prioritize subscriptions. Import/export hosts lists. Configure fetch schedules. New in I2P 2.8.1 (March 2025):\nAdded a “sort by latest” feature. Improved subscription handling (fix for ETag inconsistencies). All changes remain local—each router’s address book is unique.\n6. .i2p.alt and DNS Leak Prevention Following RFC 9476, I2P registered .i2p.alt with the GNUnet Assigned Numbers Authority (GANA) as of March 2025 (I2P 2.8.1).\nPurpose: Prevent accidental DNS leaks from misconfigured software.\nRFC 9476-compliant DNS resolvers will not forward .alt domains to the public DNS. I2P software treats .i2p.alt as equivalent to .i2p, stripping the .alt suffix during resolution. .i2p.alt is not intended to replace .i2p; it’s a technical safeguard, not a rebranding. 7. Technical Specifications (Verified 2025) Destination keys: 516–616 bytes (Base64) Hostnames: Max 67 characters (including .i2p) Allowed characters: a–z, 0–9, -, . (no double dots, no uppercase) Reserved: *.b32.i2p ETag and Last-Modified: actively used to minimize bandwidth Average hosts.txt size: ~400 KB for ~800 hosts (example figure) Bandwidth use: ~10 bytes/sec if fetched every 12 hours All specifications have been verified against the official documentation and current router behavior as of October 2025.\n8. Security Model and Philosophy I2P intentionally sacrifices global uniqueness in exchange for decentralization and security—a direct application of Zooko’s Triangle.\nKey principles:\nNo central authority: all lookups are local. Resistance to DNS hijacking: queries are encrypted to destination public keys. Sybil-attack prevention: no voting or consensus-based naming. Immutable mappings: once a local association exists, it cannot be remotely overridden. Blockchain-based naming systems (e.g., Namecoin, ENS) have explored solving all three sides of Zooko’s triangle, but I2P intentionally avoids them due to latency, complexity, and philosophical incompatibility with its local trust model.\n9. Compatibility and Stability No naming features have been deprecated between 2023–2025. Hosts.txt format, jump services, subscriptions, and all naming API implementations remain functional. The I2P Project maintains strict backwards compatibility while introducing performance and security improvements (NetDB isolation, Sub-DB separation, etc.). 10. Best Practices Keep only trusted subscriptions; avoid large, unknown host lists. Back up hostsdb.blockfile and privatehosts.txt before upgrading or reinstalling. Regularly review jump services and disable any you no longer trust. Remember: your address book defines your version of the I2P world—every hostname is local. Further Reading Naming Discussion Blockfile Specification Configuration File Format Naming Service Javadoc ","description":"How I2P maps human-readable hostnames to destinations","id":"fc2ecb5df890709d0740d866d03a6250","section":"docs","title":"Naming and Address Book","url":"/en/docs/overview/naming/"},{"categories":null,"content":" Context: This page archives long-running debates from the early I2P design era. It captures why the project favoured locally trusted address books over DNS-style lookups or majority-vote registries. For current usage guidance, see the Naming documentation.\nDiscarded Alternatives I2P’s security goals rule out familiar naming schemes:\nDNS-style resolution. Any resolver on the lookup path could spoof or censor answers. Even with DNSSEC, compromised registrars or certificate authorities remain a single point of failure. In I2P, destinations are public keys—hijacking a lookup would completely compromise an identity. Voting-based naming. An adversary can mint unlimited identities (a Sybil attack) and “win” votes for popular names. Proof-of-work mitigations raise the cost but introduce heavy coordination overhead. Instead, I2P deliberately keeps naming above the transport layer. The bundled naming library offers a service-provider interface so alternate schemes can coexist—users decide which address books or jump services they trust.\nLocal vs Global Names (jrandom, 2005) Names in I2P are locally unique but human readable. Your boss.i2p may not match somebody else’s boss.i2p, and that is by design. If a malicious actor tricked you into changing the destination behind a name, they would effectively hijack a service. Refusing global uniqueness prevents that class of attack. Treat names like bookmarks or IM nicknames—you choose which destinations to trust by subscribing to specific address books or adding keys manually. Common Objections \u0026amp; Responses (zzz) Concern Response “Downloading hosts.txt is inefficient.” At ~400\u0026nbsp;KB for ~800 hosts the bandwidth impact is minor (~10\u0026nbsp;B/s if refreshed twice daily). ETags already avoid unnecessary transfers. Alternate formats (for example recenthosts.cgi) can deliver only new entries. “It won’t scale.” A hosts.txt entry is ~500\u0026nbsp;bytes; storing thousands locally is practical. Real-time lookups would dramatically slow browsing. “Requires trust and manual setup.” True—and intentional. Users must choose address book providers they trust. Trust is not binary; forcing configuration encourages users to think about it. “Why not just use DNS?” DNS depends on short TTLs and can be hijacked mid-path. I2P destinations are immutable public keys, so DNS semantics map poorly. “Subscriptions rely on specific servers.” Subscriptions are decentralised—you can add multiple providers or run your own. Completely decentralised systems struggle with conflict resolution and hijacking. “Jump services and hosts.txt feel awkward.” They are pragmatic trade-offs. Jump services provide just-in-time lookups; subscriptions keep a local cache for performance. Efficiency Ideas Discussed Serve incremental updates (only destinations added since the last fetch). Offer supplemental feeds (recenthosts.cgi) alongside full hosts files. Explore scriptable tooling (for example, i2host.i2p) to merge feeds or filter by trust levels. Takeaways Security wins over global consensus: locally curated address books minimise hijacking risk. Multiple naming approaches can coexist through the naming API—users decide what to trust. Completely decentralised global naming remains an open research problem; trade-offs among security, human memorability, and global uniqueness still mirror Zooko’s triangle. References Naming documentation Zooko’s “Names: Decentralized, Secure, Human-Meaningful: Choose Two” Sample incremental feed: stats.i2p/cgi-bin/newhosts.txt ","description":"Historical debate about I2P's naming model and why global DNS-style schemes were rejected","id":"952b10ba82200ff92e5ddeed512d6afb","section":"docs","title":"Naming Discussion","url":"/en/docs/legacy/naming/"},{"categories":null,"content":" Note: This archival discussion outlines historical approaches to the network database (netDb). Consult the main netDb documentation for current behavior and guidance.\nHistory I2P\u0026rsquo;s netDb is distributed using a simple floodfill algorithm. Early releases also kept a Kademlia DHT implementation as a fallback, but it proved unreliable and was completely disabled in version 0.6.1.20. The floodfill design forwards a published entry to a participating router, waits for confirmation, and retries with other floodfill peers if necessary. Floodfill peers broadcast stores from non-floodfill routers to every other floodfill participant.\nIn late 2009 Kademlia lookups were partially reintroduced to reduce the storage burden on individual floodfill routers.\nIntroduction of Floodfill Floodfill first appeared in release 0.6.0.4 while Kademlia remained available as a backup. At the time, heavy packet loss and restricted routes made it difficult to obtain acknowledgements from the four closest peers, often requiring dozens of redundant store attempts. Moving to a floodfill subset of externally reachable routers provided a pragmatic short-term solution.\nRethinking Kademlia Some alternatives considered included:\nRunning the netDb as a Kademlia DHT limited to reachable routers that opt in to participation Retaining the floodfill model but limiting participation to capable routers and verifying distribution with random checks The floodfill approach won out because it was easier to deploy and the netDb carries only metadata, not user payloads. Most destinations never publish a LeaseSet because the sender typically bundles its LeaseSet in garlic messages.\nCurrent Status (Historical Perspective) The netDb algorithms are tuned for the network\u0026rsquo;s needs and have historically handled a few hundred routers comfortably. Early estimates suggested that 3–5 floodfill routers could support roughly 10,000 nodes.\nUpdated Calculations (March 2008) recvKBps = N * (L + 1) * (1 + F) * (1 + R) * S / T Where:\nN: Routers in the network L: Average number of client destinations per router (plus one for the RouterInfo) F: Tunnel failure percentage R: Tunnel rebuild period as a fraction of tunnel lifetime S: Average netDb entry size T: Tunnel lifetime Using 2008-era values (N = 700, L = 0.5, F = 0.33, R = 0.5, S = 4 KB, T = 10 minutes) yields:\nrecvKBps ≈ 700 * (0.5 + 1) * (1 + 0.33) * (1 + 0.5) * 4 KB / 10m ≈ 28 KBps Will Kademlia Return? Developers discussed reintroducing Kademlia around early 2007. The consensus was that floodfill capacity could be expanded incrementally as needed, while Kademlia added significant complexity and resource requirements for the baseline router population. The fallback remains dormant unless floodfill capacity becomes insufficient.\nFloodfill Capacity Planning Automatic admission of bandwidth-class O routers into floodfill, while tempting, risks denial-of-service scenarios if hostile nodes opt in. Historical analysis suggested that limiting the floodfill pool (for example, 3–5 peers handling ~10K routers) was more secure. Trusted operators or automatic heuristics have been used to maintain an adequate yet controlled floodfill set.\nFloodfill TODO (Historical) This section is retained for posterity. The main netDb page tracks the current roadmap and design considerations.\nOperational incidents, such as a March 13, 2008 period with only one available floodfill router, prompted several improvements delivered in releases 0.6.1.33 through 0.7.x, including:\nRandomizing floodfill selection for searches and preferring responsive peers Displaying additional floodfill metrics on the router console \u0026ldquo;Profiles\u0026rdquo; page Progressive reductions in netDb entry size to cut floodfill bandwidth usage Automatic opt-in for a subset of class O routers based on performance gathered via profile data Enhanced blocklisting, floodfill peer selection, and exploration heuristics Remaining ideas from the period included:\nUsing dbHistory statistics to better rate and select floodfill peers Improving retry behavior to avoid repeatedly contacting failing peers Leveraging latency metrics and integration scores in selection Detecting and reacting to failing floodfill routers more quickly Continuing to reduce resource demands on high-bandwidth and floodfill nodes Even as of these notes, the network was considered resilient, with infrastructure in place to respond quickly to hostile floodfills or floodfill-targeted denial-of-service attacks.\nAdditional Notes The router console has long exposed enhanced profile data to aid in analysing floodfill reliability. While historical commentary speculated about Kademlia or alternative DHT schemes, floodfill has remained the primary algorithm for production networks. Forward-looking research focused on making floodfill admission adaptive while limiting opportunities for abuse. ","description":"Historical notes on floodfill, Kademlia experiments, and future tuning for the netDb","id":"0ddefeec5b7108b36649c4d989bf474e","section":"docs","title":"Network Database Discussion","url":"/en/docs/netdb/"},{"categories":null,"content":"Want to help make I2P accessible to more people around the world? Translation is one of the most valuable contributions you can make to the project. This guide will walk you through translating both the I2P website and the router console.\nTranslation Methods There are two ways to contribute translations:\nMethod 1: Transifex (Recommended) This is the easiest way to translate I2P. Transifex provides a web-based interface that makes translation simple and accessible.\nSign up at Transifex Request to join the I2P translation team Start translating directly in your browser No technical knowledge required - just sign up and start translating!\nMethod 2: Manual Translation For translators who prefer working with git and local files, or for languages not yet set up on Transifex.\nRequirements:\nFamiliarity with git version control Text editor or translation tool (POEdit recommended) Command-line tools: git, gettext Setup:\nJoin #i2p-dev on IRC and introduce yourself Update translation status on the wiki (ask in IRC for access) Clone the appropriate repository (see sections below) Website Translation The I2P website includes documentation, blog posts, and general information pages.\nUsing Transifex (Recommended) Go to I2P on Transifex Select the website project Choose your language (or request a new one) Start translating strings in the web interface Manual Website Translation Prerequisites:\n# Install required tools (Debian/Ubuntu) sudo apt-get install git gettext # Install required tools (macOS) brew install git gettext Clone the website repository:\ngit clone https://i2pgit.org/i2p-hackers/i2p.www.git cd i2p.www Generate translation template:\n# Extract translatable strings ./update-messages.sh Create or update your language\u0026rsquo;s .po file:\n# For a new language (replace \u0026#39;es\u0026#39; with your language code) msginit -i i2p2www/translations/messages.pot -o i2p2www/translations/es/LC_MESSAGES/messages.po -l es # For updating an existing language msgmerge -U i2p2www/translations/es/LC_MESSAGES/messages.po i2p2www/translations/messages.pot Translate using POEdit:\nInstall POEdit Open your language\u0026rsquo;s messages.po file Translate the strings Save the file Submit your translations:\n# Commit your changes git add i2p2www/translations/[your-language]/ git commit -m \u0026#34;Updated [language] translations\u0026#34; # Submit via merge request on GitLab # Or send your .po file to the development team Router Console Translation The router console is the web interface you see when running I2P. Translating it helps users who aren\u0026rsquo;t comfortable with English.\nUsing Transifex (Recommended) Go to I2P on Transifex Select the router console project Choose your language Start translating Manual Router Console Translation Prerequisites:\nSame as website translation (git, gettext) GPG key (for commit access) Signed developer agreement Clone the main I2P repository:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git cd i2p.i2p Files to translate:\nThe router console has approximately 15 files that need translation:\nCore interface files:\napps/routerconsole/locale/messages_*.po - Main console messages apps/routerconsole/locale-news/messages_*.po - News messages Proxy files:\napps/i2ptunnel/locale/messages_*.po - Tunnel configuration interface Application locales:\napps/susidns/locale/messages_*.po - Address book interface apps/susimail/locale/messages_*.po - Email interface Other app-specific locale directories Documentation files:\ninstaller/resources/readme/readme_*.html - Installation readme Help files in various apps Translation workflow:\n# Update .po files from source ant extractMessages # Edit .po files with POEdit or text editor poedit apps/routerconsole/locale/messages_es.po # Build and test ant updaters # Install the update and check translations in the console Submit your work:\nCreate merge request on GitLab Or share files with the development team on IRC Translation Tools POEdit (Highly Recommended) POEdit is a specialized editor for .po translation files.\nFeatures:\nVisual interface for translation work Shows translation context Automatic validation Available for Windows, macOS, and Linux Text Editors You can also use any text editor:\nVS Code (with i18n extensions) Sublime Text vim/emacs (for terminal users) Quality Checks Before submitting:\nCheck for formatting: Ensure placeholders like %s and {0} remain unchanged Test your translations: Install and run I2P to see how they look Consistency: Keep terminology consistent across files Length: Some strings have space constraints in the UI Tips for Translators General Guidelines Stay consistent: Use the same translations for common terms throughout Keep formatting: Preserve HTML tags, placeholders (%s, {0}), and line breaks Context matters: Read the source English carefully to understand context Ask questions: Use IRC or forums if something is unclear Common I2P Terms Some terms should remain in English or be transliterated carefully:\nI2P - Keep as is eepsite - I2P website (may require explanation in your language) tunnel - Connection path (avoid Tor terminology like \u0026ldquo;circuit\u0026rdquo;) netDb - Network database floodfill - Type of router destination - I2P address endpoint Testing Your Translations Build I2P with your translations Change language in router console settings Navigate through all pages to check: Text fits in UI elements No garbled characters (encoding issues) Translations make sense in context Frequently Asked Questions Why is the translation process so complex? The process uses version control (git) and standard translation tools (.po files) because:\nAccountability: Track who changed what and when Quality: Review changes before they go live Consistency: Maintain proper file formatting and structure Scalability: Manage translations across multiple languages efficiently Collaboration: Multiple translators can work on the same language Do I need programming skills? No! If you use Transifex, you only need:\nFluency in both English and your target language A web browser Basic computer skills For manual translation, you\u0026rsquo;ll need basic command-line knowledge, but no coding is required.\nHow long does it take? Website: Depends on size, typically 10-30 hours for initial translation Router console: Approximately 15-20 hours for all files Maintenance: A few hours per month to update new strings Can multiple people work on one language? Yes! Coordination is key:\nUse Transifex for automatic coordination For manual work, communicate in #i2p-dev IRC channel Divide work by sections or files What if my language isn\u0026rsquo;t listed? Request it on Transifex or contact the team on IRC. The development team can set up a new language quickly.\nHow do I test my translations before submitting? For website:\n# Run local development server python i2p2www/manage.py runserver For router console:\nBuild I2P from source with your translations Install and run it locally Change language in console settings Getting Help IRC Support Join #i2p-dev on IRC for:\nTechnical help with translation tools Questions about I2P terminology Coordination with other translators Direct support from developers Forums Translation discussions on I2P Forums Inside I2P: Translation forum on zzz.i2p (requires I2P router) Documentation Transifex Documentation POEdit Documentation gettext Manual Recognition All translators are credited in:\nThe I2P router console (About page) Website credits page Git commit history Release announcements Your work directly helps people around the world use I2P safely and privately. Thank you for contributing!\nNext Steps Ready to start translating?\nChoose your method:\nQuick start: Sign up on Transifex Manual approach: Join #i2p-dev on IRC Pick a project:\nWebsite (documentation, blog posts) Router console (user interface) Start small: Translate a few strings to get familiar with the process\nAsk for help: Don\u0026rsquo;t hesitate to reach out on IRC or forums\nThank you for helping make I2P accessible to everyone!\n","description":"How to contribute translations to the I2P website and router console using Transifex or manual methods","id":"a436f7ab16669c43b076458496d70009","section":"docs","title":"New Translator's Guide","url":"/en/docs/develop/new-translators/"},{"categories":null,"content":" Note: This archive captures discussion threads from March 2007. For up-to-date transport details see the NTCP documentation.\nNTCP vs. SSU Discussion (March 2007) NTCP Questions Adapted from an IRC conversation between zzz and cervantes.\nWhy does NTCP have priority over SSU when NTCP appears to add overhead and latency?\nNTCP generally provides better reliability than the original SSU implementation. Does streaming over NTCP run into classic TCP-over-TCP collapse?\nPossibly, but SSU was intended to be the lightweight UDP option and proved too unreliable in practice. “NTCP Considered Harmful” (zzz, March 25, 2007) Summary: NTCP’s higher latency and overhead may cause congestion, yet routing prefers NTCP because its bid scores are hard-coded lower than SSU. The analysis raised several points:\nNTCP currently bids lower than SSU, so routers prefer NTCP unless an SSU session is already established. SSU implements acknowledgements with tightly bounded timeouts and statistics; NTCP relies on Java NIO TCP with RFC-style timeouts that may be much longer. Most traffic (HTTP, IRC, BitTorrent) uses I2P’s streaming library, effectively layering TCP over NTCP. When both layers retransmit, collapse is possible. Classic references include TCP over TCP is a bad idea. Streaming-library timeouts increased from 10 s to 45 s in release 0.8; SSU’s max timeout is 3 s, while NTCP timeouts are presumed to approach 60 s (RFC recommendation). NTCP parameters are hard to inspect externally. Field observations in 2007 showed i2psnark upload throughput oscillating, suggesting periodic congestion collapse. Efficiency tests (forcing SSU preference) reduced tunnel overhead ratios from roughly 3.5:1 to 3:1 and improved streaming metrics (window size, RTT, send/ack ratio). Proposals from the 2007 thread Flip transport priorities so routers prefer SSU (restoring i2np.udp.alwaysPreferred). Tag streaming traffic so SSU bids lower only for tagged messages, without compromising anonymity. Tighten SSU retransmission bounds to reduce collapse risk. Study semi-reliable underlays to determine whether retransmissions below the streaming library are a net benefit. Review priority queues and timeouts—for example, increasing streaming timeouts beyond 45 s to align with NTCP. Response by jrandom (March 27, 2007) Key counterpoints:\nNTCP exists because early SSU deployments suffered congestion collapse. Even modest per-hop retransmission rates can explode across multi-hop tunnels. Without tunnel-level acknowledgements, only a fraction of messages receive end-to-end delivery status; failures may be silent. TCP congestion control has decades of optimizations; NTCP leverages those via mature TCP stacks. Observed efficiency gains when preferring SSU might reflect router queuing behavior rather than intrinsic protocol advantages. Larger streaming timeouts were already improving stability; more observation and data were encouraged before major changes. The debate helped refine subsequent transport tuning but does not reflect the modern NTCP2/SSU2 architecture.\n","description":"Historical notes comparing NTCP and SSU transports and proposed tuning ideas","id":"6fe94dc04faadfde27bcfeaaf9da5f71","section":"docs","title":"NTCP Discussion","url":"/en/docs/ntcp/"},{"categories":null,"content":"Overview NTCP2 replaces the legacy NTCP transport with a Noise-based handshake that resists traffic fingerprinting, encrypts length fields, and supports modern cipher suites. Routers may run NTCP2 alongside SSU2 as the two mandatory transport protocols in the I2P network. NTCP (version 1) was deprecated in 0.9.40 (May 2019) and completely removed in 0.9.50 (May 2021).\nCurrent Status (October 2025):\nLatest I2P Version: 2.10.0 (released September 9, 2025) NTCP2 is mandatory (one of two required transports alongside SSU2) Protocol introduced in I2P 0.9.36 (August 2018) Stable since 0.9.50 with no breaking changes Noise Protocol Framework NTCP2 uses the Noise Protocol Framework Revision 33, 2017-10-04 with I2P-specific extensions:\nPattern: Noise_XK_25519_ChaChaPoly_SHA256 Extended Identifier: Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256 (for KDF initialization) DH Function: X25519 (RFC 7748) - 32-byte keys, little-endian encoding Cipher: AEAD_CHACHA20_POLY1305 (RFC 7539/RFC 8439) 12-byte nonce: first 4 bytes zero, last 8 bytes counter (little-endian) Maximum nonce value: 2^64 - 2 (connection must terminate before reaching 2^64 - 1) Hash Function: SHA-256 (32-byte output) MAC: Poly1305 (16-byte authentication tag) I2P-Specific Extensions AES Obfuscation: Ephemeral keys encrypted with AES-256-CBC using Bob\u0026rsquo;s router hash and published IV Random Padding: Cleartext padding in messages 1-2 (authenticated), AEAD padding in message 3+ (encrypted) SipHash-2-4 Length Obfuscation: Two-byte frame lengths XORed with SipHash output Frame Structure: Length-prefixed frames for data phase (TCP streaming compatibility) Block-Based Payloads: Structured data format with typed blocks Handshake Flow Alice (Initiator) Bob (Responder) SessionRequest ──────────────────────► ◄────────────────────── SessionCreated SessionConfirmed ──────────────────────► Three-Message Handshake SessionRequest - Alice\u0026rsquo;s obfuscated ephemeral key, options, padding hints SessionCreated - Bob\u0026rsquo;s obfuscated ephemeral key, encrypted options, padding SessionConfirmed - Alice\u0026rsquo;s encrypted static key and RouterInfo (two AEAD frames) Noise Message Patterns XK(s, rs): Authentication Confidentiality \u0026lt;- s (Bob\u0026#39;s static key known in advance) -\u0026gt; e, es 0 2 \u0026lt;- e, ee 2 1 -\u0026gt; s, se 2 5 \u0026lt;- 2 5 Authentication Levels:\n0: No authentication (any party could have sent) 2: Sender authentication resistant to key-compromise impersonation (KCI) Confidentiality Levels:\n1: Ephemeral recipient (forward secrecy, no recipient authentication) 2: Known recipient, forward secrecy for sender compromise only 5: Strong forward secrecy (ephemeral-ephemeral + ephemeral-static DH) Message Specifications Key Notation RH_A = Router Hash for Alice (32 bytes, SHA-256) RH_B = Router Hash for Bob (32 bytes, SHA-256) || = Concatenation operator byte(n) = Single byte with value n All multi-byte integers are big-endian unless specified otherwise X25519 keys are little-endian (32 bytes) Authenticated Encryption (ChaCha20-Poly1305) Encryption Function:\nAEAD_ChaCha20_Poly1305(key, nonce, associatedData, plaintext) → (ciphertext || MAC) Parameters:\nkey: 32-byte cipher key from KDF nonce: 12 bytes (4 zero bytes + 8-byte counter, little-endian) associatedData: 32-byte hash in handshake phase; zero-length in data phase plaintext: Data to encrypt (0+ bytes) Output:\nCiphertext: Same length as plaintext MAC: 16 bytes (Poly1305 authentication tag) Nonce Management:\nCounter starts at 0 for each cipher instance Increments for each AEAD operation in that direction Separate counters for Alice→Bob and Bob→Alice in data phase Must terminate connection before counter reaches 2^64 - 1 Message 1: SessionRequest Alice initiates connection to Bob.\nNoise Operations: e, es (ephemeral key generation and exchange)\nRaw Format +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted X (32B) + | Key: RH_B, IV: Bob\u0026#39;s published IV | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (X + options) | + k from KDF-1, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Size Constraints:\nMinimum: 80 bytes (32 AES + 48 AEAD) Maximum: 65535 bytes total Special case: Max 287 bytes when connecting to \u0026ldquo;NTCP\u0026rdquo; addresses (version detection) Decrypted Content +----+----+----+----+----+----+----+----+ | | + X (Alice ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Options Block (16 bytes, big-endian) +----+----+----+----+----+----+----+----+ | id | ver| padLen | m3p2len | Rsvd(0) | +----+----+----+----+----+----+----+----+ | tsA | Reserved (0) | +----+----+----+----+----+----+----+----+ id : 1 byte - Network ID (2 for mainnet, 16-254 for testnets) ver : 1 byte - Protocol version (currently 2) padLen : 2 bytes - Padding length in this message (0-65455) m3p2len : 2 bytes - Length of SessionConfirmed part 2 frame Rsvd : 2 bytes - Reserved, set to 0 tsA : 4 bytes - Unix timestamp (seconds since epoch) Reserved: 4 bytes - Reserved, set to 0 Critical Fields:\nNetwork ID (since 0.9.42): Fast rejection of cross-network connections m3p2len: Exact size of message 3 part 2 (must match when sent) Key Derivation Function (KDF-1) Initialize Protocol:\nprotocol_name = \u0026#34;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256\u0026#34; h = SHA256(protocol_name) ck = h // Chaining key initialized to hash MixHash Operations:\nh = SHA256(h) // Null prologue h = SHA256(h || rs) // Bob\u0026#39;s static key (known) h = SHA256(h || e.pubkey) // Alice\u0026#39;s ephemeral key X // h is now the associated data for message 1 AEAD MixKey Operation (es pattern):\ndh_result = X25519(Alice.ephemeral_private, Bob.static_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 1 // ck is retained for message 2 KDF Implementation Notes AES Obfuscation: Used for DPI resistance only; anyone with Bob\u0026rsquo;s router hash and IV can decrypt X Replay Prevention: Bob must cache X values (or encrypted equivalents) for at least 2*D seconds (D = max clock skew) Timestamp Validation: Bob must reject connections with |tsA - current_time| \u0026gt; D (typically D = 60 seconds) Curve Validation: Bob must verify X is a valid X25519 point Fast Rejection: Bob may check X[31] \u0026amp; 0x80 == 0 before decryption (valid X25519 keys have MSB clear) Error Handling: On any failure, Bob closes with TCP RST after random timeout and random byte read Buffering: Alice must flush entire message (including padding) at once for efficiency Message 2: SessionCreated Bob responds to Alice.\nNoise Operations: e, ee (ephemeral-ephemeral DH)\nRaw Format +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted Y (32B) + | Key: RH_B, IV: AES state from msg1 | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (Y + options) | + k from KDF-2, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Decrypted Content +----+----+----+----+----+----+----+----+ | | + Y (Bob ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Options Block (16 bytes, big-endian) +----+----+----+----+----+----+----+----+ | Rsvd(0) | padLen | Reserved (0) | +----+----+----+----+----+----+----+----+ | tsB | Reserved (0) | +----+----+----+----+----+----+----+----+ Rsvd : 2 bytes - Reserved, set to 0 padLen : 2 bytes - Padding length in this message Reserved: 10 bytes - Reserved, set to 0 tsB : 4 bytes - Unix timestamp (seconds since epoch) Key Derivation Function (KDF-2) MixHash Operations:\nh = SHA256(h || encrypted_payload_msg1) // 32-byte ciphertext if (msg1_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg1) h = SHA256(h || e.pubkey) // Bob\u0026#39;s ephemeral key Y // h is now the associated data for message 2 AEAD MixKey Operation (ee pattern):\ndh_result = X25519(Bob.ephemeral_private, Alice.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 2 // ck is retained for message 3 KDF Memory Cleanup:\n// Overwrite ephemeral keys after ee DH Alice.ephemeral_public = zeros(32) Alice.ephemeral_private = zeros(32) // Bob side Bob.received_ephemeral = zeros(32) // Bob side Implementation Notes AES Chaining: Y encryption uses AES-CBC state from message 1 (not reset) Replay Prevention: Alice must cache Y values for at least 2*D seconds Timestamp Validation: Alice must reject |tsB - current_time| \u0026gt; D Curve Validation: Alice must verify Y is a valid X25519 point Error Handling: Alice closes with TCP RST on any failure Buffering: Bob must flush entire message at once Message 3: SessionConfirmed Alice confirms session and sends RouterInfo.\nNoise Operations: s, se (static key reveal and static-ephemeral DH)\nTwo-Part Structure Message 3 consists of two separate AEAD frames:\nPart 1: Fixed 48-byte frame with Alice\u0026rsquo;s encrypted static key Part 2: Variable-length frame with RouterInfo, options, and padding Raw Format +----+----+----+----+----+----+----+----+ | ChaChaPoly Frame 1 (48 bytes) | + Plaintext: Alice static key (32B) + | k from KDF-2, n=1, ad=h | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame 2 (variable) + | Length specified in msg1.m3p2len | + k from KDF-3, n=0, ad=h + | Plaintext: RouterInfo + padding | + + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Size Constraints:\nPart 1: Exactly 48 bytes (32 plaintext + 16 MAC) Part 2: Length specified in message 1 (m3p2len field) Total maximum: 65535 bytes (part 1 max 48, so part 2 max 65487) Decrypted Content Part 1:\n+----+----+----+----+----+----+----+----+ | | + S (Alice static public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ Part 2:\n+----+----+----+----+----+----+----+----+ | Block: RouterInfo (required) | + Type=2, contains Alice\u0026#39;s RI + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ | Block: Options (optional) | + Type=1, padding parameters + | | +----+----+----+----+----+----+----+----+ | Block: Padding (optional) | + Type=254, random data + | MUST be last block if present | ~ . . . ~ +----+----+----+----+----+----+----+----+ Key Derivation Function (KDF-3) Part 1 (s pattern):\nh = SHA256(h || encrypted_payload_msg2) // 32-byte ciphertext if (msg2_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg2) // Encrypt static key with message 2 cipher key ciphertext = AEAD_ChaCha20_Poly1305(k_msg2, n=1, h, Alice.static_public) h = SHA256(h || ciphertext) // 48 bytes (32 + 16) // h is now the associated data for message 3 part 2 Part 2 (se pattern):\ndh_result = X25519(Alice.static_private, Bob.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 3 part 2 // ck is retained for data phase KDF ciphertext = AEAD_ChaCha20_Poly1305(k, n=0, h, payload) h = SHA256(h || ciphertext) // h is retained for SipHash KDF Memory Cleanup:\n// Overwrite Bob\u0026#39;s ephemeral key after se DH Alice.received_ephemeral = zeros(32) // Alice side Bob.ephemeral_public = zeros(32) // Bob side Bob.ephemeral_private = zeros(32) // Bob side Implementation Notes RouterInfo Validation: Bob must verify signature, timestamp, and key consistency Key Matching: Bob must verify Alice\u0026rsquo;s static key in part 1 matches the key in RouterInfo Static Key Location: Look for matching \u0026ldquo;s\u0026rdquo; parameter in NTCP or NTCP2 RouterAddress Block Order: RouterInfo must be first, Options second (if present), Padding last (if present) Length Planning: Alice must ensure m3p2len in message 1 exactly matches part 2 length Buffering: Alice must flush both parts together as one TCP send Optional Chaining: Alice may append a data phase frame immediately for efficiency Data Phase After handshake completion, all messages use variable-length AEAD frames with obfuscated length fields.\nKey Derivation Function (Data Phase) Split Function (Noise):\n// Generate transmit and receive keys zerolen = \u0026#34;\u0026#34; // Zero-length byte array temp_key = HMAC-SHA256(ck, zerolen) // Alice transmits to Bob k_ab = HMAC-SHA256(temp_key, byte(0x01)) // Bob transmits to Alice k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) // Cleanup ck = zeros(32) temp_key = zeros(32) SipHash Key Derivation:\n// Generate additional symmetric key for SipHash ask_master = HMAC-SHA256(temp_key, \u0026#34;ask\u0026#34; || byte(0x01)) // \u0026#34;siphash\u0026#34; is 7 bytes US-ASCII temp_key2 = HMAC-SHA256(ask_master, h || \u0026#34;siphash\u0026#34;) sip_master = HMAC-SHA256(temp_key2, byte(0x01)) // Alice to Bob SipHash keys temp_key3 = HMAC-SHA256(sip_master, zerolen) sipkeys_ab = HMAC-SHA256(temp_key3, byte(0x01)) sipk1_ab = sipkeys_ab[0:7] // 8 bytes, little-endian sipk2_ab = sipkeys_ab[8:15] // 8 bytes, little-endian sipiv_ab = sipkeys_ab[16:23] // 8 bytes, IV // Bob to Alice SipHash keys sipkeys_ba = HMAC-SHA256(temp_key3, sipkeys_ab || byte(0x02)) sipk1_ba = sipkeys_ba[0:7] // 8 bytes, little-endian sipk2_ba = sipkeys_ba[8:15] // 8 bytes, little-endian sipiv_ba = sipkeys_ba[16:23] // 8 bytes, IV Frame Structure +----+----+----+----+----+----+----+----+ |Obfs Len | | +----+----+ ChaChaPoly Frame + | Encrypted Block Data | + k_ab (Alice→Bob) or k_ba (Bob→Alice)| | Nonce starts at 0, increments | + No associated data (empty string) + | | ~ . . . ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | +----+----+----+----+----+----+----+----+ Frame Constraints:\nMinimum: 18 bytes (2 obfuscated length + 0 plaintext + 16 MAC) Maximum: 65537 bytes (2 obfuscated length + 65535 frame) Recommended: Few KB per frame (minimize receiver latency) SipHash Length Obfuscation Purpose: Prevent DPI identification of frame boundaries\nAlgorithm:\n// Initialization (per direction) IV[0] = sipiv // From KDF // For each frame: IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] // First 2 bytes of IV ObfuscatedLength = ActualLength XOR Mask[n] // Send 2-byte ObfuscatedLength, then ActualLength bytes Decoding:\n// Receiver maintains identical IV chain IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] ActualLength = ObfuscatedLength XOR Mask[n] // Read ActualLength bytes (includes 16-byte MAC) Notes:\nSeparate IV chains for each direction (Alice→Bob and Bob→Alice) If SipHash returns uint64, use least significant 2 bytes as mask Convert uint64 to next IV as little-endian bytes Block Format Each frame contains zero or more blocks:\n+----+----+----+----+----+----+----+----+ |Type| Length | Data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 byte - Block type identifier Length: 2 bytes - Big-endian, data size (0-65516) Data : Variable length payload Size Limits:\nMaximum frame: 65535 bytes (including MAC) Maximum block space: 65519 bytes (frame - 16-byte MAC) Maximum single block: 65519 bytes (3-byte header + 65516 data) Block Types Type Name Description 0DateTimeTime synchronization (4-byte timestamp) 1OptionsPadding parameters, dummy traffic 2RouterInfoRouterInfo delivery/flooding 3I2NPI2NP message with shortened header 4TerminationExplicit connection close 224-253ReservedExperimental features 254PaddingRandom padding (must be last) 255ReservedFuture extensions Block Ordering Rules:\nMessage 3 part 2: RouterInfo, Options (optional), Padding (optional) - NO other types Data phase: Any order except: Padding MUST be last block if present Termination MUST be last block (except Padding) if present Multiple I2NP blocks allowed per frame Multiple Padding blocks NOT allowed per frame Block Type 0: DateTime Time synchronization for clock skew detection.\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Type : 0 Length : 4 (big-endian) Timestamp: 4 bytes, Unix seconds (big-endian) Implementation: Round to nearest second to prevent clock bias accumulation.\nBlock Type 1: Options Padding and traffic shaping parameters.\n+----+----+----+----+----+----+----+----+ | 1 | size |tmin|tmax|rmin|rmax|tdmy| +----+----+----+----+----+----+----+----+ |tdmy| rdmy | tdelay | rdelay | | +----+----+----+----+----+----+----+ + | more_options (TBD) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 Length: 12+ bytes (big-endian) Padding Ratios (4.4 fixed-point float, value/16.0):\ntmin: Transmit minimum padding ratio (0.0 - 15.9375) tmax: Transmit maximum padding ratio (0.0 - 15.9375) rmin: Receive minimum padding ratio (0.0 - 15.9375) rmax: Receive maximum padding ratio (0.0 - 15.9375) Examples:\n0x00 = 0% padding 0x01 = 6.25% padding 0x10 = 100% padding (1:1 ratio) 0x80 = 800% padding (8:1 ratio) Dummy Traffic:\ntdmy: Max willing to send (2 bytes, bytes/sec average) rdmy: Requested to receive (2 bytes, bytes/sec average) Delay Insertion:\ntdelay: Max willing to insert (2 bytes, milliseconds average) rdelay: Requested delay (2 bytes, milliseconds average) Guidelines:\nMin values indicate desired traffic analysis resistance Max values indicate bandwidth constraints Sender should honor receiver\u0026rsquo;s maximum Sender may honor receiver\u0026rsquo;s minimum within constraints No enforcement mechanism; implementations may vary Block Type 2: RouterInfo RouterInfo delivery for netdb population and flooding.\n+----+----+----+----+----+----+----+----+ | 2 | size |flg | RouterInfo | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 2 Length: Flag (1 byte) + RouterInfo size Flag : Bit 0 = flood request (1) or local store (0) Bits 1-7 = Reserved, set to 0 Usage:\nIn Message 3 Part 2 (handshake):\nAlice sends her RouterInfo to Bob Flood bit typically 0 (local storage) RouterInfo NOT gzip compressed In Data Phase:\nEither party may send their updated RouterInfo Flood bit = 1: Request floodfill distribution (if receiver is floodfill) Flood bit = 0: Local netdb storage only Validation Requirements:\nVerify signature type is supported Verify RouterInfo signature Verify timestamp within acceptable bounds For handshake: Verify static key matches NTCP2 address \u0026ldquo;s\u0026rdquo; parameter For data phase: Verify router hash matches session peer Only flood RouterInfos with published addresses Notes:\nNo ACK mechanism (use I2NP DatabaseStore with reply token if needed) May contain third-party RouterInfos (floodfill usage) NOT gzip compressed (unlike I2NP DatabaseStore) Block Type 3: I2NP Message I2NP message with shortened 9-byte header.\n+----+----+----+----+----+----+----+----+ | 3 | size |type| msg_id | +----+----+----+----+----+----+----+----+ | expiration | I2NP payload | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 3 Length : 9 + payload_size (big-endian) Type : 1 byte, I2NP message type Msg_ID : 4 bytes, big-endian, I2NP message ID Expiration: 4 bytes, big-endian, Unix timestamp (seconds) Payload : I2NP message body (length = size - 9) Differences from NTCP1:\nExpiration: 4 bytes (seconds) vs 8 bytes (milliseconds) Length: Omitted (derivable from block length) Checksum: Omitted (AEAD provides integrity) Header: 9 bytes vs 16 bytes (44% reduction) Fragmentation:\nI2NP messages MUST NOT be fragmented across blocks I2NP messages MUST NOT be fragmented across frames Multiple I2NP blocks allowed per frame Block Type 4: Termination Explicit connection close with reason code.\n+----+----+----+----+----+----+----+----+ | 4 | size | valid_frames_recv | +----+----+----+----+----+----+----+----+ | (continued) |rsn | additional_data | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 4 Length : 9+ bytes (big-endian) Valid_Frames_Recv: 8 bytes, big-endian (receive nonce value) 0 if error in handshake phase Reason : 1 byte (see table below) Additional_Data : Optional (format unspecified, for debugging) Reason Codes:\nCode Reason Phase 0Normal close / unspecifiedAny 1Termination receivedData 2Idle timeoutData 3Router shutdownData 4Data phase AEAD failureData 5Incompatible optionsHandshake 6Incompatible signature typeHandshake 7Clock skewHandshake 8Padding violationAny 9AEAD framing errorData 10Payload format errorData 11Message 1 errorHandshake 12Message 2 errorHandshake 13Message 3 errorHandshake 14Intra-frame read timeoutData 15RouterInfo signature verification failHandshake 16Static key parameter mismatchHandshake 17BannedAny Rules:\nTermination MUST be last non-padding block in frame One termination block per frame maximum Sender should close connection after sending Receiver should close connection after receiving Error Handling:\nHandshake errors: Typically close with TCP RST (no termination block) Data phase AEAD errors: Random timeout + random read, then send termination See \u0026ldquo;AEAD Error Handling\u0026rdquo; section for security procedures Block Type 254: Padding Random padding for traffic analysis resistance.\n+----+----+----+----+----+----+----+----+ |254 | size | random_data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type: 254 Length: 0-65516 bytes (big-endian) Data: Cryptographically random bytes Rules:\nPadding MUST be last block in frame if present Zero-length padding is allowed Only one padding block per frame Padding-only frames are allowed Should adhere to negotiated parameters from Options block Padding in Messages 1-2:\nOutside AEAD frame (cleartext) Included in next message\u0026rsquo;s hash chain (authenticated) Tampering detected when next message AEAD fails Padding in Message 3+ and Data Phase:\nInside AEAD frame (encrypted and authenticated) Used for traffic shaping and size obfuscation AEAD Error Handling Critical Security Requirements:\nHandshake Phase (Messages 1-3) Known Message Size:\nMessage sizes are predetermined or specified in advance AEAD authentication failure is unambiguous Bob\u0026rsquo;s Response to Message 1 Failure:\nSet random timeout (range implementation-dependent, suggest 100-500ms) Read random number of bytes (range implementation-dependent, suggest 1KB-64KB) Close connection with TCP RST (no response) Blacklist source IP temporarily Track repeated failures for long-term bans Alice\u0026rsquo;s Response to Message 2 Failure:\nClose connection immediately with TCP RST No response to Bob Bob\u0026rsquo;s Response to Message 3 Failure:\nClose connection immediately with TCP RST No response to Alice Data Phase Obfuscated Message Size:\nLength field is SipHash-obfuscated Invalid length or AEAD failure could indicate: Attacker probing Network corruption Desynchronized SipHash IV Malicious peer Response to AEAD or Length Error:\nSet random timeout (suggest 100-500ms) Read random number of bytes (suggest 1KB-64KB) Send termination block with reason code 4 (AEAD failure) or 9 (framing error) Close connection Prevention of Decryption Oracle:\nNever reveal error type to peer before random timeout Never skip length validation before AEAD check Treat invalid length same as AEAD failure Use identical error handling path for both errors Implementation Considerations:\nSome implementations may continue after AEAD errors if infrequent Terminate after repeated errors (suggest threshold: 3-5 errors per hour) Balance between error recovery and security Published RouterInfo Router Address Format NTCP2 support is advertised through published RouterAddress entries with specific options.\nTransport Style:\n\u0026quot;NTCP2\u0026quot; - NTCP2 only on this port \u0026quot;NTCP\u0026quot; - Both NTCP and NTCP2 on this port (auto-detect) Note: NTCP (v1) support removed in 0.9.50 (May 2021) \u0026ldquo;NTCP\u0026rdquo; style is now obsolete; use \u0026ldquo;NTCP2\u0026rdquo; Required Options All Published NTCP2 Addresses:\nhost - IP address (IPv4 or IPv6) or hostname\nFormat: Standard IP notation or domain name May be omitted for outbound-only or hidden routers port - TCP port number\nFormat: Integer, 1-65535 May be omitted for outbound-only or hidden routers s - Static public key (X25519)\nFormat: Base64-encoded, 44 characters Encoding: I2P Base64 alphabet Source: 32-byte X25519 public key, little-endian i - Initialization Vector for AES\nFormat: Base64-encoded, 24 characters Encoding: I2P Base64 alphabet Source: 16-byte IV, big-endian v - Protocol version\nFormat: Integer or comma-separated integers Current: \u0026quot;2\u0026quot; Future: \u0026quot;2,3\u0026quot; (must be in numerical order) Optional Options:\ncaps - Capabilities (since 0.9.50)\nFormat: String of capability characters Values: \u0026quot;4\u0026quot; - IPv4 outbound capability \u0026quot;6\u0026quot; - IPv6 outbound capability \u0026quot;46\u0026quot; - Both IPv4 and IPv6 (recommended order) Not needed if host is published Useful for hidden/firewalled routers cost - Address priority\nFormat: Integer, 0-255 Lower values = higher priority Suggested: 5-10 for normal addresses Suggested: 14 for unpublished addresses Example RouterAddress Entries Published IPv4 Address:\n\u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Hidden Router (Outbound Only):\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;caps\u0026gt;4\u0026lt;/caps\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Dual-Stack Router:\n\u0026lt;!-- IPv4 Address --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; \u0026lt;!-- IPv6 Address (same keys, same port) --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;2001:db8::1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Important Rules:\nMultiple NTCP2 addresses with the same port MUST use identical s, i, and v values Different ports may use different keys Dual-stack routers should publish separate IPv4 and IPv6 addresses Unpublished NTCP2 Address For Outbound-Only Routers:\nIf a router does not accept incoming NTCP2 connections but initiates outbound connections, it MUST still publish a RouterAddress with:\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Purpose:\nAllows Bob to validate Alice\u0026rsquo;s static key during handshake Required for message 3 part 2 RouterInfo verification No i, host, or port needed (outbound only) Alternative:\nAdd s and v to existing published \u0026ldquo;NTCP\u0026rdquo; or SSU address Public Key and IV Rotation Critical Security Policy:\nGeneral Rules:\nNever rotate while router is running Persistently store key and IV across restarts Track previous downtime to determine rotation eligibility Minimum Downtime Before Rotation:\nRouter Type Min Downtime Reason Published NTCP2 address1 monthMany routers cache RouterInfo Published SSU only (no NTCP2)1 dayModerate caching No published addresses (hidden)2 hoursMinimal impact Additional Triggers:\nLocal IP address change: May rotate regardless of downtime Router \u0026ldquo;rekey\u0026rdquo; (new Router Hash): Generate new keys Rationale:\nPrevents exposing restart times through key changes Allows cached RouterInfos to expire naturally Maintains network stability Reduces failed connection attempts Implementation:\nStore key, IV, and last-shutdown timestamp persistently At startup, calculate downtime = current_time - last_shutdown If downtime \u0026gt; minimum for router type, may rotate If IP changed or rekeying, may rotate Otherwise, reuse previous key and IV IV Rotation:\nSubject to identical rules as key rotation Only present in published addresses (not hidden routers) Recommended to change IV whenever key changes Version Detection Context: When transportStyle=\u0026quot;NTCP\u0026quot; (legacy), Bob supports both NTCP v1 and v2 on the same port and must automatically detect the protocol version.\nDetection Algorithm:\n1. Wait for at least 64 bytes (minimum NTCP2 message 1 size) 2. If received ≥ 288 bytes: → Connection is NTCP version 1 (NTCP1 message 1 is 288 bytes) 3. If received \u0026lt; 288 bytes: Option A (conservative, pre-NTCP2 majority): a. Wait additional short time (e.g., 100-500ms) b. If total received ≥ 288 bytes → NTCP1 c. Otherwise → Attempt NTCP2 decode Option B (aggressive, post-NTCP2 majority): a. Attempt NTCP2 decode immediately: - Decrypt first 32 bytes (X key) with AES-256-CBC - Verify valid X25519 point (X[31] \u0026amp; 0x80 == 0) - Verify AEAD frame b. If decode succeeds → NTCP2 c. If decode fails → Wait for more data or NTCP1 Fast MSB Check:\nBefore AES decryption, verify: encrypted_X[31] \u0026amp; 0x80 == 0 Valid X25519 keys have high bit clear Failure indicates likely NTCP1 (or attack) Implement probing resistance (random timeout + read) on failure Implementation Requirements:\nAlice\u0026rsquo;s Responsibility:\nWhen connecting to \u0026ldquo;NTCP\u0026rdquo; address, limit message 1 to 287 bytes max Buffer and flush entire message 1 at once Increases likelihood of single TCP packet delivery Bob\u0026rsquo;s Responsibility:\nBuffer received data before deciding version Implement proper timeout handling Use TCP_NODELAY for rapid version detection Buffer and flush entire message 2 at once after version detected Security Considerations:\nSegmentation attacks: Bob should be resilient to TCP segmentation Probing attacks: Implement random delays and byte reads on failures DoS prevention: Limit concurrent pending connections Read timeouts: Both per-read and total (\u0026ldquo;slowloris\u0026rdquo; protection) Clock Skew Guidelines Timestamp Fields:\nMessage 1: tsA (Alice\u0026rsquo;s timestamp) Message 2: tsB (Bob\u0026rsquo;s timestamp) Message 3+: Optional DateTime blocks Maximum Skew (D):\nTypical: ±60 seconds Configurable per implementation Skew \u0026gt; D is generally fatal Bob\u0026rsquo;s Handling (Message 1) 1. Receive tsA from Alice 2. skew = tsA - current_time 3. If |skew| \u0026gt; D: a. Still send message 2 (allows Alice to calculate skew) b. Include tsB in message 2 c. Do NOT initiate handshake completion d. Optionally: Temporary ban Alice\u0026#39;s IP e. After message 2 sent, close connection 4. If |skew| ≤ D: a. Continue handshake normally Rationale: Sending message 2 even on skew allows Alice to diagnose clock issues.\nAlice\u0026rsquo;s Handling (Message 2) 1. Receive tsB from Bob 2. RTT = (current_time_now - tsA_sent) 3. adjusted_skew = (tsB - current_time_now) - (RTT / 2) 4. If |adjusted_skew| \u0026gt; D: a. Close connection immediately b. If local clock suspect: Adjust clock or use external time source c. If Bob\u0026#39;s clock suspect: Temporary ban Bob d. Log for operator review 5. If |adjusted_skew| ≤ D: a. Continue handshake normally b. Optionally: Track skew for time synchronization RTT Adjustment:\nSubtract half RTT from calculated skew Accounts for network propagation delay More accurate skew estimation Bob\u0026rsquo;s Handling (Message 3) 1. If message 3 received (unlikely if skew exceeded in message 1) 2. Recalculate skew = tsA_received - current_time 3. If |adjusted_skew| \u0026gt; D: a. Send termination block (reason code 7: clock skew) b. Close connection c. Ban Alice for period (e.g., 1-24 hours) Time Synchronization DateTime Blocks (Data Phase):\nPeriodically send DateTime block (type 0) Receiver can use for clock adjustment Round timestamp to nearest second (prevent bias) External Time Sources:\nNTP (Network Time Protocol) System clock synchronization I2P network consensus time Clock Adjustment Strategies:\nIf local clock bad: Adjust system time or use offset If peer clocks consistently bad: Flag peer issue Track skew statistics for network health monitoring Security Properties Forward Secrecy Achieved Through:\nEphemeral Diffie-Hellman key exchange (X25519) Three DH operations: es, ee, se (Noise XK pattern) Ephemeral keys destroyed after handshake completion Confidentiality Progression:\nMessage 1: Level 2 (forward secrecy for sender compromise) Message 2: Level 1 (ephemeral recipient) Message 3+: Level 5 (strong forward secrecy) Perfect Forward Secrecy:\nCompromise of long-term static keys does NOT reveal past session keys Each session uses unique ephemeral keys Ephemeral private keys never reused Memory cleanup after key agreement Limitations:\nMessage 1 vulnerable if Bob\u0026rsquo;s static key compromised (but forward secrecy from Alice compromise) Replay attacks possible for message 1 (mitigated by timestamp and replay cache) Authentication Mutual Authentication:\nAlice authenticated by static key in message 3 Bob authenticated by possession of static private key (implicit from successful handshake) Key Compromise Impersonation (KCI) Resistance:\nAuthentication level 2 (resistant to KCI) Attacker cannot impersonate Alice even with Alice\u0026rsquo;s static private key (without Alice\u0026rsquo;s ephemeral key) Attacker cannot impersonate Bob even with Bob\u0026rsquo;s static private key (without Bob\u0026rsquo;s ephemeral key) Static Key Verification:\nAlice knows Bob\u0026rsquo;s static key in advance (from RouterInfo) Bob verifies Alice\u0026rsquo;s static key matches RouterInfo in message 3 Prevents man-in-the-middle attacks Resistance to Traffic Analysis DPI Countermeasures:\nAES Obfuscation: Ephemeral keys encrypted, appears random SipHash Length Obfuscation: Frame lengths not plaintext Random Padding: Variable message sizes, no fixed patterns Encrypted Frames: All payload encrypted with ChaCha20 Replay Attack Prevention:\nTimestamp validation (±60 seconds) Replay cache of ephemeral keys (lifetime 2*D) Nonce increments prevent packet replay within session Probing Resistance:\nRandom timeouts on AEAD failures Random byte reads before connection close No responses on handshake failures IP blacklisting for repeated failures Padding Guidelines:\nMessages 1-2: Cleartext padding (authenticated) Message 3+: Encrypted padding inside AEAD frames Negotiated padding parameters (Options block) Padding-only frames permitted Denial of Service Mitigation Connection Limits:\nMaximum active connections (implementation-dependent) Maximum pending handshakes (e.g., 100-1000) Per-IP connection limits (e.g., 3-10 simultaneous) Resource Protection:\nDH operations rate-limited (expensive) Read timeouts per-socket and total \u0026ldquo;Slowloris\u0026rdquo; protection (total time limits) IP blacklisting for abuse Fast Rejection:\nNetwork ID mismatch → immediate close Invalid X25519 point → fast MSB check before decryption Timestamp out of bounds → close without computation AEAD failure → no response, random delay Probing Resistance:\nRandom timeout: 100-500ms (implementation-dependent) Random read: 1KB-64KB (implementation-dependent) No error information to attacker Close with TCP RST (no FIN handshake) Cryptographic Security Algorithms:\nX25519: 128-bit security, elliptic curve DH (Curve25519) ChaCha20: 256-bit key stream cipher Poly1305: Information-theoretically secure MAC SHA-256: 128-bit collision resistance, 256-bit preimage resistance HMAC-SHA256: PRF for key derivation Key Sizes:\nStatic keys: 32 bytes (256 bits) Ephemeral keys: 32 bytes (256 bits) Cipher keys: 32 bytes (256 bits) MAC: 16 bytes (128 bits) Known Issues:\nChaCha20 nonce reuse is catastrophic (prevented by counter increment) X25519 has small subgroup issues (mitigated by curve validation) SHA-256 theoretically vulnerable to length extension (not exploitable in HMAC) No Known Vulnerabilities (as of October 2025):\nNoise Protocol Framework widely analyzed ChaCha20-Poly1305 deployed in TLS 1.3 X25519 standard in modern protocols No practical attacks on construction References Primary Specifications NTCP2 Specification - Official I2P specification Proposal 111 - Original design document with rationale Noise Protocol Framework - Revision 33 (2017-10-04) Cryptographic Standards RFC 7748 - Elliptic Curves for Security (X25519) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols RFC 8439 - ChaCha20-Poly1305 (obsoletes RFC 7539) RFC 2104 - HMAC: Keyed-Hashing for Message Authentication SipHash - SipHash-2-4 for hash function applications Related I2P Specifications I2NP Specification - I2P Network Protocol message format Common Structures - RouterInfo, RouterAddress formats SSU Transport - UDP transport (original, now SSU2) Proposal 147 - Transport Network ID Check (0.9.42) Implementation References I2P Java - Reference implementation (Java) i2pd - C++ implementation I2P Release Notes - Version history and updates Historical Context Station-To-Station Protocol (STS) - Inspiration for Noise framework obfs4 - Pluggable transport (SipHash length obfuscation precedent) Implementation Guidelines Mandatory Requirements For Compliance:\nImplement Complete Handshake:\nSupport all three messages with correct KDF chains Validate all AEAD tags Verify X25519 points are valid Implement Data Phase:\nSipHash length obfuscation (both directions) All block types: 0 (DateTime), 1 (Options), 2 (RouterInfo), 3 (I2NP), 4 (Termination), 254 (Padding) Proper nonce management (separate counters) Security Features:\nReplay prevention (cache ephemeral keys for 2*D) Timestamp validation (±60 seconds default) Random padding in messages 1-2 AEAD error handling with random timeouts RouterInfo Publishing:\nPublish static key (\u0026ldquo;s\u0026rdquo;), IV (\u0026ldquo;i\u0026rdquo;), and version (\u0026ldquo;v\u0026rdquo;) Rotate keys according to policy Support capabilities field (\u0026ldquo;caps\u0026rdquo;) for hidden routers Network Compatibility:\nSupport network ID field (currently 2 for mainnet) Interoperate with existing Java and i2pd implementations Handle both IPv4 and IPv6 Recommended Practices Performance Optimization:\nBuffering Strategy:\nFlush entire messages at once (messages 1, 2, 3) Use TCP_NODELAY for handshake messages Buffer multiple data blocks into single frames Limit frame size to few KB (minimize receiver latency) Connection Management:\nReuse connections when possible Implement connection pooling Monitor connection health (DateTime blocks) Memory Management:\nZero sensitive data after use (ephemeral keys, DH results) Limit concurrent handshakes (DoS prevention) Use memory pools for frequent allocations Security Hardening:\nProbing Resistance:\nRandom timeouts: 100-500ms Random byte reads: 1KB-64KB IP blacklisting for repeated failures No error details to peers Resource Limits:\nMax connections per IP: 3-10 Max pending handshakes: 100-1000 Read timeouts: 30-60 seconds per operation Total connection timeout: 5 minutes for handshake Key Management:\nPersistent storage of static key and IV Secure random generation (cryptographic RNG) Follow rotation policies strictly Never reuse ephemeral keys Monitoring and Diagnostics:\nMetrics:\nHandshake success/failure rates AEAD error rates Clock skew distribution Connection duration statistics Logging:\nLog handshake failures with reason codes Log clock skew events Log banned IPs Never log sensitive key material Testing:\nUnit tests for KDF chains Integration tests with other implementations Fuzzing for packet handling Load testing for DoS resistance Common Pitfalls Critical Errors to Avoid:\nNonce Reuse:\nNever reset nonce counter mid-session Use separate counters for each direction Terminate before reaching 2^64 - 1 Key Rotation:\nNever rotate keys while router is running Never reuse ephemeral keys across sessions Follow minimum downtime rules Timestamp Handling:\nNever accept expired timestamps Always adjust for RTT when calculating skew Round DateTime timestamps to seconds AEAD Errors:\nNever reveal error type to attacker Always use random timeout before closing Treat invalid length same as AEAD failure Padding:\nNever send padding outside negotiated bounds Always place padding block last Never multiple padding blocks per frame RouterInfo:\nAlways verify static key matches RouterInfo Never flood RouterInfos without published addresses Always validate signatures Testing Methodology Unit Tests:\nCryptographic Primitives:\nTest vectors for X25519, ChaCha20, Poly1305, SHA-256 HMAC-SHA256 test vectors SipHash-2-4 test vectors KDF Chains:\nKnown-answer tests for all three messages Verify chaining key propagation Test SipHash IV generation Message Parsing:\nValid message decoding Invalid message rejection Boundary conditions (empty, maximum size) Integration Tests:\nHandshake:\nSuccessful three-message exchange Clock skew rejection Replay attack detection Invalid key rejection Data Phase:\nI2NP message transfer RouterInfo exchange Padding handling Termination messages Interoperability:\nTest against Java I2P Test against i2pd Test IPv4 and IPv6 Test published and hidden routers Security Tests:\nNegative Tests:\nInvalid AEAD tags Replayed messages Clock skew attacks Malformed frames DoS Tests:\nConnection flooding Slowloris attacks CPU exhaustion (excessive DH) Memory exhaustion Fuzzing:\nRandom handshake messages Random data phase frames Random block types and sizes Invalid cryptographic values Migration from NTCP For Legacy NTCP Support (now removed):\nNTCP (version 1) was removed in I2P 0.9.50 (May 2021). All current implementations must support NTCP2. Historical notes:\nTransition Period (2018-2021):\n0.9.36: NTCP2 introduced (disabled by default) 0.9.37: NTCP2 enabled by default 0.9.40: NTCP deprecated 0.9.50: NTCP removed Version Detection:\n\u0026ldquo;NTCP\u0026rdquo; transportStyle indicated both versions supported \u0026ldquo;NTCP2\u0026rdquo; transportStyle indicated NTCP2 only Automatic detection via message size (287 vs 288 bytes) Current Status:\nAll routers must support NTCP2 \u0026ldquo;NTCP\u0026rdquo; transportStyle is obsolete Use \u0026ldquo;NTCP2\u0026rdquo; transportStyle exclusively Appendix A: Noise XK Pattern Standard Noise XK Pattern:\nXK(s, rs): \u0026lt;- s ... -\u0026gt; e, es \u0026lt;- e, ee -\u0026gt; s, se Interpretation:\n\u0026lt;- : Message from responder (Bob) to initiator (Alice) -\u0026gt; : Message from initiator (Alice) to responder (Bob) s : Static key (long-term identity key) rs : Remote static key (peer\u0026rsquo;s static key, known in advance) e : Ephemeral key (session-specific, generated on-demand) es : Ephemeral-Static DH (Alice ephemeral × Bob static) ee : Ephemeral-Ephemeral DH (Alice ephemeral × Bob ephemeral) se : Static-Ephemeral DH (Alice static × Bob ephemeral) Key Agreement Sequence:\nPre-message: Alice knows Bob\u0026rsquo;s static public key (from RouterInfo) Message 1: Alice sends ephemeral key, performs es DH Message 2: Bob sends ephemeral key, performs ee DH Message 3: Alice reveals static key, performs se DH Security Properties:\nAlice authenticated: Yes (by message 3) Bob authenticated: Yes (by possessing static private key) Forward secrecy: Yes (ephemeral keys destroyed) KCI resistance: Yes (authentication level 2) Appendix B: Base64 Encoding I2P Base64 Alphabet:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~ Differences from Standard Base64:\nCharacters 62-63: -~ instead of +/ Padding: Same (=) or omitted depending on context Usage in NTCP2:\nStatic key (\u0026ldquo;s\u0026rdquo;): 32 bytes → 44 characters (no padding) IV (\u0026ldquo;i\u0026rdquo;): 16 bytes → 24 characters (no padding) Encoding Example:\n# 32-byte static key (hex): # f4489e1bb0597b39ca6cbf5ad9f5f1f09043e02d96cb9aa6a63742b3462429aa # I2P Base64 encoded: # 9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo= Appendix C: Packet Capture Analysis Identifying NTCP2 Traffic:\nTCP Handshake:\nStandard TCP SYN, SYN-ACK, ACK Destination port typically 8887 or similar Message 1 (SessionRequest):\nFirst application data from Alice 80-65535 bytes (typically few hundred) Appears random (AES-encrypted ephemeral key) 287 bytes max if connecting to \u0026ldquo;NTCP\u0026rdquo; address Message 2 (SessionCreated):\nResponse from Bob 80-65535 bytes (typically few hundred) Also appears random Message 3 (SessionConfirmed):\nFrom Alice 48 bytes + variable (RouterInfo size + padding) Typically 1-4 KB Data Phase:\nVariable-length frames Length field obfuscated (appears random) Encrypted payload Padding makes size unpredictable DPI Evasion:\nNo plaintext headers No fixed patterns Length fields obfuscated Random padding breaks size-based heuristics Comparison to NTCP:\nNTCP message 1 always 288 bytes (identifiable) NTCP2 message 1 size varies (not identifiable) NTCP had recognizable patterns NTCP2 designed to resist DPI Appendix D: Version History Major Milestones:\n0.9.36 (August 23, 2018): NTCP2 introduced, disabled by default 0.9.37 (October 4, 2018): NTCP2 enabled by default 0.9.40 (May 20, 2019): NTCP deprecated 0.9.42 (August 27, 2019): Network ID field added (Proposal 147) 0.9.50 (May 17, 2021): NTCP removed, capabilities support added 2.10.0 (September 9, 2025): Latest stable release Protocol Stability:\nNo breaking changes since 0.9.50 Ongoing improvements to probing resistance Focus on performance and reliability Post-quantum cryptography in development (not enabled by default) Current Transport Status:\nNTCP2: Mandatory TCP transport SSU2: Mandatory UDP transport NTCP (v1): Removed SSU (v1): Removed ","description":"Noise-based TCP transport for router-to-router links","id":"4882afdd530d8c7e8da14bb97487aecc","section":"docs","title":"NTCP2 Transport","url":"/en/docs/specs/ntcp2/"},{"categories":null,"content":" Legacy status: This content is retained for historical reference only. It documents the tunnel system that shipped before I2P 0.6.1.10 and should not be used for modern development. Refer to the current implementation for production guidance.\nThe original tunnel subsystem also used unidirectional tunnels but differed in message layout, duplicate detection, and build strategy. Many sections below mirror the structure of the deprecated document to aid comparison.\n1. Tunnel Overview Tunnels were built as ordered sequences of peers selected by the creator. Tunnel lengths ranged from 0–7 hops, with several knobs for padding, throttling, and chaff generation. Inbound tunnels delivered messages from an untrusted gateway to the creator (endpoint); outbound tunnels pushed data away from the creator. Tunnel lifetimes were 10 minutes, after which new tunnels were constructed (often using the same peers but different tunnel IDs). 2. Operation in the Legacy Design 2.1 Message Preprocessing Gateways accumulated ≤32 KB of I2NP payload, selected padding, and produced a payload containing:\nA two-byte padding-length field and that many random bytes A sequence of {instructions, I2NP message} pairs describing delivery targets, fragmentation, and optional delays Full I2NP messages padded out to a 16-byte boundary Delivery instructions packed routing information into bit fields (delivery type, delay flags, fragmentation flags, and optional extensions). Fragmented messages carried a 4-byte message ID plus an index/last-fragment flag.\n2.2 Gateway Encryption The legacy design fixed tunnel length at eight hops for the encryption phase. Gateways layered AES-256/CBC plus checksum blocks so that each hop could verify integrity without shrinking the payload. The checksum itself was a SHA-256 derived block embedded within the message.\n2.3 Participant Behaviour Participants tracked inbound tunnel IDs, verified integrity early, and dropped duplicates before forwarding. Because padding and verification blocks were embedded, the message size remained constant regardless of hop count.\n2.4 Endpoint Processing Endpoints decrypted the layered blocks sequentially, validated checksums, and split the payload back into the encoded instructions plus I2NP messages for further delivery.\n3. Tunnel Building (Deprecated Process) Peer selection: Peers were chosen from locally maintained profiles (exploratory vs. client). The original document already emphasised mitigation of the predecessor attack by reusing ordered peer lists per tunnel pool. Request delivery: Build messages were forwarded hop-by-hop with encrypted sections for each peer. Alternative ideas such as telescopic extension, midstream rerouting, or removing checksum blocks were discussed as experiments but never adopted. Pooling: Each local destination held separate inbound and outbound pools. Settings included desired quantity, backup tunnels, length variance, throttling, and padding policies. 4. Throttling and Mixing Concepts The legacy write-up proposed several strategies that informed later releases:\nWeighted Random Early Discard (WRED) for congestion control Per-tunnel throttles based on moving averages of recent usage Optional chaff and batching controls (not fully implemented) 5. Archived Alternatives Sections of the original document explored ideas that were never deployed:\nRemoving checksum blocks to shrink per-hop processing Telescoping tunnels midstream to change peer composition Switching to bidirectional tunnels (ultimately rejected) Using shorter hashes or different padding regimens These ideas remain valuable historical context but do not reflect the modern codebase.\nReferences Original legacy document archive (pre-0.6.1.10) Tunnel Overview for current terminology Peer Profiling and Selection for modern heuristics ","description":"Archived description of the tunnel design used prior to I2P 0.6.1.10.","id":"0970f5387a965fe6857e4afbb03bdc8f","section":"docs","title":"Old Tunnel Implementation (Legacy)","url":"/en/docs/legacy/old-implementation/"},{"categories":null,"content":"I2P Network Performance: Speed, Connections and Resource Management The I2P network is fully dynamic. Each client is known to other nodes and tests locally known nodes for reachability and capacity. Only reachable and capable nodes are saved to a local NetDB. During the tunnel building process, the best resources are selected from this pool to build tunnels with. Because testing happens continuously, the pool of nodes changes. Each I2P node knows a different part of the NetDB, meaning that each router has a different set of I2P nodes to be used for tunnels. Even if two routers have the same subset of known nodes, the tests for reachability and capacity will likely show different results, as the other routers could be under load just as one router tests, but be free when the second router tests.\nThis describes why each I2P node has different nodes to build tunnels. Because every I2P node has a different latency and bandwidth, tunnels (which are built via those nodes) have different latency and bandwidth values. And because every I2P node has different tunnels built, no two I2P nodes have the same tunnel sets.\nA server/client is known as a \u0026ldquo;destination\u0026rdquo; and each destination has at least one inbound and one outbound tunnel. The default is 3 hops per tunnel. This adds up to 12 hops (12 different I2P nodes) for a full round trip client → server → client.\nEach data package is sent through 6 other I2P nodes until it reaches the server:\nclient - hop1 - hop2 - hop3 - hopa1 - hopa2 - hopa3 - server\nand on the way back 6 different I2P nodes:\nserver - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - client\nTraffic on the network needs an ACK before new data is sent; it needs to wait until an ACK returns from a server: send data, wait for ACK, send more data, wait for ACK. As the RTT (Round Trip Time) adds up from the latency of each individual I2P node and each connection on this round trip, it takes usually 1–3 seconds until an ACK comes back to the client. Because of TCP and I2P transport design, a data package has a limited size. Together these conditions set a limit max bandwidth per tunnel of roughly 20–50 kB/s. However, if only one hop in the tunnel has only 5 kB/s bandwidth to spend, the whole tunnel is limited to 5 kB/s, independent of the latency and other limitations.\nEncryption, latency, and how a tunnel is built makes it quite expensive in CPU time to build a tunnel. This is why a destination is only allowed to have a maximum of 6 inbound and 6 outbound tunnels to transport data. With a max of 50 kB/s per tunnel, a destination could use roughly 300 kB/s traffic combined (in reality it could be more if shorter tunnels are used with low or no anonymity available). Used tunnels are discarded every 10 minutes and new ones are built. This change of tunnels, and sometimes clients that shut down or lose their connection to the network, will sometimes break tunnels and connections. An example of this can be seen on the IRC2P Network in loss of connection (ping timeout) or when using eepget.\nWith a limited set of destinations and a limited set of tunnels per destination, one I2P node only uses a limited set of tunnels across other I2P nodes. For example, if an I2P node is \u0026ldquo;hop1\u0026rdquo; in the small example above, it only sees one participating tunnel originating from the client. If we sum up the whole I2P network, only a rather limited number of participating tunnels could be built with a limited amount of bandwidth all together. If one distributes these limited numbers across the number of I2P nodes, there is only a fraction of available bandwidth/capacity available for use.\nTo remain anonymous, one router should not be used by the whole network for building tunnels. If one router does act as a tunnel router for all I2P nodes, it becomes a very real central point of failure as well as a central point to gather IPs and data from clients. This is why the network distributes traffic across nodes in the tunnel building process.\nAnother consideration for performance is the way I2P handles mesh networking. Each connection hop‑to‑hop utilizes one TCP or UDP connection on I2P nodes. With 1000 connections, one sees 1000 TCP connections. That is quite a lot, and some home and small office routers only allow a small number of connections. I2P tries to limit these connections to under 1500 per UDP and per TCP type. This limits the amount of traffic routed across an I2P node as well.\nIf a node is reachable, and has a bandwidth setting of \u0026gt;128 kB/s shared and is reachable 24/7, it should be used after some time for participating traffic. If it is down in between, the testing of an I2P node done by other nodes will tell them it is not reachable. This blocks a node for at least 24 hours on other nodes. So, the other nodes which tested that node as down will not use that node for 24 hours for building tunnels. This is why your traffic is lower after a restart/shutdown of your I2P router for a minimum of 24 hours.\nAdditionally, other I2P nodes need to know an I2P router to test it for reachability and capacity. This process can be made faster when you interact with the network, for instance by using applications or visiting I2P sites, which will result in more tunnel building and therefore more activity and reachability for testing by nodes on the network.\nPerformance History (selected) Over the years, I2P has seen a number of notable performance improvements:\nNative math Implemented via JNI bindings to the GNU MP library (GMP) to accelerate BigInteger modPow, which previously dominated CPU time. Early results showed dramatic speedups in public‑key cryptography. See: /misc/jbigi/\nGarlic wrapping a \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) Previously, replies often required a network database lookup for the sender’s LeaseSet. Bundling the sender’s LeaseSet in the initial garlic improves reply latency. This is now done selectively (start of a connection or when the LeaseSet changes) to reduce overhead.\nMore efficient TCP rejection Moved some validation steps earlier in the transport handshake to reject bad peers sooner (wrong clocks, bad NAT/firewall, incompatible versions), saving CPU and bandwidth.\nTunnel testing adjustments Use context‑aware tunnel testing: avoid testing tunnels already known to be passing data; favor testing when idle. This reduces overhead and speeds detection of failing tunnels.\nPersistent tunnel/lease selection Persisting selections for a given connection reduces out‑of‑order delivery and allows the streaming library to increase window sizes, improving throughput.\nCompress selected data structures GZip or similar for verbose structures (e.g., RouterInfo options) reduces bandwidth where appropriate.\nFull streaming protocol Replacement for the simplistic “ministreaming” protocol. Modern streaming includes selective ACKs and congestion control tailored to I2P’s anonymous, message‑oriented substrate. See: /docs/api/streaming/\nFuture Performance Improvements (historical ideas) Below are ideas documented historically as potential improvements. Many are obsolete, implemented, or superseded by architectural changes.\nBetter peer profiling and selection Improve how routers choose peers for tunnel building to avoid slow or overloaded ones, while remaining resistant to Sybil attacks by powerful adversaries.\nNetwork database tuning Reduce unnecessary exploration when the keyspace is stable; tune how many peers are returned in lookups and how many concurrent searches are performed.\nSession Tag tuning and improvements (legacy) For the legacy ElGamal/AES+SessionTag scheme, smarter expiration and replenishment strategies reduce ElGamal fallbacks and wasted tags.\nMigrate SessionTag to synchronized PRNG (legacy) Generate tags from a synchronized PRNG seeded during a new session establishment, reducing per‑message overhead from pre‑delivered tags.\nLonger‑lasting tunnels Longer tunnel lifetimes coupled with healing can reduce rebuild overheads; balance with anonymity and reliability.\nEfficient transport rejection and testing Reject invalid peers earlier and make tunnel tests more context‑aware to reduce contention and latency.\nMiscellaneous protocol and implementation tuning Selective LeaseSet bundling, compressed RouterInfo options, and adoption of the full streaming protocol all contribute to better perceived performance.\nSee also:\n/docs/overview/tunnel-routing/ /docs/how/peer-selection/ /docs/transport/ /spec/ssu2/ and /spec/ntcp2/ ","description":"I2P network performance: how it behaves today, historical improvements, and ideas for future tuning","id":"eb296d22dd7b2414170601d7c73a1613","section":"docs","title":"Performance","url":"/en/docs/overview/performance/"},{"categories":null,"content":"Overview I2P plugins are signed archives that extend router functionality. They ship as .xpi2p or .su3 files, install to ~/.i2p/plugins/\u0026lt;name\u0026gt;/ (or %APPDIR%\\I2P\\plugins\\\u0026lt;name\u0026gt;\\ on Windows), and run with full router permissions without sandboxing.\nSupported Plugin Types Console webapps New eepsites with cgi-bin, webapps Console themes Console translations Java programs (in-process or separate JVM) Shell scripts and native binaries Security Model CRITICAL: Plugins run in the same JVM with identical permissions as the I2P router. They have unrestricted access to:\nFile system (read and write) Router APIs and internal state Network connections External program execution Plugins should be treated as fully trusted code. Users must verify plugin sources and signatures before installation.\nFile Formats SU3 Format (Strongly Recommended) Status: Active, preferred format since I2P 0.9.15 (September 2014)\nThe .su3 format provides:\nRSA-4096 signing keys (vs. DSA-1024 in xpi2p) Signature stored in file header Magic number: I2Psu3 Better forward compatibility Structure:\n[SU3 Header with RSA-4096 signature] [ZIP Archive] ├── plugin.config (required) ├── console/ ├── lib/ ├── webapps/ └── [other plugin files] XPI2P Format (Legacy, Deprecated) Status: Supported for backwards compatibility, not recommended for new plugins\nThe .xpi2p format uses older cryptographic signatures:\nDSA-1024 signatures (obsolete per NIST-800-57) 40-byte DSA signature prepended to ZIP Requires key field in plugin.config Structure:\n[40-byte DSA signature] [16-byte version string (UTF-8, zero-padded)] [ZIP Archive] Migration Path: When migrating from xpi2p to su3, provide both updateURL and updateURL.su3 during transition. Modern routers (0.9.15+) automatically prioritize SU3.\nArchive Layout and plugin.config Required Files plugin.config - Standard I2P configuration file with key-value pairs\nRequired Properties Property Description Format nameInstallation directory name, must match for updatesAlphanumeric, no spaces signerDeveloper contact informationuser@mail.i2p format recommended versionPlugin version for update comparisonMax 16 bytes, parsed by VersionComparator keyDSA public key (172 B64 chars ending with '=')Omit for SU3 format Version Format Examples:\n1.2.3 1.2.3-4 2.0.0-beta.1 Valid separators: . (dot), - (dash), _ (underscore)\nOptional Metadata Properties Display Information date - Release date (Java long timestamp) author - Developer name (user@mail.i2p recommended) description - English description description_xx - Localized description (xx = language code) websiteURL - Plugin homepage (http://foo.i2p/) license - License identifier (e.g., \u0026ldquo;Apache-2.0\u0026rdquo;, \u0026ldquo;GPL-3.0\u0026rdquo;) Update Configuration updateURL - XPI2P update location (legacy) updateURL.su3 - SU3 update location (preferred) min-i2p-version - Minimum I2P version required max-i2p-version - Maximum compatible I2P version min-java-version - Minimum Java version (e.g., 1.7, 17) min-jetty-version - Minimum Jetty version (use 6 for Jetty 6+) max-jetty-version - Maximum Jetty version (use 5.99999 for Jetty 5) Installation Behavior dont-start-at-install - Default false. If true, requires manual start router-restart-required - Default false. Informs user restart needed after update update-only - Default false. Fails if plugin not already installed install-only - Default false. Fails if plugin already exists min-installed-version - Minimum version required for update max-installed-version - Maximum version that can be updated disableStop - Default false. Hides stop button if true Console Integration consoleLinkName - Text for console summary bar link consoleLinkName_xx - Localized link text (xx = language code) consoleLinkURL - Link destination (e.g., /appname/index.jsp) consoleLinkTooltip - Hover text (supported since 0.7.12-6) consoleLinkTooltip_xx - Localized tooltip console-icon - Path to 32x32 icon (supported since 0.9.20) icon-code - Base64-encoded 32x32 PNG for plugins without web resources (since 0.9.25) Platform Requirements (Display Only) required-platform-OS - Operating system requirement (not enforced) other-requirements - Additional requirements (e.g., \u0026ldquo;Python 3.8+\u0026rdquo;) Dependency Management (Unimplemented) depends - Comma-separated plugin dependencies depends-version - Version requirements for dependencies langs - Language pack contents type - Plugin type (app/theme/locale/webapp) Update URL Variable Substitution Feature Status: Available since I2P 1.7.0 (0.9.53)\nBoth updateURL and updateURL.su3 support platform-specific variables:\nVariables:\n$OS - Operating system: windows, linux, mac $ARCH - Architecture: 386, amd64, arm64 Example:\nupdateURL.su3=http://foo.i2p/downloads/foo-$OS-$ARCH.su3 Result on Windows AMD64:\nhttp://foo.i2p/downloads/foo-windows-amd64.su3 This enables single plugin.config files for platform-specific builds.\nDirectory Structure Standard Layout plugins/ └── pluginname/ ├── plugin.config (required) ├── console/ │ ├── locale/ # Translation JARs │ ├── themes/ # Console themes │ ├── webapps/ # Web applications │ └── webapps.config # Webapp configuration ├── eepsite/ │ ├── cgi-bin/ │ ├── docroot/ │ ├── logs/ │ ├── webapps/ │ └── jetty.xml ├── lib/ │ └── *.jar # Plugin libraries └── clients.config # Client startup configuration Directory Purposes console/locale/\nJAR files with resource bundles for I2P base translations Plugin-specific translations should be in console/webapps/*.war or lib/*.jar console/themes/\nEach subdirectory contains a complete console theme Automatically added to theme search path console/webapps/\n.war files for console integration Started automatically unless disabled in webapps.config War name does not need to match plugin name eepsite/\nComplete eepsite with own Jetty instance Requires jetty.xml configuration with variable substitution See zzzot and pebble plugin examples lib/\nPlugin JAR libraries Specify in classpath via clients.config or webapps.config Webapp Configuration webapps.config Format Standard I2P configuration file controlling webapp behavior.\nSyntax:\n# Disable autostart webapps.warname.startOnLoad=false # Add classpath JARs (as of API 0.9.53, works for any warname) webapps.warname.classpath=$PLUGIN/lib/foo.jar,$I2P/lib/bar.jar Important Notes:\nPrior to router 0.7.12-9, use plugin.warname.startOnLoad for compatibility Prior to API 0.9.53, classpath only worked if warname matched plugin name As of 0.9.53+, classpath works for any webapp name Webapp Best Practices ServletContextListener Implementation\nImplement javax.servlet.ServletContextListener for cleanup Or override destroy() in servlet Ensures proper shutdown during updates and router stop Library Management\nPlace shared JARs in lib/, not inside WAR Reference via webapps.config classpath Enables separate install/update plugins Avoid Conflicting Libraries\nNever bundle Jetty, Tomcat, or servlet JARs Never bundle JARs from standard I2P installation Check classpath section for standard libraries Compilation Requirements\nDo not include .java or .jsp source files Pre-compile all JSPs to avoid startup delays Cannot assume Java/JSP compiler availability Servlet API Compatibility\nI2P supports Servlet 3.0 (since 0.9.30) Annotation scanning NOT supported (@WebContent) Must provide traditional web.xml deployment descriptor Jetty Version\nCurrent: Jetty 9 (I2P 0.9.30+) Use net.i2p.jetty.JettyStart for abstraction Protects against Jetty API changes Client Configuration clients.config Format Defines clients (services) started with plugin.\nBasic Client:\nclientApp.0.main=com.example.PluginMain clientApp.0.name=Example Plugin Service clientApp.0.delay=30 clientApp.0.args=arg1 arg2 $PLUGIN/config.properties Client with Stop/Uninstall:\nclientApp.0.stopargs=stop clientApp.0.uninstallargs=uninstall clientApp.0.classpath=$PLUGIN/lib/plugin.jar,$I2P/lib/i2p.jar Property Reference Property Description mainFully qualified class name implementing ClientApp interface nameDisplay name for user interface delayStartup delay in seconds (default: 0) argsSpace-separated arguments passed to constructor stopargsArguments for shutdown (must handle gracefully) uninstallargsArguments called before plugin deletion classpathComma-separated JAR paths Variable Substitution The following variables are replaced in args, stopargs, uninstallargs, and classpath:\nVariable Replacement $I2PI2P base installation directory $CONFIGI2P configuration directory (typically ~/.i2p) $PLUGINThis plugin's directory ($CONFIG/plugins/name) $OSOperating system: windows, linux, mac $ARCHArchitecture: 386, amd64, arm64 Managed vs. Unmanaged Clients Managed Clients (Recommended, since 0.9.4):\nInstantiated by ClientAppManager Maintains reference and state tracking Easier lifecycle management Better memory management Unmanaged Clients:\nStarted by router, no state tracking Must handle multiple start/stop calls gracefully Use static state or PID files for coordination Called at router shutdown (as of 0.7.12-3) ShellService (since 0.9.53 / 1.7.0) Generalized solution for running external programs with automatic state tracking.\nFeatures:\nHandles process lifecycle Communicates with ClientAppManager Automatic PID management Cross-platform support Usage:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myservice.sh For platform-specific scripts:\nclientApp.0.args=$PLUGIN/bin/myservice-$OS.$ARCH Alternative (Legacy): Write Java wrapper checking OS type, call ShellCommand with appropriate .bat or .sh file.\nInstallation Process User Installation Flow User pastes plugin URL into Router Console Plugin Configuration Page (/configplugins) Router downloads plugin file Signature verification (fails if key unknown and strict mode enabled) ZIP integrity check Extract and parse plugin.config Version compatibility verification (min-i2p-version, min-java-version, etc.) Webapp name conflict detection Stop existing plugin if update Directory validation (must be under plugins/) Extract all files to plugin directory Update plugins.config Start plugin (unless dont-start-at-install=true) Security and Trust Key Management:\nFirst-key-seen trust model for new signers Only jrandom and zzz keys pre-bundled As of 0.9.14.1, unknown keys rejected by default Advanced property can override for development Installation Restrictions:\nArchives must unpack to plugin directory only Installer refuses paths outside plugins/ Plugins can access files elsewhere after installation No sandboxing or privilege isolation Update Mechanism Update Check Process Router reads updateURL.su3 (preferred) or updateURL from plugin.config HTTP HEAD or partial GET request to fetch bytes 41-56 Extract version string from remote file Compare with installed version using VersionComparator If newer, prompt user or auto-download (based on settings) Stop plugin Install update Start plugin (unless user preference changed) Version Comparison Versions parsed as dot/dash/underscore-separated components:\n1.2.3 \u0026lt; 1.2.4 1.2.3 \u0026lt; 1.2.3-1 2.0.0 \u0026gt; 1.9.9 Maximum length: 16 bytes (must match SUD/SU3 header)\nUpdate Best Practices Always increment version for releases Test update path from previous version Consider router-restart-required for major changes Provide both updateURL and updateURL.su3 during migration Use build number suffix for testing (1.2.3-456) Classpath and Standard Libraries Always Available in Classpath The following JARs from $I2P/lib are always in classpath for I2P 0.9.30+:\nJAR Contents Plugin Usage i2p.jar Core API Required for all plugins mstreaming.jar Streaming API Most plugins need streaming.jar Streaming implementation Most plugins need i2ptunnel.jar I2PTunnel HTTP/server plugins router.jar Router internals Rarely needed, avoid if possible javax.servlet.jar Servlet 3.1, JSP 2.3 API Plugins with servlets/JSPs jasper-runtime.jar Jasper compiler/runtime Plugins with JSPs commons-el.jar EL 3.0 API JSPs using expression language jetty-i2p.jar Jetty utilities Plugins starting Jetty org.mortbay.jetty.jar Jetty 9 base Custom Jetty instances sam.jar SAM API Rarely needed addressbook.jar Subscription/blockfile Use NamingService instead routerconsole.jar Console libraries Not public API, avoid jbigi.jar Native crypto Plugins should not need systray.jar URL launcher Rarely needed wrapper.jar Service wrapper Plugins should not need Special Notes commons-logging.jar:\nEmpty since 0.9.30 Prior to 0.9.30: Apache Tomcat JULI Prior to 0.9.24: Commons Logging + JULI Prior to 0.9: Commons Logging only jasper-compiler.jar:\nEmpty since Jetty 6 (0.9) systray4j.jar:\nRemoved in 0.9.26 Not in Classpath (Must Specify) JAR Contents Usage jstl.jar Standard Taglib JSP tag libraries standard.jar Standard Taglib JSP tag libraries Classpath Specification In clients.config:\nclientApp.0.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/i2p.jar In webapps.config:\nwebapps.mywebapp.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/jstl.jar Important: As of 0.7.13-3, classpaths are thread-specific, not JVM-wide. Specify complete classpath for each client.\nJava Version Requirements Current Requirements (October 2025) I2P 2.10.0 and earlier:\nMinimum: Java 7 (required since 0.9.24, January 2016) Recommended: Java 8 or higher I2P 2.11.0 and later (UPCOMING):\nMinimum: Java 17+ (announced in 2.9.0 release notes) Two-release warning given (2.9.0 → 2.10.0 → 2.11.0) Plugin Compatibility Strategy For maximum compatibility (through I2P 2.10.x):\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; /\u0026gt; min-java-version=1.7 For Java 8+ features:\n\u0026lt;javac source=\u0026#34;1.8\u0026#34; target=\u0026#34;1.8\u0026#34; /\u0026gt; min-java-version=1.8 For Java 11+ features:\n\u0026lt;javac source=\u0026#34;11\u0026#34; target=\u0026#34;11\u0026#34; /\u0026gt; min-java-version=11 Preparing for 2.11.0+:\n\u0026lt;javac source=\u0026#34;17\u0026#34; target=\u0026#34;17\u0026#34; /\u0026gt; min-java-version=17 min-i2p-version=2.11.0 Compilation Best Practices When compiling with newer JDK for older target:\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; bootclasspath=\u0026#34;${java7.home}/jre/lib/rt.jar\u0026#34; includeantruntime=\u0026#34;false\u0026#34; /\u0026gt; This prevents using APIs not available in target Java version.\nPack200 Compression - OBSOLETE Critical Update: Do Not Use Pack200 Status: DEPRECATED AND REMOVED\nThe original specification strongly recommended Pack200 compression for 60-65% size reduction. This is no longer valid.\nTimeline:\nJEP 336: Pack200 deprecated in Java 11 (September 2018) JEP 367: Pack200 removed in Java 14 (March 2020) Official I2P Updates Specification states:\n\u0026ldquo;Jar and war files in the zip are no longer compressed with pack200 as documented above for \u0026lsquo;su2\u0026rsquo; files, because recent Java runtimes no longer support it.\u0026rdquo;\nWhat to Do:\nRemove pack200 from build processes immediately Use standard ZIP compression Consider alternatives: ProGuard/R8 for code shrinking UPX for native binaries Modern compression algorithms (zstd, brotli) if custom unpacker provided For Existing Plugins:\nOld routers (0.7.11-5 through Java 10) can still unpack pack200 New routers (Java 11+) cannot unpack pack200 Re-release plugins without pack200 compression Signing Keys and Security Key Generation (SU3 Format) Use makeplugin.sh script from i2p.scripts repository:\n# Generate new signing key ./makeplugin.sh keygen # Keys stored in ~/.i2p-plugin-keys/ Key Details:\nAlgorithm: RSA_SHA512_4096 Format: X.509 certificate Storage: Java keystore format Signing Plugins # Create signed su3 file ./makeplugin.sh sign myplugin.zip myplugin.su3 keyname # Verify signature ./makeplugin.sh verify myplugin.su3 Key Management Best Practices Generate once, safeguard forever\nRouters reject duplicate keynames with different keys Routers reject duplicate keys with different keynames Updates rejected if key/name mismatch Secure storage\nBackup keystore securely Use strong passphrase Never commit to version control Key rotation\nNot supported by current architecture Plan for long-term key usage Consider multi-signature schemes for team development Legacy DSA Signing (XPI2P) Status: Functional but obsolete\nDSA-1024 signatures used by xpi2p format:\n40-byte signature 172 base64 character public key NIST-800-57 recommends (L=2048, N=224) minimum I2P uses weaker (L=1024, N=160) Recommendation: Use SU3 with RSA-4096 instead.\nPlugin Development Guidelines Essential Best Practices Documentation\nProvide clear README with installation instructions Document configuration options and defaults Include changelog with each release Specify required I2P/Java versions Size Optimization\nInclude only necessary files Never bundle router JARs Separate install vs. update packages (libraries in lib/) Use Pack200 compression OBSOLETE - Use standard ZIP Configuration\nNever modify plugin.config at runtime Use separate config file for runtime settings Document required router settings (SAM ports, tunnels, etc.) Respect user\u0026rsquo;s existing configuration Resource Usage\nAvoid aggressive default bandwidth consumption Implement reasonable CPU usage limits Clean up resources on shutdown Use daemon threads where appropriate Testing\nTest install/upgrade/uninstall on all platforms Test updates from previous version Verify webapp stop/restart during updates Test with minimum supported I2P version File System\nNever write to $I2P (may be read-only) Write runtime data to $PLUGIN or $CONFIG Use I2PAppContext for directory discovery Do not assume $CWD location Compatibility\nDo not duplicate standard I2P classes Extend classes if necessary, don\u0026rsquo;t replace Check min-i2p-version, min-jetty-version in plugin.config Test with older I2P versions if supporting them Shutdown Handling\nImplement proper stopargs in clients.config Register shutdown hooks: I2PAppContext.addShutdownTask() Handle multiple start/stop calls gracefully Set all threads to daemon mode Security\nValidate all external input Never call System.exit() Respect user privacy Follow secure coding practices Licensing\nClearly specify plugin license Respect licenses of bundled libraries Include required attribution Provide source code access if required Advanced Considerations Timezone Handling:\nRouter sets JVM timezone to UTC User\u0026rsquo;s actual timezone: I2PAppContext property i2p.systemTimeZone Directory Discovery:\n// Plugin directory String pluginDir = I2PAppContext.getGlobalContext() .getAppDir().getAbsolutePath() + \u0026#34;/plugins/\u0026#34; + pluginName; // Or use $PLUGIN variable in clients.config args Version Numbering:\nUse semantic versioning (major.minor.patch) Add build number for testing (1.2.3-456) Ensure monotonic increase for updates Router Class Access:\nGenerally avoid router.jar dependencies Use public APIs in i2p.jar instead Future I2P may restrict router class access JVM Crash Prevention (Historical):\nFixed in 0.7.13-3 Use class loaders properly Avoid updating JARs in running plugin Design for restart-on-update if necessary Eepsite Plugins Overview Plugins can provide complete eepsites with own Jetty and I2PTunnel instances.\nArchitecture Do not attempt to:\nInstall into existing eepsite Merge with router\u0026rsquo;s default eepsite Assume single eepsite availability Instead:\nStart new I2PTunnel instance (via CLI approach) Start new Jetty instance Configure both in clients.config Example Structure plugins/myeepsite/ ├── plugin.config ├── clients.config # Starts Jetty + I2PTunnel ├── eepsite/ │ ├── jetty.xml # Requires variable substitution │ ├── docroot/ │ ├── webapps/ │ └── logs/ └── lib/ └── [dependencies] Variable Substitution in jetty.xml Use $PLUGIN variable for paths:\n\u0026lt;Set name=\u0026#34;resourceBase\u0026#34;\u0026gt;$PLUGIN/eepsite/docroot\u0026lt;/Set\u0026gt; Router performs substitution during plugin start.\nExamples Reference implementations:\nzzzot plugin - Torrent tracker pebble plugin - Blog platform Both available at zzz\u0026rsquo;s plugin page (I2P-internal).\nConsole Integration Summary Bar Links Add clickable link to router console summary bar:\nconsoleLinkName=My Plugin consoleLinkURL=/myplugin/ consoleLinkTooltip=Open My Plugin Interface Localized versions:\nconsoleLinkName_de=Mein Plugin consoleLinkTooltip_de=Öffne Mein Plugin Schnittstelle Console Icons Image File (since 0.9.20):\nconsole-icon=/myicon.png Path relative to consoleLinkURL if specified (since 0.9.53), otherwise relative to webapp name.\nEmbedded Icon (since 0.9.25):\nicon-code=iVBORw0KGgoAAAANSUhEUgAAA...Base64EncodedPNG... Generate with:\nbase64 -w 0 icon-32x32.png Or Java:\njava -cp i2p.jar net.i2p.data.Base64 encode icon.png Requirements:\n32x32 pixels PNG format Base64 encoded (no line breaks) Internationalization Translation Bundles For I2P Base Translations:\nPlace JARs in console/locale/ Contain resource bundles for existing I2P apps Naming: messages_xx.properties (xx = language code) For Plugin-Specific Translations:\nInclude in console/webapps/*.war Or include in lib/*.jar Use standard Java ResourceBundle approach Localized Strings in plugin.config description=My awesome plugin description_de=Mein tolles Plugin description_fr=Mon plugin génial description_es=Mi plugin increíble Supported fields:\ndescription_xx consoleLinkName_xx consoleLinkTooltip_xx Console Theme Translation Themes in console/themes/ automatically added to theme search path.\nPlatform-Specific Plugins Separate Packages Approach Use different plugin names for each platform:\n# Windows package name=myplugin-windows # Linux package name=myplugin-linux # macOS package name=myplugin-mac Variable Substitution Approach Single plugin.config with platform variables:\nname=myplugin updateURL.su3=http://myplugin.i2p/downloads/myplugin-$OS-$ARCH.su3 In clients.config:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myapp-$OS-$ARCH Runtime OS Detection Java approach for conditional execution:\nString os = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (os.contains(\u0026#34;win\u0026#34;)) { // Windows-specific code } else if (os.contains(\u0026#34;nix\u0026#34;) || os.contains(\u0026#34;nux\u0026#34;)) { // Linux-specific code } else if (os.contains(\u0026#34;mac\u0026#34;)) { // macOS-specific code } Troubleshooting Common Issues Plugin Won\u0026rsquo;t Start:\nCheck I2P version compatibility (min-i2p-version) Verify Java version (min-java-version) Check router logs for errors Verify all required JARs in classpath Webapp Not Accessible:\nConfirm webapps.config doesn\u0026rsquo;t disable it Check Jetty version compatibility (min-jetty-version) Verify web.xml present (annotation scanning not supported) Check for conflicting webapp names Update Fails:\nVerify version string increased Check signature matches signing key Ensure plugin name matches installed version Review update-only/install-only settings External Program Won\u0026rsquo;t Stop:\nUse ShellService for automatic lifecycle Implement proper stopargs handling Check PID file cleanup Verify process termination Debug Logging Enable debug logging in router:\nlogger.record.net.i2p.router.web.ConfigPluginsHandler=DEBUG Check logs:\n~/.i2p/logs/log-router-0.txt Reference Information Official Specifications Plugin Specification: /docs/specs/plugin/ Configuration Format: /docs/specs/configuration/ Update Specification: /docs/specs/updates/ Cryptography: /docs/specs/cryptography/ I2P Version History Current Release:\nI2P 2.10.0 (September 8, 2025) Major Releases Since 0.9.53:\n2.10.0 (Sep 2025) - Java 17+ announcement 2.9.0 (Jun 2025) - Java 17+ warning 2.8.0 (Oct 2024) - Post-quantum crypto testing 2.6.0 (May 2024) - I2P-over-Tor blocking 2.4.0 (Dec 2023) - NetDB security improvements 2.2.0 (Mar 2023) - Congestion control 2.1.0 (Jan 2023) - Network improvements 2.0.0 (Nov 2022) - SSU2 transport protocol 1.7.0/0.9.53 (Feb 2022) - ShellService, variable substitution 0.9.15 (Sep 2014) - SU3 format introduced Version Numbering:\n0.9.x series: Through version 0.9.53 2.x series: Starting with 2.0.0 (SSU2 introduction) Developer Resources Source Code:\nMain repository: https://i2pgit.org/I2P_Developers/i2p.i2p GitHub mirror: https://github.com/i2p/i2p.i2p Plugin Examples:\nzzzot (BitTorrent tracker) pebble (Blog platform) i2p-bote (Serverless email) orchid (Tor client) seedless (Peer exchange) Build Tools:\nmakeplugin.sh - Key generation and signing Found in i2p.scripts repository Automates su3 creation and verification Community Support Forums:\nI2P Forum: https://i2pforum.net/ zzz.i2p: http://zzz.i2p/ (I2P-internal) IRC/Chat:\n#i2p-dev on OFTC I2P IRC within network Mailing Lists:\ni2p-dev@i2p2.de Appendix A: Complete plugin.config Example # Required fields name=example-plugin signer=developer@mail.i2p version=1.2.3 # Update configuration updateURL.su3=http://example.i2p/plugins/example-$OS-$ARCH.su3 min-i2p-version=2.0.0 min-java-version=17 # Display information date=1698796800000 author=Example Developer \u0026lt;developer@mail.i2p\u0026gt; websiteURL=http://example.i2p/ license=Apache-2.0 description=An example I2P plugin demonstrating best practices description_de=Ein Beispiel-I2P-Plugin zur Demonstration bewährter Praktiken description_es=Un plugin I2P de ejemplo que demuestra las mejores prácticas # Console integration consoleLinkName=Example Plugin consoleLinkName_de=Beispiel-Plugin consoleLinkURL=/example/ consoleLinkTooltip=Open the Example Plugin control panel consoleLinkTooltip_de=Öffne das Beispiel-Plugin-Kontrollfeld console-icon=/icon.png # Installation behavior dont-start-at-install=false router-restart-required=false # Platform requirements (informational) required-platform-OS=All platforms supported other-requirements=Requires 512MB free disk space Appendix B: Complete clients.config Example # Main service client (managed) clientApp.0.main=com.example.plugin.MainService clientApp.0.name=Example Plugin Main Service clientApp.0.delay=30 clientApp.0.args=$PLUGIN/config.properties --port=7656 clientApp.0.stopargs=shutdown clientApp.0.uninstallargs=cleanup clientApp.0.classpath=$PLUGIN/lib/example.jar,$I2P/lib/i2p.jar,$I2P/lib/mstreaming.jar # External program via ShellService clientApp.1.main=net.i2p.apps.ShellService clientApp.1.name=Example Native Helper clientApp.1.delay=35 clientApp.1.args=$PLUGIN/bin/helper-$OS-$ARCH --config $PLUGIN/helper.conf clientApp.1.classpath=$I2P/lib/i2p.jar # Jetty eepsite clientApp.2.main=net.i2p.jetty.JettyStart clientApp.2.name=Example Eepsite clientApp.2.delay=40 clientApp.2.args=$PLUGIN/eepsite/jetty.xml clientApp.2.stopargs=$PLUGIN/eepsite/jetty.xml stop clientApp.2.classpath=$PLUGIN/lib/example-web.jar,$I2P/lib/i2p.jar # I2PTunnel for eepsite clientApp.3.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.3.name=Example Eepsite Tunnel clientApp.3.delay=45 clientApp.3.args=$PLUGIN/eepsite/i2ptunnel.config Appendix C: Complete webapps.config Example # Disable autostart for admin webapp webapps.example-admin.startOnLoad=false # Main webapp with classpath webapps.example.startOnLoad=true webapps.example.classpath=$PLUGIN/lib/example-core.jar,$PLUGIN/lib/commons-utils.jar,$I2P/lib/jstl.jar,$I2P/lib/standard.jar # Legacy support (pre-0.7.12-9) plugin.example.startOnLoad=true Appendix D: Migration Checklist (0.9.53 to 2.10.0) Required Changes Remove Pack200 compression from build process\nRemove pack200 tasks from Ant/Maven/Gradle scripts Re-release existing plugins without pack200 Review Java version requirements\nConsider requiring Java 11+ for new features Plan for Java 17+ requirement in I2P 2.11.0 Update min-java-version in plugin.config Update documentation\nRemove Pack200 references Update Java version requirements Update I2P version references (0.9.x → 2.x) Recommended Changes Strengthen cryptographic signatures\nMigrate from XPI2P to SU3 if not already done Use RSA-4096 keys for new plugins Leverage new features (if using 0.9.53+)\nUse $OS / $ARCH variables for platform-specific updates Use ShellService for external programs Use improved webapp classpath (works for any warname) Test compatibility\nTest on I2P 2.10.0 Verify with Java 8, 11, 17 Check on Windows, Linux, macOS Optional Enhancements Implement proper ServletContextListener Add localized descriptions Provide console icon Improve shutdown handling Add comprehensive logging Write automated tests Document Changelog Version 2.0 (October 2025):\nVerified all content against I2P 2.10.0 Added critical Pack200 deprecation warning Updated Java version requirements with 2.11.0 timeline Clarified DSA signature obsolescence Updated I2P version numbering (0.9.x → 2.x series) Confirmed all existing mechanisms remain valid Added troubleshooting section Expanded examples and best practices Verified all URLs and references Version 1.0 (January 2022):\nOriginal specification for I2P 0.9.53 Documented ShellService feature Documented variable substitution in update URLs Comprehensive coverage of plugin system ","description":".xpi2p / .su3 packaging rules for I2P plugins","id":"b25aafc3542216f9bbc2f124d1943fbc","section":"docs","title":"Plugin Package Format","url":"/en/docs/specs/plugin/"},{"categories":null,"content":" Status: Updated through I2P 2.10.0 (October 2025). This list consolidates all active, deprecated, and reserved ports used by the I2P Java Router, i2pd, and related plugins. All ports are listed in numeric order for consistency.\nPort Service / Component Description Notes 123SNTPNetwork time synchronizationUses external NTP servers; required for accurate LeaseSet timestamps. 2827BOB interfaceLegacy client API bridgeDeprecated; disabled by default. 4444HTTP ProxyStandard web proxy for eepsite browsingDefault for both HTTP and HTTPS browser traffic. 4445HTTPS ProxyDedicated SSL/TLS proxyOptional; often redundant with 4444. 6667–6669IRC ProxyAccess to I2P IRC networksDefault = 6668; alternate ports avoid conflicts. 7650I2PControl PluginJSON‑RPC management APIAuth required; default password itoopie. 7652UPnP HTTP eventsUPnP control interfaceSupports automatic port forwarding. 7653UPnP SSDP responsesUPnP discoveryUDP response listener for device search. 7654I2CPCore application APIUsed by Java apps and i2pd for router integration. 7655SAM DatagramUDP bridge for SAM APISAM v3 support for real‑time apps. 7656SAM StreamTCP bridge for SAM APIPrimary non‑Java application interface. 7657Router Console (HTTP)Web admin interfaceLoopback‑only by default (127.0.0.1). 7658EepsiteDefault web server for I2PTunnelUsed for locally hosted services. 7659SMTP ProxyOutgoing mail via I2P‑BoteBridges standard email clients. 7660POP3 ProxyIncoming mail via I2P‑BoteServerless email retrieval. 7661I2PBote SMTP / Pebble BlogPlugin dual‑use portRarely conflicts since plugins don’t co‑install. 7662I2PBote IMAP / Zzzot TrackerPlugin dual‑use portUsed by Zzzot for BitTorrent tracking. 7663—Reserved for future pluginsUnused as of 2.10.0. 7664JAMWiki PluginWiki platform for I2P sitesOptional plugin. 7667Router Console (HTTPS)Secure web admin interfaceSelf‑signed cert by default. 7672Railroad PluginPlugin port reservationLast documented plugin port in series. 7644Browser Mode ProxyHTTP proxy for I2P Browser BundleUsed when running Browser mode alongside router. 7647Browser Mode ConsoleRouter console for I2P Browser BundleAvoids conflict with 7657. 8002I2PSnark Web UI (HTTP)BitTorrent client UIIntegrated in router console. 8003I2PSnark Web UI (HTTPS)BitTorrent client UI (SSL)Optional secure mode. 8887Router Network Port (Legacy)Old default for peer connectionsReplaced by randomized 9151–30777 range. 8118Privoxy (Reserved)External web proxy integrationNot part of core I2P; reserved for compatibility. 8123Polipo (Reserved)Alternate proxy integrationLegacy Tor proxy compatibility. 8888Freenet (Reserved)Anonymous network portPrevents conflicts on privacy nodes. 9050–9053Tor SOCKS (Reserved)Tor proxy range for co‑installationAvoids conflicts with I2P. 9150–9153Tor Browser SOCKS (Reserved)Tor Browser integrationReserved for cross‑tool coexistence. 9151–30777Router Network Port (Random)Active TCP/UDP transport portRandomized per install for anti‑fingerprinting. 1488 / 1776XD BitTorrent ClientStandalone I2P torrent clientAlternate to I2PSnark. 31000–32000Java Service WrapperRouter process managementHandles service control and restart. 3456 / 3458 / 3459Tahoe‑LAFS PluginDecentralized file storageOptional third‑party plugin. 4691 / 8997–8999Monotone Version ControlDistributed VCS supportHistorical usage for developer tools. 7070i2pd ConsoleWeb console for C++ implementationEquivalent to Java router console. 767xPlugin Range (General)Recommended port block for pluginsDevelopers start from 7672 upward. 11371SKS/GPG Key Server (Reserved)Key distribution serviceUsed for PGP/GPG over I2P. Implementation Notes All ports below 9000 (except 8887) bind to 127.0.0.1 by default for security. The router network port (9151–30777) must be open to the internet for full participation. i2pd uses mostly the same assignments for compatibility (7070 console, 7654 I2CP, 7656/7655 SAM). Plugin developers should coordinate new assignments through the I2P community to avoid conflicts. ","description":"Comprehensive reference of I2P port assignments, plugin ports, and reserved ranges.","id":"69ea4623f7bc59ab65ef7ea636966780","section":"docs","title":"Port Assignments","url":"/en/docs/overview/ports/"},{"categories":null,"content":"Overview This document specifies a re-randomizable signature scheme suitable for creating Destinations that can be blinded. It additionally can be used to blind existing Ed25519 Destinations, with a slight reduction in efficacy.\nRed25519 has been fully operational in I2P routers since version 0.9.39 (released March 21, 2019). This specification was finalized in version 0.9.47 (August 2020) after 17 months of production deployment. The signature scheme operates as signature type 11 (RedDSA_SHA512_Ed25519) in the I2P network.\nMotivation Proposal 123 (New netDB Entries) defines an encrypted LeaseSet2 format that embodies the Principle of Least Authority: each network participant is given only the information necessary for their role. In particular, an encrypted LeaseSet2 published to a floodfill does not reveal the Destination it is for, and the Leases can only be viewed by someone with prior knowledge of the Destination. However, floodfills still need to be able to authenticate the encrypted LeaseSet2s when they are published, and clients need to additionally ensure that the authentication was enforced by the Destination itself.\nProposal 123 achieves this by blinding the signing keys of Destinations. The blinded keys can be used to create signatures that are verifiable by floodfills, and clients can be certain that only the Destination could have created the signatures. It is therefore necessary to specify a signature scheme that can be used for blinding.\nNote on Proposal 123 Status: Portions of Proposal 123 have been implemented and deployed progressively since version 0.9.38, with Red25519 support added in 0.9.39. Encrypted LeaseSet2 functionality is production-ready and actively used in the I2P network for privacy-enhanced hidden services.\nDesign Core signature scheme The signature scheme specified here, Red25519, is an instantiation of RedDSA as defined in Section 5.4.6 of the Zcash Protocol Specification (Sapling and later). RedDSA is a Schnorr-based signature scheme that supports key re-randomization. It has the following functions:\nGENERATE_PRIVATE() Returns a uniformly-random private key. DERIVE_PUBLIC(sk) Returns the public key corresponding to the given private key. GENERATE_RANDOM() Returns a random scalar suitable for re-randomizing a keypair. RANDOMIZE_PRIVATE(sk, alpha) Re-randomizes a private key, using a secret scalar alpha. RANDOMIZE_PUBLIC(vk, alpha) Re-randomizes a public key, using a secret scalar alpha. SIGN(sk, m) Returns a signature by the private key sk over the given message m. VERIFY(vk, m, sig) Verifies the signature sig against the public key vk and message m. Returns true if the signature is valid, false otherwise. For a given keypair (sk, vk) the following relationship holds:\nRANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha)) Converting Ed25519 keys to Red25519 Ed25519 keys MAY be transiently one-way converted to Red25519 keys, in order to support re-randomization of existing Ed25519 Destinations. Other sigtypes are not compatible.\nWe define the following conversion functions:\nCONVERT_ED25519_PRIVATE(privkey) Returns the Red25519 private key corresponding to the given Ed25519 private key. CONVERT_ED25519_PUBLIC(pubkey) Returns the Red25519 public key corresponding to the given Ed25519 public key. For a given Ed25519 keypair (privkey, pubkey) the following relationship holds:\nCONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey)) Specification Definitions B The Ed25519 basepoint as in [RFC-8032]. L The Ed25519 order 2^252 + 27742317777372353535851937790883648493 as in [RFC-8032]. [s] B Fixed-base scalar multiplication of the basepoint by s. [s] A Variable-base scalar multiplication of A by s. x || y Concatenate two byte arrays x and y. Red25519 The scheme Red25519 specializes RedDSA with:\nG := the group of points on the Edwards form of Curve25519. In particular, this means that Red25519 uses the prime-order subgroup of order L, and the cofactor h_G is 8. P_G := the Ed25519 basepoint B. l_H := 512 H(x) := SHA-512(\u0026ldquo;I2P_Red25519H(x)\u0026rdquo; || x) Note on Hash Function Choice: Red25519 uses SHA-512 instead of BLAKE2b-512 (as used in Zcash RedDSA). This design choice is compensated by the length-prefixing protection described below. I2P Proposal 148 suggests future migration to BLAKE2b-512 for enhanced protection against Duplicate Message Identification (DMI) and Length Extension Attacks (LEA), plus improved performance.\nRedDSA assumes that H(x) is instantiated with a cryptographic hash function that is secure against length extension attacks. SHA-512 does not satisfy this on its own. To remedy this, we require that messages are prefixed with a prefix-free encoding of their length:\nlen_u16(M) || M where len_u16(M) is the 2-byte representation of the length of M, in little-endian (to be consistent with the little-endian encoding of scalars and points).\nMessages must be no longer than 65534 bytes. A length of 65535 is reserved for possible future extensions.\nSecurity Note: The inclusion of the public key (vk) in the hash function, combined with 80 random bytes in signing, ensures protection against SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack) vulnerabilities discovered in early RedDSA designs. This implementation incorporates the security fixes from the NCC Group Zcash audit (Finding NCC-Zcash2018-009).\nEncoding and decoding Red25519 private keys are scalars mod L, encoded in little-endian representation. We define the functions DECODE_SCALAR and ENCODE_SCALAR for swapping between the byte array and integer forms of a scalar.\nRed25519 public keys are points on the Edwards form of Curve25519. They are encoded as the 255-bit little-endian representation of the y-coordinate, followed by a single bit indicating the sign of the x-coordinate. This is the same encoding as for Ed25519. We define the functions DECODE_POINT and ENCODE_POINT for swapping between the byte array and coordinate forms of a point.\nRedDSA functions For ease of implementation, we explicitly write out below the RedDSA functions (as well as several helper functions) already specialized for Red25519. Implementors should refer to section 5.4.6 of the Zcash Protocol Specification for the general specification of the RedDSA functions.\nHStar(prefix1, prefix2, m) := h = SHA-512() h.input(\u0026#34;I2P_Red25519H(x)\u0026#34;) h.input(prefix1) h.input(prefix2) h.input(len(m) \u0026amp; 0xff) h.input((len(m) \u0026gt;\u0026gt; 8) \u0026amp; 0xff) h.input(m) s = h.digest() return s mod L GENERATE_PRIVATE := s = 64 random bytes return s mod L DERIVE_PUBLIC(sk) := [sk] B GENERATE_RANDOM := s = 64 random bytes return s mod L RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B SIGN(sk, m) := T = 80 random bytes vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk)) r = HStar(T, vkBytes, m) R = [r] B Rbytes = ENCODE_POINT(R) c = HStar(Rbytes, vkBytes, m) S = (r + (c * sk)) mod L return Rbytes || ENCODE_SCALAR(S) VERIFY(vk, m, sig) := Rbytes = sig[0..32] Sbytes = sig[32..64] R = DECODE_POINT(Rbytes) if R is invalid: return false S = DECODE_SCALAR(Sbytes) if S \u0026gt;= L: return false vkBytes = ENCODE_POINT(vk) c = HStar(Rbytes, vkBytes, m) return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity() Conversion functions CONVERT_ED25519_PRIVATE(privkey) := s = SHA-512(privkey)[0..32] s[0] = s[0] \u0026amp; 248 s[31] = (s[31] \u0026amp; 63) | 64 return s CONVERT_ED25519_PUBLIC(pubkey) := pubkey Note that the implementation of CONVERT_ED25519_PRIVATE is equivalent to the computation of the secret scalar s when deriving an Ed25519 public key from an Ed25519 private key, as specified in steps 1-3 from section 5.1.5 of [RFC-8032].\nSecurity implications Re-randomizing a Red25519 Destination and then creating signatures with it does not leak any information about the Destination, because the distribution of Red25519 private keys generated via RANDOMIZE_PRIVATE is identical to the distribution of private keys generated via GENERATE_PRIVATE, and DERIVE_PUBLIC is deterministic.\nConverting Ed25519 private keys to Red25519 via CONVERT_ED25519_PRIVATE does not result in the same distribution. However, we consider the reduction in security acceptable for the following reasons:\nThe space of Ed25519 scalars is roughly half the size of the space of Red25519 scalars (there are 2^251 possible Ed25519 scalars, and L ~= 2^252 possible Red25519 scalars). Thus the security loss is at most a factor of roughly 2, or roughly 1 bit (because we could have coincidentally chosen a Red25519 scalar that is also a valid Ed25519 scalar). Existing Ed25519 Destinations have already been historically exposed on the network, and it should be assumed that malicious floodfills have already enumerated them. Important: Users who are concerned about this security reduction should use Red25519 (signature type 11) as the sigtype for their Destinations instead of Ed25519 (signature type 7).\nNote that the above argument does not apply to the re-randomization scalar alpha; information about the key is leaked each time a biased alpha is chosen, because additive re-randomization behaves like a one-time pad.\nSecurity audit status Important Disclosure: I2P, including Red25519, has never undergone a formal third-party security audit. The underlying RedDSA design underwent security review by NCC Group as part of the Zcash Sapling protocol audit in 2018, where security issues were identified and fixed. However, I2P\u0026rsquo;s specific instantiation with SHA-512 (instead of BLAKE2b-512) and I2P domain separation has not been independently analyzed.\nThe ed25519-java reference implementation by str4d underwent one independent third-party audit, but this preceded Red25519 implementation and covered only Ed25519 functionality, not Red25519 extensions.\nUsers deploying Red25519 should understand this limitation and evaluate the security trade-offs based on their threat model.\nCompatibility I2P versions that support Red25519 (version 0.9.39 and later) will be able to verify network datastructures that are signed with it. I2P versions that do not support Red25519 will treat it as an unknown signature, and MAY drop the datastructures.\nDeployment Timeline:\n0.9.39 (March 2019): First implementation with Encrypted LS2 support in floodfills 0.9.40 (May 2019): Per-client authorization for Encrypted LS2 0.9.41 (August 2019): Meta LS2 and Encrypted LS2 with offline keys 0.9.43 (February 2020): b32 support for Encrypted LS2 0.9.47 (August 2020): Specification finalization 2.10.0 (October 2025): Current network version (equivalent to 0.9.67+) Users should expect the reliability of Red25519-signed datastructures to be good for Encrypted LeaseSet2 use cases, as the network has had over six years to upgrade since initial implementation. However, adoption metrics for general destination usage are not publicly available.\nPrimary Use Case: Red25519 is primarily used for Encrypted LeaseSet2 functionality where key blinding is required. For standard destinations without encrypted leaseset requirements, Ed25519 (signature type 7) remains the recommended choice due to wider compatibility and longer proven track record.\nImplementation notes Red25519 is implemented in the I2P Java router at net.i2p.crypto.eddsa.RedDSAEngine and uses the ed25519-java library by str4d (Jack Grigg) as Maven dependency net.i2p.crypto:eddsa (versions 0.1.0 through 0.3.0).\nThe i2pd C++ implementation also supports Red25519 (signaturetype=11) for encrypted LeaseSet publishing.\nConfiguration example for i2pd:\nsignaturetype=11 i2cp.leaseSetType=5 Encrypted LeaseSet2 Compatibility: The Encrypted LeaseSet specification requires that the signing public key in the unblinded destination must be Ed25519 (signature type 7) or Red25519 (signature type 11). No other signature types are supported for encrypted leaseset functionality.\nTest vectors The following test vectors are provided for implementation validation. Each vector includes:\nedsk: Ed25519 private key (random) edpk: Ed25519 public key corresponding to edsk sk: CONVERT_ED25519_PRIVATE(edsk) vk: CONVERT_ED25519_PUBLIC(edpk) msg: Message to sign sig: SIGN(sk, msg) alpha: GENERATE_RANDOM() rsk: RANDOMIZE_PRIVATE(sk, alpha) rvk: RANDOMIZE_PUBLIC(vk, alpha) rsig: SIGN(rsk, msg) Implementation Note: These test vectors should be integrated into automated unit test suites for continuous validation. Implementers should verify all conversions, signatures, and re-randomization operations match these expected values.\nTest vector 1 edsk: 0101010101010101010101010101010101010101010101010101010101010101 edpk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c sk: 58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e vk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c msg: 0202020202020202020202020202020202020202020202020202020202020202 sig: 61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a 6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08 rsk: 8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107 rvk: 6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3 rsig: 533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5 b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001 Test vector 2 edsk: 0202020202020202020202020202020202020202020202020202020202020202 edpk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 sk: a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e vk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 msg: 0303030303030303030303030303030303030303030303030303030303030303 sig: 0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d 5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203 rsk: 9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402 rvk: 527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177 rsig: 9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51 3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f Note: Additional test vectors 3-10 follow the same format and can be found in the reference implementation.\nReferences [Prop123]: New netDB Entries (Proposal 123) - /proposals/123-new-netdb-entries/ Status: Portions implemented and deployed in 0.9.38, 0.9.39, and later releases [RedDSA]: Zcash Protocol Specification, Section 5.4.6: RedDSA, RedJubjub, and RedPallas - https://zips.z.cash/protocol/protocol.pdf Note: RedDSA is defined as part of the Zcash protocol specification rather than as a standalone academic paper Security audit: NCC Group Zcash Overwinter and Sapling Cryptography Review (January 2019) [RFC-8032]: Edwards-Curve Digital Signature Algorithm (EdDSA) - https://www.rfc-editor.org/rfc/rfc8032.html [Prop148]: RedDSA-BLAKE2b-Ed25519 (Proposal 148) - /proposals/148-eddsa-blake2b-ed25519/ Status: Proposed but not yet implemented; suggests future migration to BLAKE2b-512 [EncryptedLS]: Encrypted LeaseSet Specification - /docs/specs/encryptedleaseset/ [Cryptography]: Low-level Cryptography Specification - /docs/specs/cryptography/ Change log Version history 0.9.39 (March 2019): Initial implementation and deployment 0.9.47 (August 2020): Specification finalized This revision (2025): Documentation corrections for citation accuracy, implementation timeline clarification, security audit disclosure, and deployment status updates ","description":"Re-randomizable signature scheme for creating blinded Destinations","id":"31b087e2977ad9f01f6b3b93e6af1f20","section":"docs","title":"Red25519 Signature Scheme","url":"/en/docs/specs/red25519-signature-scheme/"},{"categories":null,"content":" Releases 0.9.57 forward are signed by idk. His current public key is: Download PGP public key Releases 0.7.6 and 0.9.56 are signed by zzz. His current public key is: Download PGP public key -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 I have created new GPG keys and subkeys and signed the new keys with the old key.\nOld keys: pub 1024D/A76E0BED 2005-12-16 Key fingerprint = 4456 EBBE C805 63FE 57E6 B310 4155 76BA A76E 0BED uid zzz (zzz) zzz@mail.i2p sub 2048g/74C8122D 2005-12-16\nNew keys: pub 4096R/EE7256A8 2014-05-08 [expires: 2024-05-05] Key fingerprint = 2D3D 2D03 910C 6504 C121 0C65 EE60 C0C8 EE72 56A8 uid zzz on i2p (key signing) zzz@mail.i2p uid zzz on i2p (key signing) zzz@i2pmail.org sub 4096R/1AE988AB 2014-05-08 [expires: 2019-05-07] sub 4096R/01B5610C 2014-05-08 [expires: 2019-05-07] sub 4096R/59683006 2014-05-08 [expires: 2019-05-07]\nI will use the new keys as follows: EE7256A8: key signing 1AE988AB: email signing 01B5610C email encryption 59683006 release signing\nThe release signing key will be used starting with the 0.9.13 release. This message is signed with my old key.\nzzz May 25, 2014\nNew keys follow:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.14 (GNU/Linux) mQINBFNrjZsBEADMHWiucM8ES5VDfq6n4M9DJhMyG5jVoakzSFHfzVOEpHeDYR1E eaEIFt5CEx0mbpXWy6UBoj0E7o3se5RvF81VQQ4xO0MyHZLkpotGffZo7D34uKTd 1SFbirosXwnsOxjPGLF+PuwifV+mzSoE66XRmg5UJbOJj0ZitYBn4lDKMxU1Rext WX7D79qnJW2GXv/HuzTwZ/KV3fOVB782+fNdFBDZt4XHSM32ideXedTtTJ+FXjBv 1/eQ/Ls8PMYKaYUm/j0oTI2A5aNP+6BH8/NrVvF8xQWCibrOILASWFRJE7insciJ m9eeEPPOp1D4fRDWFyjABcn00fv7T7RDBgIdpuj3gBDvGXgx8SRiWxe9CwV9TcJl WNPTAKd9XGHT13XWwc1myO/yg+yQoJB6HO1jGjqxQuu3aHCw2i4gTHflq4qZoSDV oxJWeh+mNsfx4DgmoT1UeEmh2Uq64czMGh8wJC0FqSa+FmgCKa1FxcTnYlfIjR79 qwbEKK3JZ5PPkiK5Lh4hNvkXKLrUXpG1KHm6yNVPNIWCOMd7VCDziEhsbeNPCzQc 6af8dkyI9BUeQD3fGjeHCh/QHLju9Lde77GDddYaShXVI/Wiy4AWgN0KVUk8CnEZ Uu2JbazpJBLGGiB2CujP44eJzm9VPoBx8Xc9/Pk2RFbz2bN4uQtSD6lAjQARAQAB tCd6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6ekBtYWlsLmkycD6JAj4EEwEC ACgFAlNrjyYCGwMFCRLMAwAGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEO5g wMjuclaoxkEP/RQRz7kWfCWcDWtKSxq1zA3HEUKUHLxhBIl1C+tmMtJypyWwiP8Y hrO/Tuk8nsnVOl9wMMtz2ZxMpUS2gTsuquZ6pIUCNtEP+IAuKsZlCcsNB+yOoi2T i71cXLBPcN/rbxyoOUMpk+fJgdsustUnSMbXJQ2sLjieurD/YpUMJZw6KoNVrhU1 1nDaJqAq/zouhSvNMvx5+GBodQ41gvtb984xbrNc8B24upCBHSF1olczWYPUtaAi oMlZTNr5XFS//Q8X3sEKAoRMbAX6UvZVdtgqQajGilMg+HM3HnbPqsHoyPWx4f8O n134ITgrVwL24y+m9XHfY+JPjcBgg9uGLuLJqMrrjYfz7jVdUJQUsy/R2+yzg1Bm Ruf3SBhHpG2dSBOTxi9GD4aL/7wXuXj9uIuFtX80EwsT4XifnIaHTdtNNzVO+obF dJyiIpF1IFmFOTgJ3ba9gcILQIWXGIp1e5C8g2MtuYO/6/jZK1lhFCLbvhpA9C4q uUp6/WXnavd3beKltkzL1v2dOjC1EkjrsFF50olV4f3d56JdS7JEnFzx7gVeSQfF uLR/t22CluxzubcYoAk/hdIWM2Ufi6v6ONVWc7D5nYBW9onNRKEquA/qOHZr3C/M QbRxTYyhaMW4Nrwck9jmpcQBE1EzscX3DAr+3W+rnKDCZL5QuI2Yq5gkiEYEEBEC AAYFAlNrl+YACgkQQVV2uqduC+1XMwCcC24MIzSxDOEpX7c/ecTKm18bOQkAmwU9 WqqUgT37bQ+U9ME322JPrBsitCp6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6 ekBpMnBtYWlsLm9yZz6JAj4EEwECACgFAlNrjZsCGwMFCRLMAwAGCwkIBwMCBhUI AgkKCwQWAgMBAh4BAheAAAoJEO5gwMjuclaobxQP/0oU+/nhTx7NRUZ3Ay/LzD7v DHqX+A1iPos1Xzmz+vq9a7z/mjjiQn0wfFiMctFc5dRf+hSM+W7BUfcG5rML+416 rEgtCDsQ0KfaFYUPRObxxNRdDv4N0j6uw2hFmAZ+KkOxKf5Z5CV7A2dwpjsO+PSc Ed0BM1iAjzNbod5b5uAn6r/Z43GSH2omRdhE8Ne5UrH58kLFSg8+iAfnnV5SSEKo bkP0f5m91esbh+vAgq0nFRsB8PeBYklw20wnAkIy6rmKJngBpiF0KfC/V6NY3g63 NDqf4wbSO8WqnrS9QWqYFzJfDsARQvx3jBqLTcQ4SlpIVWKNeogkeSeuqCVKRgvN jWBHdfABkf+DHrzlf072PK8RtDZn6wn1D91MeFCvg+Ss6XV2d0JEd+bxdK6Aj1RR X4XGv0jcH1Ftm9JRNjzXsALzndvwvEKU2xgDA2LATA7ikKbIq19VoTf90uc7i1Os 6cOXZkezZatyuJzJITGeq4llek+PVFxU/5LnRLr6h6K5D0/5F9KlgtPJKgSDOipp TN1Vof8f+v1/zWmyxpw9jtkNjM9chtOY7xhQfNxQLZuHXjQtDT3+JGo6/gTqj105 Yg+HNTJjkDYl2Y5AHb0WFHUFSn2GiBtot4V/g2ojMeQIiw2a8v17H6HUZSKYBjgR L7ln7O4oBduvaSSyZE2jiEYEEBECAAYFAlNrl+YACgkQQVV2uqduC+3d7ACgpRpk 13FSAhz/RpPnqYwRSFUiQTsAoIewgMNIxgbPQGUVDO3FpzChAfUruQINBFNrj7YB EAC8GDV5JcAcktMYnUbPxpydlWSDzzBaDUvbOAtWbrmkwQUXyij0O4ZW1W81e0R+ APT26TLuqc6Q+v6b0rWlVoZkSKYaqzm0S3mtLWUvEgPjHfYXT7VaHtzu6QUPwmVa w+o8dxkbajl5C1i9CZyr8ACziD23FSPA5nd/WQ18EAbnIjnT4cV9dP7lLqZAWtzE Cp3ze4ZHt6kg5i6rhJBJWbycHAZK2SMclC37S6MtZAwW0pJJwn/qdj7UvmL72QoV qXNHe8dfKfnxzo0/HoCKn4rlIW0W3xHgqy6VQUnyigL0blrVmxzcH5bgttXr94yh MVV1Kg9ie1GfhPf1ui86NnGHczbZB2TmTc/d2Nl1/L3TwxiWX2fv9BF+mVczRiXc 9FZRTF5JsBN0BAyxIE9vDXK/yygiWRSD1ND/0eTmKJRqOplpXoCBSDCsfvFN6/63 mx70wP92bNMmDZ/zbjFApmbMCjf+0wCZljiBtkNgT4k2nOYjb6Kt+vOeEg1XBTqo WREHEUA23xsu2DMH5Ra0OA0NwA9jrp1dg4t7fKIkSlBLNlIsZ73lNV21uuA8lVFR KHRX7y394c5/T9c8zPtJSmIZnAY52KXBFfsM3h+ExaQIWclyU375kYi0IBE9tCfF 7VuX1JgvA/9SjjtgfEWWLkhkPUAUl82e8SYQRx5Ki3RIvQARAQABiQREBBgBAgAP BQJTa4+2AhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkBAgAGBQJTa4+2AAoJEA6+ gRoa6YirbtsQAKheBU6M3oAfyAJ7i13mPEY2EvZFXdY41ct89ebdLCe4revG5Tao Fj/OmD0W+eBvRbJvOglw+0wYjpjAsnl95kYCBRL/BAr9xWt/g9SCcQqxOaYI9gM0 pFAcPjicEF44xdSMDSWGpN0PT5M6omlz5EObxuU3vaZ8y2XWYdvW8p1AwST66y/M AoACZqJUsIo7HIsz607XzNa3evIkCuGGNbTrD0OCTNUxOhwtqMIt3bHE2h4I8Hwp hptTf2eDf2z587/32gs3yp/VAeP6dCeQF3+Wduc41aRsCru7HnE2w/BiW1nzePyK 6b3RA56bZcbANIS8k/+EVOakS4uRDnweqkwBVgkWsCk17+XNeIaRaY0pWJaFs+hO f7cdp/XK+z2eFO1brEJa3BmnHHMx/lUv5YS8MgD+CcdvHvb2dirthzvyb6yDKFNn ZkMz3/Z1wnlDkMp/fjJAwXfmKT7IOqPVN5fpLcXp27Jh2BSrafvLupkIzZhrGL7R hTg8X83rLuQ0ZSn8k9cFju1pECI1atXC/kPMlSC4VffoViqwSZDLFsniFSNTaBOw EfKCLxv4s0BNovaUQfY2DUkL2BHrU18HbpGkaD3Gmb6TnzBYRTWSz15/9w8cjOc9 rr9d5SZaUeMZkGmlUdEG5q43b0MwQxYSA4Y3ZZGMgbjzEa83YN2njV7U07MP/1C2 D/tpWM2SliCGQ9ioPZVnwB43sme7J0GWjLRR085Q8+4V3/buWNG0UBc+l3MNlO0m N/zPp8ZqKCe6tLIXiExgiMSfcv9/7G3AgKxfzY+t3wFC6ISZiG5JFQIx/NI6zR+F RPUXUf8ZWH+i49p3UY564wULQMLobMuxhO2+BkjZKPkHAiXB0FTdP9WW/Gt2vWgZ L6ogdmo2bo2BQCU0VOOlCp8MxL9MlQ0FGURT/2kGoFzNFUo63UGvJc2iFmICI//9 OGBkpEMuPGrZI9W/4NTh+yMYj1b176IssWU2PWvhpempaXbcgXnlZQ5x6qcszzrw m403O814RLkIljRdtjHWOJKygXpjj8qTbDFfLXWDZ6MTtZOgFOPHFpc+Drbyzgu0 Z3dpXBeoyXQaZGOtClVJTCUYMjE6AaWZrnvsjT2TSxK+oy4XXzI4vVvDMJh2Ibfs YKiRahGQnBiYEMIrefoj/wu2GaZ71y8P6tCfdvlv9DikIVTHajdG4G2K7Sr4glgk cB9M2IsSy7bw2OGrGFvkpqriL1aYvIF5Wf4KIsxpMZ2FIUeGP4YfT3ec7zfSC5bp /yBP8J/XXaCV8NkhLF4bD9tU+XRRK54LZkoDrJwmTreHknluF6hFuJl8d0+oHyjp kHpGGVpi+TDayW7RDiko0E56L05VFDc4BkUCG2CnuQINBFNrkIwBEADXMc/4hU5K lUF1QCIxMCqUD5oBasQXaVMI1zHfUrfj6qankhj0GiJbaXT9Hymr+c7so86EmXCi 6oevuRfGqn4O1DYTOr1514Ftub9c+NiBY1pmgQfmf1slOAyhPtc8Hgbxtn9smYqp 4zPgpZTl+mxRC8+EmPYH23GNL8DoCBBx+kg4+sAAeN05mb6I3nZBoBdQ/wIgwjYQ TYfb9tYCKpJTzhlm2J1y1rZZiYBmF9C6abKoDDar7cH2C4pxBU955GV01g7CHJi5 mKGUM441h5mkc54DmsrJlxMUdZiJdTIjdbXTiMUozgrUKiIc8o6GYeSs+ceIDevS Q8JyQ3NbPCQffizCWH+/98A9W804+FTpkgUYYSiFuYWOUuEL8dc6EJyKrQpB1cQp PYzzP0xJZ+BEI0qOf8eSoHaoFn2sGjCwcbPYb8i64ssZmToDU+fXBZsnruK2NiYy dNnHr/QJewN3WIxpZAixQaBTquSOAr4+yAUXwnyx8ZGaCmA2smf82FdN0+nKHqRN +Z+EXhQ8DcMQroZu5dHRbg9EkLq3a1bM5hcAc6v5YfwRhRAFVJmIVCei5DmqmEj9 1DoCTWxsfzMb0yvREvq3hlo6+f57XIfIy6/iNrlcdr1y2M1ZPwnNYNd/8zbRcfH8 SHpHtsjLOvSGLJsQcB84/0FngJ5j7+PnvwARAQABiQIlBBgBAgAPBQJTa5CMAhsM BQkJZgGAAAoJEO5gwMjuclaojRIP/3WT7zq2+YQ77EWX3yTmy3gVxA19j9W5zLhV vOC4vJEyxkrm8jEQrgUABvN5aplZstLyhzYYf4PFr2nwpfS9kPwu3CKHSLht8qw1 in47pHNK4jKBK30rv7oRoz5CLeasPtEaJwBYruSc+AOTk1+Ql65gOW/uQHlS7oHE Fst21YCp810YK+FN+50i5sxzkjdRfjN8Ns6egEOmHEJv+yJxp5wlf4AY158mY3CH EfUBf9+8wxwvHFuzdsTuMF9TogzErPTGbxCwrD4v4gTxWcb65UjQtEtIgid406gn kQ6DrNrSNIv765AeClPwysYaIBBxO6captkoQDt2ef7x3ntnlHoOrx9C95xi2DZh XqemfQc4XR2nEu+ocoUX8/2yl24Bp+lg1lS1lYtrbXiVZMbrv3DLoPyAkmJAhkww FLGPSSahYT2Ee3MRbbTRecpBuYY9UwDA3rXrSWg95U/o+r8ythjy68Mxhb+qnLtX O8IZNUW1y4M3+ZSccelua94njRyJKRHxoCpwhSNaBLSa9K972impje3tdBvSILUi uBI2jaoog6RBgwNaBfDr2f7oTk+RKhSDrqNcP7B3ufKX7kWAavmq5g/VeAotR62K ie1RxXEaW5esIBcp7wv1IS0x8CrZVMQDi9kRVqUSX6W3lbp6mN3ia1QUCZd9Gyif E8hpmtTguQINBFNrktABEADet5BeKv8Jlbp1BjlCR6Vsp505hEV0Cvy2QP1Tj66o 00Io1HW+Pm9RAzXSxaHeG0YkG01Nn/8RCGTaPCWaHFJfty2Hxt+YCyHXx6f9pkU7 9ABFd8W09zx/gyjFS/8Sg/1nz84sy4ROb5RmqoUhVztexfbj/YnVAlLUE1ph8b3C g3Ugjr3IW5oNSKQW0KCJNACvHdHBqfEs+D5Y0F1atoBpoVao2v8pS5b39l77pzzB bx9K3gB4vmk8ebN08JCEdBFyDr+pLVJmiB3nuof6okz7S4UTL9CH0M1sXyv8VY5H JoS3xQO07bvjpvseL5bCdniOS8Kh9CNEcGfqsbYQ3RpVpOjqtEbeKXIJncOF/CQJ XYIdeBXClVkLMdYWLnrzisOCne2iRN9a9G/g3XFOb7WPaXPDb+K5mJjm/BCcPlJH sjt7cBVW+N+qdakaXSN/IOG8nWDdiUOlOkS2CS5sh+LsO1zynS55REWy5FWn/RWK aMLv8iUeCLhIk76WuOAp9hgZ2SIbUrQqaodq9nXFbGSyZI1+7IaE3NiChL+91Uf8 cBQIR5P5Z1qsInetc0aWHWirgdwFHQthXr/cKhqHcDEo2z9J7szjAUv2uwGdvY0u Qrld79Rmb9SA4q75PhWQrNMxFJikX4y8hwkWCDoXFN5WPu8NuK51qTe6UdSLWQeU OQARAQABiQREBBgBAgAPBQJTa5LQAhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkB AgAGBQJTa5LQAAoJEIXzRd1ZaDAGph0QAK8q+L/n4O+q0BvMilIrTAxL7eWOVtLI 3bh8Q7cKg9Eeo4CAD05oDkhj6mHdml8ADXZv6AZU1C6/B2W1egnE/L7egON3PGeW kexUrTejZexx/n6jMqybiXA7Oz8kdp40m6eQLZahHNzjr1RJjT7H/MlSbXFje4aB 1XlXfIOr8D2nx1RATvEZzXjHDp+4Y4SncYiwSD5FJ/YDiKY2tZZPNtkZHuWq/Y5Q X/JlrMNNvYD9EQQwRvEvPm8OfA1GF49ZU8eOlz1lDqfHOAz4dKVqlDTbb+PQtQ7d 70QKoeuCwk5nAn4vNrJqmC7bwa4wfZP2f0daT0QsIh7u3oyXCPcMrkW7wy8YcVIb A12dkdMX0laoBlay0zL+myNadF7mtQTHmsURfEEW+dPs8y8sKPTrn2tqQBxpDfU4 GJYxkzWKdkrjwRvCsyyAEMYOEo1DCrx447lNLKYa16NQJRLQtJy3QHPWwhSAb8XN FxdGbi6p2PZDBOjdC8qHu/LPVDbhjQYQ31RyQHYW0AJWfln25+p582Vg0I0jTZ4h e4znmKisPqzKZAtOzlUsKbqBAK/vXDvBvTlGM3pF3KQG1JUN7ttTRz2/6guS6Q1v 3TyM6RjxciXBFre31CO+ZGdwmSizmMVbpuQI0iyRfsUgu/dvzkBy7/swt7ku5Fpc AP10EyJ4xJI/Ro4P/3AdLJB0lpSvxSxpGqPL3MAYWmqQK1TrasJy4ObMqi7KHj9V lF7DqQM+1qpgMbX/MzNfSKU1U0c3dufgnnPvu2ZBAPCrOwQhdrtc4/kN94MjfwSJ YKifvL30u+F8/61pOSwbzoMwT+jkA19B+rmJpObmIfMNb2bFO45GeuwnxXpxN7Rb uro6QcwO1Cw4W04Lbdd0urZ0EYvMyJQ7494Al1NmrOfk1nMmgWwHjjhxa/t0wJae qHZPMu9ZU42GRp+8YuEIz7CQRwu7tgLG4thLNP0AxKwTLoPE5XMcqrp5WpEEyuuh 9DrZ7BFq79ZJIy+d0AifDb+XAR3chA7xOPbIDnz0MuJhIBXeFnKWPA49J/Vh7kvD IUCMjPZJQONULfdFxYycNDl9g4/v5ik+1S+oLqHyBoXNu0n/KtJGeejW6IwFOwRn UDYnhUxVrGqf0gHV5IFqDnZZAJgWI3A7BR8i1FUgxsS8DeoTHkgLDXGN1U5ncw1F MtwzIk0uDK3Z0Swe8NO9jlkA7UKCboGV08PwmpAZBqZvMxEtzVTceV/NWN2aeGEw C9RzgXCrXXNwYRkV8yHIBlrfAfx8QeGeOTtiTP7oYrMI2xrsNpC++i6Hgo3In3FM ZinrYEOuBATZHB2bWODz/GVsKXpCQrdH88li2aIXEeOUI9rZymcJqTpTskdr =iP9a\n\u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1 iEYEARECAAYFAlOB3xkACgkQQVV2uqduC+3+UgCfYZiUtx7FDGdQDhdVP8MyRf0D ANIAn2YHOQh4yv84u2Kuars1gC0j3Nr2 =Zu9F \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; Releases from 0.9.9 could be signed by str4d. His current public key is: -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA512 My current public keys are as follows:\npub 4096R/0EC51FCDA94FB53E 2014-03-11 [expires: 2019-03-10] uid [ full ] str4d (http://str4d.i2p) str4d@mail.i2p uid [ full ] str4d str4d@i2pmail.org sub 4096R/1CC61D9B33C3241B 2014-03-11 [expired: 2015-03-11] sub 4096R/803DEE491A3473E7 2014-03-12 [expired: 2015-03-12] sub 4096R/A1B84C9B733AAC82 2015-04-05 [expires: 2016-04-04] sub 4096R/13B5EE58C09FB3E0 2015-04-05 [expires: 2016-04-04]\nI currently use the keys as follows: A94FB53E: key signing 733AAC82: email encryption C09FB3E0: email and release signing\nI generate new encryption and signing subkeys yearly. Any I2P release signed by me will always be signed with the latest signing subkey at release time.\nstr4d Nov 20, 2015\nCurrent keys (as of above date) follow:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; mQINBFMfofkBEADlyw6v1hGBtnIISujt/18RJcVTLAxYtfe3DsGhWqYZN3iKGGWb NJ5vZcV65FVH/70NFnmKlvYp+tVNJcoRtEYpfwiNG7nIyOC4GgaSLwkNVgLcFZhV mNj2RIJphjN5qsWm6ut9p9CyhWkVNJYDP65gqwShZQ2lPboo9s0XjUF78SrSshy2 iVij0xu6oqdjwqn1B7L3lXVYCwxReCvSdFnBMpjGUEgGnbt7euhrViFk8FrUkAje 2tZA5FAUA/t2Mnc9JREe6WlbZ44mLApOjFdw0g415FdcnS2GGaYuXNG1lJ1yOA33 n9JXT7A31wPyiw5yz7fxgl7ZNYZr2TsRjBlqEhf2SCPfqU9UlhJ9NqApaPyCEr+8 oZQfZ9r6stc98MlnmdQ7p4SmKRwCLiBtgmrB8mbgYV+iOwaKztqEoma3FoO2EJ+j Gx+UrJ0bIFVr6sL0ulfneYlY76wWWRpB/pLLgIMmZw83uB+JDBQyZFXcAHj9jMQ7 ZNn0MNQ/I+qcmX+CRAyl2+cQHUVbbQWDjB3crZlpK5TGw/x7w0YxBYAH8Us5JqJH QOsact8ADnE4IiKm5gVefFmNX6vsljkNESdpAMxnB7Ckl2XV/r5sKwrdxxUbFSxp IKGx2uKGUs4oUffOzpKULhGBWypN+3fVwvP+q896Il9hgyx6SCQ8AgPHRwARAQAB tClzdHI0ZCAoaHR0cDovL3N0cjRkLmkycCkgPHN0cjRkQG1haWwuaTJwPokCQAQT AQoAKgIbAwUJCWYBgAULCgkIBwYVCgkIAwIEFgMCAQIeAQIXgAUCUx/ZQgIZAQAK CRAOxR/NqU+1Pk9EEADHdpsmrA6ZKU4EmBZNbw62D7tAo00Fh25m8OuIkXtOqEbF /guTZiZM4nbhZpPFG9sCN1bXS8VslA7isOedbznkKnSK0BJcrzldwKzW25cwptoQ CCqTUarYbhcIzEOKNetYqICWrVTy2Yuc37maA66PnRLphV7pP3Fj7eN6aMtqwtpJ YukIU4LAjKOMJ6gwy7tjsZYbAqgSE8wRJm7i1MfO1W864a1l2a68Gooz03NC6mfY J8aW0y1F87xMJIgZeN7OyHf2AC4/Tp/cL+Gd3HcUuoRjmWBgaxH8tVNgfxSIUMNH 5pTdDs5VlRolwlOEcTW5VxOSu5C7ZbuKyFmbI0DSevDVGS0rxSSizjlyGmnxkLU1 ozpeIwTbwTUzvd26+k8cidGodKqoNoyAXzjaiBXYKgIrVeXBMHxCGeQtGeEhQR+L OXs8cEX6xpt9g7nKbNki0Cfv/lx9Byn+0v9RvMJKDa1mOSKbNOx3NJ8+ewdTVkTs iYFTZwpJexbfovPYqTdisiO7dv0i5teE8sEj25icdPtKYvn/55JCT67E8MVZaeyU YOaMPtgsiOX0v68NtrC1L37UuBykQlm7FdobN4Sg5FnLTt4IWktf0/vsaLdhRozD KsbTmsumCrScAwZfa0H3S8WqK6yCEKjPi+J4xG1OZP1WptlV41wLnFKkeFaZRIkB HAQTAQoABgUCUx/Y+AAKCRDV3jiWlKRlsmU0B/96eiPHIIvapoXKoZSt23OFjXG+ 3xp/Zzf2Ug0384FYZJ1eX/R2IWsh64CVvOR0LMFvHvPU7SCMu2OreNHfPx/B/kn8 MmusGy6JHP25A4BWzs1eeyKgYQTFz7vSCeAnytmcdBot1s099upIRw4usCLhdxzv Qyx6TogAacGC3YFj7o0agz+ApPnCQZ68kZpDOCDrtOe/DRted1LLXM661Cp15d5R d+91ZSKfQ9xjK1d2k8iMYJqWYll50DalGtzPGDB335gX7agliI5dYiu2XSLyynhw /7f8d0Bz8KVj7pgCroAVjTSdHvZfVcZJU4HST/jHx5hilVUzkr9NK5YONJ8SiQQc BBABCgAGBQJTKlm2AAoJEPvivaOtdGgqmGAgALl0eAcUSF7IuloPT4VyJeNGMuOb 7aN4yYrGBM+y7Ij/dTWSS1yjlcixsqd+s0dqGse6RtJkyhkisEmNdS7Sf62okGDl ZbmhjvMQteUO1zw+CREdfx5oMpW/eCHq/Pzw8KRdp6qY0wBRj10GFMAaMX8XCNOh 6B6Ti0AQ/424yEvcPpA0zXwvLGylFozRxjK6qWEHEmW/+knxYYN/W+8TERuwVJSN F3jBYl73DTVBZ4bzpu5jMSydhRD02nV2LbnolhbCzGllLkhQw6iFW36br8600Tba loQhcJU+cmuCId/B6xXcF+fyWqmMmm+b0UFoHGRBnXCf4gBcjCK0UwJ1lUOTY5qg IYJTrBpCrGAoGTd9s+1CtnnZFlIcwFJB7NwMZEsTWvOvO6sZPYP33ktcUwWAKqNj 3sSjy43kdfUeVip0jzV0K5uStC+DiVq8VwH7uNIH2UbkQZato67WgShUCCaSvf2p HapSRdrmwIaoANQuEluhytdafX7yqJXGkhYI0Ylh2FH3oZyTnz1XoB5y5T1OpFpi I7CgjRO677aieRsf6HACHPX5mWcq8zJQ8fuxoHZ5GJ8FEyk6ULUgFJ3u9SgG5k5I vP4pK8+lP/d90Zf98Uaq4aMgAoIlrtwz68Bv/KUlpwVWhiIgo89C5UwcTUNQOmi3 0PxCpamM81NwGPxjZAqr/+0YP3NBtJOITL0oqRCxcHCJ9N8gmqUmUEgEffP+glsJ p/mQeJEacmR9loz6WAB6GT9mu5TvX6bZ5EawnluQ1mI6Tn+v6ltjhKzPzaVhOo6d iKriQFZhcelX1qDnE3zs7driBeacuKGt4URV8A+UDGJBeIAEfrlszor3FQ0qOUPs plbcbB4YudUOhlH1REtGx7zWVFefuy80ZC7abHsPhWkJow2axWlvPqjSsd/KgpjG IAHIZxiYAozNJqDNluGx1+qa1d7/YINthZKefhkG3XDLuhgxvD8rAovyAFW/8Vy0 S+GpzUVtC8HY9FZf2gRkVtZQGboZck2uFyIaU/Ni4ahX8Z9IvtsU9JPLzp0HRgAv 9kz9EyRZt1viueeIVcmadHirUe1IKqndeslcXOX4dUF0nrqP1+shYhebgq93rMPR yH3EsoXtAP1KCN8tWPdnlDnMY0Zpy32mfCL0hMMnH+CY5rARssSbiFP9HeWk/CN+ yES7FY705QmV/2SV4rEngqnIcrcqEJFp49JPihC1pSikHCItzSVFaODbUl4qhTjn Tjtl0pdFQc9ksA/6IEOH/bufDwtxCLwAjUpqyNGEH/8FnxtwotsTmhmTWMe9vxYe YStdTLkAvJFMVEU0W+H2ZZG481P5/8tqFS9cHEU++3VvuYxfipwjpIQhm5WJARwE EAEKAAYFAlMuEVwACgkQq+DDGd8KChpPGwf/QL66k12OzqI40KQL+UbzW25vxbmE OyZ1MT9SuUVt6Th9zdoNm9Cosi9kOiq+DPLFFT751Lmm1hcM0rDDNeN+l8wpLwX9 EifD/bQ7Q5esM8NJmGVyhA/Cd3wkp5yYNdZPOu9/0xpe/Px4YgficRErhgyVh2Vs svQRQ0WcTYbgbmQFpOUsjNVOchJMFERSJaQxWgN3olYd5DTDxPDLztt3vdBCIkz0 4OAotZqbqdnmvlkjKjzrJylfCkyo9bOU471v6Hs3mfUQXo9nXC9zGETFWsvB4WCC QdWEyj+2K+PcdZU0FEPonfTouVcsR9oTqQqqfg21M7HUHSmlrOyCLqNnZ4kCHAQQ AQIABgUCU2vk5AAKCRDuYMDI7nJWqGIzD/9vdI3uUUYGCaURAprGEo4kk6JP2TcS AmyO9Pr8bBdpmt/DVFK0zWllQ+69QAWLFoCmgjOgWUPRNWA+ldG5lzExjuuP38P1 4HupPMh0yOd+QUod4Gdi+hqPCuFT4/oErWZcOGGXAw4ZcvdEGKY9E975D+3yd7sG HGskvGB/UmLIBQ2XfQOoqk0A9eXz55wLN1ia1imHd/0NkPkQOHkjTdOtHhcBhuoc ttex9HcmYy2g5oorG+7wx0EtHxIhuCcRq1wQgXm2JtbiFHXiH0MpLfBr29kpzH7y 8jompGgAJsK8uRwTC8UFWHnx0VxnFQ+4vinqlgj7/O+WMZ/siDlOZDo2RC3ts+Ct 91kYNFHsycrkJYuoPzNcMy7mmixQFj5L2VIG1Ne3OTdEPVWE5jIQ/w5IX0aYxNt4 ANIZJA/r1AqDqDEhto6gdnkrVZSJN+Mvd7yj7XTbrErpTmQeNkGgb9ult4XaEOdm bjAjE6rTQqFD3Tn8SeXNgkJFr0Zb8lZypmOL6cxU4vTG66blJPLZGuaH3yCrtA1i ynZPrV2TYiET+fhg2TBEXbjLkWHQnA+7sFFOTgK5WOqc6vK29h5ssEQKIFodDh4a e88tiGLW9lSc+YWRpKHgEc8QDXIuBrV18hZEvbITvLZnnf5uIFXJV5ZCHG+o6I+Y jQrPY4oC2HGrMIkBIgQQAQoADAUCVRRYygWDB4YfgAAKCRCFZ1M6Yr7+XbxwB/42 Kbk6DpZueEK0qtdoLUh7H+dWfwA0Gsh/vCoS6RM9iXjKPBoQGlbCBpsBpqCJkGd/ iXH+tnkU2dq4BvGc/igSHadNYmYq077l1vu3pJjDjxfQ2qZSF9D27EUzlXLd4Q6s hysZ18HoTehxr3AG33N1tEm9kBUfZjeMZxk7zbty3Lo7tK/UYN+4mIgYqLc97XIe 40Z3IyFcb4A23kLi7AjFVFto+JdEBQzS4KIdU3ZjhOlg2uGQdqGpjSeCN9MjkYYD lhepjGEQzFU76x5yynruV+U/Wn+TvGhGMJhcNrebNRCZbNsvTCPMA0UlSoxusbYR HX1Fcy6qzYt/Ax9ehAItiQIcBBABAgAGBQJUI6eeAAoJEBCd1EKVjp1/eucP/2eA 4jDnQcd2Hv1i43XXcXjUIAhggr4dGuXzQqUzjpzxyh02pJuCxf/VEjug0kE94xrB ZEKpHyDyo1IlFUnnoz+LT51iiUMmM0IAadMKl4cuvFzO6BH8bPnybEaw8b/fXBkX R/n+t6TQJMqkjR6gWX71HLHwy+8Z6+ospDq2IKnZuwX811rd5u/H18vgHpJ5x26G MoyucHrduEyec9E8GVZnkwwBK6pi4srvr9qLTd67djr3y2snhkAyAu0ehox9YBEH zsgM4WI4K8AujiFLxBe7qrNAQeWRWUbLw7zHo3gYRzu4Sv/1rKGSB+wVZpgYIgm9 Lhdtd9kd42XrV9yRgnDb8OvG8IW9KI5kLln9v0QHOR/ctuqnn5oBCTqpk6bkGidt k/vFePyhQkVn7pxcomxeyPTXmakuTXG76S4z3AgXfY5nq33i7Xs0nxGE0Ak4MXnD GoNYsFnmuQL0x53m3BI6jVoLa6hmm2q1NNDhcnXVr4vW2mzRBTnu4Efgg25GJZcp SAKLbf3+tMnbfoilo0LbPoQXBY5oDV24rv9lU012J7ryyGgetSWDX4Kq51tl+kMK bUtoC7Ew+xTkghr/MrAAL/SmJN+qJI/upHcPaRHpkvyb2vHNuAqpkKZP7Woq1AP4 cSNHCTuGqLoCU3WV7DJK9IYY6Nx0lcGaVoMpeXzciQQiBBIBAgAMBQJUtIPWBYMH hh+AAAoJELQxtndw5Ko4p6UgAKS53UyHIDowFgBQC19Iae//3p6W2MP3JuKUSd2K SpydYNsKKq6sTQnUrSJqDS198ozqrLbAZCoV+3PkDDQrshXCOjyyKvGpe0kys7RD PakQbtytthoqMXShFwUox6t7l1Fcu/PPgePV/IGsnRxcH/2GeMCnPzUafS3j1QXN R5c2NoDDMVVeyEOaIz9kn9R0BB8L3AzLpPAkm0VM+hEt3My6ySKK+ZFMvnZ6hEDa G+0Jr+GUKCDuQoNjXiaFMW0RzvAdRysU7Sa6wQ4QqLmNo4yuMS0VP54y5OAJjIIk vvaYmc4NmbSmUDBW/0g5DS0tvWBDKkFre6WRBCgBG3zNZRw/HAxXiYvAIVdugTtS X38cwNZVTD04w1hgbHRSAKX37/Xbiz5+CMi/LZtyKVLUVIxmXGd8LD720QXnENOx RnNIfcQmaAB8/nLutGxyiWMEchhbGkh1LOS9dknb00i/0+vIIhJHYDW0hbWZ7AQN UFBHLqXGjf+ozwiMeeCHGkfrnN3fG+s0vy9fH0Nnx1d9v2fjzKkr0qEFpbPOl8p5 g37B0bFRtIJkYtuYXJhfZv/3g635MC00jKNM5qlC4EwTlt4xk9RNwkuMcwYstSG/ 1RG6SxCxJefG/KJFCwDXG8Ts13OdgS5pwD4yE+3MDdFBTAXMBs3kNos6r1qcS4fX wyWR9r3ZgBI/ZNJ6miDMWlI4knN/m0uneqGfu8t7rlDg1Jl5l3vmiWgc89TirReT nucGlonAn+J5PKr+pR1bRYlA6orX15B0/jJ2iy15n8YxTf4yRtgMpkcCvxSyIqYb 07XNk3RcWGU0YU9XhSE4iwp1k+hmCNMdpwN5sLHDdJfx/lIcNUYNzrhgvbAGJp33 SmwfQoeD+zKUZudOGS7YxGxIUL2gAOdtpMCzHGFWFL+r66QRh284mXqOUq8bUFd0 vWgG+zD2espSk2tKZI3LVY5ib6kXr/ThGWenm0wE4KIzcRRD6FCHB/aWDpCap4Sy +yT7mxZ1yhTvU5nNdwsZZjvfHigdcD6YP1lriIKo71qqS+TYu0yoBxMrH3Jovlj8 l2reohJ4ayfYNJM5foSlJEPOCTPmrfGiXV+e6qC5RmLJjEQUlQ4jYkPeACXESLMY MEQiYsZQMZl4j081hsKsVbZo9087PkU7AR72kUn/YEfFkd7cQbmkXMP20SDt5MHK DGsXJYdQTSedwUJQe4gd23CguuHQ9rOvdHgSKqQjHhSmv3HFhi2Hfjw28RVM/AU0 +uOUYOFcyzbLhDONa2/ku9p7CxAfkKVGtaRavNvntKwi74R+kvwfwsSmxAQGb4a7 5R7t923xTHXQJDmw4fPg7Nzk3EWkVpIO5bbONoihLl6Sm0C0GXN0cjRkIDxzdHI0 ZEBpMnBtYWlsLm9yZz6JAj0EEwEKACcFAlMfuxICGwMFCQlmAYAFCwoJCAcGFQoJ CAMCBBYDAgECHgECF4AACgkQDsUfzalPtT4HTBAAgiQkCYL7bQRxO1lSdBWM/qRl IvL7OWruPjLVFXLaHS3LB0F1BGyL3zQXofCnrU0KqSybTdE9bnPe+lBgNZBxhl8U ipZdau7opbol5z4UYGTTuwsRwiqfp0PJf1tdnrVK5CBUroOGM277/4Fja2gw5/nJ v7OZ3zU4DPhG3wB5q+f22rUrrIXTTCZ+crFJ+6ii93QQJ0ey1ruNkpCP3zrReEzs EMKDVj477O9tq9l8Jyra3om195/cb3li3nCCx5n9Tu5VIt+GBpXXWByWKdU+P1uI MGXbqrZ4rHDBxDpxarhGm1CqC1ets6WlmuSiKbhaLcb2joypHUpa9UwemxHTkdzS Tq/eq5FXcc6hIcYmZXj5W0APTRdUS7AFqxNMEeLeamexCgFeYYX1TIZDDjQlL9xM BYrYsmNae3H49uXTGuBIw5Shy+ncnuTkzNUNBiH4nS9vMrDzJ9SPRHpfWu0d+9rl ZDl3wK77g4dAZpcwpmIpNBlA2BUVW8veEmQdkMwAexi93xJqZskkbpZfPUbmAWRL xOczZ+z+65wg7bHaK0n6fay19/MO5hYU2BQcCcdHbWnT+vzw5ybbJ2Us1M1FlZpP acaLUEIsBxvnkKzZbm33g/h2W36kUh+2VARK+sEBe8kOKSuvgL9A/aHWuosyBIDv QuTluo4/5iffXBIsctGJARwEEwEKAAYFAlMf2PgACgkQ1d44lpSkZbKzMwf+OLgL EqCgLrZLTC9EeztmRQOXCKRLYpvoMBtF4UZ8vxXR6gtU4nMRWmvKZ3u5aYhT7722 U3+3Om60JQutP3+rjyHmdgEAYkg2GMjJLU5/tWIWqrrV3gskmRiuPWrOJtC2L7Km VP0mKK/C+gmA3LqXbcAx7ilE7zCob1rKr3BARJXhuI/zBt7EYveBKwKW47S71YrG 95Y3YiYj/LIyHbUfRwA6NtDMbpF11xH9jweZgaCx7W+kDtr4YunPI7dCEMpRADMA snAaUhrgjscKvUKI+2sUHEy9fgQ6+n49u8jkIDgb9dLc+4hyGsmkYMagu+DW/EGv i88hpuGzpk5EeRoxgYkEHAQQAQoABgUCUypZvAAKCRD74r2jrXRoKhGpIAC7v88N a6w17UteB3JRIpK8XQlqBtR8kqOGFqDTlMhPORQY9HxutGuw2hCIRaAI/NEvsgOW W6F8GxBAqEqh4m5Y9+39tZCAFJFeA36GidQNbDrQoL54xbGB4botZUrArmSBB+Bn wZzzOoGfzEnI22MaR8k7QACYp8XR1pJIFeIEJCl/8XTRldUbutSqE/3KmOLI2EGg 06wKUoEeQZtiN+ZINLz84m+8+qX81+URUNEApcCHXjgRGa+xB7PBA4Y/YtwGcaJA qF7Ap1wD+z0i1WJuyrjDb6TQMvUiqNoFy2mk5IcNkdu1a9Z+/++JHEEIhLrxWGIl 05nSnHZ4a0jPh68V7tz1febEgcJc2Dqx3b7b1pHOSEbvwz9clPjNm9yeQu0G/UpS Ug3uHRcWHD6nc3U56EXW3t1m1ChebtXnITV9LJFQ76h7E1YRp3yIYblnNOd8MHVW hiH5YQKN8u5Pzy4w2a+CmYJ1YSLcZketo++/qh0i2gilt0Ox66ARy83LzTU5J1Ii jxkcXMuqLd3tTyTSXpTHEVmWaf1cbWOeONTb3PgjFhUA/OtLFWGzIteLZUVdT+L5 U8LzUS03amrf1h0S/jTiXNg9YP0DwLs8ptcQtI9i4Kug2dYYxlXpI0NQbeaafbCD /tOLORdCbeXO3MFGPsRaQOmoPN30VhiR5CsJmiaiTggMauRZY4NseofTvqAKabAH +uZPnBmyFfK0/5LmeZsH9bwYn8dgzfxnmd/oAKqiZbqnmsykpw61N997T8DA8Dyn Rpb3og7aBDuJtIMgOOZazhBnAMmlKwIO2f2UR1Sh8jYSvfp2S+xGL7mTqimZbaLv A0tMepXXTNyPfFR0Hvb2Icps1dfXIo2q8tiSwn043fUF4ZYegFTQ+pZLGUEaaYnp NQk4ytyhLsOm1mCZf/qWh2nM33ClZN+Xf6RioujabWcMqVeB4ns9MrdXBfO3jYjm 4SyfpTk13v0oEPstd8esZAwelaMSGTg6w3xrm7fLq9ERI2bZrOlkblT1NmEfwRg+ kbQsu88Dmxkrrkt6KbMsvDLIkPbLEP4rntcCCbcs7TulnBw8IxusJuHE/Lqok3D5 poofD+fIesQ811Ms9vOOjp2Qn51DbzGyoBJBtGXywlTAPReRcceKLChFXtAw5zBw f0whxd9ZytVVvkPGwM2KWbtfdB461JNpeZFOYUWnURtTtBqbDGfB5+4SFiC7qpr5 n70I61hAiY1QewT9MYUnAJzmsGGArqd4oto4xVswvKzV7MkolgydzO12evPZrjIL 1/PKDgNTZYVkIar91r/TDsqLpEvOitUxSEBsr4KoI/a01BfZBr3iVF2L9GKRFwE+ tdGtGXHOrOp44qeaiQEcBBABCgAGBQJTLhFcAAoJEKvgwxnfCgoaCQEH/0qjOxiM 30i4Bxg73QH9MWMsLwX6vdnhb3qlxPBqRZwXz2rBKlWcOmrw9SGoVShlRW5xZ9sW pN0xfe/1LumpBZuJB+G3o8Y3oKZ6qLcfb2mC1WnMEai7nOR2t03+Z8RZXIYK7GUW L272EZ36vf4Dc2JbHEVCS56VE1pEjFBfC9rZxbkUODGr84DrBqJwJNrJ6x+dssmX 9zzm4vcrIe3rGJ2ExM6eFcVB5DwrhHEWHzmpZGYV1PvO/38AbJ9OLhkJKNMuFNah FDA5x68/Ki3uWOLJRRI5nHvt2GF8kZ/0oi7YAhd1PiWmJF5pwfFlhekQfJBjTBXk QwgD52VCqdBdTbGJAhwEEAECAAYFAlNr5OQACgkQ7mDAyO5yVqi6mg//XHuH/fXw MMoTqiNbKl4anXPjiuNe6VvI+e/NS8PR4T7CGcgxKlThRhM2J1psPzYtQfGfULLD cHT4Axg1xgVvhMKDBCF2Oe4+ZR6KopwUenOH7CN2oneLDoh+gJWONaYpcp/CNvS0 46cyk2fxeAWIAD4XKKhYy4SQOijaF8F86kSAe1oitDq+F+UXvuOKOeF82gp8g6tk vcT4J1CMEyMzqeyh9MuM17fagTLR8UtRAsWrf6iJRO/rvGTM409yigydsB6ZKvmt 4HR/S+/hLiEpGp4qEMpTIivUz44oZoXz1OXnPKfwLTBzJx5nQHQ0wPYxktZnzYaT bzZKA+v/Vi2C7/0y+hIzXV+OVPgUhvM1OhM77TLSR1014GsgrGrrrJxGPAiGKMUb 4CT3M4CLLaB68+8An3hJEXs/MifPiRXEbzh0/HHxxClfwV481a2A5Xf9KALW7PLZ ly8eXbtqGg+ZereUWsr4x9vkWXir06dtMtN5ck3hlx4ItGL8OmjHXoNXkO0HVvsD qB88vVxMftwBNpDLU0r6iZ6HBWBXAMD30wWRkikmHlSztERBBYopmagJ9sdLrUIo as98jm/CIJ6AttbJf4hyATo4cTR9Owp9mRPfOE21BD+Nmm7QEoz7B/WmcgBKGVwZ nUcqUSOCJzh9fyNaXDY2GfwGVfKLGO3lC4CJASIEEAEKAAwFAlUUWNEFgweGH4AA CgkQhWdTOmK+/l3Q0Qf9Ge9s1wn7X9l4YV3bsCk0bklXye3FznNx2vf544Ft3NbP O9oFy0cSN9fBwTsR67M1LNWyuRV5xBpzVka9xW8KB9/dAvbqru8lwyOh7ztZ3NRL SAtl41XemAstLY3wWt36VFZNgiuloA/tAQjGZnmf/AkuMJK7MI17lAqSmKTJTcwG KZcLLCeF3aYLjUThfNZdGgs/+TSrS85g/UTIrcnnig+vTCKfUBDK+q2ocxyNMA44 gMgthR5+jAhhnm5XBudCGMy6TZ1dgBga3qgXMjVXJe+wwjYSW9flk6AemmBmHsnu 53lPPdulhRIeGtzGpsLpK47GycE7JzEfNKkZJWaw/IkCHAQQAQIABgUCVCOnngAK CRAQndRClY6df5u3D/9rIpwvfe7kjQshFNm1sxVuBCVXtslDtHuXyNI+rrRyLxVd cFWF6CFE9OWCIuGMl8FPnIzoR/p4sp/HzMDCALgUsBgn9j+4906CkoyjHiPTQRy6 uhQZDj6OfDcEZV3ZW7oZECuYND3R1686ESnoB56KJL4gxeQy6JSFoW/3+weS3swb XOpupZYa+52rU8d5pLOCsFXdulWhxSdjRBfSUYvf8M2ZZLlV9GvHvBGxBlzQPHhs CKdPlviPXvEa2zP93xKleN6/8woL0VAAN2Ru5yyoDDGXNj+T+99zCMAvXEjpw1/S /UI/+y8GFTIRMWzciQtl9Xd9PO+0NXWV/y1jW/PKZEVQv/TFrSDeNPtRd1AMVa5y jTaY1+mha33w6k9e/2Ib9VbZ9jWOOA8gpevhfXQ/Jzj1aCFvZLJB5+Ho1/VlBpv5 LjgffGxGJbcCP8WXDrBJL/TYKEF+h/dYzby9icvXtT5/7e9YZn0n81OqXdFHoVka eMAQ+DpHWDNWP748TEKHqFWu4/MfMRtduZFsRAmWBB7aA4+SyTSkTXWWCTB4JAtJ 0A7ARsrfqddSvfQDF0ePSpsJxN0jM9dkvj+w/YJNn5uyiUY7fDtUpPcm7UIc0xNI hsAUlra0v/ajvDeb9SR2EieddwkbpqioonfwpKwrIKRha5rpyzaEkwSL6kHDH4kE IgQSAQIADAUCVLSD1gWDB4YfgAAKCRC0MbZ3cOSqOKBOH/9eHeFpvQbwaA6N34y7 dAmac7bav4dDjhgBHCS1uocjYDBGCFzH06MxXS9z18CYL94/5YJzgXfKNykIf61l 53Cqbo5ywLBo4QC4M7eHx/QdKVJSS1Y6yHXcxDEo2UvHOqivqRuXoAQErcNDCsKp fzGuIfWkNxxM7w84ZL7hhGGnqDy878TGE9EOAwoEmO3nrNMNgZM3ThSIFB0V2ral D7rJimFlWWS3Zg9RJtittruyogw7wo7ofl2z19LjozeN0/knaKv5GUHGqRRUEXIk a3TJX+66VN53FY15h+ZDzCUakl4zepR9BvuLdTTbdzoN7iF0TBQn9bTrmD3grC6i FYupxswRvK3/8Gx4V2dlxo7S3XqxwIIPDkOdMTW/6lCuXQt8tkaUbStwhzLnxSKV H1HUILD/H38zSnuwe11XMFZg6ZahzC0kjEQ9v3DN1I8djZGYAvQfP0y/+E2OMptj //7zIh/eDfV3ruLQh/583laMGwFxbj4g6GPILou7DZ1dbofF8WftxALMfNDXHsvs 0zBNlqSZNzSinTiz3JoszeWGmRX0KuyZDaCoQ/gMBjbDxorJ+a0NUgRYwJgUJW45 pTI1X3MI+qCbCgTRgvINNzopjJNXr4MHXuLD/Sh8sGRWj0YD0nqA8foFl3h0+Ft/ 9TNbc2CeNlmQPxKC5pHu3h3lRhZYR2k5ljEFnOVi1w55OQ0TlJrrtR+khqWFf33h BNCe0UlnBVBcnywAxAhfnls90S2XvaoeEj9PUSdpgeG4TcpSpknNQ/kNLw0Qv52b Se9yWdRQNyAe3xZ12RjfQ3sGXwC7vg9DA0ER9eSSJb32f4pDtUbbl3PmD+2Xg4tl d2NpDeAy0bridAlBXHVkNNY/sfovCxCRv+QKfvh5WMm3QTaoKN3ip3+pHsVocwwG rhgqszAk4itbKS+0NG4mAavqhQV27waoQ9JbimCvZii+0pDvg2HpD0hUfVGOpvA8 gRiszXuJo2OlrF65o4PChS1gUmepatruO+LlL4eApSjfGk7StlPXv1BXHi9OzGXI 8RVtIjEkct0pxIDolkYuXIQXQ/e14Yedntw7t/vHMtQr9TSCYDFmCLpezB1msoat vGePfFPODxVWqpwHTeWzhLaXVJH1v9Xf6kkCFUzjrVapVsom/F2yC4Z313vQeyER yPOlPUrvSqHXJwM8WI9LgYjsiro1oz42aTqNHFE7bcnFvQ9DaLob3UfsppkN03Da bxUdOEgYrcdbO61D3BELW0TeZUUexH5D162JTsw8dRwIXI38VwZlGii4wuyrLWCG M2VZ8d7wrZ+6dpqoPSYAx4thPSF9XgMbSWahz+JcRaxQFFExzCKhUE7AXk5GARzA IiRDuQINBFMfo0EBEAC+nzaOz0FYik2T2zNxc0AMtFySaM+44LBmhl7i9bm5Kc2K YqwSzCQZUJSXL4OdrRH3ta2zIR5IOtzcUHc0k/gDGPI1ptOyT1744C/MuYt/yIpF Iw5AVvYlrU7BIYh4DBUfWr+2843wRnwaNlINgWuK+LRVtE70WaWYsPKhO6g765Fl 5eIX7Ia4w33EiZeWXeV6abGlfEgrBcbCYs2fIXztvZ5Swhn/+0SxPsAB8rIOfHSY kB/+143DvrquumpmRlh1J5p4EfsaV35DueIt8aJyJUFp1G/v7+nYtbR9n00mx6q1 bfM02cQUMBZIwBJRDNJh5Y2NITM82dc3W4mrzVZggjkTiv/3FLmYsD4o2mWWe5zK S85bAfbgNeQ9bWXxJK20TNbnKvyBuu+gjTlDlj83I2m4U4eMlqTc8hjZg0XBH/eK a8KIZG//iIhXyHerQviJPd+OJl3xIoVHvaTnMn06US6CKVn25wcXXC4RyEk/iU1M 3SW6GpUwoWemIHAFQoZBeSGue0uutZR5DrrKUwCB9DXtAS3IdkYblc77WWBSPZEw 23spbxmiEma9WuSxZH6bJpBpAO6E5GlMDUIcqY9VTxcvxHAe5fXIMd3EsmosN34/ ghqytIrxgdruyr92fF0qgZwfpD72MMDRBzgSHTw3m1kwPSBbdPIhWXkOrvaCowAR AQABiQIlBBgBCgAPBQJTH6NBAhsMBQkB4TOAAAoJEA7FH82pT7U+MXkP/jHAevVm 3KDdkehU9m9x8NmESCDlE83AwqKAoLLwfs/yqhxX4NZuaLMP6LQTNn99VP4xpph/ HLP0TUDEVUXd7WZqRR8RRWjgZZBECtX7PaGUKxia8DZ6aq+Lwpx6u28rlmjajmsi TOsZHb5e3SGad3v8fblFd2OBh4UMvHkuehc0vu8HeimX/Ra4KMRPQOu4cRpjs1oO ikRXht8/qO3nIEBpACxv8/KdB+YzQuDK83jA8sxKFQRfJ5qeK7EPNUxyFESyZjsd fLvBhlg0BFlEvsO22NanorSpy5DgeAkTbEqjg0qQnFH3ICH0G06hRqJueaOKQhqN GsvfDUJdSMVTSrRalJI27oDtZt1Y7b32AWAWOaumnQRp2a421IMl6W9z5bR/dSTZ lU4uZfdjsDE3ys2plOkTuLPlnnlO2cIgixA5OJmQ3zPiu6yWuZuXLYPMEQ18zGTv Q53uJXAA2tdur86PqWlmMIUyhtiRXUAu2PJCXa4XuNtxKPgyMdy6+ge/3jeXdzlD /lhsIyH8maV0XFhVTcy5KO3iDch9fApFhNa/gQ/LNv9wM+aE0Ts5a2/+Rllqwyz8 QoWZZHOXN89Oh8Aig9TToQX+Yaf2gcn/UmrqIkTnd2j+/b3OrMoPqBcZzZveyrqX Xs4yxwkJsLoIqyNOKNntue4Na++/q9dC7GgTuQINBFMfpAoBEACumUCKKAzbKA55 QiPlDOBlbn0fuL0l+J26IUTSPLGnxO/guP36sHnjvmtIHmqMJHqruDrXJ+hil3Ue d10HLtzbzuHIP0EuUyh6u3YuHiLEGjCZPDPFe3mNxaVSDsQ/rGzDhMicRpBZZRP3 spdDxfY7hmBwcFSNKFyPciIQutk2Jer30dpoa9C0CtE2ndlrU91WqoDF/wd9JxVJ 5koFM1I11cmIxToMi9Sx3+V0trHkJJzQMhjtC7S+Ct0qazzy1vMXDkpEnH9atiee IE8RpO1E1dKIQ+gUSmHQg7DlkgzYQ2iFitWlwgbY7h7c45ZsTLzAthOpeFf3Zlvk /XtRyBFPrqcK9yKYfad2oyR5wHSRV4o+rFSFlEb5fGT8bYvWrkqq0E2p1Mz2DMJ4 HqJF9LnqMn3ZlnkwRe/AqQLcFn9fnITc1gxL7ZTWAdLYeACsFg7HotTsWoFA1ENu 6dAqk/Op0zXCRUxhMuSei88Hiur2Il/V6QlLdqb1oUv1Ra0dVrybZRsPyR6cHI53 Pr98ya6j8+aJky9eZcFUa6evQ+hxyvLMuQtCmrAqJ3piria5R8CVbs3ABRtApyru Dy2yJvt2KLwtcpStp1BupR5YK50rBCgaFlC5ou7+Ym8QJfe5zygQRl78fELAbQFj 7zyterTIaWFtKvsL7QxZ/sHb75bt7wARAQABiQREBBgBCgAPBQJTH6QKAhsCBQkB 4TOAAikJEA7FH82pT7U+wV0gBBkBCgAGBQJTH6QKAAoJEIA97kkaNHPnKkEP/ifZ IkCH7V1WeS5Mls8oiplwRYzSezuDYeqOH8toyT/2/1DLNCn8gKILEow8mfVtJbbB yG+MMhUoXCZ+gzTJ+dGQWu/hnctA9YhvsL0YJjcCEuJwl7kZFlb6IbsUJpty6ltL qdVunvcFFIUQythpwFdNYB9F9aNNPszSDegwdkkGST6+7au+Odq2OJYtbXLECHE6 8+10uKClix18vM9XuUZOp8nQQrYReT6h7dMX9uePuODKTxX/7O1w1JlCE5lVS02C RxEvv0cDfkBq1uKHrqF2hx6cZxRCIi7v3poeF8Yconvxva18IbOzwjZW6b50FkF+ yHuxNIb+AEiyELK5ijeJ6uemBifQBgRQq/RfmRLE0Vi+KxlmEdFK/TQnZSsR1jjH MvVWUcB1sHMgPLzJUuNJQXBw/Pvu3snY2V1fVUwRPjRJ+XWEsAWbvMtWYSY+oNGR NdwNz8u/csKq0U6WLmLj9rYs1xvHtfnXCSCvIjKLVX439bM7TBdk4tzZuNiI81Aw Rr1hu6vdKjbAm1HbxSyqki+6/b/uJcx+mXN6SNG49DYzTI7NwFGFFEhGbyTeo2xx Hiwvbkmue0AwzUH7yYLPGbZBhmboyWLXTdeAuaqSUK31l3PDNncwmp/Ay0Qy9kJe Cp621tM6L7lFhQ4yM0W4uXI/hAJZzZfiqcyCf7MATrMQALeumUhVN+XOl/u7WscA nHi5KQhhTLezfRLsGOp8cUSluY+hw18eppbJziiYNKzMg2EOROuLgE9gmI7Sg6Uv AzOmlr98BcAWcTkkYunYKxNXbmze2N/0+creQCdpLi6fTS37+CPlPHO+nDqRe+Nl Tubw+rpdxeOuuGgMX3uWkPF3zvshoXRIUjmNMiLidDtstGkpCX9XOxAwGbawENxM uP29jmetHG/IeKPqtqHG40PmF49hbV3HmNenmd+TNbg2x7i20w4yPfdg3R6rQMlc Ei+3uHXj4QKOb3tz1FXnyC649/qg2+CXjIYZIDocjqwsjEd9niUUeNntXyv7WWhe EiNhb8bxSB+ZoAEHjugHdst0/dZAjgq2G4cO0o+7d/Y4GcWvhhQ1eB8GKPRIDMMD d192MaloUrXxu9ZZgjJfJsRHErJ/BflaAZpICA/2LVCpsF4qG4bQZkZJt4Zn0mcb L2KUzO9Z+7RxvNKfU3szM0Dpp9I9bTrhBcN8UodkDSYBKicrvhfodPYFNREjpSio qd0gQydcdXG15JWftgAwR0HruT+mc5TBprD+CurSu1z4We6VvcnmH+hFYdu5HE+C H3RVcdhubnte1QKVs81VF5nY0Q7tXsq4Gp0AclppPd8Mo2X0evvld4uw5pTMnF8+ ak60UQqG4WP6T3flNr8s5uZxuQINBFUhuxYBEADcD2Mzt15AKdFhqxOO4Clgy4XS BO+m2gV0cQczkX7P+LblqgEXOL7W+HwFi9ML7y/us5Dx40fTNxgZQSbDlesbSwB0 e+uyI0aNDVgezAAm8b1OIj3hg9eiMpG+3Fmtx7xFxnCoIgjunsB6j2HruMd7nxo/ GVpbsBZUshJ2wBCPzyTT4NVthaWIiY6YRAlLOS/lsXBZ+YsgiQlrGOxNPDPSgRMG R/DXojdz0LnIi/0NBdKM8wBeqUvhNtxJdISOqkZ5Eo7msTSMYh36hRcrlAekSHcc JZR5/kxvcnlDLYem3sOx2tv+hupX2olDcb84OpfyOSruuDix/rkG0pQyVSiJUuTy Z13bejlEtXA70cD32BAdFKfDOGkpDApnOngTtXPIga8pYgb/uOdtKna0Kq+y9HIO POdaVpQkfj3cPP4RbhX9pel4+XRJRqG2ueXpKgofMLHPVhXBsaWijEFuM1LZjyGL ij5norqMcU5x53SLnDWb7YIg+4yMRHKq7xNQI66qGn4OdFWFBLui39vIVUXijjnY SWecptCwagXaQyKvowBlt3gUx9kvb08lBP4xzGK4Lf9Vulnx22AZjDM2cgm926pn YH6tFafUc/R3UZ/KKNyqaU8BTxP0wGW7BKwZp9KscNQX5HPCIYwR+MsNNxhe+ik+ msXjkJkliFOJhRYyfwARAQABiQIlBBgBCgAPBQJVIbsWAhsMBQkB4TOAAAoJEA7F H82pT7U+XrUQALjGShUI1df0Pl5hq81nXY6juNt8/aJ0DXF4ZJ1d/bvccxthssoM Jjp389+WfHIyYOwE1j5gyiePuFtr5XEdSgOPiwi97v3gzZ6QWED3dwQYVxH9kbGw qyUGfDVGEK6KwtQ95Shyb1xmIOolooShLWo376Y2N8SyJ72q57YuFTbDz/QPfTHw zGJX9CkGDViTL1pdWJI/Onv3DFn3dYNyvG5N3xCfjA81a/j7ZkSS1wFjmWqMUw6v Hy23uDSa818bK5Marqc6SbSJebAYAC4ujY4LIC+v57TlNbhV6MdpF758nP1q1L/S 5eXh3aZFpFyYWcMn83XUv/ewcew3tXLeRK7UBmm/QZGnz97bgkRYpr29EJA0s2Wa LRhSTCrBuUeqzQ2GIfNBaWC/d2ilpH+DTTxr73siZ67y7EyVq7sOzmkfJtAHYDiO MeHClVwxPXBHUTpnB3j1TBq/gRGqHPd+a8UscP96jAUjU8oBD4c2JltcUGnDbIUC rJyLGxR4NNL2/bCPDDbx6LG3DthgiLXjB5GKMhCWRoT1kb3Yr7UJi/kTIOdsOVNr mLBqRlZZebdCUO69uQuhM5wWdK4M0psXqrUPYznapGnED6ospzFN45uj9uALn+/7 NB5sJYfAbGevamkV+lss7SAnXxd6/x34znvcRLL+SRgX4fw5ATZBKnxNuQINBFUh vAYBEACo7iPCytu2SytGXmI9qRGizI+QulF8NISLmCN+9ITSk24dQAtDcnck5rIa b1dRuKoFu2JnCRuIlHA1WuLL7NFhmOgxX4WSTVws6lYSnTii490JL7BQOTrnfMZW S1/Mcuj5CvX51hsmNm2I2pAQ/9X26Rqpnd3YzjdpGBMHybF/s0V8CXLBlQTRKY7l 5HEg8t9nS9eIm+qyEDmXbIJXsEr3i2tYt3eevuDkLBz86/zGGExJtOJZqHVlZtV8 6btYPOo3R9f73IB80dML2eWz50i6NcKLPKJcMXwfJahjfeG0Wdo3Sv6tB9q4D/f0 iFnlLlXZpdjbouUNMZhWeeDZvLB4jDFrlRTD20lHba61P8W0B6ZWErRp5zSUl1R3 5Z+EdlroiXbsSOCq0IXO93N19iFRQPq75oIoEyGU0u5ktM/dAFKTMQ/ngbP2/jVu +gfwpBN5MqVsuEgf7FEf7rDB7ermqq7VJJgU9CRd2MxQcw1PKwAQfb51mkoAniwq WQPlfJd/GnfasshWe0L2vnwVvWftoBQA3JnY3+A+lsdYvUkU4EUHQXuOvC9znLAi WWVvSpB/86nCadJd7nwVNXcFS9luzy81O3TXui8Ns2Fd3Ze3KwcLDJ9Z1zxt0yMA rRSFcNXXrUTy/I0KM/BWVTkm+u25I0tLgKiPMuAimjCD5hH82QARAQABiQREBBgB CgAPAhsCBQJVIcIpBQkB4TmjAinBXSAEGQEKAAYFAlUhvAYACgkQE7XuWMCfs+Df vg//VNWTSJMcC6GN4EhTIhWnaPWUHobWcgdJSJDVlgK8Z/H5SIoa0YSlWRb0F6oi SARsOoqI6tiuctmbDGRGboY4+TJ4n9k7sRk4sX5yDFmrjRzXhS3RLQtb1/09N1Iw AOvmhE4oAuhjGbVjYGeYuHqOTRLllWyGShkiZDtz1J8j7pJ8azPnVR/ZfB2zq041 l9vazzkSFXFY6Ku1NuKGQgx68MGzUuzfx++FK+jDOt5l6V5VVg+atW8tCnpvm2C7 gp4ZbhiSNC1FgkIvCMSIjvfeysFs0Hl2jplBHearu42os+8YUuA1of1cEMyLRR7W 2nLKNZNZE+bz9/Nd101QBOW5gH2ELmHVpzEsNL0ZCoFGbNdTpYKvyW5TLbHy71qK n5jtelQ+wij1Nw7PnwjDuVQpwTk0kM7OmTpdcYfiHD/edXJ5IY5GlewgE2GSgi6S uVNC4RsOKcu6djzwEiZrESMCYbVQMlvcevO1RH8oMyGojPi/R6PwO60Ti/XNufww ZVzAdW0SFQtyOSAVgAyTCAGbwVRzkl2mZA2emzLIijT7RdU/uAA5i1jrJJR0E60j rMCDPs3JEU7G4m+G16BXJasVuU4sAi7gyiOEgRUSruBk/U7XRz1x0PheZMaDZstb WKc4ARGrv8kkXBEnwRD2J5gNdFSexUERy5uAslO3bAStBdgJEA7FH82pT7U+H0gQ AJgI95bmTC46gMH8mNlYu2zEZLHjHEMsA0E08pHLB3EXNjBdNgQhB7WU78rvkDjv wTPe/SNRC5Zk8UQnzxg3L+bNJRcRiuFP17OlPkxZxbeGp9Jl2sTYoq5yTyBj7WYE Ph09tfjn3qlSY9LwdX699DKzg4l2kIh4sgYEDmaS408gTRsykPsb/shxbXf1xXfE ByN3Uqm5cfekQ06YA06VbX2DLuBLbU/ToDnRlpytEUW8Is3pSa/zjXlNVfqhei0I Jy2KSCFIigBuSgW2n4KnadqrJgOW6ZyZswXqixgLEryuFuHYh45eAoyv4Q9Ds/Dc hoc31wzOO7w0Rx710REj+3ukAjZRBnYv0euiQe6SE4Jd4HaYndOzjrcbZ7KTbj5S ylOSUx6cPo1xr9MvtMISPfwUE7nVPsUcd0sdDMSpGdK9RDwGbM/NccsovtsebLGm IzX+8XQQ5WNrfq3AcmytQkc9ZdMFz69LeL2qEKCT3LCB7jFt4jEL4q5QcKQ9DtHO h9fjrvGH/JWMFwUGRPk2wj9fzg+zrTQ7xSEO31sybhk0b6165jVf1FwNFLf9V24f wmRI0QoYzYeLT8jg+6+S9u1SRgLG56JWvHnEQ42B7m+07XsBhwRTouJVfwA+yfnj 4YV3JAnV9sLAi15pITsi2N694aA2nyO/14e4Dz9ceYJh =8Jpe\n\u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; iQIcBAEBCgAGBQJWT6iBAAoJEBO17ljAn7PgnxIP/RevbXaCm2Q3ildI0YLjQFDr vSIGKsCjD9nZY3ETk+CNFGOL4aYWp96HWuQoMq7B6qlb/sLejN/Ssu3M0sxf2hNK pCIagZClqRchSBK+0UpAEIs98sf0sPakqKg0FlOJhuCsKHMUOxpQJ4qCDh6f24b2 cqKR8GjyUAgSeiiyN+DkDyqRYingQGAU5vzKepYzX+DMHC/izqQhrwQLVImv20wr 5pKZJDjfOpYUZRTuScV5Qwcgc0JYcMOjfgA93ZUA2zDrGIpw3dcCSMrpNQcvM6Cg 1mfiLZzkvPH3UkUOWhHCn/N2XaAF58joCaS+/bVUaXx02IbxJ1TTjqtCiH9491mE aaHeRCFYbkKCXWjuxCx1+VZN2yRk24rSkis/+LFgZm850fXgYfrqiyPRDlCMApdo 5JDUBTioyZz24vhqWpe0OZueu11DXtpU1G0BiheGrweXAAx0Yki8dRiPTXkavAMj oMBND9G7a1564KOe+t6V2qUyH50+3NaANvIiDJZbspX7yl8eVzPbwcGvtHzmHdnV pDh+38XUQEID5YJ/mdZh6evzmmTnQR1HVqPVrzs8SwIDO++tqj8DXTjID47c3VIl YhCMNlucciFxVn/sYI5qiJzCEMLMbvG+EhnoLNU4JGjfzo6I0RCpPfbrDfOsWJNi zYMz9htqusCQsGwUZSTZ =XBC5 \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; str4d has signed the following releases: 0.9.23 Releases 0.7.6 through 0.9.12 were signed by zzz with the following key: -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.6 (GNU/Linux) mQGiBEOjTnURBADegKKrIP6pz4+n57dqo3l9QrKhIklCtIxgJkL06ZJq5fKAnMLv GPaGXmn5vRrbo6QzHs/lGLG+ySWFWr9SsVstNKrwk+F1yGIERutl0BqMwX1esfN2 ugiZ3wB1yRu0PIrkm5cuDAFASFE+2lBjr1lfOrhw/dV+lLTcWx4NzkMzlwCgxgIk 4cqQMGaVkmtuICQdYmmMicUD/AmNSVJEm2XUvaS5fYWsHJG3+oNkdNGcx5SOMUdk PFwcSozqvT9FeIP76OVHAshQKeftE3utOFANQ/YomXEnypmwMxLLR+GPw5pMbKlK 6p+87aJZz+SA95E3ekmh7MmndvRd5RJDboUZy2H0FKX+FgaBlpsLl0uhT6uDuM/s 7nb0A/9nEAgICOU5SeXtO3jKY+RQvKyE0AblK7xVaU+Sn8ly0zauOJD13rycVGhu vLcAUVR3FKEjxafpvZ0ZPBo7AACjSDqAoCw/s/vt9gmrhHKiqN31PhYYLhKdfKTs 4LzWKTWKIAOwErkbYsMAXWKFT3LXsrEYvxq5j5m/6zMOwz2N7rQYenp6ICh6enop IDx6enpAbWFpbC5pMnA+iF8EExECAB8FAkOjTnUCGwMGCwkIBwMCBBUCCAMDFgIB Ah4BAheAAAoJEEFVdrqnbgvtxGsAn39SvQ3+ey87WDDG+TWArN6oU8gnAJ4zeAsA LUK37WZIt8OImZSxk37uQbkCDQRDo06VEAgAy2UeqsM5a+U6ZOWS9NQiILb3KbTL FeeAd2rn9oLSLpn5gDWycwUS0Q62JmbSMWy6m9aczpnxvwaBYXz6aCIvZmTNtaU6 vyR/6wfJDyiUWSHtCyjpyFFYJimANd8Y8dDCimvceI/ihEDVyBX0kkgUGRAn8t3e unaLXqhbfiLiFw/GG1MNxUMzHt55/+9AqLOfRZg0riZvDoV79K+1sYSs8n1WeaVc T3wTb+Cb7fKNN7GT1MUhcXIoYYY6FGwsy5EWFsxYBRervqHtBJog2SoNUa/6BFGr zX+LDjK9L3xMTr3+fHIt4gPR/Lt4nnfEzL+rjClz/Fazmv38BRwPuKahFwADBQgA nD/AvZCnbWSB6khAVMqva5ROaD0gV0/UejCelZdYfgfHeCmrcMNQ+wCyww2NPsih 9vB1w+AUE0pdH37k65VZN+2falUdzN+PFugJGuH2pmlVOprH2SuC5gKpGRvzUqV5 U0nJmT2okDpW/52asUDJJLu1g//A3qBP83WGvSKUZg/ZisZA0qTiHH4QpjklopXi sSxR2hT8Fr9gF9WmDa09wbxE2xh/EL7gvVg/vk0gwOJcsFd67bNC+KUMOnjhOP0T K0/Ah4TEEs/hHNe9RsyyWlMoIUsF8AhG71ISOrJ5lLSXNe151XEb5FzZRM8sD9Zq 0E3PjmLbdVhanYvsPnWK6YhJBBgRAgAJBQJDo06VAhsMAAoJEEFVdrqnbgvtXTwA njMu9ueCFbsjme7nwsz96PdazJcHAKCce17hGI25QNXDZyHohrjha6IxDg== =fAfi \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nReleases 0.6.1.31 through 0.7.5 were signed by Complication. His public key is: -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 Hello,\nI certify that below is my new public key, issued on 2007-11-24, valid until 2009-11-23, and its key fingerprint is:\n73CF 2862 87A7 E7D2 19FF DB66 FA1D FC6B 79FC CE33\nIf you have my old public key, and use it to verify this, you will notice that my old key expired on 2007-11-15. Apologies for being late with this update.\nFor people who want to copy the key directly from this message, but aren\u0026rsquo;t reading this using an e-mail program, please remember to delete the \u0026ldquo;- \u0026quot; escape sequences from the start and end marker of the public key block. Otherwise it won\u0026rsquo;t be recognized.\nComplication.\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux) mQGiBEdH5SYRBACzCum9jIjq+/G7ckuZ/TcFmaVYeBRE6OXPQozyrmTYtoCM2qGj DmvMJvKYiNiQVM42KiwlnqvaNtlgnXIZ6rcyLyn+bCI5cdX1SD5Rr5tgsgcXYA6Z l7usiFv1bTjD67piBehF130o+LZAJnVzI7JdpbA9SBY0mUwgKXLi0DAo8wCgiKOV UXC8+9X9vU1Mh/GyIrD4c3kD/iQOkYH4ajNaehTHNB31K+61ltpK9tMmcWtUY30A Z3q38jg/nmqqup/MYCtkvOqY4X9kujKzu01eSWSNZIE+BQSSd1cSsVD17OY3TL6B EvE+UFxh8OnDKs3tzJ0COnT/2zbgTavbWwqovoUE0P0PSYOFm2Co0BEQiCt9Tabc CxU3BACRWDvq7LFMRnHT+/OOJS6M442CYzy3+tIuc3ZAmZ8QwGsh4r1kd+5P1JTN YJCun6MPQEllJbRyHRBby76vFkWearRgnkpAmk2l1T2SXw3lip/SdmI0GgIzPSfQ 8WyNbMjQXyH8/3k2Y9rgrC0DttrJPYOcTFMNKPpeTR+HN3ZnibQ+Q29tcGxpY2F0 aW9uIChodHRwOi8vY29tcGxpY2F0aW9uLmkycCkgPGNvbXBsaWNhdGlvbkBtYWls LmkycD6IZQQTEQIAJQUCR0flJgIbAwUJA8JnAAYLCQgHAwIEFQIIAwMWAgECHgEC F4AACgkQ+h38a3n8zjP1yACfWkF1zjmlD0EzLaJRnefW5OHr10MAn0fgMyElK6ee AoPl2mTfxQQYOophuQQNBEdH5SYQEACTcoMJQBhyrr+EunLmEGNMO7D6RSBAtEKZ i5ctmhr/TCXMV9qjXkWISLZ9AS6z88rKozeOOK+QPBnc2FcEf77N04O5hwSdAyPH Qt7+umhiNQFQpZycJ5W87Y0ryERJygA5XyU47g7CGvuuOLgKGk0dDGCNFZGSblwI xtSh1CsrjWp23grFiBS0xvlU2VyuYUyrBuH5ip04pxmOyeRcaelkQerFhEXSRIR7 XFxl6JpfqWt2oWHmYbYD3RT6WHU+rpSF1Hyey+zoF2zXfRb+JD90MpBL1xIkpieQ Y69Cj5U5VRjEppJJowSmwgz+UyMnT2KLl45vJesPrMUaSgduHiIQo4LM5BcbbV+2 SC5i9xqbSJ+rc19Ftt9IEUZVMLole9PJC5Ff/h1qsabyueFuMIQkbiaUiNLOKl31 I+JAiDt0Xku2PEVCERg7Jq5AsTLB9D+zKqxbvFu+JvqSdlaCvlas2BYU5rBosszH TStK2XW/+poTKnjnbJl6nGC06BNQPhRFAwuXboyUC5fyiuG1HohvPmPIi6IejLUY G8A5nZ+7um/XpKlt2i5rdVRfN1BX3+aKHQeLmrc+EIORZUU32TrP4ceLtSDf+JOW 8N3vwzqKIPu42Y5KB8vnXEFSOkyt36OfEd6CcPKmncDyA4wJmfC+X3eoKcj+Yrh7 UMr0elyw4wADBg/9F7g+bTpT4wPXj5ax1i+4BdedjVlO3YBdhc4LP6MXipNU6yLl l63TJ8q/l8pvSkUWZXrO3a7OibM/MHp0Te/7sTmKib2/3MFwHTrtjgcZBF6wx8LD T3oa6O0IK8IRnRwNqeu83SxojvVY0wLz/hpUbnIrOcHMZjWLMJEfHkNBHn+1HhT5 tk9LRGu3j1oTpGh+DpdoPF5fggNu48YJ6n7etJJGW2MXQ++33aKeQSFrx+KlMtFW DSzg3KKSroB8Ex9wiKKWybagaed0YoP9BW3vIAaOeDpqK92UuTFz1Bte1DYiYU1e Rqq1xoBVhJXE5xzGmvS4/PIZMOL/bpKcuNxAgmwOVoaYoWZuIgePUaBbNvNg84HE RBjFMyfpzRCdPlWPZ18KcLUki3T58KzXEZ7WS5hC5lezwC6ET+wJusAt0A+Ik146 igayKfVnvhedQdqufWhQWNr+hDc5Fb/az8nTyNOflAhD3yHldjxgkCOV8wjqyS+4 iO33P5wW7o2QkZNWq8pyjsKRRJCtZ/PJ7FRGkUOjoC/gwhnGvBi0KoDcyBmfnPXp 3MAgrzk9LwiA7PlS7PyhyMx5mYpa90xlXzszweCIXzGfbm6ciCUAM3G3Qb+qa2dW 0u1X5L6bVtHVpYnr+5JOxCS4qwQvoK0QnHu6ezu4+rFutUJN35z6rFquejiITwQY EQIADwUCR0flJgIbDAUJA8JnAAAKCRD6HfxrefzOMzSZAJ9PmYNkW4Ia1qPqowg9 z4Ja+hJ3dgCeL3mqvOEHG7AcUQrSlc6xlC1vbNY= =rGxK\n\u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux) iD8DBQFHR/zm4tLxqYRsGn0RAtCfAJ9rz+tsyEbeUAHcogdzgSPfuiWOAwCfWaVn Aiib6V5wOPbYTy13ADmxhfE= =mPFq \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; ","description":"PGP keys used to sign I2P releases and where to obtain them","id":"ae494d28c5c0216d277398ccdcc21df5","section":"docs","title":"Release Signing Key","url":"/en/docs/develop/release-signing-key/"},{"categories":null,"content":"About Reseed Hosts New routers need a handful of peers to join the I2P network. Reseed hosts provide that initial bootstrap set over encrypted HTTPS downloads. Each reseed bundle is signed by the host, preventing tampering by unauthenticated parties. Established routers may occasionally reseed if their peer set becomes stale.\nNetwork Bootstrap Process When an I2P router first starts or has been offline for an extended period, it requires RouterInfo data to connect to the network. Since the router has no existing peers, it cannot obtain this information from within the I2P network itself. The reseed mechanism solves this bootstrap problem by providing RouterInfo files from trusted external HTTPS servers.\nThe reseed process delivers 75-100 RouterInfo files in a single cryptographically signed bundle. This ensures new routers can quickly establish connections without exposing them to man-in-the-middle attacks that could isolate them into separate, untrusted network partitions.\nCurrent Network Status As of October 2025, the I2P network operates with router version 2.10.0 (API version 0.9.67). The reseed protocol introduced in version 0.9.14 remains stable and unchanged in its core functionality. The network maintains multiple independent reseed servers distributed globally to ensure availability and censorship resistance.\nThe service checki2p monitors all I2P reseed servers every 4 hours, providing real-time status checks and availability metrics for the reseed infrastructure.\nSU3 File Format Specification The SU3 file format is the foundation of I2P\u0026rsquo;s reseed protocol, providing cryptographically signed content delivery. Understanding this format is essential for implementing reseed servers and clients.\nFile Structure The SU3 format consists of three main components: header (40+ bytes), content (variable length), and signature (length specified in header).\nHeader Format (Bytes 0-39 minimum) Byte Range Field Description 0-5Magic NumberASCII string \"I2Psu3\" (0x493250737533) 6ReservedUnused, must be 0x00 7File Format VersionCurrent version: 0x00 8-9Signature TypeBig-endian 16-bit integer. Type 6 = RSA-4096-SHA512 (reseed standard) 10-11Signature LengthBig-endian 16-bit integer. 512 bytes (0x0200) for RSA-4096 12ReservedUnused, must be 0x00 13Version LengthMinimum 16 bytes (0x10) for compatibility 14ReservedUnused, must be 0x00 15Signer ID LengthLength of UTF-8 signer identifier string 16-23Content LengthBig-endian 64-bit integer, length of content in bytes 24ReservedUnused, must be 0x00 25File Type0x00 = ZIP, 0x01 = XML, 0x02 = HTML, 0x03 = XML.GZ, 0x04 = TXT.GZ, 0x05 = DMG, 0x06 = EXE 26ReservedUnused, must be 0x00 27Content Type0x00 = unknown, 0x01 = router update, 0x02 = plugin, 0x03 = reseed, 0x04 = news, 0x05 = blocklist 28-39PaddingUnused, must be all zeros 40-55Version StringASCII version string, padded with zeros (minimum 16 bytes) 56-...Signer IDUTF-8 encoded signer identifier (e.g., \"user@mail.i2p\") Reseed-Specific SU3 Parameters For reseed bundles, the SU3 file must have the following characteristics:\nFile name: Must be exactly i2pseeds.su3 Content Type (byte 27): 0x03 (RESEED) File Type (byte 25): 0x00 (ZIP) Signature Type (bytes 8-9): 0x0006 (RSA-4096-SHA512) Version String: Unix timestamp in ASCII (seconds since epoch, date +%s format) Signer ID: Email-style identifier matching the X.509 certificate CN Network ID Query Parameter Since version 0.9.42, routers append ?netid=2 to reseed requests. This prevents cross-network connections, as test networks use different network IDs. The current I2P production network uses network ID 2.\nExample request: https://reseed.example.com/i2pseeds.su3?netid=2\nZIP Content Structure The content section (after the header, before the signature) contains a standard ZIP archive with the following requirements:\nCompression: Standard ZIP compression (DEFLATE) File count: Typically 75-100 RouterInfo files Directory structure: All files must be at the top level (no subdirectories) File naming: routerInfo-{44-character-base64-hash}.dat Base64 alphabet: Must use I2P\u0026rsquo;s modified base64 alphabet The I2P base64 alphabet differs from standard base64 by using - and ~ instead of + and / to ensure filesystem and URL compatibility.\nCryptographic Signature The signature covers the entire file from byte 0 through the end of the content section. The signature itself is appended after the content.\nSignature Algorithm (RSA-4096-SHA512) Compute SHA-512 hash of bytes 0 through end of content Sign the hash using \u0026ldquo;raw\u0026rdquo; RSA (NONEwithRSA in Java terminology) Pad signature with leading zeros if necessary to reach 512 bytes Append 512-byte signature to the file Signature Verification Process Clients must:\nRead bytes 0-11 to determine signature type and length Read entire header to locate content boundaries Stream content while computing SHA-512 hash Extract signature from end of file Verify signature using signer\u0026rsquo;s RSA-4096 public key Reject file if signature verification fails Certificate Trust Model Reseed signer keys are distributed as self-signed X.509 certificates with RSA-4096 keys. These certificates are included in I2P router packages in the certificates/reseed/ directory.\nCertificate format:\nKey type: RSA-4096 Signature: Self-signed Subject CN: Must match Signer ID in SU3 header Validity dates: Clients should enforce certificate validity periods Running a Reseed Host Operating a reseed service requires careful attention to security, reliability, and network diversity requirements. More independent reseed hosts increase resilience and make it harder for attackers or censors to block new routers from joining.\nTechnical Requirements Server Specifications Operating System: Unix/Linux (Ubuntu, Debian, FreeBSD tested and recommended) Connectivity: Static IPv4 address required, IPv6 recommended but optional CPU: Minimum 2 cores RAM: Minimum 2 GB Bandwidth: Approximately 15 GB per month Uptime: 24/7 operation required I2P Router: Well-integrated I2P router running continuously Software Requirements Java: JDK 8 or later (Java 17+ will be required starting with I2P 2.11.0) Web Server: nginx or Apache with reverse proxy support (Lighttpd no longer supported due to X-Forwarded-For header limitations) TLS/SSL: Valid TLS certificate (Let\u0026rsquo;s Encrypt, self-signed, or commercial CA) DDoS Protection: fail2ban or equivalent (mandatory, not optional) Reseed Tools: Official reseed-tools from https://i2pgit.org/idk/reseed-tools Security Requirements HTTPS/TLS Configuration Protocol: HTTPS only, no HTTP fallback TLS Version: Minimum TLS 1.2 Cipher Suites: Must support strong ciphers compatible with Java 8+ Certificate CN/SAN: Must match the served URL hostname Certificate Type: May be self-signed if communicated with dev team, or issued by recognized CA Certificate Management SU3 signing certificates and TLS certificates serve different purposes:\nTLS Certificate (certificates/ssl/): Secures HTTPS transport SU3 Signing Certificate (certificates/reseed/): Signs reseed bundles Both certificates must be provided to the reseed coordinator (zzz@mail.i2p) for inclusion in router packages.\nDDoS and Scraping Protection Reseed servers face periodic attacks from buggy implementations, botnets, and malicious actors attempting to scrape the network database. Protection measures include:\nfail2ban: Required for rate limiting and attack mitigation Bundle Diversity: Deliver different RouterInfo sets to different requestors Bundle Consistency: Deliver same bundle to repeated requests from same IP within configurable time window IP Logging Restrictions: Do not publicize logs or IP addresses (privacy policy requirement) Implementation Methods Method 1: Official reseed-tools (Recommended) The canonical implementation maintained by the I2P project. Repository: https://i2pgit.org/idk/reseed-tools\nInstallation:\n# Install dependencies sudo apt-get install golang git # Clone repository git clone https://i2pgit.org/idk/reseed-tools.git cd reseed-tools # Build make # Generate keys and start server (first run) ./reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/path/to/i2p/netDb \\ --tlsHost=your-domain.tld \\ --port=8443 On first run, the tool will generate:\nyour-email@mail.i2p.crt (SU3 signing certificate) your-email@mail.i2p.pem (SU3 signing private key) your-email@mail.i2p.crl (Certificate revocation list) TLS certificate and key files Features:\nAutomatic SU3 bundle generation (350 variations, 77 RouterInfos each) Built-in HTTPS server Rebuild cache every 9 hours via cron X-Forwarded-For header support with --trustProxy flag Compatible with reverse proxy configurations Production Deployment:\n# Create systemd service cat \u0026gt; /etc/systemd/system/i2p-reseed.service \u0026lt;\u0026lt; EOF [Unit] Description=I2P Reseed Server After=network.target [Service] Type=simple User=i2p-reseed WorkingDirectory=/opt/i2p-reseed ExecStart=/opt/i2p-reseed/reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/var/lib/i2p/netDb \\ --port=8443 \\ --ip=127.0.0.1 \\ --trustProxy Restart=always [Install] WantedBy=multi-user.target EOF systemctl enable i2p-reseed systemctl start i2p-reseed Method 2: Python Implementation (pyseeder) Alternative implementation by PurpleI2P project: https://github.com/PurpleI2P/pyseeder\npip install pyseeder # Generate SU3 file echo \u0026#34;your_password\u0026#34; | pyseeder reseed \\ --netdb /path/to/netDb \\ --private-key priv_key.pem \\ --outfile i2pseeds.su3 \\ --signer-id user@mail.i2p # Serve via built-in server pyseeder serve \\ --port 8443 \\ --host 0.0.0.0 \\ --private-key priv_key.pem \\ --cert user_at_mail.i2p.crt \\ --file i2pseeds.su3 Method 3: Docker Deployment For containerized environments, several Docker-ready implementations exist:\nDivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd/i2p-tools-1: Adds Tor onion service and IPFS support Reverse Proxy Configuration nginx Configuration upstream i2p_reseed { server 127.0.0.1:8443; } server { listen 443 ssl http2; server_name reseed.example.com; ssl_certificate /path/to/tls-cert.crt; ssl_certificate_key /path/to/tls-key.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://i2p_reseed; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; } } Apache Configuration \u0026lt;VirtualHost *:443\u0026gt; ServerName reseed.example.com SSLEngine on SSLCertificateFile /path/to/tls-cert.crt SSLCertificateKeyFile /path/to/tls-key.key SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 ProxyRequests Off \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; ProxyPass / http://127.0.0.1:8443/ ProxyPassReverse / http://127.0.0.1:8443/ \u0026lt;/VirtualHost\u0026gt; Registration and Coordination To include your reseed server in the official I2P package:\nComplete setup and testing Send both certificates (SU3 signing and TLS) to the reseed coordinator Contact: zzz@mail.i2p or zzz@i2pmail.org Join #i2p-dev on IRC2P for coordination with other operators Operational Best Practices Monitoring and Logging Enable Apache/nginx combined log format for statistics Implement log rotation (logs grow rapidly) Monitor bundle generation success and rebuild times Track bandwidth usage and request patterns Never publicize IP addresses or detailed access logs Maintenance Schedule Every 9 hours: Rebuild SU3 bundle cache (automated via cron) Weekly: Review logs for attack patterns Monthly: Update I2P router and reseed-tools As needed: Renew TLS certificates (automate with Let\u0026rsquo;s Encrypt) Port Selection Default: 8443 (recommended) Alternative: Any port between 1024-49151 Port 443: Requires root privileges or port forwarding (iptables redirect recommended) Example port forwarding:\niptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port 8443 Alternative Reseed Methods Other bootstrap options help users behind restrictive networks:\nFile-Based Reseed Introduced in version 0.9.16, file-based reseeding allows users to manually load RouterInfo bundles. This method is particularly useful for users in censored regions where HTTPS reseed servers are blocked.\nProcess:\nA trusted contact generates an SU3 bundle using their router Bundle is transferred via email, USB drive, or other out-of-band channel User places i2pseeds.su3 in I2P configuration directory Router automatically detects and processes the bundle on restart Documentation: /blog/2020/06/07/help-your-friends-join-i2p-by-sharing-reseed-bundles/\nUse Cases:\nUsers behind national firewalls blocking reseed servers Isolated networks requiring manual bootstrap Testing and development environments Cloudflare-Proxied Reseeding Routing reseed traffic through Cloudflare\u0026rsquo;s CDN provides several advantages for operators in high-censorship regions.\nBenefits:\nOrigin server IP address hidden from clients DDoS protection via Cloudflare\u0026rsquo;s infrastructure Geographic load distribution via edge caching Improved performance for global clients Implementation Requirements:\n--trustProxy flag enabled in reseed-tools Cloudflare proxy enabled for DNS record Proper X-Forwarded-For header handling Important Considerations:\nCloudflare port restrictions apply (must use supported ports) Same-client bundle consistency requires X-Forwarded-For support SSL/TLS configuration managed by Cloudflare Documentation: https://homepage.np-tokumei.net/post/notes-i2p-reseed-over-cloudflare/\nCensorship-Resistant Strategies Research by Nguyen Phong Hoang (USENIX FOCI 2019) identifies additional bootstrap methods for censored networks:\nCloud Storage Providers Box, Dropbox, Google Drive, OneDrive: Host SU3 files on public links Advantage: Difficult to block without disrupting legitimate services Limitation: Requires manual URL distribution to users IPFS Distribution Host reseed bundles on InterPlanetary File System Content-addressed storage prevents tampering Resilient to takedown attempts Tor Onion Services Reseed servers accessible via .onion addresses Resistant to IP-based blocking Requires Tor client on user\u0026rsquo;s system Research Documentation: https://homepage.np-tokumei.net/post/notes-censorship-resistant-i2p-reseeding/\nCountries with Known I2P Blocking As of 2025, the following countries are confirmed to block I2P reseed servers:\nChina Iran Oman Qatar Kuwait Users in these regions should utilize alternative bootstrap methods or censorship-resistant reseeding strategies.\nProtocol Details for Implementers Reseed Request Specification Client Behavior Server Selection: Router maintains hardcoded list of reseed URLs Random Selection: Client randomly selects server from available list Request Format: GET /i2pseeds.su3?netid=2 HTTP/1.1 User-Agent: Should mimic common browsers (e.g., \u0026ldquo;Wget/1.11.4\u0026rdquo;) Retry Logic: If SU3 request fails, fall back to index page parsing Certificate Validation: Verify TLS certificate against system trust store SU3 Signature Validation: Verify signature against known reseed certificates Server Behavior Bundle Selection: Select pseudo-random subset of RouterInfos from netDb Client Tracking: Identify requests by source IP (respecting X-Forwarded-For) Bundle Consistency: Return same bundle to repeat requests within time window (typically 8-12 hours) Bundle Diversity: Return different bundles to different clients for network diversity Content-Type: application/octet-stream or application/x-i2p-reseed RouterInfo File Format Each .dat file in the reseed bundle contains a RouterInfo structure:\nFile Naming: routerInfo-{base64-hash}.dat\nHash is 44 characters using I2P base64 alphabet Example: routerInfo-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn.dat File Contents:\nRouterIdentity (router hash, encryption key, signing key) Publication timestamp Router addresses (IP, port, transport type) Router capabilities and options Signature covering all above data Network Diversity Requirements To prevent network centralization and enable Sybil attack detection:\nNo complete NetDb dumps: Never serve all RouterInfos to single client Random sampling: Each bundle contains different subset of available peers Minimum bundle size: 75 RouterInfos (increased from original 50) Maximum bundle size: 100 RouterInfos Freshness: RouterInfos should be recent (within 24 hours of generation) IPv6 Considerations Current Status (2025):\nSeveral reseed servers show IPv6 unresponsiveness Clients should prefer or force IPv4 for reliability IPv6 support is recommended for new deployments but not critical Implementation Note: When configuring dual-stack servers, ensure both IPv4 and IPv6 listen addresses function correctly, or disable IPv6 if it cannot be properly supported.\nSecurity Considerations Threat Model The reseed protocol defends against:\nMan-in-the-middle attacks: RSA-4096 signatures prevent bundle tampering Network partitioning: Multiple independent reseed servers prevent single point of control Sybil attacks: Bundle diversity limits attacker\u0026rsquo;s ability to isolate users Censorship: Multiple servers and alternative methods provide redundancy The reseed protocol does NOT defend against:\nCompromised reseed servers: If attacker controls reseed certificate private keys Complete network blocking: If all reseed methods are blocked in a region Long-term monitoring: Reseed requests reveal IP attempting to join I2P Certificate Management Private Key Security:\nStore SU3 signing keys offline when not in use Use strong passwords for key encryption Maintain secure backups of keys and certificates Consider hardware security modules (HSMs) for high-value deployments Certificate Revocation:\nCertificate Revocation Lists (CRLs) distributed via news feed Compromised certificates can be revoked by coordinator Routers automatically update CRLs with software updates Attack Mitigation DDoS Protection:\nfail2ban rules for excessive requests Rate limiting at web server level Connection limits per IP address Cloudflare or similar CDN for additional layer Scraping Prevention:\nDifferent bundles per requesting IP Time-based bundle caching per IP Logging patterns that indicate scraping attempts Coordination with other operators on detected attacks Testing and Validation Testing Your Reseed Server Method 1: Fresh Router Install Install I2P on clean system Add your reseed URL to configuration Remove or disable other reseed URLs Start router and monitor logs for successful reseed Verify connection to network within 5-10 minutes Expected log output:\nReseed got 77 router infos from https://your-reseed.example.com/i2pseeds.su3?netid=2 with 0 errors Reseed complete, 77 received Method 2: Manual SU3 Validation # Download bundle curl -k -A \u0026#34;Wget/1.11.4\u0026#34; https://your-reseed.example.com/i2pseeds.su3 \u0026gt; test.su3 # Verify it\u0026#39;s a valid SU3 file hexdump -C test.su3 | head -n 3 # Should show: 49 32 50 73 75 33 (I2Psu3) # Extract content (requires su3 tools) java -cp /path/to/i2p.jar net.i2p.crypto.SU3File verify test.su3 your-cert.crt # Unzip content # (Extract content section, skip header+signature, then unzip) Method 3: checki2p Monitoring The service at https://checki2p.com/reseed performs automated checks every 4 hours on all registered I2P reseed servers. This provides:\nAvailability monitoring Response time metrics TLS certificate validation SU3 signature verification Historical uptime data Once your reseed is registered with the I2P project, it will automatically appear on checki2p within 24 hours.\nTroubleshooting Common Issues Issue: \u0026ldquo;Unable to read signing key\u0026rdquo; on first run\nSolution: This is expected. Answer \u0026lsquo;y\u0026rsquo; to generate new keys. Issue: Router fails to verify signature\nCause: Certificate not in router\u0026rsquo;s trust store Solution: Place certificate in ~/.i2p/certificates/reseed/ directory Issue: Same bundle delivered to different clients\nCause: X-Forwarded-For header not properly forwarded Solution: Enable --trustProxy and configure reverse proxy headers Issue: \u0026ldquo;Connection refused\u0026rdquo; errors\nCause: Port not accessible from internet Solution: Check firewall rules, verify port forwarding Issue: High CPU usage during bundle rebuild\nCause: Normal behavior when generating 350+ SU3 variations Solution: Ensure adequate CPU resources, consider reducing rebuild frequency Reference Information Official Documentation Reseed Contributors Guide: /guides/creating-and-running-an-i2p-reseed-server/ Reseed Policy Requirements: /guides/reseed-policy/ SU3 Specification: /docs/specs/updates/ Reseed Tools Repository: https://i2pgit.org/idk/reseed-tools Reseed Tools Documentation: https://eyedeekay.github.io/reseed-tools/ Alternative Implementations PurpleI2P pyseeder: https://github.com/PurpleI2P/pyseeder DivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd i2p-tools-1: https://github.com/RTradeLtd/i2p-tools-1 Python WSGI reseeder: https://github.com/torbjo/i2p-reseeder Community Resources I2P Forum: https://i2pforum.net/ Gitea Repository: https://i2pgit.org/I2P_Developers/i2p.i2p IRC: #i2p-dev on IRC2P Status Monitoring: https://checki2p.com/reseed Version History 0.9.14 (2014): SU3 reseed format introduced 0.9.16 (2014): File-based reseeding added 0.9.42 (2019): Network ID query parameter requirement 2.0.0 (2022): SSU2 transport protocol introduced 2.4.0 (2024): NetDB isolation and security improvements 2.6.0 (2024): I2P-over-Tor connections blocked 2.10.0 (2025): Current stable release (as of September 2025) Signature Type Reference Type Code Algorithm Key Size Signature Size Hash DSA-SHA10DSA1024-bit40 bytesSHA-1 ECDSA-SHA256-P2561ECDSAP-25664 bytesSHA-256 ECDSA-SHA384-P3842ECDSAP-38496 bytesSHA-384 ECDSA-SHA512-P5213ECDSAP-521132 bytesSHA-512 RSA-SHA256-20484RSA2048-bit256 bytesSHA-256 RSA-SHA384-30725RSA3072-bit384 bytesSHA-384 RSA-SHA512-40966RSA4096-bit512 bytesSHA-512 EdDSA-SHA512-Ed255197EdDSAEd2551964 bytesSHA-512 Reseed Standard: Type 6 (RSA-SHA512-4096) is required for reseed bundles.\nAppreciation Thanks to every reseed operator for keeping the network accessible and resilient. Special recognition to the following contributors and projects:\nzzz: Long-time I2P developer and reseed coordinator idk: Current maintainer of reseed-tools and release manager Nguyen Phong Hoang: Research on censorship-resistant reseeding strategies PurpleI2P Team: Alternative I2P implementations and tools checki2p: Automated monitoring service for reseed infrastructure The I2P network\u0026rsquo;s decentralized reseed infrastructure represents a collaborative effort by dozens of operators worldwide, ensuring that new users can always find a path to join the network regardless of local censorship or technical barriers.\n","description":"Operating reseed services and alternate bootstrap methods","id":"02dba83ad9e38e1355d624c0d4fa28aa","section":"docs","title":"Reseed Hosts","url":"/en/docs/misc/reseed/"},{"categories":null,"content":"Overview This document provides a comprehensive technical specification of I2P configuration files used by the router and various applications. It covers file format specifications, property definitions, and implementation details verified against the I2P source code and official documentation.\nScope Router configuration files and formats Client application configurations I2PTunnel tunnel configurations File format specifications and implementation Version-specific features and deprecations Implementation Notes Configuration files are read and written using DataHelper.loadProps() and storeProps() methods in the I2P core library. The file format differs significantly from the serialized format used in I2P protocols (see Common Structures Specification - Type Mapping).\nGeneral Configuration File Format I2P configuration files follow a modified Java Properties format with specific exceptions and constraints.\nFormat Specification Based on Java Properties with the following critical differences:\nEncoding MUST use UTF-8 encoding (NOT ISO-8859-1 as in standard Java Properties) Implementation: Uses DataHelper.getUTF8() utilities for all file operations Escape Sequences NO escape sequences are recognized (including backslash \\) Line continuation is NOT supported Backslash characters are treated as literal Comment Characters # starts a comment in any position on a line ; starts a comment only when in column 1 ! does NOT start a comment (differs from Java Properties) Key-Value Separators = is the ONLY valid key-value separator : is NOT recognized as a separator Whitespace is NOT recognized as a separator Whitespace Handling Leading and trailing whitespace is NOT trimmed on keys Leading and trailing whitespace IS trimmed on values Line Processing Lines without = are ignored (treated as comments or blank lines) Empty values (key=) are supported as of version 0.9.10 Keys with empty values are stored and retrieved normally Character Restrictions Keys may NOT contain:\n# (hash/pound sign) = (equals sign) \\n (newline character) Cannot start with ; (semicolon) Values may NOT contain:\n# (hash/pound sign) \\n (newline character) Cannot start or end with \\r (carriage return) Cannot start or end with whitespace (trimmed automatically) File Sorting Configuration files need not be sorted by key. However, most I2P applications sort keys alphabetically when writing configuration files to facilitate:\nManual editing Version control diff operations Human readability Implementation Details Reading Configuration Files // Method signature from net.i2p.data.DataHelper public static Properties loadProps(File file) Behavior:\nReads UTF-8 encoded files Enforces all format rules described above Validates character restrictions Returns empty Properties object if file doesn\u0026rsquo;t exist Throws IOException for read errors Writing Configuration Files // Method signature from net.i2p.data.DataHelper public static void storeProps(Properties props, File file) Behavior:\nWrites UTF-8 encoded files Sorts keys alphabetically (unless OrderedProperties used) Sets file permissions to mode 600 (user read/write only) as of version 0.8.1 Throws IllegalArgumentException for invalid characters in keys or values Throws IOException for write errors Format Validation The implementation performs strict validation:\nKeys and values are checked for prohibited characters Invalid entries cause exceptions during write operations Reading silently ignores malformed lines (lines without =) Format Examples Valid Configuration File # This is a comment ; This is also a comment (column 1 only) key.with.dots=value with spaces another_key=value=with=equals empty.value= numeric.value=12345 unicode.value=こんにちは Invalid Configuration Examples # INVALID: Key contains equals sign invalid=key=value # INVALID: Key contains hash invalid#key=value # INVALID: Value contains newline (implicit) key=value continues here # INVALID: Semicolon comment not in column 1 (treated as key) ; not.a.comment=value Core Library and Router Configuration Clients Configuration (clients.config) Location: $I2P_CONFIG_DIR/clients.config (legacy) or $I2P_CONFIG_DIR/clients.config.d/ (modern)\nConfiguration Interface: Router console at /configclients\nFormat Change: Version 0.9.42 (August 2019)\nDirectory Structure (Version 0.9.42+) As of release 0.9.42, the default clients.config file is automatically split into individual configuration files:\n$I2P_CONFIG_DIR/ ├── clients.config.d/ │ ├── 00-webConsole.config │ ├── 01-i2ptunnel.config │ ├── 02-i2psnark.config │ ├── 03-susidns.config │ └── ... └── clients.config (legacy, auto-migrated) Migration Behavior:\nOn first run after upgrade to 0.9.42+, monolithic file is split automatically Properties in split files are prefixed with clientApp.0. Legacy format still supported for backward compatibility Split format enables modular packaging and plugin management Property Format Lines are of the form clientApp.x.prop=val, where x is the app number.\nApp numbering requirements:\nMUST start with 0 MUST be consecutive (no gaps) Order determines startup sequence Required Properties main Type: String (fully qualified class name) Required: Yes Description: The constructor or main() method in this class will be invoked depending on client type (managed vs. unmanaged) Example: clientApp.0.main=net.i2p.router.web.RouterConsoleRunner Optional Properties name Type: String Required: No Description: Display name shown in router console Example: clientApp.0.name=Router Console args Type: String (space or tab separated) Required: No Description: Arguments passed to main class constructor or main() method Quoting: Arguments containing spaces or tabs may be quoted with ' or \u0026quot; Example: clientApp.0.args=-d $CONFIG/eepsite delay Type: Integer (seconds) Required: No Default: 120 Description: Seconds to wait before starting the client Overrides: Overridden by onBoot=true (sets delay to 0) Special Values: \u0026lt; 0: Wait for router to reach RUNNING state, then start immediately in new thread = 0: Run immediately in same thread (exceptions propagate to console) \u0026gt; 0: Start after delay in new thread (exceptions logged, not propagated) onBoot Type: Boolean Required: No Default: false Description: Forces delay of 0, overrides explicit delay setting Use Case: Start critical services immediately at router boot startOnLoad Type: Boolean Required: No Default: true Description: Whether to start the client at all Use Case: Disable clients without removing configuration Plugin-Specific Properties These properties are used only by plugins (not core clients):\nstopargs Type: String (space or tab separated) Description: Arguments passed to stop the client Variable Substitution: Yes (see below) uninstallargs Type: String (space or tab separated) Description: Arguments passed to uninstall the client Variable Substitution: Yes (see below) classpath Type: String (comma-separated paths) Description: Additional classpath elements for the client Variable Substitution: Yes (see below) Variable Substitution (Plugins Only) The following variables are substituted in args, stopargs, uninstallargs, and classpath for plugins:\nVariable Expands To Example $I2P Base I2P installation directory /usr/share/i2p $CONFIG User configuration directory ~/.i2p $PLUGIN Plugin directory ~/.i2p/plugins/foo $OS Operating system name linux $ARCH Architecture name amd64 Note: Variable substitution is performed only for plugins, not for core clients.\nClient Types Managed Clients Constructor is called with RouterContext and ClientAppManager parameters Client must implement ClientApp interface Lifecycle controlled by router Can be started, stopped, and restarted dynamically Unmanaged Clients main(String[] args) method is called Run in separate thread Lifecycle not managed by router Legacy client type Example Configuration # Router Console (core client) clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=-d $CONFIG/eepsite clientApp.0.delay=0 clientApp.0.onBoot=true clientApp.0.startOnLoad=true # I2PTunnel (core client) clientApp.1.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.1.name=I2PTunnel clientApp.1.args= clientApp.1.delay=120 clientApp.1.startOnLoad=true # Plugin Example clientApp.2.main=org.example.plugin.PluginMain clientApp.2.name=Example Plugin clientApp.2.args=-config $PLUGIN/config.properties clientApp.2.stopargs=-shutdown clientApp.2.uninstallargs=-remove $PLUGIN clientApp.2.classpath=$PLUGIN/lib/plugin.jar,$PLUGIN/lib/dep.jar clientApp.2.delay=240 clientApp.2.startOnLoad=true Logger Configuration (logger.config) Location: $I2P_CONFIG_DIR/logger.config\nConfiguration Interface: Router console at /configlogging\nProperties Reference Console Buffer Configuration logger.consoleBufferSize Type: Integer Default: 20 Description: Maximum number of log messages to buffer in console Range: 1-1000 recommended Date and Time Formatting logger.dateFormat Type: String (SimpleDateFormat pattern) Default: From system locale Example: HH:mm:ss.SSS Documentation: Java SimpleDateFormat Log Levels logger.defaultLevel Type: Enum Default: ERROR Values: CRIT, ERROR, WARN, INFO, DEBUG Description: Default logging level for all classes logger.minimumOnScreenLevel Type: Enum Default: CRIT Values: CRIT, ERROR, WARN, INFO, DEBUG Description: Minimum level for messages shown on screen logger.record.{class} Type: Enum Values: CRIT, ERROR, WARN, INFO, DEBUG Description: Per-class logging level override Example: logger.record.net.i2p.router.transport.udp=DEBUG Display Options logger.displayOnScreen Type: Boolean Default: true Description: Whether to display log messages in console output logger.dropDuplicates Type: Boolean Default: true Description: Drop duplicate consecutive log messages logger.dropOnOverflow Type: Boolean Default: false Description: Drop messages when buffer is full (vs. blocking) Flushing Behavior logger.flushInterval Type: Integer (seconds) Default: 29 Since: Version 0.9.18 Description: How often to flush log buffer to disk Format Configuration logger.format Type: String (character sequence) Description: Log message format template Format Characters: d = date/time c = class name t = thread name p = priority (log level) m = message Example: dctpm produces [timestamp] [class] [thread] [level] message Compression (Version 0.9.56+) logger.gzip Type: Boolean Default: false Since: Version 0.9.56 Description: Enable gzip compression for rotated log files logger.minGzipSize Type: Integer (bytes) Default: 65536 Since: Version 0.9.56 Description: Minimum file size to trigger compression (64 KB default) File Management logger.logBufferSize Type: Integer (bytes) Default: 1024 Description: Maximum messages to buffer before flushing logger.logFileName Type: String (file path) Default: logs/log-@.txt Description: Log file naming pattern (@ replaced with rotation number) logger.logFilenameOverride Type: String (file path) Description: Override for log file name (disables rotation pattern) logger.logFileSize Type: String (size with unit) Default: 10M Units: K (kilobytes), M (megabytes), G (gigabytes) Example: 50M, 1G logger.logRotationLimit Type: Integer Default: 2 Description: Highest rotation file number (log-0.txt through log-N.txt) Example Configuration # Basic logging configuration logger.consoleBufferSize=50 logger.dateFormat=yyyy-MM-dd HH:mm:ss.SSS logger.defaultLevel=WARN logger.displayOnScreen=true logger.dropDuplicates=true logger.dropOnOverflow=false # Flushing and format logger.flushInterval=30 logger.format=dctpm # File management logger.logBufferSize=2048 logger.logFileName=logs/log-@.txt logger.logFileSize=25M logger.logRotationLimit=5 # Compression (0.9.56+) logger.gzip=true logger.minGzipSize=131072 # On-screen filtering logger.minimumOnScreenLevel=ERROR # Per-class overrides logger.record.net.i2p.router.transport=INFO logger.record.net.i2p.router.tunnel=DEBUG logger.record.net.i2p.crypto=WARN Plugin Configuration Individual Plugin Configuration (plugins/*/plugin.config) Location: $I2P_CONFIG_DIR/plugins/{plugin-name}/plugin.config\nFormat: Standard I2P configuration file format\nDocumentation: Plugin Specification\nRequired Properties name Type: String Required: Yes Description: Plugin display name Example: name=I2P Plugin Example key Type: String (public key) Required: Yes (omit for SU3 signed plugins) Description: Plugin signing public key for verification Format: Base64-encoded signing key signer Type: String Required: Yes Description: Plugin signer identity Example: signer=user@example.i2p version Type: String (VersionComparator format) Required: Yes Description: Plugin version for update checking Format: Semantic versioning or custom comparable format Example: version=1.2.3 Display Properties date Type: Long (Unix timestamp milliseconds) Description: Plugin release date author Type: String Description: Plugin author name websiteURL Type: String (URL) Description: Plugin website URL updateURL Type: String (URL) Description: Update check URL for plugin updateURL.su3 Type: String (URL) Since: Version 0.9.15 Description: SU3 format update URL (preferred) description Type: String Description: English plugin description description_{language} Type: String Description: Localized plugin description Example: description_de=Deutsche Beschreibung license Type: String Description: Plugin license identifier Example: license=Apache 2.0 Installation Properties dont-start-at-install Type: Boolean Default: false Description: Prevent automatic start after installation router-restart-required Type: Boolean Default: false Description: Require router restart after installation install-only Type: Boolean Default: false Description: Install once only (no updates) update-only Type: Boolean Default: false Description: Update existing installation only (no fresh install) Example Plugin Configuration # Required properties name=Example I2P Plugin signer=developer@mail.i2p version=1.5.0 # Display properties author=Plugin Developer websiteURL=http://plugin.example.i2p updateURL=http://plugin.example.i2p/update.xpi2p updateURL.su3=http://plugin.example.i2p/update.su3 description=Example plugin demonstrating configuration description_de=Beispiel-Plugin zur Demonstration der Konfiguration license=MIT # Installation behavior dont-start-at-install=false router-restart-required=false Global Plugin Configuration (plugins.config) Location: $I2P_CONFIG_DIR/plugins.config\nPurpose: Enable/disable installed plugins globally\nProperty Format plugin.{name}.startOnLoad=true|false {name}: Plugin name from plugin.config startOnLoad: Whether to start plugin at router launch Example plugin.i2psnark.startOnLoad=true plugin.susimail.startOnLoad=true plugin.susidns.startOnLoad=true plugin.i2pbote.startOnLoad=false Web Applications Configuration (webapps.config) Location: $I2P_CONFIG_DIR/webapps.config\nPurpose: Enable/disable and configure web applications\nProperty Format webapps.{name}.startOnLoad Type: Boolean Description: Whether to start webapp at router launch Format: webapps.{name}.startOnLoad=true|false webapps.{name}.classpath Type: String (space or comma-separated paths) Description: Additional classpath elements for webapp Format: webapps.{name}.classpath=[paths] Variable Substitution Paths support the following variable substitutions:\nVariable Expands To Context $I2P Base I2P directory Core webapps $CONFIG User config directory All webapps $PLUGIN Plugin directory Plugin webapps Classpath Resolution Core webapps: Paths relative to $I2P/lib Plugin webapps: Paths relative to $CONFIG/plugins/{appname}/lib Example Configuration # Router console webapps.routerconsole.startOnLoad=true webapps.routerconsole.classpath=routerconsole.jar # I2PSnark webapps.i2psnark.startOnLoad=true webapps.i2psnark.classpath=i2psnark.jar # SusiDNS webapps.susidns.startOnLoad=true webapps.susidns.classpath=susidns.jar # Plugin webapp example webapps.exampleplugin.startOnLoad=false webapps.exampleplugin.classpath=$PLUGIN/lib/webapp.jar,$PLUGIN/lib/deps.jar Router Configuration (router.config) Location: $I2P_CONFIG_DIR/router.config\nConfiguration Interface: Router console at /configadvanced\nPurpose: Core router settings and network parameters\nConfiguration Categories Network Configuration Bandwidth settings:\ni2np.bandwidth.inboundKBytesPerSecond=100 i2np.bandwidth.outboundKBytesPerSecond=50 i2np.bandwidth.share.percentage=80 Transport configuration:\n# NTCP (TCP-based transport) i2np.ntcp.port=8887 i2np.ntcp.enable=true i2np.ntcp.autoip=true # SSU (UDP-based transport) i2np.udp.port=8887 i2np.udp.enable=true # UPnP/NAT-PMP i2np.upnp.enable=true Router Behavior # Tunnel participation router.maxParticipatingTunnels=200 router.sharePercentage=80 # Updates router.updatePolicy=notify router.updateURL=http://update.i2p2.i2p/ # Network integration router.hiddenMode=false router.clockSkewOffset=0 Console Configuration # Language and display routerconsole.lang=en routerconsole.country=US routerconsole.summaryRefresh=60 # Browser routerconsole.browser=default # Security routerconsole.enableCompression=true Time Configuration # NTP time.disabled=false time.sntpServerList=0.pool.ntp.org,1.pool.ntp.org Note: Router configuration is extensive. See router console at /configadvanced for complete property reference.\nApplication Configuration Files Address Book Configuration (addressbook/config.txt) Location: $I2P_CONFIG_DIR/addressbook/config.txt\nApplication: SusiDNS\nPurpose: Hostname resolution and address book management\nFile Locations router_addressbook Default: ../hosts.txt Description: Master address book (system-wide hostnames) Format: Standard hosts file format privatehosts.txt Location: $I2P_CONFIG_DIR/addressbook/privatehosts.txt Description: Private hostname mappings Priority: Highest (overrides all other sources) userhosts.txt Location: $I2P_CONFIG_DIR/addressbook/userhosts.txt Description: User-added hostname mappings Management: Via SusiDNS interface hosts.txt Location: $I2P_CONFIG_DIR/addressbook/hosts.txt Description: Downloaded public address book Source: Subscription feeds Naming Service BlockfileNamingService (Default since 0.8.8) Storage format:\nFile: hostsdb.blockfile Location: $I2P_CONFIG_DIR/addressbook/ Performance: ~10x faster lookups than hosts.txt Format: Binary database format Legacy naming service:\nFormat: Plain text hosts.txt Status: Deprecated but still supported Use Case: Manual editing, version control Hostname Rules I2P hostnames must conform to:\nTLD requirement: Must end with .i2p Maximum length: 67 characters total Character set: [a-z], [0-9], . (period), - (hyphen) Case: Lowercase only Start restrictions: Cannot start with . or - Forbidden patterns: Cannot contain .., .-, or -. (since 0.6.1.33) Reserved: Base32 hostnames *.b32.i2p (52 chars of base32.b32.i2p) Valid Examples example.i2p my-site.i2p test.example.i2p site123.i2p Invalid Examples example.com # Wrong TLD -invalid.i2p # Starts with hyphen invalid..i2p # Contains double dot invalid.-.i2p # Contains dot-hyphen UPPERCASE.I2P # Must be lowercase verylonghostnameover67charactersthatexceedsthemaximumlength.i2p # Too long Subscription Management subscriptions.txt Location: $I2P_CONFIG_DIR/addressbook/subscriptions.txt Format: One URL per line Default: http://i2p-projekt.i2p/hosts.txt Subscription Feed Format (Since 0.9.26) Advanced feed format with metadata:\n# # I2P Address Book Subscription Feed # Format: hostname=destination [#property=value ...] # example.i2p=base64destination #added=20250101 #src=manual another.i2p=base64destination #added=20250102 #src=feed1 Metadata properties:\nadded: Date hostname was added (YYYYMMDD format) src: Source identifier sig: Optional signature Backward compatibility: Simple hostname=destination format still supported.\nExample Configuration # Address book locations router_addressbook=../hosts.txt privatehosts.txt=$CONFIG/addressbook/privatehosts.txt userhosts.txt=$CONFIG/addressbook/userhosts.txt hosts.txt=$CONFIG/addressbook/hosts.txt # Naming service naming.service=BlockfileNamingService naming.service.blockfile.location=$CONFIG/addressbook/hostsdb.blockfile # Subscriptions subscriptions.txt=$CONFIG/addressbook/subscriptions.txt subscriptions.schedule=daily subscriptions.proxy=false I2PSnark Configuration (i2psnark.config.d/i2psnark.config) Location: $I2P_CONFIG_DIR/i2psnark.config.d/i2psnark.config\nApplication: I2PSnark BitTorrent client\nConfiguration Interface: Web GUI at http://127.0.0.1:7657/i2psnark\nDirectory Structure $I2P_CONFIG_DIR/i2psnark.config.d/ ├── i2psnark.config ├── [torrent-hash-1]/ │ └── *.config ├── [torrent-hash-2]/ │ └── *.config └── ... Main Configuration (i2psnark.config) Minimal default configuration:\ni2psnark.dir=i2psnark Additional properties managed via web interface:\n# Basic settings i2psnark.dir=i2psnark i2psnark.autoStart=false i2psnark.openTrackers=true # Network settings i2psnark.uploaders=8 i2psnark.upBW=40 i2psnark.seedPct=100 # I2CP settings i2psnark.i2cpHost=127.0.0.1 i2psnark.i2cpPort=7654 Individual Torrent Configuration Location: $I2P_CONFIG_DIR/i2psnark.config.d/[torrent-hash]/*.config\nFormat: Per-torrent settings\nManagement: Automatic (via web GUI)\nProperties include:\nTorrent-specific upload/download settings File priorities Tracker information Peer limits Note: Torrent configurations are primarily managed through the web interface. Manual editing is not recommended.\nTorrent Data Organization Data storage is separate from configuration:\n$I2P_CONFIG_DIR/i2psnark/ # Data directory ├── *.torrent # Torrent metadata files ├── *.torrent.downloaded/ # Downloaded file directories ├── file1.dat # Direct file downloads └── ... $I2P_CONFIG_DIR/i2psnark.config.d/ # Configuration directory ├── i2psnark.config # Main config └── [hashes]/ # Per-torrent configs I2PTunnel Configuration (i2ptunnel.config) Location: $I2P_CONFIG_DIR/i2ptunnel.config (legacy) or $I2P_CONFIG_DIR/i2ptunnel.config.d/ (modern)\nConfiguration Interface: Router console at /i2ptunnel\nFormat Change: Version 0.9.42 (August 2019)\nDirectory Structure (Version 0.9.42+) As of release 0.9.42, the default i2ptunnel.config file is automatically split:\n$I2P_CONFIG_DIR/ ├── i2ptunnel.config.d/ │ ├── http-proxy/ │ │ └── tunnel.config │ ├── irc-proxy/ │ │ └── tunnel.config │ ├── ssh-service/ │ │ └── tunnel.config │ └── ... └── i2ptunnel.config (legacy, auto-migrated) Critical Format Difference:\nMonolithic format: Properties prefixed with tunnel.N. Split format: Properties NOT prefixed (e.g., description=, not tunnel.0.description=) Migration Behavior On first run after upgrade to 0.9.42:\nExisting i2ptunnel.config is read Individual tunnel configs created in i2ptunnel.config.d/ Properties are de-prefixed in split files Original file backed up Legacy format still supported for backward compatibility Configuration Sections The I2PTunnel configuration is documented in detail in the I2PTunnel Configuration Reference section below. Property descriptions are applicable to both monolithic (tunnel.N.property) and split (property) formats.\nI2PTunnel Configuration Reference This section provides comprehensive technical reference for all I2PTunnel configuration properties. Properties are shown in split format (without tunnel.N. prefix). For monolithic format, prefix all properties with tunnel.N. where N is the tunnel number.\nImportant: Properties described as tunnel.N.option.i2cp.* are implemented in I2PTunnel and are NOT supported via other interfaces such as I2CP protocol or SAM API.\nBasic Properties tunnel.N.description (description) Type: String Context: All tunnels Description: Human-readable tunnel description for UI display Example: description=HTTP Proxy for outproxy access tunnel.N.name (name) Type: String Context: All tunnels Required: Yes Description: Unique tunnel identifier and display name Example: name=I2P HTTP Proxy tunnel.N.type (type) Type: Enum Context: All tunnels Required: Yes Values: client - Generic client tunnel httpclient - HTTP proxy client ircclient - IRC client tunnel socksirctunnel - SOCKS IRC proxy sockstunnel - SOCKS proxy (version 4, 4a, 5) connectclient - CONNECT proxy client streamrclient - Streamr client server - Generic server tunnel httpserver - HTTP server tunnel ircserver - IRC server tunnel httpbidirserver - Bidirectional HTTP server streamrserver - Streamr server tunnel.N.interface (interface) Type: String (IP address or hostname) Context: Client tunnels only Default: 127.0.0.1 Description: Local interface to bind for incoming connections Security Note: Binding to 0.0.0.0 allows remote connections Example: interface=127.0.0.1 tunnel.N.listenPort (listenPort) Type: Integer Context: Client tunnels only Range: 1-65535 Description: Local port to listen on for client connections Example: listenPort=4444 tunnel.N.targetHost (targetHost) Type: String (IP address or hostname) Context: Server tunnels only Description: Local server to forward connections to Example: targetHost=127.0.0.1 tunnel.N.targetPort (targetPort) Type: Integer Context: Server tunnels only Range: 1-65535 Description: Port on targetHost to connect to Example: targetPort=80 tunnel.N.targetDestination (targetDestination) Type: String (comma or space-separated destinations) Context: Client tunnels only Format: destination[:port][,destination[:port]] Description: I2P destination(s) to connect to Examples: targetDestination=example.i2p targetDestination=example.i2p:8080 targetDestination=site1.i2p,site2.i2p:8080 tunnel.N.i2cpHost (i2cpHost) Type: String (IP address or hostname) Default: 127.0.0.1 Description: I2P router I2CP interface address Note: Ignored when running in router context Example: i2cpHost=127.0.0.1 tunnel.N.i2cpPort (i2cpPort) Type: Integer Default: 7654 Range: 1-65535 Description: I2P router I2CP port Note: Ignored when running in router context Example: i2cpPort=7654 tunnel.N.startOnLoad (startOnLoad) Type: Boolean Default: true Description: Whether to start tunnel when I2PTunnel loads Example: startOnLoad=true Proxy Configuration tunnel.N.proxyList (proxyList) Type: String (comma or space-separated hostnames) Context: HTTP and SOCKS proxies only Description: List of outproxy hosts Example: proxyList=outproxy.example.i2p,backup.example.i2p Server Configuration tunnel.N.privKeyFile (privKeyFile) Type: String (file path) Context: Servers and persistent client tunnels Description: File containing persistent destination private keys Path: Absolute or relative to I2P config directory Example: privKeyFile=eepsite/eepPriv.dat tunnel.N.spoofedHost (spoofedHost) Type: String (hostname) Context: HTTP servers only Default: Base32 hostname of destination Description: Host header value passed to local server Example: spoofedHost=example.i2p tunnel.N.spoofedHost.NNNN (spoofedHost.NNNN) Type: String (hostname) Context: HTTP servers only Description: Virtual host override for specific incoming port Use Case: Host multiple sites on different ports Example: spoofedHost.8080=site1.example.i2p Client-Specific Options tunnel.N.sharedClient (sharedClient) Type: Boolean Context: Client tunnels only Default: false Description: Whether multiple clients can share this tunnel Example: sharedClient=false tunnel.N.option.persistentClientKey (persistentClientKey) Type: Boolean Context: Client tunnels only Default: false Description: Store and reuse destination keys across restarts Conflict: Mutually exclusive with i2cp.newDestOnResume=true Example: option.persistentClientKey=true I2CP Options (I2PTunnel Implementation) Important: These properties are prefixed with option.i2cp. but are implemented in I2PTunnel, not in the I2CP protocol layer. They are not available via I2CP or SAM APIs.\ntunnel.N.option.i2cp.delayOpen (option.i2cp.delayOpen) Type: Boolean Context: Client tunnels only Default: false Description: Delay tunnel creation until first connection Use Case: Save resources for rarely-used tunnels Example: option.i2cp.delayOpen=false tunnel.N.option.i2cp.newDestOnResume (option.i2cp.newDestOnResume) Type: Boolean Context: Client tunnels only Default: false Requires: i2cp.closeOnIdle=true Conflict: Mutually exclusive with persistentClientKey=true Description: Create new destination after idle timeout Example: option.i2cp.newDestOnResume=false tunnel.N.option.i2cp.leaseSetPrivateKey (option.i2cp.leaseSetPrivateKey) Type: String (base64-encoded key) Context: Server tunnels only Description: Persistent private leaseset encryption key Use Case: Maintain consistent encrypted leaseset across restarts Example: option.i2cp.leaseSetPrivateKey=AAAA...base64... tunnel.N.option.i2cp.leaseSetSigningPrivateKey (option.i2cp.leaseSetSigningPrivateKey) Type: String (sigtype:base64) Context: Server tunnels only Format: sigtype:base64key Description: Persistent leaseset signing private key Example: option.i2cp.leaseSetSigningPrivateKey=7:AAAA...base64... Server-Specific Options tunnel.N.option.enableUniqueLocal (option.enableUniqueLocal) Type: Boolean Context: Server tunnels only Default: false Description: Use unique local IP per remote I2P destination Use Case: Track client IPs in server logs Security Note: May reduce anonymity Example: option.enableUniqueLocal=false tunnel.N.option.targetForPort.NNNN (option.targetForPort.NNNN) Type: String (hostname:port) Context: Server tunnels only Description: Override targetHost/targetPort for incoming port NNNN Use Case: Port-based routing to different local services Example: option.targetForPort.8080=localhost:8080 Thread Pool Configuration tunnel.N.option.i2ptunnel.usePool (option.i2ptunnel.usePool) Type: Boolean Context: Server tunnels only Default: true Description: Use thread pool for connection handling Note: Always false for standard servers (ignored) Example: option.i2ptunnel.usePool=true tunnel.N.option.i2ptunnel.blockingHandlerCount (option.i2ptunnel.blockingHandlerCount) Type: Integer Context: Server tunnels only Default: 65 Description: Maximum thread pool size Note: Ignored for standard servers Example: option.i2ptunnel.blockingHandlerCount=100 HTTP Client Options tunnel.N.option.i2ptunnel.httpclient.allowInternalSSL (option.i2ptunnel.httpclient.allowInternalSSL) Type: Boolean Context: HTTP clients only Default: false Description: Allow SSL connections to .i2p addresses Example: option.i2ptunnel.httpclient.allowInternalSSL=false tunnel.N.option.i2ptunnel.httpclient.disableAddressHelper (option.i2ptunnel.httpclient.disableAddressHelper) Type: Boolean Context: HTTP clients only Default: false Description: Disable address helper links in proxy responses Example: option.i2ptunnel.httpclient.disableAddressHelper=false tunnel.N.option.i2ptunnel.httpclient.jumpServers (option.i2ptunnel.httpclient.jumpServers) Type: String (comma or space-separated URLs) Context: HTTP clients only Description: Jump server URLs for hostname resolution Example: option.i2ptunnel.httpclient.jumpServers=http://jump.i2p/jump,http://stats.i2p/jump tunnel.N.option.i2ptunnel.httpclient.sendAccept (option.i2ptunnel.httpclient.sendAccept) Type: Boolean Context: HTTP clients only Default: false Description: Pass Accept-* headers (except Accept and Accept-Encoding) Example: option.i2ptunnel.httpclient.sendAccept=false tunnel.N.option.i2ptunnel.httpclient.sendReferer (option.i2ptunnel.httpclient.sendReferer) Type: Boolean Context: HTTP clients only Default: false Description: Pass Referer headers through proxy Privacy Note: May leak information Example: option.i2ptunnel.httpclient.sendReferer=false tunnel.N.option.i2ptunnel.httpclient.sendUserAgent (option.i2ptunnel.httpclient.sendUserAgent) Type: Boolean Context: HTTP clients only Default: false Description: Pass User-Agent headers through proxy Privacy Note: May leak browser information Example: option.i2ptunnel.httpclient.sendUserAgent=false tunnel.N.option.i2ptunnel.httpclient.sendVia (option.i2ptunnel.httpclient.sendVia) Type: Boolean Context: HTTP clients only Default: false Description: Pass Via headers through proxy Example: option.i2ptunnel.httpclient.sendVia=false tunnel.N.option.i2ptunnel.httpclient.SSLOutproxies (option.i2ptunnel.httpclient.SSLOutproxies) Type: String (comma or space-separated destinations) Context: HTTP clients only Description: In-network SSL outproxies for HTTPS Example: option.i2ptunnel.httpclient.SSLOutproxies=ssl-outproxy.i2p tunnel.N.option.i2ptunnel.useLocalOutproxy (option.i2ptunnel.useLocalOutproxy) Type: Boolean Context: HTTP clients only Default: true Description: Use registered local outproxy plugins Example: option.i2ptunnel.useLocalOutproxy=true HTTP Client Authentication tunnel.N.option.proxyAuth (option.proxyAuth) Type: Enum Context: HTTP clients only Default: false Values: true, false, basic, digest Description: Require local authentication for proxy access Note: true is equivalent to basic Example: option.proxyAuth=basic tunnel.N.option.proxy.auth.USER.md5 (option.proxy.auth.USER.md5) Type: String (32 character lowercase hex) Context: HTTP clients only Requires: proxyAuth=basic or proxyAuth=digest Description: MD5 hash of password for user USER Deprecation: Use SHA-256 instead (0.9.56+) Example: option.proxy.auth.alice.md5=5f4dcc3b5aa765d61d8327deb882cf99 tunnel.N.option.proxy.auth.USER.sha256 (option.proxy.auth.USER.sha256) Type: String (64 character lowercase hex) Context: HTTP clients only Requires: proxyAuth=digest Since: Version 0.9.56 Standard: RFC 7616 Description: SHA-256 hash of password for user USER Example: option.proxy.auth.alice.sha256=5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 Outproxy Authentication tunnel.N.option.outproxyAuth (option.outproxyAuth) Type: Boolean Context: HTTP clients only Default: false Description: Send authentication to outproxy Example: option.outproxyAuth=false tunnel.N.option.outproxyUsername (option.outproxyUsername) Type: String Context: HTTP clients only Requires: outproxyAuth=true Description: Username for outproxy authentication Example: option.outproxyUsername=user tunnel.N.option.outproxyPassword (option.outproxyPassword) Type: String Context: HTTP clients only Requires: outproxyAuth=true Description: Password for outproxy authentication Security: Stored in plaintext Example: option.outproxyPassword=secret SOCKS Client Options tunnel.N.option.i2ptunnel.socks.proxy.default (option.i2ptunnel.socks.proxy.default) Type: String (comma or space-separated destinations) Context: SOCKS clients only Description: In-network outproxies for unspecified ports Example: option.i2ptunnel.socks.proxy.default=outproxy.i2p tunnel.N.option.i2ptunnel.socks.proxy.NNNN (option.i2ptunnel.socks.proxy.NNNN) Type: String (comma or space-separated destinations) Context: SOCKS clients only Description: In-network outproxies for port NNNN specifically Example: option.i2ptunnel.socks.proxy.443=ssl-outproxy.i2p tunnel.N.option.outproxyType (option.outproxyType) Type: Enum Context: SOCKS clients only Default: socks Since: Version 0.9.57 Values: socks, connect (HTTPS) Description: Type of configured outproxy Example: option.outproxyType=connect HTTP Server Options tunnel.N.option.maxPosts (option.maxPosts) Type: Integer Context: HTTP servers only Default: 0 (unlimited) Description: Max POSTs from one destination per postCheckTime Example: option.maxPosts=10 tunnel.N.option.maxTotalPosts (option.maxTotalPosts) Type: Integer Context: HTTP servers only Default: 0 (unlimited) Description: Max POSTs from all destinations per postCheckTime Example: option.maxTotalPosts=50 tunnel.N.option.postCheckTime (option.postCheckTime) Type: Integer (seconds) Context: HTTP servers only Default: 300 Description: Time window for checking POST limits Example: option.postCheckTime=600 tunnel.N.option.postBanTime (option.postBanTime) Type: Integer (seconds) Context: HTTP servers only Default: 1800 Description: Ban duration after maxPosts exceeded for single destination Example: option.postBanTime=3600 tunnel.N.option.postTotalBanTime (option.postTotalBanTime) Type: Integer (seconds) Context: HTTP servers only Default: 600 Description: Ban duration after maxTotalPosts exceeded Example: option.postTotalBanTime=1200 HTTP Server Security Options tunnel.N.option.rejectInproxy (option.rejectInproxy) Type: Boolean Context: HTTP servers only Default: false Description: Reject connections apparently via an inproxy Example: option.rejectInproxy=false tunnel.N.option.rejectReferer (option.rejectReferer) Type: Boolean Context: HTTP servers only Default: false Since: Version 0.9.25 Description: Reject connections with Referer header Example: option.rejectReferer=false tunnel.N.option.rejectUserAgents (option.rejectUserAgents) Type: Boolean Context: HTTP servers only Default: false Since: Version 0.9.25 Requires: userAgentRejectList property Description: Reject connections with matching User-Agent Example: option.rejectUserAgents=false tunnel.N.option.userAgentRejectList (option.userAgentRejectList) Type: String (comma-separated match strings) Context: HTTP servers only Since: Version 0.9.25 Case: Case-sensitive matching Special: \u0026ldquo;none\u0026rdquo; (since 0.9.33) matches empty User-Agent Description: List of User-Agent patterns to reject Example: option.userAgentRejectList=Mozilla,Opera,none IRC Server Options tunnel.N.option.ircserver.fakeHostname (option.ircserver.fakeHostname) Type: String (hostname pattern) Context: IRC servers only Default: %f.b32.i2p Tokens: %f = Full base32 destination hash %c = Cloaked destination hash (see cloakKey) Description: Hostname format sent to IRC server Example: option.ircserver.fakeHostname=%c.irc.i2p tunnel.N.option.ircserver.cloakKey (option.ircserver.cloakKey) Type: String (passphrase) Context: IRC servers only Default: Random per session Restrictions: No quotes or spaces Description: Passphrase for consistent hostname cloaking Use Case: Persistent user tracking across restarts/servers Example: option.ircserver.cloakKey=mysecretkey tunnel.N.option.ircserver.method (option.ircserver.method) Type: Enum Context: IRC servers only Default: user Values: user, webirc Description: Authentication method for IRC server Example: option.ircserver.method=webirc tunnel.N.option.ircserver.webircPassword (option.ircserver.webircPassword) Type: String (password) Context: IRC servers only Requires: method=webirc Restrictions: No quotes or spaces Description: Password for WEBIRC protocol authentication Example: option.ircserver.webircPassword=webircpass tunnel.N.option.ircserver.webircSpoofIP (option.ircserver.webircSpoofIP) Type: String (IP address) Context: IRC servers only Requires: method=webirc Description: Spoofed IP address for WEBIRC protocol Example: option.ircserver.webircSpoofIP=10.0.0.1 SSL/TLS Configuration tunnel.N.option.useSSL (option.useSSL) Type: Boolean Default: false Context: All tunnels Behavior: Servers: Use SSL for connections to local server Clients: Require SSL from local clients Example: option.useSSL=false tunnel.N.option.keystoreFile (option.keystoreFile) Type: String (file path) Context: Client tunnels only Default: i2ptunnel-(random).ks Path: Relative to $(I2P_CONFIG_DIR)/keystore/ if not absolute Auto-generated: Created if doesn\u0026rsquo;t exist Description: Keystore file containing SSL private key Example: option.keystoreFile=my-tunnel.ks tunnel.N.option.keystorePassword (option.keystorePassword) Type: String (password) Context: Client tunnels only Default: changeit Auto-generated: Random password if new keystore created Description: Password for SSL keystore Example: option.keystorePassword=secretpassword tunnel.N.option.keyAlias (option.keyAlias) Type: String (alias) Context: Client tunnels only Auto-generated: Created if new key generated Description: Alias for private key in keystore Example: option.keyAlias=mytunnel-key tunnel.N.option.keyPassword (option.keyPassword) Type: String (password) Context: Client tunnels only Auto-generated: Random password if new key created Description: Password for private key in keystore Example: option.keyPassword=keypass123 Generic I2CP and Streaming Options All tunnel.N.option.* properties (not specifically documented above) are passed through to the I2CP interface and streaming library with the tunnel.N.option. prefix stripped.\nImportant: These are separate from I2PTunnel-specific options. Refer to:\nI2CP Specification Streaming Library Specification Example streaming options:\noption.i2cp.messageReliability=BestEffort option.i2p.streaming.connectDelay=1000 option.i2p.streaming.maxWindowSize=128 Complete Tunnel Example # HTTP Proxy (split format without tunnel.N. prefix) name=I2P HTTP Proxy description=HTTP proxy for accessing I2P sites and outproxy type=httpclient interface=127.0.0.1 listenPort=4444 targetDestination= sharedClient=true startOnLoad=true # I2CP configuration i2cpHost=127.0.0.1 i2cpPort=7654 # HTTP client options option.i2ptunnel.httpclient.allowInternalSSL=false option.i2ptunnel.httpclient.disableAddressHelper=false option.i2ptunnel.httpclient.jumpServers=http://stats.i2p/cgi-bin/jump.cgi option.i2ptunnel.httpclient.sendAccept=false option.i2ptunnel.httpclient.sendReferer=false option.i2ptunnel.httpclient.sendUserAgent=false # Proxy authentication option.proxyAuth=false # Outproxy configuration option.i2ptunnel.httpclient.SSLOutproxies=false.i2p proxyList=false.i2p # Client behavior option.persistentClientKey=false option.i2cp.delayOpen=false # I2CP tunnel options option.inbound.length=3 option.outbound.length=3 option.inbound.quantity=2 option.outbound.quantity=2 Version History and Feature Timeline Version 0.9.10 (2013) Feature: Empty value support in configuration files\nKeys with empty values (key=) now supported Previously ignored or caused parsing errors Version 0.9.18 (2015) Feature: Logger flush interval configuration\nProperty: logger.flushInterval (default 29 seconds) Reduces disk I/O while maintaining acceptable log latency Version 0.9.23 (November 2015) Major Change: Java 7 minimum requirement\nJava 6 support ended Required for continued security updates Version 0.9.25 (2015) Features: HTTP server security options\ntunnel.N.option.rejectReferer - Reject connections with Referer header tunnel.N.option.rejectUserAgents - Reject specific User-Agent headers tunnel.N.option.userAgentRejectList - User-Agent patterns to reject Use Case: Mitigate crawlers and unwanted clients Version 0.9.33 (January 2018) Feature: Enhanced User-Agent filtering\nuserAgentRejectList string \u0026ldquo;none\u0026rdquo; matches empty User-Agent Additional bug fixes for i2psnark, i2ptunnel, streaming, SusiMail Version 0.9.41 (2019) Deprecation: BOB Protocol removed from Android\nAndroid users must migrate to SAM or I2CP Version 0.9.42 (August 2019) Major Change: Configuration file splitting\nclients.config split into clients.config.d/ directory structure i2ptunnel.config split into i2ptunnel.config.d/ directory structure Automatic migration on first run after upgrade Enables modular packaging and plugin management Legacy monolithic format still supported Additional Features:\nSSU performance improvements Cross-network prevention (Proposal 147) Initial encryption type support Version 0.9.56 (2021) Features: Security and logging improvements\nlogger.gzip - Gzip compression for rotated logs (default: false) logger.minGzipSize - Minimum size for compression (default: 65536 bytes) tunnel.N.option.proxy.auth.USER.sha256 - SHA-256 digest authentication (RFC 7616) Security: SHA-256 replaces MD5 for digest authentication Version 0.9.57 (January 2023) Feature: SOCKS outproxy type configuration\ntunnel.N.option.outproxyType - Select outproxy type (socks|connect) Default: socks HTTPS CONNECT support for HTTPS outproxies Version 2.6.0 (July 2024) Breaking Change: I2P-over-Tor blocked\nConnections from Tor exit node IP addresses now rejected Reason: Degrades I2P performance, wastes Tor exit resources Impact: Users accessing I2P through Tor exit nodes will be blocked Non-exit relays and Tor clients unaffected Version 2.10.0 (September 2025 - Current) Major Features:\nPost-quantum cryptography available (opt-in via Hidden Service Manager) UDP tracker support for I2PSnark to reduce tracker load Hidden Mode stability improvements to reduce RouterInfo depletion Network improvements for congested routers Enhanced UPnP/NAT traversal NetDB improvements with aggressive leaseset removal Observability reductions for router events Configuration: No new configuration properties added\nCritical Upcoming Change: Next release (likely 2.11.0 or 3.0.0) will require Java 17 or later\nDeprecations and Breaking Changes Critical Deprecations I2P-over-Tor Access (Version 2.6.0+) Status: BLOCKED since July 2024 Impact: Connections from Tor exit node IPs rejected Reason: Degrades I2P network performance without providing anonymity benefits Affects: Only Tor exit nodes, not relays or regular Tor clients Alternative: Use I2P or Tor separately, not combined MD5 Digest Authentication Status: Deprecated (use SHA-256) Property: tunnel.N.option.proxy.auth.USER.md5 Reason: MD5 cryptographically broken Replacement: tunnel.N.option.proxy.auth.USER.sha256 (since 0.9.56) Timeline: MD5 still supported but discouraged Configuration Architecture Changes Monolithic Configuration Files (Version 0.9.42+) Affected: clients.config, i2ptunnel.config Status: Deprecated in favor of split directory structure Migration: Automatic on first run after 0.9.42 upgrade Compatibility: Legacy format still works (backward compatible) Recommendation: Use split format for new configurations Java Version Requirements Java 6 Support Ended: Version 0.9.23 (November 2015) Minimum: Java 7 required since 0.9.23 Java 17 Requirement (Upcoming) Status: CRITICAL UPCOMING CHANGE Target: Next major release after 2.10.0 (likely 2.11.0 or 3.0.0) Current Minimum: Java 8 Action Required: Prepare for Java 17 migration Timeline: To be announced with release notes Removed Features BOB Protocol (Android) Removed: Version 0.9.41 Platform: Android only Alternative: SAM or I2CP protocols Desktop: BOB still available on desktop platforms Recommended Migrations Authentication: Migrate from MD5 to SHA-256 digest authentication Configuration Format: Migrate to split directory structure for clients and tunnels Java Runtime: Plan for Java 17 upgrade before next major release Tor Integration: Do not route I2P through Tor exit nodes References Official Documentation I2P Configuration Specification - Official configuration file format specification I2P Plugin Specification - Plugin configuration and packaging I2P Common Structures - Type Mapping - Protocol data serialization format Java Properties Format - Base format specification Source Code I2P Java Router Repository - GitHub mirror I2P Developers Gitea - Official I2P source repository DataHelper.java - Configuration file I/O implementation Community Resources I2P Forum - Active community discussions and support I2P Website - Official project website API Documentation DataHelper JavaDoc - API documentation for configuration file methods Specification Status Last Specification Update: January 2023 (Version 0.9.57) Current I2P Version: 2.10.0 (September 2025) Technical Accuracy: Specification remains accurate through 2.10.0 (no breaking changes) Maintenance: Living document updated when configuration format modified ","description":"Configuration options and formats for I2P routers and clients","id":"b6b01c53245c0e36ca08c56f843abb7f","section":"docs","title":"Router Configuration","url":"/en/docs/specs/configuration/"},{"categories":null,"content":"Hosting GitLab inside I2P is straightforward: run the GitLab omnibus container, expose it on loopback, and forward traffic through an I2P tunnel. The steps below mirror the configuration used for git.idk.i2p but work for any self-hosted instance.\n1. Prerequisites Debian or another Linux distribution with Docker Engine installed (sudo apt install docker.io or docker-ce from Docker’s repo). An I2P router (Java I2P or i2pd) with enough bandwidth to serve your users. Optional: a dedicated VM so GitLab and the router stay isolated from your desktop environment. 2. Pull the GitLab Image docker pull gitlab/gitlab-ce:latest The official image is built from Ubuntu base layers and updated regularly. Audit the Dockerfile if you need additional reassurance.\n3. Decide on Bridging vs. I2P-Only I2P-only instances never contact clearnet hosts. Users may mirror repositories from other I2P services but not from GitHub/GitLab.com. This maximises anonymity. Bridged instances reach out to clearnet Git hosts via an HTTP proxy. This is useful for mirroring public projects into I2P but it deanonymises the server’s outbound requests. If you choose the bridged mode, configure GitLab to use an I2P HTTP proxy bound on the Docker host (for example http://172.17.0.1:4446). The default router proxy listens on 127.0.0.1 only; add a new proxy tunnel bound to the Docker gateway address.\n4. Start the Container docker run --detach \\ --env HTTP_PROXY=http://172.17.0.1:4446 \\ # omit for I2P-only --publish 127.0.0.1:8443:443 \\ --publish 127.0.0.1:8080:80 \\ --publish 127.0.0.1:8022:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab:Z \\ --volume /srv/gitlab/logs:/var/log/gitlab:Z \\ --volume /srv/gitlab/data:/var/opt/gitlab:Z \\ gitlab/gitlab-ce:latest Bind the published ports to loopback; the I2P tunnels will expose them as needed. Replace /srv/gitlab/... with storage paths that suit your host. Once the container is running, visit https://127.0.0.1:8443/, set an admin password, and configure account limits.\n5. Expose GitLab Through I2P Create three I2PTunnel server tunnels:\nPurpose Local target Suggested inbound port HTTPS web UI 127.0.0.1:8443 auto-generated HTTP web UI (optional) 127.0.0.1:8080 auto-generated SSH push/pull 127.0.0.1:8022 auto-generated Configure each tunnel with appropriate tunnel lengths and bandwidth. For public instances, 3 hops with 4–6 tunnels per direction is a good starting point. Publish the resulting Base32/Base64 destinations on your landing page so users can configure client tunnels.\nDestination Enforcement If you use HTTP(S) tunnels, enable destination enforcement so only the intended hostname can reach the service. This prevents the tunnel from being abused as a generic proxy.\n6. Maintenance Tips Run docker exec gitlab gitlab-ctl reconfigure whenever you change GitLab settings. Monitor disk usage (/srv/gitlab/data)—Git repositories grow quickly. Back up configuration and data directories regularly. GitLab’s backup rake tasks work inside the container. Consider placing an external monitoring tunnel in client mode to ensure the service is reachable from the broader network. 7. Related Guides Embedding I2P in your application Git over I2P (client guide) Git bundles for offline/slow networks A well-configured GitLab instance provides a collaborative development hub wholly inside I2P. Keep the router healthy, stay current with GitLab security updates, and coordinate with the community as your user base grows.\n","description":"Deploying GitLab inside I2P using Docker and an I2P router","id":"0c6aba5984de265324df6360a00204c9","section":"docs","title":"Running GitLab over I2P","url":"/en/docs/guides/gitlab/"},{"categories":null,"content":" Deprecated: SAM v1 is retained for historical reference only. New applications should use SAM v3 or BOB. The original bridge only supports DSA-SHA1 destinations and a limited option set.\nLibraries The Java I2P source tree still includes legacy bindings for C, C#, Perl, and Python. They are no longer maintained and shipped mainly for archival compatibility.\nVersion Negotiation Clients connect via TCP (default 127.0.0.1:7656) and exchange:\nClient → HELLO VERSION MIN=1 MAX=1 Bridge → HELLO REPLY RESULT=OK VERSION=1.0 As of Java I2P 0.9.14 the MIN parameter is optional and both MIN/MAX accept single-digit forms (\u0026quot;3\u0026quot; etc.) for upgraded bridges.\nSession Creation SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value]* DESTINATION=name loads or creates an entry in sam.keys; TRANSIENT always creates a temporary destination. STYLE selects virtual streams (TCP-like), signed datagrams, or raw datagrams. DIRECTION applies to stream sessions only; defaults to BOTH. Additional key/value pairs are passed through as I2CP options (for example, tunnels.quantityInbound=3). The bridge replies with:\nSESSION STATUS RESULT=OK DESTINATION=name Failures return DUPLICATED_DEST, I2P_ERROR, or INVALID_KEY plus an optional message.\nMessage Formats SAM messages are single-line ASCII with space-delimited key/value pairs. Keys are UTF‑8; values may be quoted if they contain spaces. No escaping is defined.\nCommunication types:\nStreams – proxied through the I2P streaming library Repliable datagrams – signed payloads (Datagram1) Raw datagrams – unsigned payloads (Datagram RAW) Options Added in 0.9.14 DEST GENERATE accepts SIGNATURE_TYPE=... (allowing Ed25519, etc.) HELLO VERSION treats MIN as optional and accepts single-digit version strings When to Use SAM v1 Only for interoperability with legacy software that cannot be updated. For all new development use:\nSAM v3 for feature-complete stream/datagram access BOB for destination management (still limited, but supports more modern features) References SAM v2 SAM v3 Datagram Specification Streaming Protocol SAM v1 laid the foundation for router-agnostic application development, but the ecosystem has moved on. Treat this document as a compatibility aid rather than a starting point.\n","description":"Legacy Simple Anonymous Messaging protocol (deprecated)","id":"d6c20329db11e9b5a1eff3a8709b3294","section":"docs","title":"SAM v1","url":"/en/docs/legacy/sam/"},{"categories":null,"content":" Deprecated: SAM v2 shipped with I2P 0.6.1.31 and is no longer maintained. Use SAM v3 for new development. v2’s only improvement over v1 was support for multiple sockets multiplexed over a single SAM connection.\nVersion Notes Reported version string remains \u0026quot;2.0\u0026quot;. Since 0.9.14 the HELLO VERSION message accepts single-digit MIN/MAX values and the MIN parameter is optional. DEST GENERATE supports SIGNATURE_TYPE so Ed25519 destinations can be created. Session Basics SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value] Each destination may have only one active SAM session (streams, datagrams, or raw). STYLE selects virtual streams, signed datagrams, or raw datagrams. Additional options are passed to I2CP (for example, tunnels.quantityInbound=3). Responses mirror v1: SESSION STATUS RESULT=OK|DUPLICATED_DEST|I2P_ERROR|INVALID_KEY. Message Encoding Line-oriented ASCII with key=value pairs separated by spaces (values may be quoted). Communication types are the same as v1:\nStreams via the I2P streaming library Repliable datagrams (PROTO_DATAGRAM) Raw datagrams (PROTO_DATAGRAM_RAW) When to Use Only for legacy clients that cannot migrate. SAM v3 offers:\nBinary destination handoff (DEST GENERATE BASE64) Subsessions and DHT support (v3.3) Better error reporting and option negotiation Refer to:\nSAM v1 SAM v3 Datagram API Streaming Protocol ","description":"Legacy Simple Anonymous Messaging protocol","id":"a21e46f2603ba3051f18eff26aa5084d","section":"docs","title":"SAM v2","url":"/en/docs/legacy/samv2/"},{"categories":null,"content":"SAM v3 (“Simple Anonymous Messaging”) is the current stable, router agnostic API that allows external applications to communicate with the I2P network without embedding the router itself. It provides unified access to streams, datagrams, and raw messages, and remains the canonical bridge layer for non-Java software.\n1. Overview and Purpose SAM v3 enables developers to build I2P aware software in any language using a lightweight TCP/UDP protocol. It abstracts router internals, exposing a minimal set of commands over TCP (7656) and UDP (7655). Both Java I2P and i2pd implement subsets of the SAM v3 specification, though i2pd still lacks most 3.2 and 3.3 extensions as of 2025.\n2. Version History Version Introduced Key Features 3.00.7.3 (May 2009)Streams + Datagrams; binary destinations; `SESSION CREATE STYLE=` parameter. 3.10.9.14 (Jul 2014)Signature type negotiation via `SIGNATURE_TYPE`; improved `DEST GENERATE`. 3.20.9.24 (Jan 2016)Per session encryption + tunnel options; `STREAM CONNECT ID` support. 3.30.9.25 (Mar 2016)PRIMARY / SUBSESSION architecture; multiplexing; improved datagrams. Naming Note Java I2P uses PRIMARY/SUBSESSION. i2pd and I2P+ continue to use legacy MASTER/SUBSESSION terminology for backward compatibility. 3. Core Workflow Version Negotiation HELLO VERSION MIN=3.1 MAX=3.3 HELLO REPLY RESULT=OK VERSION=3.3 Destination Creation DEST GENERATE SIGNATURE_TYPE=7 SIGNATURE_TYPE=7 → Ed25519 (EdDSA SHA512). Strongly recommended since I2P 0.9.15. Session Creation SESSION CREATE STYLE=STREAM DESTINATION=NAME OPTION=i2cp.leaseSetEncType=4,0 OPTION=inbound.quantity=3 OPTION=outbound.quantity=3 i2cp.leaseSetEncType=4,0 → 4 is X25519 (ECIES X25519 AEAD Ratchet) and 0 is ElGamal fallback for compatibility. Explicit tunnel quantities for consistency: Java I2P default 2, i2pd default 5. Protocol Operations STREAM CONNECT ID=1 DESTINATION=b32address.i2p STREAM SEND ID=1 SIZE=128 STREAM CLOSE ID=1 Core message types include: STREAM CONNECT, STREAM ACCEPT, STREAM FORWARD, DATAGRAM SEND, RAW SEND, NAMING LOOKUP, DEST LOOKUP, PING, QUIT.\nGraceful Shutdown QUIT 4. Implementation Differences (Java I2P vs i2pd) Feature Java I2P 2.10.0 i2pd 2.58.0 (Sept\u0026nbsp;2025) SAM enabled by default❌ Requires manual enable in router console✅ Enabled via `enabled=true` in `i2pd.conf` Default portsTCP 7656 / UDP 7655Same AUTH / USER / PASSWORD✓ Supported✗ Not implemented PING / PONG keepalive✓ Supported✗ Not implemented QUIT / STOP / EXIT commands✓ Supported✗ Not implemented FROM_PORT / TO_PORT / PROTOCOL✓ Supported✗ Not implemented PRIMARY/SUBSESSION support✓ (since 0.9.47)✗ Absent SESSION ADD / REMOVE✓ Supported✗ Not implemented Datagram2 / Datagram3 support✓ (since 2.9.0)✗ Not implemented SSL/TLSOptional✗ None Default tunnel quantitiesInbound/outbound=2Inbound/outbound=5 Recommendation: Always specify tunnel quantities explicitly to ensure cross router consistency.\n5. Supported Libraries (2025 Snapshot) Library Language SAM Support Maintenance Status (2025) libsam3C3.1Maintained by I2P Project (eyedeekay) i2psamC++3.1Minimal updates since 2019 sam3Go3.3Active; migrated from `eyedeekay/sam3` onrampGo3.3Actively maintained (2025) i2plibPython3.1Modern async replacement for `i2p.socket` i2p.socketPython3.2Abandoned (last release 2017) Py2pPython3.3Unverified/inactive i2p-rsRust3.1Experimental; unstable API @diva.exchange/i2p-samTypeScript / JS3.3Most actively maintained (2024–2025) I2PSharpC#3.3Functional; light maintenance 6. Upcoming and New Features (2024–2025) Feature Status Introduced NAMING LOOKUP `OPTIONS=true`✓ Supported2.8.0 Datagram2 / Datagram3 formats✓ (Java only)2.9.0 Post-quantum hybrid crypto (ML KEM)Optional2.10.0 Java 17+ runtime requirementPlanned2.11.0 I2P over Tor blockingActive2.6.0 Improved floodfill selectionActive2.8.0+ 7. Security and Configuration Notes Bind SAM to 127.0.0.1 only. For persistent services, use PRIMARY sessions with static keys. Use HELLO VERSION to test for feature support. Use PING or NAMING LOOKUP to verify router liveness. Avoid unauthenticated remote SAM connections (no TLS in i2pd). 8. References and Specifications /docs/api/samv3/ /docs/legacy/samv2/ /docs/specs/streaming/ /docs/api/datagrams/ /docs/ https://i2pd.website/docs 9. Summary SAM v3 remains the recommended bridge protocol for all non Java I2P applications. It offers stability, cross language bindings, and consistent performance across router types.\nWhen developing with SAM:\nUse Ed25519 signatures and X25519 encryption. Verify feature support dynamically via HELLO VERSION. Design for compatibility, especially when supporting both Java I2P and i2pd routers. ","description":"Stable bridge protocol for non-Java I2P applications","id":"dd6d27c1d72fe7c4333dc148d132f546","section":"docs","title":"SAM v3","url":"/en/docs/api/samv3/"},{"categories":null,"content":"Security Contact To report security vulnerabilities or sensitive security issues, please contact the I2P Security Team at security@i2p.net\nFor secure communication, please use our PGP key below.\nPGP Key Information Email: security@i2p.net Key ID: 176E1941 Fingerprint: 40DF FE20 7D79 9BEC 3AE8 7DEA 5F98 BE91 176E 1941 Key Type: RSA 4096-bit Created: 2025-10-19 Expires: 2030-11-19 UID: I2P Security \u0026lt;security@i2p.net\u0026gt; Public Key Following is the GPG public key for the I2P Security Team:\n-----BEGIN PGP PUBLIC KEY BLOCK----- mQINBGj1TtUBEADKsCC54egdJgxMs4HWcsYlr4GbrevM5gjZ+QZYEDGjaz44duOc E9W+a/NNA8PsryCql893odYdqGrFX+WTUT3UuN7DbbS7qSDs7jWZzjj0lr4/pbzJ B28lC0aIx6SQTEbzsGr2hOlFq/+JD9x/fMFrHFX81cJdIz9yabcH1vg9wPuhwkUS 5v2GFtvODCmSxQEJHSWvL2PkGiYEEZMKVXF5msdqJZK5/Dwp3UgVNeAkUYEHU6px Vu/YUpGo07/LNW5FfGDGf0pWYQ/9Tu5ykno3q3EA7TwWoVwbDK0hh9mpbZYiWSoy PSbIWNpwVMwGri4+KFjCEyG8DLzDlM4UMrK3PnrPh4M4+4a+flR+CMNeM1lyioC3 +jJf3TEOjvUsMzbwoDEE6O0wxBtfFC0xzzDDCAVrPvEZ3lt0do3kVHLbYS6ZXHkX ZwZWNBDWr2mSG9GU4oWizPIlq7MIhRYKA+ADqNxznxm9rtdfidk1tcLdyNUDjOwC jk/vQ8PCORbUYfytMhHzlRk7zieK6wBwr3aFFVgE8HxhgIZkAaUEbeej+dNADo6Z IFY+OF8mjpErcfJscCNgPSDbNid87dA78qRrqL6HLU2sek9g72EFpx2OVV7drkEp +Zy9kuiML4wWfOpC+kQa1Ka66E520U8Hs++cpf1LUOUmn1ajQDSfGoJMMwARAQAB tB9JMlAgU2VjdXJpdHkgPHNlY3VyaXR5QGkycC5uZXQ+iQJXBBMBCABBFiEEQN/+ IH15m+w66H3qX5i+kRduGUEFAmj1TtUCGwMFCQmQP4EFCwkIBwICIgIGFQoJCAsC BBYCAwECHgMCF4AACgkQX5i+kRduGUEEJhAAuZECNIWnC2UbrW/AXF8nPvFjpvLe kK7VQmMgno6iHRB1HAMh5hk3ZOYSRcjghcOHRpMFT64Uuc5vc9eBoegi5TDxYDkF Y9/ciEG5j2TXk93R/rY14UiH/kjFIhBAmc2t6Fs9R1m1vHHJtgY+KLqRF9fh2hc9 43odXnCrn5nhONtW+nb086eJEnJ4vsG/yR4EGzbu+fbrMJlycA/gZS63Q0rIcEJ2 VbZPCEXAf8LmebwxPxlboEuhXJSjCt1gWZwoKZlELaWdHliL3fUrMd3ojM5y66q3 ClO+7nWuwzKxKtZGKzxvF78o0O+HR4BbC16oQGpkT0yAij7ps/3KD2FJVQ/GQLef mpNQABfdVCPgcDS1p9/hjUoVHlRSC4gyehKX/C+H8Qvem92tzmJZy8PvcXaCsK/u wRxRwkoGhv0H5rsMOxfnB06dvT1Mo+KHED5j4y8C5DOnNpzHqwxJh1nQlJvLUvh8 LWIxiiE4+CeQ5V5YH7KfJmGq5ho93GgFmOXJvAuoFCoOLwXbQt9rMpq8iXM1RHRG E1AbB+KA3zcvAdzbgPtXlrOMkIfYO9xCyc8M0sfHB8b4RgrUs2tFz1fw3g4yE7ax 5ljquRefDmqBjtvu15FcZ4CA+I8FyVnrEb9jDTXyW7DiyM2kB7ZFeLpYytShbPq3 oJQMJYaGMoxDk025Ag0EaPVO1QEQAOuZtLOlab2EnuR5St05MXBpwtQUSWJzRckf w3NpnOl55+BavqsPl63rZYiO2lH9rAkZvfcL7auddQZSjDdsuPbUpsrQgsi2P9ig a3QiJOwSZzJ1qNb4VZSXrq2AqkBhCdw9rjpXGFfPNlClgVRbWpsGaQ5KtflnOA+I RfymidNXH0mDROBQuRh+2lkEYfANshjFjIqbI05tDic0KOab46R5MRVF7cihaMWp qPdxeYmvFWZ9lAnx5lMGwDdnGgfWFkU57lAd3NuHUnYIr/ExB/YgMdDeie5lQHKu svbcws9tIucUME9n8lGY77+1HlmNOCU4V12i4ZURJ4TwjHpScMOovkumtO4nXGRq GS8j1zeG7V9+yvdkSrclHJC33Mu6SPFC5SJBqU1G39/VpTD6CZPSPowZ0RlH2AVh D77Snrn53R3gziv5uxq+LpSJoafAx5tgIrg7HB+iJYRB1YVwIIHoT4YrBF01YyH6 cclkf3TNBjKgmtsynVw/TGy56nvR5lmt2uMq0Wwl4ZEwYPp+8ZmFuLbEHsI9RSdD iAdHoK9pEsTSxvzpcDTcG0CLZ4By/4oIKra6KuLr7XcB5eBmgXxrFBw4kveNWGW0 iEdg0xUVp8dxNjdZucB8m9qXQUUSmUxVjFYu4ee8tpo8iEVzu4wm4kOiOBKlwCn2 nOI72oGxABEBAAGJAjwEGAEIACYWIQRA3/4gfXmb7DrofepfmL6RF24ZQQUCaPVO 1QIbDAUJCZA/gQAKCRBfmL6RF24ZQShLD/9BlA+nLmJvwL3FYXm8JOqN07gPKlyQ +gWdV8p22Gawoq6dJLJanWURjn5Kfy30x2CSX6QwiaQG5aHHudNBF2h4Z/qEMcO5 ml5Dq7BP9R5VKmG4vwrL5ccNwuey1/d9Rtjt1zsd+52+x6dfjFv95o9j8jviIEoS HhhbO9ujmx3QLRNlg0SkG6ZlTALGp3EcKNdrV1vpF6ccgt3pdWYFB62N7q8zObHf bfOFMITJIXJJVKICCxzw3xOW2fMashjqf4Ic2UTFsAG3Hqqf5ASGbu4TyjFS3VXV JSzvdhGnxb7qJUzBImK9mGPRXYSV5d4g7kCFfgUg6KSFxbfYreEjCZXWJyqCr/VB eLpIhUWce/AiDPD8lGVD6sNevsNw4HhO6IyQu0pqbRAo+fJZNi+wcqOUqYlMczNw tUKw73QmFj0IqvyBr8Rfq9JC9O6ipyzalwK8uO0gmqOiK79zfnNIJaZ1+LM3Gh6n 3yluwq1df40lEU171i70IbSON6ekGNLTrvhTlDg6vHCMRfQR2UjA5FYBAtFXqQNG c4IYbu2UQm/191P77oI0vBEh3YnrD9eXtdYxgyT+Lj8RBJ+aM+IykK7c2mgOmlqb vYv+KkVFCpOyXrvSwId+3jHiGP6jis7vuzTwiG0S9EyOjxf9XIDowULuY28ntBB0 hOLK7ID/AeaOxA== =39fn \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; ","description":"GPG public key for contacting the I2P Security Team","id":"c65864821d13039a727e933e7e6e2891","section":"docs","title":"Security GPG Key","url":"/en/docs/develop/security-key/"},{"categories":null,"content":" Caution: The SOCKS tunnel forwards application payloads without sanitizing them. Many protocols leak IPs, hostnames, or other identifiers. Only use SOCKS with software you have audited for anonymity.\n1. Overview I2P provides SOCKS 4, 4a, and 5 proxy support for outbound connections through an I2PTunnel client. It enables standard applications to reach I2P destinations but cannot access clearnet. There is no SOCKS outproxy, and all traffic remains within the I2P network.\nImplementation Summary Parameter Java I2P i2pd Default Port User-defined 127.0.0.1:4447 Supported SOCKS Versions 4, 4a, 5 4, 4a, 5 UDP Mode Stubbed (non-functional) Stubbed (non-functional) Persistent Keys ✅ Since 0.9.9 ✅ Shared Client Tunnels Supported Supported Outproxy Support ❌ None ❌ None Supported address types:\n.i2p hostnames (addressbook entries) Base32 hashes (.b32.i2p) No Base64 or clearnet support 2. Security Risks and Limitations Application-Layer Leakage SOCKS operates below the application layer and cannot sanitize protocols. Many clients (e.g., browsers, IRC, email) include metadata that reveals your IP address, hostname, or system details.\nCommon leaks include:\nIPs in mail headers or IRC CTCP responses Real names/usernames in protocol payloads User-agent strings with OS fingerprints External DNS queries WebRTC and browser telemetry I2P cannot prevent these leaks—they occur above the tunnel layer. Only use SOCKS for audited clients designed for anonymity.\nShared Tunnel Identity If multiple applications share a SOCKS tunnel, they share the same I2P destination identity. This enables correlation or fingerprinting across different services.\nMitigation: Use non-shared tunnels for each application and enable persistent keys to maintain consistent cryptographic identities across restarts.\nUDP Mode Stubbed Out UDP support in SOCKS5 is not implemented. The protocol advertises UDP capability, but calls are ignored. Use TCP-only clients.\nNo Outproxy by Design Unlike Tor, I2P does not offer SOCKS-based clearnet outproxies. Attempts to reach external IPs will fail or expose identity. Use HTTP or HTTPS proxies if outproxying is required.\n3. Historical Context Developers have long discouraged SOCKS for anonymous use. From internal developer discussions and the 2004 Meeting 81 and Meeting 82:\n“Forwarding arbitrary traffic is unsafe, and it behooves us as developers of anonymity software to have the safety of our end users foremost in our minds.”\nSOCKS support was included for compatibility but is not recommended for production environments. Nearly every internet application leaks sensitive metadata unsuited to anonymous routing.\n4. Configuration Java I2P Open the I2PTunnel manager at http://localhost:7657/i2ptunnel Create a new client tunnel of type “SOCKS 4/4a/5” Configure options: Local port (any available) Shared client: disable for separate identity per app Persistent key: enable to reduce key correlation Start the tunnel i2pd i2pd includes SOCKS5 support enabled by default at 127.0.0.1:4447. Configuration in i2pd.conf under [SOCKSProxy] allows you to adjust port, host, and tunnel parameters.\n5. Development Timeline Version Change Date 0.7.1 Initial SOCKS 4/4a/5 support 2010 0.9.9 Added persistent keying 2013 1.7.0 BOB API deprecated and removed 2022 2.6.0 I2P-over-Tor blocked to improve network health 2024 2.10.0 Post-quantum hybrid encryption introduced 2025 The SOCKS module itself has seen no major protocol updates since 2013, but the surrounding tunnel stack has received performance and cryptographic improvements.\n6. Recommended Alternatives For any production, public-facing, or security-critical application, use one of the official I2P APIs instead of SOCKS:\nAPI Description Recommended For SAM v3 (3.3) Simple Anonymous Messaging API Cross-language apps needing socket-like I/O Streaming Library TCP-like sockets for Java Native Java integrations I2CP Low-level router communication Custom protocols, router-level integration BOB Deprecated (removed 2022) Legacy only; migrate to SAM These APIs provide proper destination isolation, cryptographic identity control, and better routing performance.\n7. OnionCat / GarliCat OnionCat supports I2P through its GarliCat mode (fd60:db4d:ddb5::/48 IPv6 range). Still functional but with limited development since 2019.\nUsage caveats:\nRequires manual .oc.b32.i2p configuration in SusiDNS Needs static IPv6 assignment Not officially supported by the I2P project Recommended only for advanced VPN-over-I2P setups.\n8. Best Practices If you must use SOCKS:\nCreate separate tunnels per application. Disable shared client mode. Enable persistent keys. Force SOCKS5 DNS resolution. Audit protocol behavior for leaks. Avoid clearnet connections. Monitor network traffic for leaks. 9. Technical Summary Parameter Value Supported SOCKS Versions 4, 4a, 5 Transport TCP only UDP Support Stubbed (non-functional) Clearnet Access Not supported Default Ports Java I2P: user-set; i2pd: 127.0.0.1:4447 Persistent Keying Supported since 0.9.9 Shared Tunnels Supported (discouraged) 10. Conclusion The SOCKS proxy in I2P provides basic compatibility with existing TCP applications but is not designed for strong anonymity guarantees. It should only be used for controlled, audited testing environments.\nFor serious deployments, migrate to SAM v3 or the Streaming API. These APIs isolate application identities, use modern cryptography, and receive ongoing development.\nAdditional Resources Official SOCKS Docs SAM v3 Specification Streaming Library Docs I2PTunnel Reference I2P Developer Docs Community Forum ","description":"Using I2P's SOCKS tunnel safely (updated for 2.10.0)","id":"e71093f25f593f15b6820398338abc89","section":"docs","title":"SOCKS Proxy","url":"/en/docs/api/socks/"},{"categories":null,"content":"Overview Routers automatically check for updates by polling a signed news feed distributed through the I2P network. When a newer version is advertised, the router downloads a cryptographically signed update archive (.su3) and stages it for installation.\nThis system ensures authenticated, tamper-resistant, and multi-channel distribution of official releases.\nAs of I2P 2.10.0, the update system uses:\nRSA-4096 / SHA-512 signatures SU3 container format (replacing legacy SUD/SU2) Redundant mirrors: in-network HTTP, clearnet HTTPS, and BitTorrent 1. News Feed Routers poll the signed Atom feed every few hours to discover new versions and security advisories.\nThe feed is signed and distributed as a .su3 file, which may include:\n\u0026lt;i2p:version\u0026gt; — new version number \u0026lt;i2p:minVersion\u0026gt; — minimum supported router version \u0026lt;i2p:minJavaVersion\u0026gt; — required minimum Java runtime \u0026lt;i2p:update\u0026gt; — lists multiple download mirrors (I2P, HTTPS, torrent) \u0026lt;i2p:revocations\u0026gt; — certificate revocation data \u0026lt;i2p:blocklist\u0026gt; — network-level blocklists for compromised peers Feed Distribution Channel Description Usage I2P HTTP (eepsite) Primary update source Private, resilient Clearnet HTTPS Fallback mirror Public fallback BitTorrent magnet Distributed channel Reduces mirror load Routers prefer the I2P feed but can fall back to clearnet or torrent distribution if necessary.\n2. File Formats SU3 (Current Standard) Introduced in 0.9.9, SU3 replaced the legacy SUD and SU2 formats.\nEach file contains a header, payload, and trailing signature.\nHeader Structure\nField Description Magic \"I2Psu3\" Format Version 0 Signature Type e.g., 0x000B (RSA-SHA512-4096) Signature Length 512 bytes Version String Router version Signer ID Certificate name Content Type 1 = router update, 3 = reseed, 4 = news feed Signature Verification Steps\nParse header and identify signature algorithm. Verify hash and signature using stored signer certificate. Confirm signer not revoked. Compare embedded version string with payload metadata. Routers ship with trusted signer certificates (currently zzz and str4d) and reject any unsigned or revoked sources.\nSU2 (Obsolete) Used .su2 extension with Pack200-compressed JARs. Removed after Java 14 deprecated Pack200 (JEP 367). Disabled in I2P 0.9.48+; now fully replaced by ZIP compression. SUD (Legacy) Early DSA-SHA1-signed ZIP format (pre-0.9.9). No signer ID or header, limited integrity. Superseded due to weak cryptography and lack of version enforcement. 3. Update Workflow 3.1 Header Verification Routers fetch only the SU3 header to verify the version string before downloading full files.\nThis prevents wasting bandwidth on stale mirrors or outdated versions.\n3.2 Full Download After verifying the header, the router downloads the complete .su3 file from:\nIn-network eepsite mirrors (preferred) HTTPS clearnet mirrors (fallback) BitTorrent (optional peer-assisted distribution) Downloads use standard I2PTunnel HTTP clients, with retries, timeout handling, and mirror fallback.\n3.3 Signature Verification Each downloaded file undergoes:\nSignature check: RSA-4096/SHA512 verification Version matching: Header vs. payload version check Downgrade prevention: Ensures update is newer than installed version Invalid or mismatched files are discarded immediately.\n3.4 Installation Staging Once verified:\nExtract ZIP contents to temporary directory Remove files listed in deletelist.txt Replace native libraries if lib/jbigi.jar is included Copy signer certificates to ~/.i2p/certificates/ Move update to i2pupdate.zip for application on next restart The update installs automatically on next startup or when “Install update now” is triggered manually.\n4. File Management deletelist.txt A plaintext list of obsolete files to remove before unpacking new contents.\nRules:\nOne path per line (relative paths only) Lines starting with # ignored .. and absolute paths rejected Native Libraries To prevent stale or mismatched native binaries:\nIf lib/jbigi.jar exists, old .so or .dll files are deleted Ensures platform-specific libraries are freshly extracted 5. Certificate Management Routers can receive new signer certificates through updates or news feed revocations.\nNew .crt files are copied to the certificate directory. Revoked certificates are deleted before future verifications. Supports key rotation without requiring manual user intervention. All updates are signed offline using air-gapped signing systems.\nPrivate keys are never stored on build servers.\n6. Developer Guidelines Topic Details Signing Use RSA-4096 (SHA-512) via apps/jetty/news SU3 tooling. Mirror Policy I2P eepsite preferred, clearnet HTTPS fallback, torrent optional. Testing Validate updates from prior releases, across all OS platforms. Version Enforcement minVersion prevents incompatible upgrades. Certificate Rotation Distribute new certs in updates and revocation lists. Future releases will explore post-quantum signature integration (see Proposal 169) and reproducible builds.\n7. Security Overview Threat Mitigation Tampering Cryptographic signature (RSA-4096/SHA512) Key Compromise Feed-based certificate revocation Downgrade Attack Version comparison enforcement Mirror Hijack Signature verification, multiple mirrors DoS Fallback to alternate mirrors/torrents MITM HTTPS transport + signature-level integrity 8. Versioning Router: 2.10.0 (API 0.9.67) Semantic versioning with Major.Minor.Patch. Minimum version enforcement prevents unsafe upgrades. Supported Java: Java 8–17. Future 2.11.0+ will require Java 17+. ","description":"Secure signed update mechanism and feed structure for I2P routers","id":"aea843f73d809c9546b3d675324af161","section":"docs","title":"Software Update Specification","url":"/en/docs/specs/updates/"},{"categories":null,"content":" Deprecated: SSU was superseded by SSU2. Support was removed from i2pd 2.44.0 (API 0.9.56, Nov 2022) and from Java I2P 2.4.0 (API 0.9.61, Dec 2023).\nSSU provided UDP-based, semi-reliable delivery with congestion control, NAT traversal, and introducer support. It complemented NTCP by handling routers behind NAT/firewalls and by coordinating IP discovery.\nAddress Elements transport: SSU caps: capability flags (B, C, 4, 6, etc.) host / port: IPv4 or IPv6 listener (optional when firewalled) key: Base64 introduction key mtu: Optional; default 1484 (IPv4) / 1488 (IPv6) ihost/ikey/iport/itag/iexp: introducer entries when the router is firewalled Features Cooperative NAT traversal using introducers Local IP detection via peer tests and inspection of inbound packets Automatically relayed firewall status to other transports and the router console Semireliable delivery: messages retransmitted up to a limit, then dropped Congestion control with additive increase / multiplicative decrease and fragment ACK bitfields SSU also handled metadata tasks such as timing beacons and MTU negotiation. All functionality is now provided (with modern cryptography) by SSU2.\n","description":"Original Secure Semireliable UDP transport","id":"15d4d0ea2bfc8074b5a7981b8673c420","section":"docs","title":"SSU (legacy)","url":"/en/docs/legacy/ssu/"},{"categories":null,"content":" Deprecated: SSU (Secure Semi-Reliable UDP) has been replaced by SSU2. Java I2P removed SSU in release 2.4.0 (API 0.9.61) and i2pd removed it in 2.44.0 (API 0.9.56). This document is retained for historical reference only.\nHighlights UDP transport providing encrypted, authenticated point-to-point delivery of I2NP messages. Relied on a 2048-bit Diffie–Hellman handshake (same prime as ElGamal). Each datagram carried a 16-byte HMAC-MD5 (non-standard truncated variant) + 16-byte IV followed by AES-256-CBC encrypted payload. Replay prevention and session state tracked within the encrypted payload. Message Header [16-byte MAC][16-byte IV][encrypted payload] MAC calculation used: HMAC-MD5(ciphertext || IV || (len ^ version ^ ((netid-2)\u0026lt;\u0026lt;8))) with a 32-byte MAC key. Payload length was big-endian 16-bit appended inside the MAC calculation. Protocol version defaulted to 0; netId defaulted to 2 (main network).\nSession \u0026amp; MAC Keys Derived from the DH shared secret:\nConvert the shared value to a big-endian byte array (prepend 0x00 if high bit set). Session key: first 32 bytes (pad with zeros if shorter). MAC key: bytes 33–64; if insufficient, fall back to SHA-256 hash of the shared value. Status Routers no longer advertise SSU addresses. Clients should migrate to SSU2 or NTCP2 transports. Historical implementations can be found in older releases:\nJava sources prior to 2.4.0 under router/transport/udp i2pd sources prior to 2.44.0 For current UDP transport behaviour, refer to SSU2 specification.\n","description":"Original UDP transport used prior to SSU2","id":"1eefecf66e3adc6ea013d5a5e58326da","section":"docs","title":"SSU Transport (Deprecated)","url":"/en/docs/legacy/ssu/"},{"categories":null,"content":"Status This document defines the final SSU2 (Secure Semi-Reliable UDP version 2) protocol as implemented in all current I2P routers. SSU2 has fully replaced SSU1 as of I2P 0.9.61 (Java) and i2pd 2.44.0, providing improved security, performance, and NAT traversal.\nFor full technical and security background, refer to Proposal 159.\n1. Overview SSU2 is a UDP-based transport layer protocol used for secure, semi-reliable router-to-router communication in I2P. It is not a general-purpose transport but is specialized for I2NP message exchange.\nCore Capabilities Authenticated key exchange via Noise XK pattern Encrypted headers for DPI resistance NAT traversal using relays and hole-punching Connection migration and address validation Optional path validation Forward secrecy and replay protection Legacy and Compatibility Implementation SSU2 Default SSU1 Removed i2pd 2.44.0 2.44.0 Java I2P 0.9.56 0.9.61 SSU1 is no longer in use across the public I2P network.\n2. Cryptography SSU2 uses Noise_XK_25519_ChaChaPoly_SHA256 with I2P-specific extensions.\nFunction Algorithm Notes Diffie-Hellman X25519 (RFC 7748) 32-byte keys Cipher ChaCha20/Poly1305 (RFC 7539) AEAD encryption Hash SHA-256 Used for key derivation and message integrity KDF HKDF-SHA256 (RFC 5869) For session and header keys Headers and payloads are cryptographically bound via mixHash().\nAll cryptographic primitives are shared with NTCP2 and ECIES for implementation efficiency.\n3. Message Overview 3.1 UDP Datagram Rules Each UDP datagram carries exactly one SSU2 message. Session Confirmed messages may be fragmented across multiple datagrams. Minimum size: 40 bytes\nMaximum size: 1472 bytes (IPv4) / 1452 bytes (IPv6)\n3.2 Message Types Type Message Header Description 0 Session Request 32B Handshake initiation 1 Session Created 32B Handshake response 2 Session Confirmed 16B Final handshake, may be fragmented 6 Data 16B Encrypted I2NP message blocks 7 Peer Test 32B NAT reachability testing 9 Retry 32B Token or rejection notice 10 Token Request 32B Request for validation token 11 Hole Punch 32B NAT traversal signaling 4. Session Establishment 4.1 Standard Flow (Valid Token) Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.2 Token Acquisition Alice Bob TokenRequest ───────────────\u0026gt; \u0026lt;────────────── Retry (Token) SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.3 Invalid Token Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── Retry (Termination) 5. Header Structures 5.1 Long Header (32 bytes) Used before session establishment (SessionRequest, Created, Retry, PeerTest, TokenRequest, HolePunch).\nField Size Description Destination Connection ID 8 Random unique ID Packet Number 4 Random (ignored during handshake) Type 1 Message type Version 1 Always 2 NetID 1 2 = main I2P network Flags 1 Reserved (0) Source Connection ID 8 Random ID distinct from destination Token 8 Token for address validation 5.2 Short Header (16 bytes) Used during established sessions (SessionConfirmed, Data).\nField Size Description Destination Connection ID 8 Stable throughout session Packet Number 4 Incrementing per message Type 1 Message type (2 or 6) Flags 3 ACK/fragment flags 6. Encryption 6.1 AEAD All payloads are encrypted with ChaCha20/Poly1305 AEAD:\nciphertext = ChaCha20_Poly1305_Encrypt(key, nonce, plaintext, associated_data) Nonce: 12 bytes (4 zero + 8 counter) Tag: 16 bytes Associated Data: includes header for integrity binding 6.2 Header Protection Headers are masked using ChaCha20 keystream derived from session header keys. This ensures all Connection IDs and packet fields appear random, providing DPI resistance.\n6.3 Key Derivation Phase Input Output Initial introKey + salt handshake header key Handshake DH(X25519) chainKey + AEAD key Data phase chainKey TX/RX keys Key rotation oldKey newKey 7. Security and Replay Prevention Tokens are per-IP, expiring in ~60 seconds. Replays are prevented via per-session Bloom filters. Duplicate ephemeral keys are rejected. Headers and payloads are cryptographically tied. Routers must discard any packet failing AEAD authentication or with an invalid version or NetID.\n8. Packet Numbering and Session Lifetime Each direction maintains its own 32-bit counter.\nStarts at 0, increments per packet. Must not wrap; session rekey or terminate before reaching 2³². Connection IDs remain static for the entire session, including during migration.\n9. Data Phase Type = 6 (Data) Short header (16 bytes) Payload contains one or more encrypted blocks: ACK/NACK lists I2NP message fragments Padding (0–31 bytes random) Termination blocks (optional) Selective retransmission and out-of-order delivery are supported. Reliability remains “semi-reliable” — missing packets may be dropped silently after retry limits.\n10. Relay and NAT Traversal Message Type Purpose Peer Test 7 Determines inbound reachability Retry 9 Issues new token or rejection Token Request 10 Requests new address token Hole Punch 11 Coordinates NAT hole punching Relay routers assist peers behind restrictive NATs using these control messages.\n11. Session Termination Either peer may close the session using a Termination block within a Data message.\nResources must be released immediately after receipt.\nRepeat termination packets may be ignored after acknowledgment.\n12. Implementation Guidelines Routers MUST:\nValidate version = 2 and NetID = 2. Drop packets \u0026lt;40 bytes or invalid AEAD. Enforce 120s replay cache. Reject reused tokens or ephemeral keys. Routers SHOULD:\nRandomize padding 0–31 bytes. Use adaptive retransmission (RFC 6298). Implement per-peer path validation before migration. 13. Security Summary Property Achieved By Forward secrecy X25519 ephemeral keys Replay protection Tokens + Bloom filter Authenticated encryption ChaCha20/Poly1305 KCI resistance Noise XK pattern DPI resistance Encrypted headers NAT traversal Relay + Hole Punch Migration Static connection IDs 14. References Proposal 159 – SSU2 Noise Protocol Framework [RFC 9000 – QUIC Transport] [RFC 9001 – QUIC TLS] [RFC 7539 – ChaCha20/Poly1305 AEAD] [RFC 7748 – X25519 ECDH] [RFC 5869 – HKDF-SHA256] ","description":"Secure Semi-Reliable UDP Transport Protocol Version 2","id":"b45756033b706b68daaee09f536f3c91","section":"docs","title":"SSU2 Specification","url":"/en/docs/specs/ssu2/"},{"categories":null,"content":"Overview The I2P Streaming Library provides reliable, in-order, authenticated transport over I2P’s message layer, similar to TCP over IP.\nIt sits above the I2CP protocol and is used by nearly all interactive I2P applications, including HTTP proxies, IRC, BitTorrent, and email.\nCore Characteristics One-phase connection setup using SYN, ACK, and FIN flags that can be bundled with payload data to reduce round-trips. Sliding-window congestion control, with slow start and congestion avoidance tuned for I2P’s high-latency environment. Packet compression (default 4KB compressed segments) balancing retransmission cost and fragmentation latency. Fully authenticated, encrypted, and reliable channel abstraction between I2P destinations. This design enables small HTTP requests and responses to complete in a single round-trip.\nA SYN packet may carry the request payload, while the responder’s SYN/ACK/FIN may contain the full response body.\nAPI Basics The Java streaming API mirrors standard Java socket programming:\nI2PSocketManager mgr = I2PSocketManagerFactory.createManager(host, port, options); I2PSocket socket = mgr.connect(destination); I2PServerSocket server = mgr.getServerSocket(); I2PSocketManagerFactory negotiates or reuses a router session via I2CP. If no key is provided, a new destination is automatically generated. Developers can pass I2CP options (e.g., tunnel lengths, encryption types, or connection settings) through the options map. I2PSocket and I2PServerSocket mirror standard Java Socket interfaces, making migration straightforward. Full Javadocs are available from the I2P router console or here.\nConfiguration and Tuning You can pass configuration properties when creating a socket manager via:\nI2PSocketManagerFactory.createManager(host, port, properties); Key Options Option Description Default i2p.streaming.maxWindowSize Maximum send window (bytes) 128 KB i2p.streaming.initialRTO Initial retransmission timeout 9s i2p.streaming.inactivityTimeout Timeout before connection close 90s i2p.streaming.enforceProtocol Enforce protocol ID (prevents confusion) true i2p.streaming.congestionAlgorithm Congestion control method Default (AIMD TCP-like) i2p.streaming.disableRejectLogging Disable logging rejected packets false Behavior by Workload Workload Recommended Settings HTTP-like Default parameters are ideal. Bulk Transfer Increase window size to 256 KB or 512 KB; lengthen timeouts. Real-time Streaming Lower tunnel length to 1-2 hops; adjust RTO downwards. Newer features since version 0.9.4 include reject log suppression, DSA list support (0.9.21), and mandatory protocol enforcement (0.9.36).\nRouters since 2.10.0 include post-quantum hybrid encryption (ML-KEM + X25519) at the transport layer.\nProtocol Details Each stream is identified by a Stream ID. Packets carry control flags similar to TCP: SYNCHRONIZE, ACK, FIN, and RESET.\nPackets may contain both data and control flags simultaneously, improving efficiency for short-lived connections.\nConnection Lifecycle SYN sent — initiator includes optional data. SYN/ACK response — responder includes optional data. ACK finalization — establishes reliability and session state. FIN/RESET — used for orderly closure or abrupt termination. Fragmentation and Reordering Because I2P tunnels introduce latency and message reordering, the library buffers packets from unknown or early-arriving streams.\nBuffered messages are stored until synchronization completes, ensuring complete, in-order delivery.\nProtocol Enforcement The option i2p.streaming.enforceProtocol=true (default since 0.9.36) ensures connections use the correct I2CP protocol number, preventing conflicts between multiple subsystems sharing one destination.\nInteroperability and Best Practices The streaming protocol coexists with the Datagram API, giving developers the choice between connection-oriented and connectionless transports.\nUse Case Recommended Transport Reliable, ordered data (HTTP, IRC, FTP) Streaming Connectionless or lossy data (DNS, telemetry) Datagram Shared Clients Applications can reuse existing tunnels by running as shared clients, allowing multiple services to share the same destination.\nWhile this reduces overhead, it increases cross-service correlation risk—use with care.\nCongestion Control The streaming layer continuously adapts to network latency and throughput via RTT-based feedback. Applications perform best when routers are contributing peers (participating tunnels enabled). TCP-like congestion control mechanisms prevent overloading slow peers and help balance bandwidth use across tunnels. Latency Considerations Because I2P adds several hundred milliseconds of base latency, applications should minimize round-trips.\nBundle data with connection setup where possible (e.g., HTTP requests in SYN).\nAvoid designs relying on many small sequential exchanges.\nTesting and Compatibility Always test against both Java I2P and i2pd to ensure full compatibility. Although the protocol is standardized, minor implementation differences may exist. Handle older routers gracefully—many peers still run pre-2.0 versions. Monitor connection stats using I2PSocket.getOptions() and getSession() to read RTT and retransmission metrics. Performance depends heavily on tunnel configuration:\nShort tunnels (1–2 hops) → lower latency, reduced anonymity. Long tunnels (3+ hops) → higher anonymity, increased RTT. Key Improvements (2.0.0–2.10.0) Feature Introduced Description Persistent ACK Bundling 2.0.0 Optimized round-trip reduction for HTTP workloads. Adaptive Window Scaling 2.3.0 Improved large file transfer stability. Thread Pooling and Socket Reuse 2.5.0 Reduced per-connection overhead. Protocol Enforcement Default 0.9.36 Ensures correct stream usage. Hybrid ML-KEM Ratchet 2.10.0 Adds post-quantum hybrid encryption layer. i2pd Streaming API Compatibility Fixes 2.9.0 Full parity with Java I2P library behavior. Summary The I2P Streaming Library is the backbone of all reliable communication within I2P.\nIt ensures in-order, authenticated, encrypted message delivery and provides a near drop-in replacement for TCP in anonymous environments.\nTo achieve optimal performance:\nMinimize round-trips with SYN+payload bundling. Tune window and timeout parameters for your workload. Favor shorter tunnels for latency-sensitive applications. Use congestion-friendly designs to avoid overloading peers. ","description":"TCP-like transport used by most I2P applications","id":"d5eaf45dea26928a910e0f2b8a0e1037","section":"docs","title":"Streaming Protocol","url":"/en/docs/api/streaming/"},{"categories":null,"content":"Overview The I2P Streaming Library provides reliable, in-order, and authenticated data delivery on top of I2P’s unreliable message layer — analogous to TCP over IP【46†source】. It is used by nearly all interactive I2P applications such as web browsing, IRC, email, and file sharing.\nIt ensures reliable transmission, congestion control, retransmission, and flow control across I2P’s high-latency anonymous tunnels. Each stream is fully encrypted end-to-end between destinations.\nCore Design Principles The streaming library implements a one-phase connection setup, where SYN, ACK, and FIN flags may carry data payloads in the same message. This minimizes round-trips in high-latency environments — a small HTTP transaction can complete in a single round-trip【46†source】.\nCongestion control and retransmission are modeled after TCP but adapted for I2P’s environment. Window sizes are message-based, not byte-based, and tuned for tunnel latency and overhead. The protocol supports slow start, congestion avoidance, and exponential backoff similar to TCP’s AIMD algorithm【46†source】.\nArchitecture The streaming library operates between applications and the I2CP interface【46†source】.\nLayer Responsibility Application Standard I2PSocket and I2PServerSocket usage Streaming Library Connection setup, sequencing, retransmission, and flow control I2CP Tunnel creation, routing, and message handling I2NP / Router Layer Transport through tunnels Most users access it via I2PSocketManager, I2PTunnel, or SAMv3. The library transparently handles destination management, tunnel usage, and retransmissions.\nPacket Format +-----------------------------------------------+ | Send Stream ID (4B) | Receive Stream ID (4B) | +-----------------------------------------------+ | Sequence Number (4B) | Ack Through (4B) | +-----------------------------------------------+ | NACK Count (1B) | optional NACK list (4B each) +-----------------------------------------------+ | Flags (1B) | Option Size (1B) | Options ... | +-----------------------------------------------+ | Payload ... | Header Details Stream IDs: 32-bit values uniquely identifying local and remote streams. Sequence Number: Starts at 0 for SYN, increments per message. Ack Through: Acknowledges all messages up to N, excluding those in the NACK list. Flags: Bitmask controlling state and behavior. Options: Variable-length list for RTT, MTU, and protocol negotiation. Key Flags Flag Purpose SYN Connection initiation ACK Acknowledge received packets FIN Graceful close RST Reset connection FROM_INCLUDED Sender’s destination included SIGNATURE_INCLUDED Message signed by sender ECHO / ECHO_REPLY Ping/Pong keepalive Flow Control and Reliability Streaming uses message-based windowing, unlike TCP’s byte-based approach. The number of unacknowledged packets allowed in flight equals the current window size (default 128)【46†source】.\nMechanisms Congestion control: Slow start and AIMD-based avoidance. Choke/Unchoke: Flow control signaling based on buffer occupancy. Retransmission: RFC 6298-based RTO calculation with exponential backoff. Duplicate filtering: Ensures reliability over potentially reordered messages. Typical configuration values:\nParameter Default Description maxWindowSize 128 Max unacknowledged messages maxMessageSize 1730 Maximum payload bytes per message initialRTO 9000 ms Initial retransmission timeout inactivityTimeout 90000 ms Idle connection timeout connectTimeout 300000 ms Connection establishment timeout Connection Establishment Initiator sends a SYN (optionally with payload and FROM_INCLUDED). Responder replies with SYN+ACK (may include payload). Initiator sends final ACK confirming establishment. Optional initial payloads allow data transmission before full handshake completion.\nImplementation Details Retransmission and Timeout The retransmission algorithm follows RFC 6298.\nInitial RTO: 9s Min RTO: 100ms Max RTO: 45s Alpha: 0.125 Beta: 0.25 Control Block Sharing Recent connections to the same peer reuse previous RTT and window data for faster ramp-up, avoiding “cold start” latency. Control blocks expire after several minutes.\nMTU and Fragmentation Default MTU: 1730 bytes (fits two I2NP messages). ECIES destinations: 1812 bytes (reduced overhead). Minimum supported MTU: 512 bytes. Payload size excludes the 22-byte minimum streaming header.\nVersion History Router Version Feature 0.7.1 Protocol numbers defined in I2CP 0.9.11 Variable-length signatures 0.9.12 ECDSA signature support 0.9.15 Ed25519 signature support 0.9.18 Ping/Pong payloads 0.9.20 FROM_INCLUDED not required in RESET 0.9.36 Protocol enforcement enabled by default 0.9.39 OFFLINE_SIGNATURE support 0.9.58 Bob’s hash added to NACK field in SYN 2.10.0 Post-Quantum hybrid encryption (experimental) Application-Level Usage Java Example Properties props = new Properties(); props.setProperty(\u0026#34;i2p.streaming.maxWindowSize\u0026#34;, \u0026#34;512\u0026#34;); I2PSocketManager mgr = I2PSocketManagerFactory.createManager(props); I2PSocket socket = mgr.connect(destination); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); SAMv3 and i2pd Support SAMv3: Provides STREAM and DATAGRAM modes for non-Java clients. i2pd: Exposes identical streaming parameters via configuration file options (e.g. i2p.streaming.maxWindowSize, profile, etc). Choosing Between Streaming and Datagrams Use Case Recommended Transport Reason HTTP, IRC, Email Streaming Requires reliability DNS Repliable Datagram Single request/response Telemetry, Logging Raw Datagram Best-effort acceptable P2P DHT Datagram High connection churn Security and Post-Quantum Future Streaming sessions are end-to-end encrypted at the I2CP layer.\nPost-quantum hybrid encryption (ML-KEM + X25519) is supported experimentally in 2.10.0 but disabled by default.\nReferences Streaming API Overview Streaming Protocol Specification I2CP Specification Proposal 144: Streaming MTU Calculations I2P 2.10.0 Release Notes ","description":"Reliable, TCP-like transport used by most I2P applications","id":"100837c91cc0808ee048c86902b36251","section":"docs","title":"Streaming Protocol","url":"/en/docs/specs/streaming/"},{"categories":null,"content":"This implementation of I2P (the Java implementation distributed on this site) includes a “Strict Countries List” used to adjust router behavior in regions where participating in routing for others may be restricted by law. While we are not aware of jurisdictions that prohibit using I2P, several have broad prohibitions on relaying traffic. Routers that appear to be in “strict” countries are automatically placed into Hidden mode.\nThe Project references research from civil and digital rights organizations when making these decisions. In particular, ongoing research by Freedom House informs our choices. General guidance is to include countries with a Civil Liberties (CL) score of 16 or less, or an Internet Freedom score of 39 or less (not free).\nHidden Mode Summary When a router is placed into Hidden mode, three key things change about its behavior:\nIt does not publish a RouterInfo to the netDb. It does not accept participating tunnels. It rejects direct connections to routers in the same country. These defenses make routers more difficult to enumerate reliably, and reduce the risk of violating local prohibitions on relaying traffic for others.\nStrict Countries List (as of 2024) /* Afghanistan */ \u0026#34;AF\u0026#34;, /* Azerbaijan */ \u0026#34;AZ\u0026#34;, /* Bahrain */ \u0026#34;BH\u0026#34;, /* Belarus */ \u0026#34;BY\u0026#34;, /* Brunei */ \u0026#34;BN\u0026#34;, /* Burundi */ \u0026#34;BI\u0026#34;, /* Cameroon */ \u0026#34;CM\u0026#34;, /* Central African Republic */ \u0026#34;CF\u0026#34;, /* Chad */ \u0026#34;TD\u0026#34;, /* China */ \u0026#34;CN\u0026#34;, /* Cuba */ \u0026#34;CU\u0026#34;, /* Democratic Republic of the Congo */ \u0026#34;CD\u0026#34;, /* Egypt */ \u0026#34;EG\u0026#34;, /* Equatorial Guinea */ \u0026#34;GQ\u0026#34;, /* Eritrea */ \u0026#34;ER\u0026#34;, /* Ethiopia */ \u0026#34;ET\u0026#34;, /* Iran */ \u0026#34;IR\u0026#34;, /* Iraq */ \u0026#34;IQ\u0026#34;, /* Kazakhstan */ \u0026#34;KZ\u0026#34;, /* Laos */ \u0026#34;LA\u0026#34;, /* Libya */ \u0026#34;LY\u0026#34;, /* Myanmar */ \u0026#34;MM\u0026#34;, /* North Korea */ \u0026#34;KP\u0026#34;, /* Palestinian Territories */ \u0026#34;PS\u0026#34;, /* Pakistan */ \u0026#34;PK\u0026#34;, /* Rwanda */ \u0026#34;RW\u0026#34;, /* Saudi Arabia */ \u0026#34;SA\u0026#34;, /* Somalia */ \u0026#34;SO\u0026#34;, /* South Sudan */ \u0026#34;SS\u0026#34;, /* Sudan */ \u0026#34;SD\u0026#34;, /* Eswatini (Swaziland) */ \u0026#34;SZ\u0026#34;, /* Syria */ \u0026#34;SY\u0026#34;, /* Tajikistan */ \u0026#34;TJ\u0026#34;, /* Thailand */ \u0026#34;TH\u0026#34;, /* Turkey */ \u0026#34;TR\u0026#34;, /* Turkmenistan */ \u0026#34;TM\u0026#34;, /* Venezuela */ \u0026#34;VE\u0026#34;, /* United Arab Emirates */ \u0026#34;AE\u0026#34;, /* Uzbekistan */ \u0026#34;UZ\u0026#34;, /* Vietnam */ \u0026#34;VN\u0026#34;, /* Western Sahara */ \u0026#34;EH\u0026#34;, /* Yemen */ \u0026#34;YE\u0026#34; If you believe a country should be added or removed from the strict list, please open an issue: https://i2pgit.org/i2p/i2p.i2p/\nReference: Freedom House – https://freedomhouse.org/\n","description":"How I2P behaves in jurisdictions with restrictions on routing or anonymity tools (Hidden Mode and strict list)","id":"483dc8380c381981cff8df178412f086","section":"docs","title":"Strict/Restrictive Countries","url":"/en/docs/overview/restrictive-countries/"},{"categories":null,"content":" Note: This archive captures speculative design work predating I2P 0.9.41. For the production implementation, consult the tunnel documentation.\nConfiguration Alternatives Ideas considered for future tunnel knobs included:\nFrequency throttles for message delivery Padding policies (including chaff injection) Tunnel lifetime controls Batch and queue strategies for payload dispatch None of these options shipped with the legacy implementation.\nPadding Strategies Potential padding approaches discussed:\nNo padding at all Random-length padding Fixed-length padding Padding to the nearest kilobyte Padding to powers of two (2^n bytes) Early measurements (release 0.4) led to the current fixed 1024-byte tunnel message size. Higher-level garlic messages may add their own padding.\nFragmentation To prevent tagging attacks via message length, tunnel messages are fixed at 1024 bytes. Larger I2NP payloads are fragmented by the gateway; the endpoint reassembles fragments within a short timeout. Routers may rearrange fragments to maximize packing efficiency before sending.\nAdditional Alternatives Adjust Tunnel Processing Midstream Three possibilities were examined:\nAllow an intermediate hop to terminate a tunnel temporarily by granting access to decrypted payloads. Permit participating routers to “remix” messages by sending them through one of their own outbound tunnels before continuing to the next hop. Enable the tunnel creator to redefine a peer’s next hop dynamically. Bidirectional Tunnels Using separate inbound and outbound tunnels limits the information any single set of peers can observe (e.g., a GET request vs. a large response). Bidirectional tunnels simplify peer management but expose full traffic patterns to both directions simultaneously. Unidirectional tunnels therefore remained the preferred design.\nBackchannels and Variable Sizes Allowing variable tunnel message sizes would enable covert channels between colluding peers (e.g., encoding data via selected sizes or frequencies). Fixed-size messages mitigate this risk at the cost of additional padding overhead.\nTunnel Building Alternatives Reference: Hashing it out in Public\nLegacy “Parallel” Build Method Prior to release 0.6.1.10, tunnel build requests were sent in parallel to each participant. This method is documented on the old tunnel page.\nOne-Shot Telescopic Building (Current Method) The modern approach sends build messages hop-by-hop through the partially constructed tunnel. Although similar to Tor’s telescoping, routing build messages through exploratory tunnels reduces information leakage.\n“Interactive” Telescoping Building one hop at a time with explicit round-trips allows peers to count messages and infer their position in the tunnel, so this approach was rejected.\nNon-Exploratory Management Tunnels One proposal was to maintain a separate pool of management tunnels for build traffic. While it could help partitioned routers, it was deemed unnecessary with adequate network integration.\nExploratory Delivery (Legacy) Before 0.6.1.10, individual tunnel requests were garlic-encrypted and delivered via exploratory tunnels, with replies returning separately. This strategy was replaced by the current one-shot telescoping method.\nTakeaways Fixed-size tunnel messages guard against size-based tagging and covert channels, despite added padding cost. Alternative padding, fragmentation, and build strategies were explored but not adopted when weighed against anonymity trade-offs. Tunnel design continues to balance efficiency, observability, and resistance to predecessor and congestion attacks. ","description":"Historical exploration of tunnel padding, fragmentation, and build strategies","id":"e5773155afe129d73b1384e5c116ec56","section":"docs","title":"Tunnel Discussion","url":"/en/docs/legacy/tunnel/"},{"categories":null,"content":" Scope: This guide consolidates the tunnel implementation, message format, and both tunnel creation specifications (ECIES and legacy ElGamal). Existing deep links continue to work through the aliases above.\nTunnel Model I2P forwards payloads through unidirectional tunnels: ordered sets of routers that carry traffic in a single direction. A full round trip between two destinations requires four tunnels (two outbound, two inbound).\nStart with the Tunnel Overview for terminology, then use this guide for the operational details.\nMessage Lifecycle The tunnel gateway batches one or more I2NP messages, fragments them, and writes delivery instructions. The gateway encapsulates the payload in a fixed-size (1024 B) tunnel message, padding if necessary. Each participant verifies the previous hop, applies its encryption layer, and forwards {nextTunnelId, nextIV, encryptedPayload} to the next hop. The tunnel endpoint removes the final layer, consumes delivery instructions, reassembles fragments, and dispatches the reconstructed I2NP messages. Duplicate detection uses a decaying Bloom filter keyed by the XOR of the IV and first cipher block to stop tagging attacks based on IV swaps.\nRoles at a Glance Role Pre-processing Crypto Operation Post-processing Outbound gateway (creator) Fragment, batch, pad Iteratively decrypt using every hop’s keys (so downstream peers encrypt) Forward to first hop Participant — Encrypt IV and payload with hop keys Forward to next hop Outbound endpoint — Encrypt once more to reveal plaintext payload Deliver to target tunnel/destination Inbound gateway Fragment, batch, pad Encrypt with local keys Forward to next hop Inbound endpoint (creator) — Iteratively decrypt using stored hop keys Reassemble and deliver locally Encryption Workflow Inbound tunnels: the gateway encrypts once with its layer key; downstream participants keep encrypting until the creator decrypts the final payload. Outbound tunnels: the gateway pre-applies the inverse of each hop’s encryption so that each participant encrypts. When the endpoint encrypts, the gateway’s original plaintext is revealed. Both directions forward {tunnelId, IV, encryptedPayload} to the next hop.\nTunnel Message Format Tunnel gateways fragment I2NP messages into fixed-size envelopes to hide payload length and simplify per-hop processing.\nEncrypted Layout +----------------+----------------+-------------------+ | Tunnel ID (4B) | IV (16B) | Encrypted payload | +----------------+----------------+-------------------+ Tunnel ID – 32-bit identifier for the next hop (non-zero, rotates each build cycle). IV – 16-byte AES IV chosen per message. Encrypted payload – 1008 bytes of AES-256-CBC ciphertext. Total size: 1028 bytes.\nDecrypted Layout After a hop removes its encryption layer:\n[Checksum (4B)][Padding ... 0x00 terminator] [Delivery Instructions 1][I2NP fragment 1] [Delivery Instructions 2][I2NP fragment 2] ... Checksum validates the decrypted block. Padding is random non-zero bytes terminated by a zero byte. Delivery instructions tell the endpoint how to handle each fragment (locally deliver, forward to another tunnel, etc.). Fragments carry the underlying I2NP messages; the endpoint reassembles them before passing them to higher layers. Processing Steps Gateways fragment and queue I2NP messages, retaining partial fragments briefly for reassembly. The gateway encrypts the payload with the appropriate layer keys and installs the tunnel ID plus IV. Each participant encrypts the IV (AES-256/ECB) and then the payload (AES-256/CBC) before re-encrypting the IV and forwarding the message. The endpoint decrypts in reverse order, verifies the checksum, consumes delivery instructions, and reassembles the fragments. Tunnel Creation (ECIES-X25519) Modern routers build tunnels with ECIES-X25519 keys, shrinking build messages and enabling forward secrecy.\nBuild message: a single TunnelBuild (or VariableTunnelBuild) I2NP message carries 1–8 encrypted build records, one per hop. Layer keys: creators derive per-hop layer, IV, and reply keys via HKDF using the hop’s static X25519 identity and the creator’s ephemeral key. Processing: each hop decrypts its record, validates request flags, writes the reply block (success or detailed failure code), re-encrypts the remaining records, and forwards the message. Replies: the creator receives a garlic-wrapped reply message. Records marked as failed include a severity code so the router can profile the peer. Compatibility: routers may still accept legacy ElGamal builds for backward compatibility, but new tunnels default to ECIES. For field-by-field constants and key derivation notes, see the ECIES proposal history and router source; this guide covers the operational flow.\nLegacy Tunnel Creation (ElGamal-2048) The original tunnel build format used ElGamal public keys. Modern routers keep limited support for backward compatibility.\nStatus: Obsolete. Retained here for historical reference and for anyone maintaining legacy-compatible tooling.\nNon-interactive telescoping: a single build message traverses the entire path. Each hop decrypts its 528-byte record, updates the message, and forwards it. Variable length: the Variable Tunnel Build Message (VTBM) permitted 1–8 records. The earlier fixed message always contained eight records to obscure tunnel length. Request record layout: Bytes 0–3 : Tunnel ID (receiving ID) Bytes 4–35 : Current hop router hash Bytes 36–39 : Next tunnel ID Bytes 40–71 : Next hop router hash Bytes 72–103 : AES-256 layer key Bytes 104–135: AES-256 IV key Bytes 136–167: AES-256 reply key Bytes 168–183: AES-256 reply IV Byte 184 : Flags (bit7=IBGW, bit6=OBEP) Bytes 185–188: Request time (hours since epoch) Bytes 189–192: Next message ID Bytes 193–221: Padding Flags: bit 7 indicates an inbound gateway (IBGW); bit 6 marks an outbound endpoint (OBEP). They are mutually exclusive. Encryption: each record is ElGamal-2048 encrypted with the hop’s public key. Symmetric AES-256-CBC layering ensures only the intended hop can read its record. Key facts: tunnel IDs are non-zero 32-bit values; creators may insert dummy records to hide actual tunnel length; reliability depends on retrying failed builds. Tunnel Pools and Lifecycle Routers maintain independent inbound and outbound tunnel pools for exploratory traffic and for each I2CP session.\nPeer selection: exploratory tunnels draw from the “active, not failing” peer bucket to encourage diversity; client tunnels prefer fast, high-capacity peers. Deterministic ordering: peers are sorted by the XOR distance between SHA256(peerHash || poolKey) and the pool’s random key. The key rotates on restart, giving stability within a run while frustrating predecessor attacks across runs. Lifecycle: routers track historical build times per {mode, direction, length, variance} tuple. As tunnels near expiration, replacements begin early; the router increases parallel builds when failures occur while capping outstanding attempts. Configuration knobs: active/backup tunnel counts, hop length and variance, zero-hop allowances, and build rate limits are all tunable per pool. Congestion and Reliability Although tunnels resemble circuits, routers treat them as message queues. Weighted Random Early Discard (WRED) is used to keep latency bounded:\nDrop probability rises as utilisation nears configured limits. Participants consider fixed-size fragments; gateways/endpoints drop based on combined fragment size, penalising large payloads first. Outbound endpoints drop before other roles to waste the least network effort. Guaranteed delivery is left to higher layers such as the Streaming library. Applications that require reliability must handle retransmission and acknowledgments themselves.\nFurther Reading Unidirectional Tunnels (Historical) Peer Selection Tunnel Overview Old Tunnel Implementation ","description":"Unified specification for building, encrypting, and transporting traffic with I2P tunnels.","id":"6fb0b76b8bc10fa3e571b748f502baaa","section":"docs","title":"Tunnel Operations Guide","url":"/en/docs/specs/implementation/"},{"categories":null,"content":" Status: Updated for I2P 2.10.0 (October 2025). Reflects the current dual ElGamal/ECIES tunnel architecture, short build messages, ChaCha20‑based encryption, and enhanced tunnel pooling logic.\nOverview I2P builds temporary, unidirectional tunnels — ordered sequences of routers that forward encrypted traffic.\nTunnels are classified as inbound (messages flow toward the creator) or outbound (messages flow away from the creator).\nA typical exchange routes Alice’s message out through one of her outbound tunnels, instructs the outbound endpoint to forward it to the gateway of one of Bob’s inbound tunnels, and then Bob receives it at his inbound endpoint.\nA: Outbound Gateway (Alice)\nB: Outbound Participant\nC: Outbound Endpoint\nD: Inbound Gateway\nE: Inbound Participant\nF: Inbound Endpoint (Bob)\nTunnels have a fixed lifetime of 10 minutes and carry fixed‑size messages of 1024 bytes (1028 bytes including the tunnel header) to prevent traffic analysis based on message size or timing patterns 【66†research.txt†L1-L20】.\nTunnel Vocabulary Tunnel gateway: First router in a tunnel. For inbound tunnels, this router’s identity appears in the published LeaseSet. For outbound tunnels, the gateway is the originating router (A and D above). Tunnel endpoint: Last router in a tunnel (C and F above). Tunnel participant: Intermediate router in a tunnel (B and E above). Participants cannot determine their position or tunnel direction. n‑hop tunnel: Number of inter‑router hops. 0‑hop: Gateway and endpoint are the same router – minimal anonymity. 1‑hop: Gateway connects directly to endpoint – low latency, low anonymity. 2‑hop: Default for exploratory tunnels; balanced security/performance. 3‑hop: Recommended for applications requiring strong anonymity. Tunnel ID: 4‑byte integer unique per router and per hop, randomly chosen by the creator. Each hop receives and forwards on different IDs. Tunnel Build Information Routers filling gateway, participant, and endpoint roles receive different records within the Tunnel Build Message.\nModern I2P supports two methods:\nElGamal (legacy, 528‑byte records) ECIES‑X25519 (current, 218‑byte records via Short Tunnel Build Message – STBM) 【66†research.txt†L20-L40】 Information Distributed to Participants Gateway receives:\nTunnel layer key (AES‑256 or ChaCha20 key depending on tunnel type) Tunnel IV key (for encrypting initialization vectors) Reply key and reply IV (for build reply encryption) Tunnel ID (inbound gateways only) Next hop identity hash and tunnel ID (if non‑terminal) Intermediate participants receive:\nTunnel layer key and IV key for their hop Tunnel ID and next hop info Reply key and IV for build response encryption Endpoints receive:\nTunnel layer and IV keys Reply router and tunnel ID (outbound endpoints only) Reply key and IV (outbound endpoints only) For full details see the Tunnel Creation Specification and ECIES Tunnel Creation Specification.\nTunnel Pooling Routers group tunnels into tunnel pools for redundancy and load distribution. Each pool maintains multiple parallel tunnels, allowing failover when one fails. Pools used internally are exploratory tunnels, while application‑specific pools are client tunnels 【66†research.txt†L60-L80】.\nEach destination maintains separate inbound and outbound pools configured by I2CP options (tunnel count, backup count, length, and QoS parameters). Routers monitor tunnel health, run periodic tests, and rebuild failed tunnels automatically to maintain pool size.\nTunnel Length 0‑hop Tunnels Offer only plausible deniability. Traffic always originates and terminates at the same router — discouraged for any anonymous use.\n1‑hop Tunnels Provide basic anonymity against passive observers but are vulnerable if an adversary controls that single hop.\n2‑hop Tunnels Include two remote routers and substantially increase attack cost. Default for exploratory pools.\n3‑hop Tunnels Recommended for applications requiring robust anonymity protection. Extra hops add latency without meaningful security gain.\nDefaults Routers use 2‑hop exploratory tunnels and application‑specific 2 or 3 hop client tunnels, balancing performance and anonymity.\nTunnel Testing Routers periodically test tunnels by sending a DeliveryStatusMessage through an outbound tunnel to an inbound tunnel.\nIf the test fails, both tunnels receive negative profile weight. Consecutive failures mark a tunnel unusable; the router then rebuilds a replacement and publishes a new LeaseSet. Results feed into peer capacity metrics used by the peer selection system 【66†research.txt†L80-L110】.\nTunnel Creation Routers construct tunnels using a non‑interactive telescoping method: a single Tunnel Build Message propagates hop‑by‑hop.\nEach hop decrypts its record, adds its reply, and forwards the message on. The final hop returns the aggregate build reply via a different path, preventing correlation. Modern implementations use Short Tunnel Build Messages (STBM) for ECIES and Variable Tunnel Build Messages (VTBM) for legacy paths. Each record is encrypted per‑hop using ElGamal or ECIES‑X25519 【66†research.txt†L110-L150】.\nTunnel Encryption Tunnel traffic uses multi‑layer encryption. Each hop adds or removes a layer of encryption as messages traverse the tunnel. ElGamal tunnels: AES‑256/CBC for payloads with PKCS#5 padding. ECIES tunnels: ChaCha20 or ChaCha20‑Poly1305 for authenticated encryption. Each hop has two keys: a layer key and an IV key. Routers decrypt the IV, use it to process the payload, then re‑encrypt the IV before forwarding. This double IV scheme prevents message tagging.\nOutbound gateways pre‑decrypt all layers so that endpoints receive plaintext after all participants have added encryption. Inbound tunnels encrypt in the opposite direction. Participants cannot determine tunnel direction or length 【66†research.txt†L150-L180】.\nOngoing Development Dynamic tunnel lifetimes and adaptive pool sizing for network load balancing Alternate tunnel testing strategies and individual hop diagnostics Optional proof‑of‑work or bandwidth certificate validation (implemented in API 0.9.65+) Traffic shaping and chaff insertion research for endpoint mixing Continued retirement of ElGamal and migration to ECIES‑X25519 See Also Tunnel Implementation Specification Tunnel Creation Specification (ElGamal) Tunnel Creation Specification (ECIES‑X25519) Tunnel Message Specification Garlic Routing I2P Network Database Peer Profiling and Selection I2P Threat Model ElGamal/AES + SessionTag Encryption I2CP Options ","description":"Overview of I2P tunnel terminology, construction, and lifecycle","id":"d2bb4d16ccaaecd4bfaae8d5b1356800","section":"docs","title":"Tunnel Routing","url":"/en/docs/overview/tunnel-routing/"},{"categories":null,"content":"Overview This specification documents the protocol for UDP BitTorrent announces in I2P. For the overall specification of BitTorrent in I2P, see the BitTorrent over I2P documentation. For background and additional information on the development of this specification, see Proposal 160.\nThis protocol was formally approved on June 24, 2025 and implemented in I2P version 2.10.0 (API 0.9.67), released September 8, 2025. UDP tracker support is currently operational on the I2P network with multiple production trackers and full i2psnark client support.\nDesign This specification uses repliable datagram2, repliable datagram3, and raw datagrams, as defined in the I2P Datagram Specification. Datagram2 and Datagram3 are variants of repliable datagrams, defined in Proposal 163. Datagram2 adds replay resistance and offline signature support. Datagram3 is smaller than the old datagram format, but without authentication.\nBEP 15 For reference, the message flow defined in BEP 15 is as follows:\nClient Tracker Connect Req. -------------\u0026gt; \u0026lt;-------------- Connect Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. The connect phase is required to prevent IP address spoofing. The tracker returns a connection ID that the client uses in subsequent announces. This connection ID expires by default in one minute at the client, and in two minutes at the tracker.\nI2P uses the same message flow as BEP 15, for ease of adoption in existing UDP-capable client code bases, for efficiency, and for security reasons discussed below:\nClient Tracker Connect Req. -------------\u0026gt; (Repliable Datagram2) \u0026lt;-------------- Connect Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) ... This potentially provides a large bandwidth savings over streaming (TCP) announces. While the Datagram2 is about the same size as a streaming SYN, the raw response is much smaller than the streaming SYN ACK. Subsequent requests use Datagram3, and the subsequent responses are raw.\nThe announce requests are Datagram3 so that the tracker need not maintain a large mapping table of connection IDs to announce destination or hash. Instead, the tracker may generate connection IDs cryptographically from the sender hash, the current timestamp (based on some interval), and a secret value. When an announce request is received, the tracker validates the connection ID, and then uses the Datagram3 sender hash as the send target.\nConnection Lifetime BEP 15 specifies that the connection ID expires in one minute at the client, and in two minutes at the tracker. It is not configurable. That limits the potential efficiency gains, unless clients batched announces to do all of them within a one-minute window. i2psnark does not currently batch announces; it spreads them out, to avoid bursts of traffic. Power users are reported to be running thousands of torrents at once, and bursting that many announces into one minute is not realistic.\nHere, we propose to extend the connect response to add an optional connection lifetime field. The default, if not present, is one minute. Otherwise, the lifetime specified in seconds shall be used by the client, and the tracker will maintain the connection ID for one minute more.\nCompatibility with BEP 15 This design maintains compatibility with BEP 15 as much as possible to limit changes required in existing clients and trackers.\nThe only required change is the format of peer info in the announce response. The addition of the lifetime field in the connect response is not required but is strongly recommended for efficiency, as explained above.\nSecurity Analysis An important goal of a UDP announce protocol is to prevent address spoofing. The client must actually exist and bundle a real leaseset. It must have inbound tunnels to receive the Connect Response. These tunnels could be zero-hop and built instantly, but that would expose the creator. This protocol accomplishes that goal.\nIssues This protocol does not support blinded destinations, but may be extended to do so. See below.\nSpecification Protocols and Ports Repliable Datagram2 uses I2CP protocol 19; repliable Datagram3 uses I2CP protocol 20; raw datagrams use I2CP protocol 18. Requests may be Datagram2 or Datagram3. Responses are always raw. The older repliable datagram (\u0026ldquo;Datagram1\u0026rdquo;) format using I2CP protocol 17 must NOT be used for requests or replies; these must be dropped if received on the request/reply ports. Note that Datagram1 protocol 17 is still used for the DHT protocol.\nRequests use the I2CP \u0026ldquo;to port\u0026rdquo; from the announce URL; see below. The request \u0026ldquo;from port\u0026rdquo; is chosen by the client, but should be nonzero, and a different port from those used by DHT, so that responses may be easily classified. Trackers should reject requests received on the wrong port.\nResponses use the I2CP \u0026ldquo;to port\u0026rdquo; from the request. The response \u0026ldquo;from port\u0026rdquo; is the \u0026ldquo;to port\u0026rdquo; from the request.\nAnnounce URL The announce URL format is not specified in BEP 15, but as in clearnet, UDP announce URLs are of the form \u0026ldquo;udp://host:port/path\u0026rdquo;. The path is ignored and may be empty, but is typically \u0026ldquo;/announce\u0026rdquo; on clearnet. The :port part should always be present; however, if the \u0026ldquo;:port\u0026rdquo; part is omitted, use a default I2CP port of 6969, as that is the common port on clearnet. There may also be CGI parameters \u0026amp;a=b\u0026amp;c=d appended; those may be processed and provided in the announce request, see BEP 41. If there are no parameters or path, the trailing / may also be omitted, as implied in BEP 41.\nDatagram Formats All values are sent in network byte order (big endian). Do not expect packets to be exactly of a certain size. Future extensions could increase the size of packets.\nConnect Request Client to tracker. 16 bytes. Must be repliable Datagram2. Same as in BEP 15. No changes.\nOffset Size Name Value 0 64-bit integer protocol_id 0x41727101980 // magic constant 8 32-bit integer action 0 // connect 12 32-bit integer transaction_id Connect Response Tracker to client. 16 or 18 bytes. Must be raw. Same as in BEP 15 except as noted below.\nOffset Size Name Value 0 32-bit integer action 0 // connect 4 32-bit integer transaction_id 8 64-bit integer connection_id 16 16-bit integer lifetime optional // Change from BEP 15 The response MUST be sent to the I2CP \u0026ldquo;to port\u0026rdquo; that was received as the request \u0026ldquo;from port\u0026rdquo;.\nThe lifetime field is optional and indicates the connection_id client lifetime in seconds. The default is 60, and the minimum if specified is 60. The maximum is 65535 or about 18 hours. The tracker should maintain the connection_id for 60 seconds more than the client lifetime.\nAnnounce Request Client to tracker. 98 bytes minimum. Must be repliable Datagram3. Same as in BEP 15 except as noted below.\nThe connection_id is as received in the connect response.\nOffset Size Name Value 0 64-bit integer connection_id 8 32-bit integer action 1 // announce 12 32-bit integer transaction_id 16 20-byte string info_hash 36 20-byte string peer_id 56 64-bit integer downloaded 64 64-bit integer left 72 64-bit integer uploaded 80 32-bit integer event 0 // 0: none; 1: completed; 2: started; 3: stopped 84 32-bit integer IP address 0 // default, unused in I2P 88 32-bit integer key 92 32-bit integer num_want -1 // default 96 16-bit integer port // must be same as I2CP from port 98 varies options optional // As specified in BEP 41 Changes from BEP 15:\nkey is ignored IP address is unused port is probably ignored but must be same as I2CP from port The options section, if present, is as defined in BEP 41 The response MUST be sent to the I2CP \u0026ldquo;to port\u0026rdquo; that was received as the request \u0026ldquo;from port\u0026rdquo;. Do not use the port from the announce request.\nAnnounce Response Tracker to client. 20 bytes minimum. Must be raw. Same as in BEP 15 except as noted below.\nOffset Size Name Value 0 32-bit integer action 1 // announce 4 32-bit integer transaction_id 8 32-bit integer interval 12 32-bit integer leechers 16 32-bit integer seeders 20 32 * n 32-byte hash binary hashes // Change from BEP 15 ... // Change from BEP 15 Changes from BEP 15:\nInstead of 6-byte IPv4+port or 18-byte IPv6+port, we return a multiple of 32-byte \u0026ldquo;compact responses\u0026rdquo; with the SHA-256 binary peer hashes. As with TCP compact responses, we do not include a port. The response MUST be sent to the I2CP \u0026ldquo;to port\u0026rdquo; that was received as the request \u0026ldquo;from port\u0026rdquo;. Do not use the port from the announce request.\nI2P datagrams have a very large maximum size of about 64 KB; however, for reliable delivery, datagrams larger than 4 KB should be avoided. For bandwidth efficiency, trackers should probably limit the maximum peers to about 50, which corresponds to about a 1600 byte packet before overhead at various layers, and should be within a two-tunnel-message payload limit after fragmentation.\nAs in BEP 15, there is no count included of the number of peer addresses (IP/port for BEP 15, hashes here) to follow. While not contemplated in BEP 15, an end-of-peers marker of all zeros could be defined to indicate that the peer info is complete and some extension data follows.\nSo that extension is possible in the future, clients should ignore a 32-byte all-zeros hash, and any data that follows. Trackers should reject announces from an all-zeros hash, although that hash is already banned by Java routers.\nScrape Scrape request/response from BEP 15 is not required by this specification, but may be implemented if desired, no changes required. The client must acquire a connection ID first. The scrape request is always repliable Datagram3. The scrape response is always raw.\nError Response Tracker to client. 8 bytes minimum (if the message is empty). Must be raw. Same as in BEP 15. No changes.\nOffset Size Name Value 0 32-bit integer action 3 // error 4 32-bit integer transaction_id 8 string message Extensions Extension bits or a version field are not included. Clients and trackers should not assume packets to be of a certain size. This way, additional fields can be added without breaking compatibility. The extensions format defined in BEP 41 is recommended if required.\nThe connect response is modified to add an optional connection ID lifetime.\nIf blinded destination support is required, we can either add the blinded 35-byte address to the end of the announce request, or request blinded hashes in the responses, using the BEP 41 format (parameters TBD). The set of blinded 35-byte peer addresses could be added to the end of the announce reply, after an all-zeros 32-byte hash.\nImplementation Guidelines See the design section above for a discussion of the challenges for non-integrated, non-I2CP clients and trackers.\nClients For a given tracker hostname, a client should prefer UDP over HTTP URLs, and should not announce to both.\nClients with existing BEP 15 support should require only small modifications.\nIf a client supports DHT or other datagram protocols, it should probably select a different port as the request \u0026ldquo;from port\u0026rdquo; so that the replies come back to that port and are not mixed up with DHT messages. The client only receives raw datagrams as replies. Trackers will never send a repliable datagram2 to the client.\nClients with a default list of opentrackers should update the list to add UDP URLs after the known opentrackers are known to support UDP.\nClients may or may not implement retransmission of requests. Retransmissions, if implemented, should use an initial timeout of at least 15 seconds, and double the timeout for each retransmission (exponential backoff).\nClients must back off after receiving an error response.\nTrackers Trackers with existing BEP 15 support should require only small modifications. This specification differs from the 2014 proposal, in that the tracker must support reception of repliable datagram2 and datagram3 on the same port.\nTo minimize tracker resource requirements, this protocol is designed to eliminate any requirement that the tracker store mappings of client hashes to connection IDs for later validation. This is possible because the announce request packet is a repliable Datagram3 packet, so it contains the sender\u0026rsquo;s hash.\nA recommended implementation is:\nDefine the current epoch as the current time with a resolution of the connection lifetime, epoch = now / lifetime. Define a cryptographic hash function H(secret, clienthash, epoch) which generates an 8 byte output. Generate the random constant secret used for all connections. For connect responses, generate connection_id = H(secret, clienthash, epoch) For announce requests, validate the received connection ID in the current epoch by verifying connection_id == H(secret, clienthash, epoch) || connection_id == H(secret, clienthash, epoch - 1) Deployment Status This protocol was approved on June 24, 2025 and is fully operational on the I2P network as of September 2025.\nCurrent Implementations i2psnark: Full UDP tracker support is included in I2P version 2.10.0 (API 0.9.67), released September 8, 2025. All I2P installations from this version forward include UDP tracker capability by default.\nzzzot tracker: Version 0.20.0-beta2 and later support UDP announces. As of October 2025, the following production trackers are operational:\nopentracker.dg2.i2p opentracker.simp.i2p opentracker.skank.i2p Client Compatibility Notes SAM v3.3 limitations: External BitTorrent clients using SAM (Simple Anonymous Messaging) require SAM v3.3 support for Datagram2/3. This is available in Java I2P but not currently supported by i2pd (the C++ I2P implementation), which may limit adoption in libtorrent-based clients like qBittorrent.\nI2CP clients: Clients using I2CP directly (such as BiglyBT) can implement UDP tracker support without SAM limitations.\nReferences [BEP15]: BitTorrent UDP Tracker Protocol - http://www.bittorrent.org/beps/bep_0015.html [BEP41]: UDP Tracker Protocol Extensions - http://www.bittorrent.org/beps/bep_0041.html [DATAGRAMS]: I2P Datagrams Specification - /docs/api/datagrams/ [Prop160]: UDP Trackers Proposal - /proposals/160-udp-trackers/ [Prop163]: Datagram2 Proposal - /proposals/163-datagram2/ [SPEC]: BitTorrent over I2P - /docs/applications/bittorrent/ ","description":"Protocol specification for UDP-based BitTorrent tracker announces in I2P","id":"2413d642663e185a8a31352c9a9e8f28","section":"docs","title":"UDP BitTorrent Announces","url":"/en/docs/specs/udp-bittorrent-announces/"},{"categories":null,"content":" Historical Notice: This page preserves the legacy “Unidirectional Tunnels” discussion for reference. Consult the active tunnel implementation documentation for current behaviour.\nOverview I2P builds unidirectional tunnels: one tunnel carries outbound traffic and a separate tunnel carries inbound replies. This structure dates to the earliest network designs and remains a key differentiator from bidirectional-circuit systems like Tor. For terminology and implementation details, see the tunnel overview and tunnel specification.\nReview Unidirectional tunnels keep request and response traffic separate, so any single group of colluding peers observes only half of a round trip. Timing attacks must intersect two tunnel pools (outbound and inbound) instead of analysing a single circuit, raising the bar for correlation. Independent inbound and outbound pools let routers adjust latency, capacity, and failure-handling characteristics per direction. Drawbacks include increased peer management complexity and the need to maintain multiple tunnel sets for reliable service delivery. Anonymity Hermann and Grothoff’s paper, I2P is Slow… and What to Do About It, analyses predecessor attacks against unidirectional tunnels, suggesting that determined adversaries can eventually confirm long-lived peers. Community feedback notes that the study relies on specific assumptions about adversary patience and legal powers, and does not weigh the approach against timing attacks that affect bidirectional designs. Continued research and practical experience keep reinforcing unidirectional tunnels as a deliberate anonymity choice rather than an oversight.\n","description":"Historical summary of I2P's unidirectional tunnel design.","id":"37ac13877a690f9c4635959a57451755","section":"docs","title":"Unidirectional Tunnels","url":"/en/docs/legacy/unidirectional/"},{"categories":null,"content":" The main I2P development branch (i2p.i2p) has been set up to enable developers to easily set up two of the commonly-used IDEs for Java development: Eclipse and NetBeans. Eclipse The main I2P development branches (i2p.i2p and branches from it) contain build.gradle to enable the branch to be easily set up in Eclipse. Make sure you have a recent version of Eclipse. Anything newer than 2017 should do. Check out the I2P branch into some directory (e.g. $HOME/dev/i2p.i2p). Select \"File → Import...\" and then under \"Gradle\" select \"Existing Gradle Project\". For \"Project root directory:\" choose the directory that the I2P branch was checked out to. In the \"Import Options\" dialog, select \"Gradle Wrapper\" and press Continue. In the \"Import Preview\" dialog you can review the project structure. Multiple projects should appear under \"i2p.i2p\". Press \"Finish\". Done! Your workspace should now contain all projects within the I2P branch, and their build dependencies should be correctly set up. NetBeans The main I2P development branches (i2p.i2p and branches from it) contain NetBeans project files. ","description":"Set up Eclipse and NetBeans for developing I2P with Gradle and bundled project files","id":"59847e4ae7ce8d8ccadb441422ecc856","section":"docs","title":"Using an IDE with I2P","url":"/en/docs/guides/ides/"},{"categories":null,"content":" Status: This is a concise reference for the v3dgsend utility. It complements the Datagram API and SAM v3 docs.\nOverview v3dgsend is a command-line helper for sending I2P datagrams using the SAM v3 interface. It is useful for testing datagram delivery, prototyping services, and verifying end-to-end behavior without writing a full client.\nTypical uses include:\nSmoke-testing datagram reachability to a Destination Validating firewall and address book configuration Experimenting with raw vs. signed (repliable) datagrams Usage Basic invocation varies by platform and packaging. Common options include:\nDestination: base64 Destination or .i2p name Protocol: raw (PROTOCOL 18) or signed (PROTOCOL 17) Payload: inline string or file input Refer to your distribution’s packaging or --help output for exact flags.\nSee Also Datagram API: /docs/api/datagrams/ SAM v3: /docs/api/samv3/ Streaming (alternative to datagrams): /docs/api/streaming/ ","description":"CLI utility for sending I2P datagrams via SAM v3","id":"3fe6f64806c4c692f530bf7fa6eb9c45","section":"docs","title":"v3dgsend","url":"/en/docs/api/v3dgsend/"},{"categories":null,"content":"This guide shows how to configure common browsers to send traffic through I2P\u0026rsquo;s built‑in HTTP proxy. It covers Safari, Firefox, and Chrome/Chromium browsers with detailed step-by-step instructions.\nImportant Notes:\nI2P\u0026rsquo;s default HTTP proxy listens on 127.0.0.1:4444. I2P protects traffic inside the I2P network (.i2p sites). Make sure your I2P router is running before configuring your browser. Safari (macOS) Safari uses the system-wide proxy settings on macOS.\nStep 1: Open Network Settings Open Safari and go to Safari → Settings (or Preferences) Click on the Advanced tab In the Proxies section, click Change Settings\u0026hellip; This will open your Mac\u0026rsquo;s System Network Settings.\nStep 2: Configure HTTP Proxy In the Network settings, check the box for Web Proxy (HTTP) Enter the following: Web Proxy Server: 127.0.0.1 Port: 4444 Click OK to save your settings You can now browse .i2p sites in Safari!\nNote: These proxy settings will affect all applications that use macOS system proxies. Consider creating a separate user account or using a different browser exclusively for I2P if you want to isolate I2P browsing.\nFirefox (Desktop) Firefox has its own proxy settings independent of the system, making it ideal for dedicated I2P browsing.\nStep 1: Open Settings Click the menu button (☰) in the top right Select Settings Step 2: Find Proxy Settings In the Settings search box, type \u0026ldquo;proxy\u0026rdquo; Scroll to Network Settings Click the Settings\u0026hellip; button Step 3: Configure Manual Proxy Select Manual proxy configuration Enter the following: HTTP Proxy: 127.0.0.1 Port: 4444 Leave SOCKS Host empty (unless you specifically need SOCKS proxy) Check Proxy DNS when using SOCKS only if using SOCKS proxy Click OK to save You can now browse .i2p sites in Firefox!\nTip: Consider creating a separate Firefox profile dedicated to I2P browsing. This keeps your I2P browsing isolated from regular browsing. To create a profile, type about:profiles in the Firefox address bar.\nChrome / Chromium (Desktop) Chrome and Chromium-based browsers (Brave, Edge, etc.) typically use system proxy settings on Windows and macOS. This guide shows the Windows configuration.\nStep 1: Open Chrome Settings Click the three dots menu (⋮) in the top right Select Settings Step 2: Open Proxy Settings In the Settings search box, type \u0026ldquo;proxy\u0026rdquo; Click Open your computer\u0026rsquo;s proxy settings Step 3: Open Manual Proxy Setup This will open Windows Network \u0026amp; Internet settings.\nScroll down to Manual proxy setup Click Set up Step 4: Configure Proxy Server Toggle Use a proxy server to On Enter the following: Proxy IP address: 127.0.0.1 Port: 4444 Optionally, add exceptions in \u0026ldquo;Don\u0026rsquo;t use the proxy server for addresses beginning with\u0026rdquo; (e.g., localhost;127.*) Click Save You can now browse .i2p sites in Chrome!\nNote: These settings affect all Chromium-based browsers and some other applications on Windows. To avoid this, consider using Firefox with a dedicated I2P profile instead.\nLinux: Chrome with Command-Line Flags On Linux, you can launch Chrome/Chromium with proxy flags to avoid changing system settings:\nchromium \\ --proxy-server=\u0026#34;http=127.0.0.1:4444 \\ --proxy-bypass-list=\u0026#34;\u0026lt;-loopback\u0026gt;\u0026#34; Or create a desktop launcher script:\n#!/bin/bash chromium --proxy-server=\u0026#34;http=127.0.0.1:4444\u0026#34; --user-data-dir=\u0026#34;$HOME/.config/chromium-i2p\u0026#34; The --user-data-dir flag creates a separate Chrome profile for I2P browsing.\nFirefox‑based Android (IceRaven and others) Modern “Fenix” Firefox builds limit about:config and extensions by default. IceRaven is a Firefox fork that enables a curated set of extensions, making proxy setup simple.\nExtension‑based configuration (IceRaven):\nIf you already use IceRaven, consider clearing browsing history first (Menu → History → Delete History). Open Menu → Add‑Ons → Add‑Ons Manager. Install the extension “I2P Proxy for Android and Other Systems”. The browser will now proxy through I2P. This extension also works on pre‑Fenix Firefox‑based browsers if installed from AMO: https://addons.mozilla.org/en-US/android/addon/i2p-proxy/\nEnabling wide extension support in Firefox Nightly requires a separate process documented by Mozilla: https://blog.mozilla.org/addons/2020/09/29/expanded-extension-support-in-firefox-for-android-nightly/\nInternet Explorer / Windows System Proxy On Windows, the system proxy dialog applies to IE and can be used by Chromium‑based browsers when they inherit system settings.\nOpen “Network and Internet Settings” → “Proxy”. Enable “Use a proxy server for your LAN”. Set address 127.0.0.1, port 4444 for HTTP.. Optionally check “Bypass proxy server for local addresses”. ","description":"Configure popular browsers to use I2P’s HTTP/HTTPS proxies on desktop and Android","id":"a40410c542dc82558c1c1a8be78d2e62","section":"docs","title":"Web Browser Configuration","url":"/en/docs/guides/browser-config/"}]