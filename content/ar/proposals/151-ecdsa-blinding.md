---
title: "تعمية المفاتيح في ECDSA"
number: "151"
author: "orignal"
created: "2019-05-21"
lastupdated: "2019-05-29"
status: "Open"
thread: "http://zzz.i2p/topics/2717"
toc: true
---

## الدافع

بعض الأشخاص لا يحبون EdDSA أو RedDSA. يجب أن نقدم بعض البدائل ونسمح لهم بتعمية التوقيعات في ECDSA.

## نظرة عامة

تصف هذه الاقتراح كيفية تعمية المفاتيح لأنواع التوقيع في ECDSA 1، 2، 3.

## الاقتراح

يعمل بنفس طريقة RedDSA، لكن كل شيء باللغة النهاية الكبيرة.
يُسمح فقط بنفس أنواع التوقيع، مثل 1->1، 2->2، 3->3.

### التعريفات

B
    نقطة الأساس في المنحنى

L
   ترتيب مجموعة المنحنى البيضوي. خاصية المنحنى.

DERIVE_PUBLIC(a)
    تحويل مفتاح خاص إلى عام، عبر ضرب B على منحنى بيضوي

alpha
    رقم عشوائي بطول 32 بايت معروف للذين يعرفون الوجهة.

GENERATE_ALPHA(destination, date, secret)
    توليد alpha لتاريخ اليوم، لأولئك الذين يعرفون الوجهة والسر.

a
    مفتاح التوقيع الخاص غير المعمى والمستخدم لتوقيع الوجهة

A
    مفتاح التوقيع العام غير المعمى بطول 32 بايت في الوجهة،
    = DERIVE_PUBLIC(a)، كما في المنحنى المعني

a'
    مفتاح التوقيع الخاص المعمى بطول 32 بايت المستخدم لتوقيع مجموعة الإيجار المشفرة
    هذا مفتاح ECDSA خاص صالح.

A'
    مفتاح التوقيع العام المعمى بطول 32 بايت في الوجهة،
    يمكن توليده باستخدام DERIVE_PUBLIC(a')، أو من A و alpha.
    هذا مفتاح ECDSA عام صالح على المنحنى

H(p, d)
    دالة تجزئة SHA-256 تأخذ سلسلة تكوين p وبيانات d، وتنتج مخرجاً بطول 32 بايت.

    استخدم SHA-256 كالتالي::

        H(p, d) := SHA-256(p || d)

HKDF(salt, ikm, info, n)
    دالة اشتقاق مفتاح تشفيرية تأخذ بعض المواد المفتاحية ikm (يجب أن تمتلك قوة تشفير جيدة لكن ليس من الضروري أن تكون سلسلة عشوائية موحدة)، وملح بطول 32 بايت، وعامل "info" خاص بالسياق، وتنتج مخرجًا بطول n بايت مناسب للاستخدام كمادة مفتاحية.

    استخدم HKDF كما هو محدد في [RFC-5869](https://tools.ietf.org/html/rfc5869)، باستخدام دالة HMAC التشفيرية SHA-256
    كما هو محدد في [RFC-2104](https://tools.ietf.org/html/rfc2104). هذا يعني أن SALT_LEN هو 32 بايت كحد أقصى.


### حسابات التعمية

يجب توليد سر جديد alpha والمفاتيح المعمّاة كل يوم (UTC).
السر alpha والمفاتيح المعمّاة محسوبة كالتالي.

GENERATE_ALPHA(destination, date, secret)، لجميع الأطراف:

```text
// GENERATE_ALPHA(destination, date, secret)

  // السر اختياري، وإلا فطوله صفر
  A = مفتاح التوقيع العام للوجهة
  stA = نوع توقيع A، 2 بايت بنهاية كبيرة (0x0001، 0x0002 أو 0x0003)
  stA' = نوع توقيع المفتاح العام المعمى A'، 2 بايت بنهاية كبيرة، دائمًا مثل stA
  keydata = A || stA || stA'
  datestring = 8 بايت ASCII YYYYMMDD من تاريخ اليوم UTC
  secret = سلسلة مشفرة بالـ UTF-8
  seed = HKDF(H("I2PGenerateAlpha", keydata), datestring || secret, "i2pblinding1", 64)
  // تعامل مع seed كنمط طول 64 بايت بنهاية كبيرة
  alpha = seed mod L
```


BLIND_PRIVKEY()، للمالك الذي يقوم بنشر مجموعة الإيجار:

```text
// BLIND_PRIVKEY()

  alpha = GENERATE_ALPHA(destination, date, secret)
  a = مفتاح التوقيع الخاص للوجهة
  // الجمع باستخدام الحساب العددي الاسكالي
  مفتاح التوقيع الخاص المعمى = a' = BLIND_PRIVKEY(a, alpha) = (a + alpha) mod L
  مفتاح التوقيع العام المعمى = A' = DERIVE_PUBLIC(a')
```


BLIND_PUBKEY()، للعملاء الذين يسترجعون مجموعة الإيجار:

```text
// BLIND_PUBKEY()

  alpha = GENERATE_ALPHA(destination, date, secret)
  A = مفتاح التوقيع العام للوجهة
  // الجمع باستخدام عناصر المجموعة (النقاط على المنحنى)
  المفتاح العام المعمى = A' = BLIND_PUBKEY(A, alpha) = A + DERIVE_PUBLIC(alpha)
```


تؤدي كلا الطريقتين لحساب A' إلى نفس النتيجة، كما هو مطلوب.

## عنوان b33

المفتاح العام في ECDSA هو زوج (X، Y)، لذا بالنسبة لـ P256، على سبيل المثال، هو 64 بايت، بدلاً من 32 كما في RedDSA.
إما سيكون العنوان b33 أطول، أو يمكن تخزين المفتاح العام في شكل مضغوط كما في محافظ البيتكوين.

## المراجع

* [RFC-2104](https://tools.ietf.org/html/rfc2104)
* [RFC-5869](https://tools.ietf.org/html/rfc5869)
