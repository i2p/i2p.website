--- 
title: "NTCP 2" 
number: "111" 
author: "EinMByte, orignal, psi, str4d, zzz" 
created: "2014-02-13" 
lastupdated: "2019-08-13" 
status: "Closed" 
thread: "http://zzz.i2p/topics/1577" 
supercedes: "106" 
target: "0.9.36" 
implementedin: "0.9.36" 
editor: "manas, str4d, zzz" 
---

## ملاحظة
مرحلة الاقتراح مغلقة.
انظر إلى [SPEC](/en/docs/spec/ntcp2/) للحصول على المواصفات الرسمية.
قد يظل هذا الاقتراح مرجعًا لمعلومات الخلفية.

## نظرة عامة

يصف هذا الاقتراح بروتوكول اتفاقية مفتاح موثوق به لتحسين مقاومة [NTCP](/en/docs/transport/ntcp/) لأشكال مختلفة من التعريف الآلي والهجمات.

يُنظم الاقتراح كما يلي: تقدم الأهداف الأمنية، تليها مناقشة البروتوكول الأساسي. بعد ذلك، يتم تقديم مواصفات كاملة لجميع رسائل البروتوكول. أخيرًا، يتم مناقشة عناوين الموجهات وتعريف الإصدار. يشمل الملحق مناقشة لهجوم عام على مخططات التعبئة الشائعة، بالإضافة إلى ملحق يحتوي على عدد من المرشحين للتشفير الموثوق به.

كما هو الحال مع وسائل النقل الأخرى لـ I2P، يتم تعريف NTCP2 فقط للنقل من نقطة إلى نقطة (من الموجه إلى الموجه) لرسائل I2NP. وليس كأنبوب بيانات للأغراض العامة.

## الدافع

يتم تشفير بيانات [NTCP](/en/docs/transport/ntcp/) بعد الرسالة الأولى (وتبدو الرسالة الأولى بيانات عشوائية)، مما يمنع التعرف على البروتوكول من خلال "تحليل الحمولة". لا يزال عرضة للتعرف على البروتوكول من خلال "تحليل التدفق". وذلك لأن الرسائل الأربع الأولى (أي المصافحة) لها طول ثابت (288، 304، 448، و48 بايتًا).

بإضافة كميات عشوائية من البيانات العشوائية إلى كل من الرسائل، يمكننا جعل الامور أصعب بكثير.

يعترف المؤلفون بأن الممارسات الأمنية القياسية تشير إلى استخدام بروتوكول موجود مثل TLS، لكن هذا هو [Prop104](/en/proposals/104/) وله مشاكله الخاصة. كلما كان ذلك مناسبًا، أضفنا فقرات "الأعمال المستقبلية" للإشارة إلى الميزات المفقودة أو الموضوعات التي تحتاج إلى نقاش.

## أهداف التصميم

- دعم NTCP 1 و 2 على منفذ واحد، واكتشاف تلقائي، ونشر باسم "نقل" واحد (أي [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) في [NetDB](/en/docs/how/network-database/).

- نشر دعم للإصدار 1 فقط، 2 فقط، أو 1+2 في NetDB في حقل منفصل، والوضع الافتراضي للإصدار 1 فقط (لا تربط دعم الإصدار بإصدار موجه محدد).

- التأكد من أن كل التطبيقات (Java/i2pd/Kovri/go) يمكنها إضافة دعم للإصدار 2 (أو عدمه) حسب جدول زمني خاص بها.

- إضافة تعبئة عشوائية لجميع رسائل NTCP بما في ذلك رسائل المصافحة والبيانات (أي إخفاء الطول حتى لا تكون كل الرسائل مضاعفة 16 بايتًا) توفير آلية خيارات لكلا الجانبين لطلب الحد الأدنى والحد الأقصى للتعبئة و / أو توزيع التعبئة. تعتمد تفاصيل توزيع التعبئة على التطبيق وقد يتم تحديدها أو لا يتم تحديدها في البروتوكول نفسه.

- تشويش محتويات الرسائل التي لم يتم تشفيرها (1 و 2)، بشكل كاف بحيث لا يمكن لصناديق DPI وتوقيعات AV تصنيفها بسهولة. وكذلك التأكد من أن الرسائل المرسلة إلى نظير واحد أو مجموعة من الأقران ليس لها نمط مشابه من البتات.

- إصلاح فقدان البتات في DH الناتج عن تنسيق Java [Ticket1112](https://trac.i2p2.i2p/ticket/1112)، ربما (على الأرجح؟) بالتبديل إلى X25519.

- التبديل إلى وظيفة اشتقاق مفتاح حقيقية (KDF) بدلاً من استخدام نتيجة DH كما هي؟

- إضافة "مقاومة الفحص" (كما يسميها تور)؛ يتضمن ذلك مقاومة التكرار.

- الحفاظ على التبادل الموثوق للمفاتيح ثنائي الاتجاه (2W-AKE). 1W-AKE غير كافٍ لتطبيقنا.

- الاستمرار في استخدام التوقيعات المتغيرة النوع والطول (من مفتاح توقيع [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/)) كجزء من المصادقة. الاعتماد على مفتاح عام ثابت ينشر في RouterInfo كجزء آخر من المصادقة.

- إضافة خيارات / إصدار في المصافحة لأجل التوسع المستقبلي.

- إضافة مقاومة للتجزئة الخبيثة لـ MitM TCP إذا كان ذلك ممكنًا.

- عدم إضافة عبء كبير على وحدة المعالجة المركزية المطلوبة لإنشاء الاتصال؛ إذا كان ذلك ممكنًا، تقليله بشكل كبير.

- إضافة مصادقة الرسائل (MAC)، وربما HMAC-SHA256 و Poly1305، وإزالة الفحص التكراري Adler.

- تقصير وتبسيط رأس I2NP:
  تقصير انتهاء الصلاحية إلى 4 بايت، كما هو الحال في SSU.
  إزالة فحص SHA256 المختصر ببايت واحد.

- إذا كان ذلك ممكنًا، تقليل مصافحة الرسائل الأربعة، جولات الرحلة ذات الاتجاهين إلى مصافحة برسائل ثلاثة، رحلة واحدة ذات اتجاه واحد، كما في [SSU](/en/docs/transport/ssu/). سيتطلب ذلك نقل توقيع بوب في الرسالة 4 إلى الرسالة 2. البحث في سبب وجود 4 رسائل في أرشيفات البريد الإلكتروني / الحالة / الاجتماعات التي استمرت لسنوات.

- تقليل عبء البروتوكول قبل التعبئة. بينما ستُضاف التعبئات، وربما بكميات كبيرة منها، يبقى العبء قبل التعبئة عبئًا. يجب أن تكون العقد ذات النطاق الترددي المنخفض قابلة لاستخدام NTCP2.

- الحفاظ على الطوابع الزمنية للكشف عن التكرار والانحراف.

- تجنب أية مشاكل في عام 2038 المتعلقة بالطوابع الزمنية، يجب أن يعمل على الأقل حتى عام 2106.

- زيادة الحد الأقصى لحجم الرسالة من 16K إلى 32K أو 64K.

- يجب أن تكون العينات التشفيرية الجديدة متاحة عبر مكتبات لاستخدام تطبيق الموجهات في Java و C++ و Go.

- تضمين ممثلين عن مطوري موجهات الجافا و C++ و Go في التصميم.

- تقليل التغييرات (لكن سيظل هناك الكثير منها).

- دعم كلا الإصدارين في مجموعة شائعة من الأكواد (قد لا يكون ذلك ممكنًا ويعتمد على التنفيذ في أي حال من الأحوال).


### غير الأهداف

- مقاومة موثوقة لدقة حزم الشبكة العميقة... سيكون ذلك من مواصفات النقل القابلة للتوصيل، [Prop109](/en/proposals/109/).

- وسيلة نقل تعتمد على TLS (أو تبدو كـ HTTPS)... سيكون ذلك من [Prop104](/en/proposals/104/).

- من المقبول تغيير التشفير المتدفق المتناظر.

- مقاومة رأس المال المعتمد على التوقيت (يمكن أن يكون تأخير زمن الوصول بين الرسائل يعتمد على التطبيق؛ يمكن إدخال تأخير بين الرسائل في أي نقطة، بما في ذلك قبل إرسال التعبئة العشوائية، على سبيل المثال). يمكن أن تكون التأخيرات الاصطناعية (ما يسمى بـ obfs4 IAT أو وقت الوصول المتقطع) مستقلة عن البروتوكول نفسه.

- إنكار المشاركة في الجلسة (هناك توقيعات في الداخل).

الأهداف غير المحددة التي قد يتم إعادة النظر فيها جزئياً أو مناقشتها:

- درجة الحماية ضد التفتيش العميق لحزم الشبكة (DPI)

- أمان ما بعد الكم (PQ)

- الإنكار



### الأهداف ذات الصلة

- تنفيذ إعداد اختبار لـ NTCP 1/2


## الأهداف الأمنية

نعتبر هنا ثلاثة جهات:

- أليس، التي ترغب في إنشاء جلسة جديدة.
- بوب، الذي ترغب أليس في إقامة جلسة معه.
- مالوري، الرجل الوسيط بين أليس وبوب.

يمكن لحد أقصى المشاركين المشاركة في الهجمات النشطة.

كلاً من أليس وبوب يمتلكان زوج مفاتيح ثابتة، والتي يتضمنها [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) الخاص بهما.

يسعى البروتوكول المقترح للسماح لأليس وبوب بالاتفاق على مفتاح سري مشترك (K) تحت الشروط التالية:

1) أمان المفتاح الخاص: لا يتعلم بوب أو مالوري أي شيء حول المفتاح الخاص الثابت لأليس. بشكل متناظر، لا تتعلم أليس أي شيء عن المفتاح الخاص الثابت لبوب.

2) لا يتم معرفة المفتاح الجلسة K إلا من قبل أليس وبوب.

3) السرية الأمامية الكاملة: يظل المفتاح المتفق عليه سريًا في المستقبل، حتى عندما تُكشف المفاتيح الخاصة الثابتة لأليس و / أو بوب بعد الاتفاق عليها.

4) مصادقة ثنائية الاتجاه: أليس متأكدة من أنها قد أقامت جلسة مع بوب، والعكس صحيح.

5) الحماية ضد التفتيش المباشر عبر الخط: التأكد من عدم بساطة اكتشاف أن أليس وبوب يشاركان في البروتوكول باستخدام تقنيات تفتيش حزم مباشرة (DPI) بسيطة. انظر أدناه.

6) الإنكار المحدود: لا يمكن لأي من أليس أو بوب إنكار المشاركة في البروتوكول، ولكن إذا سرب أحدهما المفتاح المشترك، يمكن للطرف الآخر إنكار صحة المحتويات للبيانات المنقولة.

يحاول هذا الاقتراح توفير جميع المتطلبات الخمسة بناءً على بروتوكول Station-To-Station [STS]_. لاحظ أن هذا البروتوكول هو أيضًا الأساس لبروتوكول [SSU](/en/docs/transport/ssu/).

### مناقشة إضافية حول DPI

نحن نفترض مكونين لدقة الحزم عبر الخط:

1) دقة الحزم عبر الخط المباشر
`````````````

دقة الحزم المباشر عبر الخط تتفحص جميع التدفقات في الوقت الفعلي. قد تُحظر الاتصالات أو يتم العبث بها بطريقة أخرى. يمكن التعرف على بيانات الاتصال أو بيانات التعريف وتخزينها للتحليل غير المتصل بالخط لاحقًا. ولا تُتاح الدقة المباشرة عبر الخط الوصول إلى قاعدة بيانات الشبكة الخاصة بـ I2P. تقتصر الدقة المباشرة عبر الخط على قدرات حاسوبية حقيقية محدودة في الوقت الحقيقي، بما في ذلك حساب الطول، وفحص الحقل، والحسابات البسيطة مثل الـ XOR. ولكنها لديها القدرة على تطبيق وظائف التشفير السريعة عبر الخط الحقيقي مثل AES، AEAD، والتجزئة، لكن ستكون مكلفة جدًا لتطبيقها على معظم أو جميع التدفقات. يمكن تطبيق هذه العمليات التشفيرية فقط على التدفقات على مجموعات IP/Port المحددة والتي تم تحديدها مسبقًا عن طريق التحليل غير المتصل بالخط. لا تملك الدقة المباشرة عبر الخط القدرة على وظائف التشفير ذات الحمل العالي مثل DH أو elligator2. لا يتم تصميم الدقة المباشرة عبر الخط تحديداً للكشف عن I2P، على الرغم من أنه قد يحتوي على قواعد تصنيف محدودة لهذا الغرض.

يهدف الهدف إلى منع تحديد البروتوكول من قبل دقة الحزمة عبر الخط المباشر.

تتضمن دقة الحزمة المباشرة أو "البسيطة" هنا ادراج اعتداء يعادي قدرات التالي:

1) القدرة على فحص جميع البيانات المرسلة أو المستلمة من الجهة المستهدفة.

2) القدرة على إجراء عمليات على البيانات الملاحظة، مثل تطبيق تشفير كتلة أو وظائف التجزئة.

3) القدرة على التخزين والمقارنة مع الرسائل المرسلة سابقًا.

4) القدرة على التعديل أو التأخير أو تجزئة الحزم.

ومع ذلك، يتم افتراض القيود التالية على الدقة المباشرة عبر الخط:

5) عدم القدرة على تعيين عناوين IP إلى تجزئة الموجه. بينما يكون ذلك بسيطًا مع الوصول في الوقت الحقيقي إلى قاعدة بيانات الشبكة، فإن ذلك يتطلب نظام DPI مصمم خصيصًا لاستهداف I2P.

6) عدم القدرة على استخدام معلومات التوقيت لاكتشاف البروتوكول.

7) عمومًا، لا يتضمن صندوق أدوات الدقة المباشرة عبر الخط أي أدوات مبنية خصيصًا للكشف عن I2P. يتضمن ذلك إنشاء "فخاخ"، والتي قد تشمل على سبيل المثال لا الحصر تضمين حشو غير عشوائي في رسائلهم. لاحظ أن ذلك لا يستثني أنظمة التعلم الآلي أو أدوات DPI عالية القابلية للتكوين طالما أنها تلتزم بالمتطلبات الأخرى.

لمكافحة تحليل الحمولة، يتم ضمان أن جميع الرسائل لا يمكن تمييزها عن العشوائية. يتطلب ذلك أيضًا أن يكون طولها عشوائيًا، وهو أمر أكثر تعقيدًا من مجرد إضافة حشو عشوائي. في الواقع، في الملحق A، يجادل المؤلفون بأن مخطط الحشو الساذج (أي المخطط الموحد) لا يحل المشكلة. يقترح الملحق A بالتالي إدراج تأخيرات عشوائية أو تطوير مخطط حشو بديل يمكن أن يقدم حماية معقولة للهجوم المقترح.

لحماية المعايير السادسة المذكورة أعلاه، يجب أن تتضمن التطبيقات تأخيرات عشوائية في البروتوكول. لم يتم تغطية مثل هذه التقنيات في هذه الاقتراح، لكنها قد تحل أيضًا مشاكل طول التعبئة. باختصار، يقدم الاقتراح حماية جيدة ضد تحليل الحمولة (عندما تؤخذ في الاعتبار الاعتبارات في الملحق A)، لكن حماية محدودة ضد تحليل التدفق.

2) دقة الحزم عبر الخط غير المباشر
````````````

دقة الحزم غير المباشرة عبر الخط تفحص البيانات التي جاءت من الدقة المباشرة عبر الخط للتحليل لاحقًا. قد يتم تصميمها خصيصًا للكشف عن I2P. دقة الحزم غير المباشرة عبر الخط لديها وصول حقيقي في الوقت الحقيقي إلى قاعدة بيانات الشبكة الخاصة بـ I2P. الوصول إلى مواصفات I2P ومواصفات أخرى أيضًا. تمتلك القدرة الحسابية غير المحدودة، بما في ذلك جميع وظائف التشفير المحددة في هذه المواصفات.

لا تتمتع دقة الحزم غير المباشرة عبر الخط القدرة على حظر الاتصالات الموجودة. ولكن لديها القدرة على القيام بإعادة تشغيل في الوقت القريب من الرسائل السابقة لأغراض "الفحص" أو لأسباب أخرى.

لا يهدف الهدف إلى منع دقة الحزمة عبر الخط المباشر.

جميع فك تشفير البيانات الغامضة في الرسائل الأولى والتمام من الرسائل التي يتم تنفيذها من قبل موجهات I2P، يمكن أيضًا تنفيذها من قبل دقة الحزمة عبر الخط المباشر.

الهدف هو رفض الاتصالات المستخدمة باستخدام إعادة تشغيل الرسائل السابقة.

الأعمال المستقبلية
`````````````

- النظر في سلوك البروتوكول عندما يتم إسقاط الحزم أو إعادة ترتيبها من قبل المهاجم. يمكن العثور على عمل حديث مثير للاهتمام في هذا المجال في [IACR-1150](https://eprint.iacr.org/2015/1150).

- توفير تصنيف أكثر دقة لأنظمة DPI، مع الأخذ في الاعتبار الأدب الموجود المتعلق بهذا الموضوع.

- مناقشة الأمان الرسمي للبروتوكول المقترح، مع الأخذ في الاعتبار نموذج المهاجم الخاص بالـ DPI.

## إطار عمل بروتوكول Noise

يقدم هذا الاقتراح المتطلبات بناءً على إطار عمل بروتوكول Noise [NOISE](http://noiseprotocol.org/) (المراجعة 33، 2017-10-04). Noise يتمتع بصفات مشابهة لبروتوكول Station-To-Station [STS]، الذي يشكل الأساس لبروتوكول [SSU](/en/docs/transport/ssu/). بلغة Noise، أليس هي المبادر، وبوب هو المستجيب.

NTCP2 يعتمد على بروتوكول Noise الذي هو Noise_XK_25519_ChaChaPoly_SHA256. (المعرف الفعلي لوظيفة اشتقاق المفتاح الأولي هو "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256" للإشارة إلى الامتدادات الخاصة بـ I2P - انظر قسم KDF 1 أدناه) يستخدم هذا البروتوكول من Noise المكونات التالية:

- نمط المصافحة: XK
  تقوم أليس بإرسال مفتاحها إلى بوب (X)
  تعرف أليس مفتاح بوب الثابت بالفعل (K)

- وظيفة DH: X25519
  X25519 DH بطول مفتاح 32 بايت كما هو محدد في [RFC-7748](https://tools.ietf.org/html/rfc7748).

- وظيفة الشفرة: ChaChaPoly
  AEAD_CHACHA20_POLY1305 كما هو محدد في [RFC-7539](https://tools.ietf.org/html/rfc7539) القسم 2.8.
  نونسي بحدود 12 بايت، مع تعيين الأربعة بايت الأولى إلى الصفر.

- وظيفة التجزئة: SHA256
  تجزئة قياسية بطول 32 بايت، تُستخدم بكثرة في I2P.


## الإضافات إلى الإطار

يجري تحديد الاقتراح الحالي للتالي:

1) يتم تكبير المفاتيح المؤقتة الواضحة باستخدام تشفير AES باستخدام مفتاح و IV معروف. يمكن تحقيق ذلك بسرعة أكثر من elligator2.

2) يتم إضافة تعبئة عشوائية واضحة للرسائل 1 و 2. ستكون التعبئة العشوائية جزءًا من حساب الهاش المختلط (MixHash). انظر إلى أقسام KDF أدناه للرسالة 2 والجزء 1 من الرسالة 3. يتم إضافة تعبئة AEAD العشوائية إلى الرسالة 3 ورسائل مرحلة البيانات.

3) يتم إضافة حقل طول الإطار بطول بايتين، كما هو مطلوب لـ Noise عبر TCP، وكما هو الحال في obfs4. يتم استخدام هذا في رسائل مرحلة البيانات فقط. تتمتع إطارات الرسالة 1 و 2 AEAD بالطول الثابت. الطول الخاص بالرسالة 3 الجزء 1 AEAD محدد في الرسالة 1.

4) يتم تكبير حقل طول الإطار باستخدام SipHash-2-4، كما هو الحال في obfs4.

5) يتم تحديد تنسيق الحمولة للرسائل 1 و 2 و 3 ومرحلة البيانات. بالطبع، لا يتم تحديد ذلك في Noise.

## العينات التشفيرية الجديدة لـ I2P

تتطلب تنفيذات موجهات I2P الحالية تنفيذات للعينات التشفيرية القياسية التالية، والتي ليست مطلوبة للبروتوكولات الحالية لـ I2P:

1) توليد مفتاح X25519 و DH

2) AEAD_ChaCha20_Poly1305 (يُختصر أدناه تحت عنوان ChaChaPoly)

3) SipHash-2-4

## تقدير عبء العملية (Processing overhead estimate)

أحجام الرسائل للرسائل الثلاثة:

1) 64 بايتًا + تعبئة (كانت NTCP 288 بايتًا)
2) 64 بايتًا + تعبئة (كانت NTCP 304 بايتًا)
3) تقريبًا 64 بايتًا + معلومات توجيه أليس + تعبئة متوسط معلومات الموجه هو حوالي 750 بايتًا إجمالي متوسط 814 بايتًا قبل التعبئة (كانت NTCP 448 بايتًا)
4) ليست مطلوبة في NTCP2 (كانت NTCP 48 بايتًا)

الإجمالي قبل التعبئة: NTCP2: 942 بايت NTCP: 1088 بايت لاحظ أنه إذا اتصلت أليس لبوب لغرض إرسال رسالة تخزين قاعدة البيانات لمعلومات موجهها، فإن تلك الرسالة ليست مطلوبة، مما يوفر حوالي 800 بايت.

تتطلب العمليات التشفيرية التالية من كل طرف لإكمال المصافحة وبدء مرحلة البيانات:

- AES: 2
- SHA256: 7 (أليس)، 6 (بوب) (لا تشمل 1 أليس، و2 بوب محسوبة مسبقًا لجميع الاتصالات) (لا تشمل HMAC-SHA256)
- HMAC-SHA256: 19
- ChaChaPoly: 4
- توليد مفتاح X25519: 1
- X25519 DH: 3
- التحقق من التوقيع: 1 (بوب) (وقعت أليس مسبقًا عند توليد معلومات موجهها) من المفترض أن يكون Ed25519 (يعتمد على نوع توقيع معلومات الموجه)

تتطلب العمليات التشفيرية التالية من كل طرف لكل رسالة في مرحلة البيانات:
- SipHash: 1
- ChaChaPoly: 1

## الرسائل
تقل الرسائل في NTCP2 عن 65537 بايتًا أو تساوي 65537 بايتًا في الطول. ويعتمد تنسيق الرسالة على رسائل Noise، مع تعديلات للتأطير والاستقلالية. قد تحتاج التطبيقات التي تستخدم مكتبات Noise القياسية إلى معالجة مسبقة للرسائل المستلمة لإعادة تنسيقها وفقًا لتنسيق رسائل Noise. كل الحقول المشفرة هي نصوص مشفرة AEAD.
يتبع التتابع الإنشاء التالي:

Alice                           Bob

  SessionRequest ------------------->
  <------------------- SessionCreated
  SessionConfirmed ----------------->
بموجب مصطلحات Noise، التتابع للوصول إلى إنشاء البيانات هو كما يلي:
(خصائص الأمان للحمولة)

XK(s, rs):           Authentication   Confidentiality
    <- s
    ...
    -> e, es                  0                2
    <- e, ee                  2                1
    -> s, se                  2                5
    <-                        2                5
بمجرد إنشاء الجلسة، يمكن لأليس وبوب تبادل رسائل البيانات.

يتم تحديد جميع أنواع الرسائل (SessionRequest، SessionCreated، SessionConfirmed، Data وTimeSync) في هذا القسم.

بعض الرموز::

  - RH_A = تجزئة الموجه الخاص بأليس (32 بايت)
  - RH_B = تجزئة الموجه الخاص ببوب (32 بايت)


### التشفير المحقق

هناك ثلاث مجموعات تشفير منفصلة (CipherStates).
واحدة خلال مرحلة المصافحة، واثنتان (إرسال واستقبال) لمرحلة البيانات.
لكل منها مفتاح خاص بها من خلال KDF.

سيتم تمثيل البيانات المشفرة / الموثقة كـ:

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   Encrypted and authenticated data    |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
ChaCha20/Poly1305
`````````````````

تنسيق البيانات المشفرة والمحققة.

المدخلات إلى وظائف التشفير / فط العقدية:

k :: 32 بايت مفتاح الشفرة، كما يتم توليده من KDF

  nonce :: عدّاد الجموع، 12 بايت.
           يبدأ من 0 ويتم زيادته لكل رسالة.
           الأربعة بايت الأولى هي دائمًا صفر.
           الثمانية بايت الأخيرة هي العداد، مشفرة بنمط endian صغير.
           القيمة القصوى هي 2**64 - 2.
           يجب أن تسقط الالتحاق ويعاد تشغيله بعد
           وصوله إلى تلك القيمة.
           يجب ألا تُرسل القيمة 2**64 - 1.

  ad :: في مرحلة المصافحة:
        بيانات مرتبطة، 32 بايت.
        التجزئة SHA256 لجميع البيانات السابقة.
        في مرحلة البيانات:
        صفر بايت

  data :: بيانات النص العادي، 0 أو أكثر من البايت

إخراج وظيفة التشفير، المدخل إلى وظيفة فك التشفير:

+----+----+----+----+----+----+----+----+
  |Obfs Len |                             |
  +----+----+                             +
  |       ChaCha20 encrypted data         |
  ~               .   .   .               ~
  |  Poly1305 Message Authentication Code |
  +              (MAC)                    +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+

  Obfs Len :: طول (البيانات المشفرة + MAC) تليها، 16 - 65535
              التشويش باستخدام SipHash (انظر أدناه)
              غير مستخدم في الرسالة 1 أو 2، أو الرسالة 3 الجزء 1، حيث يكون الطول ثابتًا
              غير مستخدم في الرسالة 3 الجزء 1، حيث يتم تحديد الطول في الرسالة 1

  encrypted data :: نفس حجم بيانات النص العادي، 0 - 65519 بايت

  MAC :: رمز توثيق الرسائل Poly1305، 16 بايت

بالنسبة لـ ChaCha20، ما يوصف هنا يتوافق مع [RFC-7539](https://tools.ietf.org/html/rfc7539)، والذي يستخدم بشكل مشابه في TLS [RFC-7905](https://tools.ietf.org/html/rfc7905).

ملاحظات
`````
- نظرًا لأن ChaCha20 هو تشفير تيار، لا يلزم تعبئة النصوص العادية.
  يتم تجاهل كيستريم إضافي.

- يتم الاتفاق على المفتاح للشفرة (256 بت) عبر SHA256 KDF.
  تفاصیل KDF لكل رسالة موجودة في الأقسام المنفصلة أدناه.

- إطارات ChaChaPoly للرسائل 1 و 2 والجزء الأول من الرسالة 3،
  ذات حجم معروف. بدءًا من الجزء الثاني من الرسالة 3،
  تكون الإطارات ذات حجم متغير. الطول للجزء 1 من الرسالة 3 يتم تحديده في الرسالة 1.
  بدءًا من مرحلة البيانات، يسبق الإطارات حقل طول ثنائي البايت مشوش بـ SipHash كما في obfs4.

- تعتبر التعبئة خارج الإطار المحقق للرسائل 1 و 2.
  تستخدم التعبئة في KDF للرسالة التالية بحيث يتم اكتشاف التلاعب.

التعامل مع أخطاء AEAD
```````````````````
- في الرسائل 1، 2، والرسالة 3 الأجزاء 1 و 2، يكون حجم رسالة AEAD معروفًا مسبقًا.
  في حالة فشل التحقق من AEAD، يجب على المستلم إيقاف متابعة معالجة الرسائل وإغلاق
  الاتصال دون الاستجابة. يجب أن يكون هذا إغلاق غير طبيعي (TCP RST).

- لمقاومة الفحص، في الرسالة 1، بعد فشل AEAD، يجب أن
  يضبط بوب مؤقت عشوائي (نطاق تحدد لاحقًا) ثم يقرئ عدد عشوائي من البايتات (نطاق تحدد لاحقًا)
  قبل إغلاق المقبس. يجب أن يحافظ بوب على قائمة سوداء لعناوين IP التي تحتوي على
  فشل متكرر.

- في مرحلة البيانات، يكون حجم رسالة AEAD "مشفرة" (مشوشة) بـ SipHash.
  يجب اتخاذ الحيطة لتفادي إنشاء شيفرة فك التشفير.
  في حالة فشل التحقق من مصادقة AEAD في مرحلة البيانات، يجب أن
  يضبط المستلم مؤقت عشوائي (نطاق تحدد لاحقًا) ثم يقرأ عدد عشوائي من البايتات (نطاق تحدد لاحقًا).
  بعد القراءة، أو في حالة انتهاء مهلة القراءة، يجب على المستلم إرسال حمولة
  تحتوي على كتلة إنهاء تحتوي على كود "فشل AEAD"،
  ويغلق الاتصال.

- اتخاذ نفس الإجراء للأخطاء في قيمة حقل الطول ضمن مرحلة البيانات.


### وظيفة التشفير المستمد (KDF) (لرسالة المصافحة 1)

تولد KDF مفتاح تشفير لمرحلة المصافحة k من نتيجة DH،
باستخدام HMAC-SHA256(key, data) كما هو معرف في [RFC-2104](https://tools.ietf.org/html/rfc2104).
هذه هي الدوال InitializeSymmetric() و MixHash() و MixKey()،
كما هو معرف بالفعل في مواصفة Noise.

هذه هي نمط "e" للرسالة:

  // تعيين protocol_name.
  Set protocol_name = "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256"
   (48 بايت، مشفّرة بـ US-ASCII، لا تعمل على الإنهاء بالـ NULL).

  // تعريف تجزئة h = 32 بايت
  h = SHA256(protocol_name);

  تعريف ck = سلسلة التجزئة بطول 32 بايت. أنسخ بيانات h إلى ck.
  Set ck = h

  تعريف rs = 32 بايت مفتاح ثابت لبوب كما هو منشور في RouterInfo

  // MixHash(null prologue)
  h = SHA256(h);

  // حتى هنا، يمكن حساب كل شيء مسبقًا من قبل أليس لجميع الاتصالات الخارجة

  // يجب أن تتحقق أليس من أن مفتاح بوب الثابت هو نقطة

- في منحنى هنا.

  // مفتاح ثابت لبوب
  // MixHash(rs)
  // || تعني الملاحقة أدناه
  h = SHA256(h || rs);

  // حتى هنا، يمكن حساب كل شيء مسبقًا من قبل بوب لجميع الاتصالات الداخلة

  هذا هو نمط الرسالة "e":

  تولد أليس زوج مفتاح DH المؤقت الخاص بها e.

  // مفتاح مؤقت لـ أليس X
  // MixHash(e.pubkey)
  // || تعني الملاحقة أدناه
  h = SHA256(h || e.pubkey);

  // h يستخدم كبيانات متصلة للإعداد في AEAD في الرسالة 1
  // احتفظ بالـ Hash h لـ KDF الرسالة 2


  نهاية نمط الرسالة "e".

  هذا هو نمط الرسالة "es":

  // DH(e, rs) == DH(s, re)
  تعريف input_key_material = 32 بايت نتيجة DH لمفتاح أليس المؤقت ومفتاح بوب الثابت
  Set input_key_material = X25519 DH result

  // MixKey(DH())

  تعريف temp_key = 32 بايت
  تعريف HMAC-SHA256(key, data) كما في [RFC-2104](https://tools.ietf.org/html/rfc2104)
  // توليد مفتاح مؤقت من سلسلة التجزئة ونتيجة DH
  // ck هو سلسلة التجزئة، المعرفة أعلاه
  temp_key = HMAC-SHA256(ck, input_key_material)
  // مسح نتيجة DH في الذاكرة، لم تعد مطلوبة
  input_key_material = (all zeros)

  // الإخراج 1
  // تعيين سلسلة تجزئة جديدة من المفتاح المؤقت
  // byte() أدناه يعني بايت واحد
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // الإخراج 2
  // توليد مفتاح تشفير k
  تعريف k = 32 بايت
  // || تعني الملاحقة أدناه
  // byte() أدناه يعني بايت واحد
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
  // مسح المفتاح المؤقت في الذاكرة، لم تعد مطلوبة
  temp_key = (all zeros)

  // الاحتفاظ بسلسلة التجزئة ck لـ KDF الرسالة 2


  نهاية نمط الرسالة "es".

### 1) (طلب الجلسة) SessionRequest

ترسل أليس إلى بوب.

محتوى Noise: مفتاح أليس المؤقت X
حمولة Noise: كتلة خيار بطول 16 بايت
حمولة غير noise: تعبئة عشوائية

(خصائص الأمان للحمولة)

XK(s, rs):           Authentication   Confidentiality
    -> e, es                  0                2

    المصادقة: لا يوجد (0).
    من الممكن أن هذه الحمولة يمكن أن تُرسل من أي طرف، بما في ذلك مهاجم نشط.

    السرية: 2.
    التشفير لمستلم معروف، سرية التتحليل المستقبلي فقط عند تسلل المرسل، عرضة للتكرار. يتم تشفير هذه الحمولة بناءً على تحويلات DH تتضمن مفتاح ثابت للمستلم. إذا تم اختراق المفتاح الخاص الثابت للطرف المستقبل، حتى في تاريخ لاحق، يمكن فك تشفير هذه الحمولة. يمكن أيضًا تكرار هذه الرسالة، حيث لا يوجد مساهم مؤقت من الطرف المستلم.

    "e": تولد أليس زوج مفتاح مؤقت جديد وتخزنه في المتغير e، وتكتب المفتاح المؤقت العام كنص غامض في مؤقت الرسالة، وتقوم بدمج المفتاح العام مع القديم في h لاشتقاق h جديد.

    "es": يتم تنفيذ عملية DH بين زوج المفتاح المؤقت لأليس وزوج المفتاح الثابت لبوب. النتيجة تُدمج مع القديم ck لاشتقاق ck وk جديدة، ويتم تعيين n للصفر.


يتم تشفير القيمة X لضمان عدم تمييز الحمولة والتفرد، وهي ضرورية لمكافحة DPI.
نستخدم التشفير AES لتحقيق ذلك،
بدلاً من البدائل الأكثر تعقيدًا والأبطأ مثل elligator2.
سيكون التشفير التماثلي لمفتاح الموجه العام لبوب بطيئًا للغاية.
التشفير AES يُستخدم مع تجزئة الموجه لبوب كمفتاح و IV لبوب كما هو نشر
في قاعدة بيانات الشبكة.

التشفير AES هو لمقاومة DPI فقط.
يمكن لأي طرف يعرف تجزئة الموجه لبوب و IV، المنشورة في قاعدة بيانات الشبكة، فك تشفير القيمة X في هذه الرسالة.

الحشو لا يتم تشفيره من قبل أليس.
قد يكون من الضروري لبوب فك تشفير الحشو،
لمنع الهجمات الزمنية.

محتويات خام:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        obfuscated with RH_B           +
  |       AES-CBC-256 encrypted X         |
  +             (32 bytes)                +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |        frame                      |
  +                                       +
  |   k هو المحدد في KDF للرسالة 1        |
  +   n = 0                               +
  |   انظر إلى KDF للبيانات المرتبطة     |
  +----+----+----+----+----+----+----+----+
  |     unencrypted authenticated         |
  ~         padding (optional)            ~
  |     length defined in options block   |
  +----+----+----+----+----+----+----+----+

  X :: 32 بايت، X25519 مفتاح مؤقت، endian صغير

  padding :: بيانات عشوائية، 0 أو أكثر من البايتات.
             يجب أن يكون الطول الإجمالي للرسالة 65535 بايتًا أو أقل.
             يجب أن يكون الطول الإجمالي للرسالة 287 بايتًا أو أقل إذا
             كان بوب ينشر عنوانه كـ NTCP
             (انظر قسم كشف الإصدار أدناه).
             ستستخدم أليس وبوب بيانات التعبئة في KDF للرسالة 2.
             يتم التحقق منها حتى يتم اكتشاف أي تلاعب.

بيانات غير مشفرة (العلامة الدالة لـ Poly1305 غير معروضة):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                   X                   |
  +              (32 bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               options                 |
  +              (16 bytes)               +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     تعبئة موثقة غير مشفرة            +
  +         padding (optional)          +
  |     الطول المحدد في كتلة الخيارات      ~
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  X :: 32 بايت، X25519 مفتاح مؤقت، endian صغير

  الخيارات :: كتلة الخيارات، 16 بايت، انظر أدناه

  padding :: بيانات عشوائية، 0 أو أكثر من البايتات.
             يجب أن يكون الطول الإجمالي للرسالة 65535 بايتًا or less.
             يجب أن يكون الطول الإجمالي للرسالة 287 بايتًا if
             كان بوب ينشر عنوانه كـ "NTCP"
             (انظر قسم كشف الإصدار أدناه)
             ستستخدم أليس وبوب بيانات التعبئة في KDF للرسالة 2.
             يتم التحقق منها حتى يتم اكتشاف أي تلاعب.

كتلة الخيارات: 
ملاحظة: جميع الحقول هي big-endian.

+----+----+----+----+----+----+----+----+
  | id | ver|  padLen | m3p2len | Rsvd(0) |
  +----+----+----+----+----+----+----+----+
  |        tsA        |   Reserved (0)    |
  +----+----+----+----+----+----+----+----+

  id :: 1 بايت، معرف الشبكة (حاليًا 2، باستثناء شبكات الاختبار)
        كما هو في 0.9.42. انظر الاقتراح 147.

  ver :: 1 بايت، إصدار البروتوكول (حاليًا 2)

  padLen :: بطول 2 بايت، طوال التعبئة، 0 أو أكثر
            الحد الأدنى / أقصى الإرشادات التي سيتم تحديدها لاحقًا. حجم عشوائي من 0 إلى 31 بايت كحد أدنى؟
            (التوزيع لتحديد في الملحق A.)

  m3p2Len :: بطول 2 بايت، لمدة إطار AEAD الثاني في SessionConfirmed
             (رسالة الجزء 3 الجزء 2) انظر الملاحظات أدناه

  Rsvd :: 2 بايت، يتم تعيينها إلى 0 للتوافق مع الخيارات المستقبلية

  tsA :: 4 بايت، طابع UNIX الزمني، ثواني غير مستوفاة.
         الرسومات تلتف في 2106

  Reserved :: 4 بايت، مجموعة إلى 0 للتوافق مع الخيارات المستقبلية

ملاحظات
`````
- عندما يتم نشر العنوان كـ "NTCP"، يدعم بوب كلاً من NTCP و NTCP2
  على نفس المنفذ. لأجل التوافق، عند بدء الاتصال باتجاه
  عنوان ينشر باسم "NTCP"، يجب أن تحد أليس من الحد الأقصى لحجم هذه الرسالة،
  بما في ذلك الحشو، عند 287 بايتًا أو أقل.ذلك يسهل التعرف التلقائي للبروتوكول
  من قبل بوب. عندما ينشر كـ "NTCP2"، لا توجد قيود على الحجم. انظر
  أقسام العناوين المنشورة وكشف الإصدار أدناه.

- يضمن العدد X الفريد في الكتلة AES الأولية أن النص المشفر
  مختلف لكل جلسة.

- يجب أن يرفض بوب الاتصالات حيث تكون قيمة الطابع الزمني بعيدة
  عن الزمن الحالي. نسمي الحد الأقصى للوقت "D". يجب أن يحتفظ بوب
  بذاكرة محلية للمستخدمين السابقين للقيم المستخدمة في المصافحات ورفض
  التكرارات، لمنع هجمات التكرار. ينبغي أن تكون مدة القيم في
  ذاكرة التخزين المؤقت لا تقل عن 2*D.
  القيم في ذاكرة التخزين المؤقت تعتمد على التنفيذ، ومع ذلك يمكن استخدام
  القيمة X 32 بايت (أو ما يعادلها المشفر) كذروة.

- لا يجب إعادة استخدام مفاتيح Diffie-Hellman المؤقتة مطلقًا، لمنع
  الهجمات التشفيرية، وسيتم رفض الاستخدام كـ هجمة تكرار.

- يجب أن يكون الخياران "KE" و "auth" متوافقين، أي يجب أن يكون
  المفتاح المشترك K بالحجم المناسب. إذا تمت إضافة المزيد من الخيارات
  "auth"، فقد يغير ذلك بشكل ضمني مفهوم الخيار "KE" لاستخدام KDF مختلفة
  أو حجم اقتطاع مختلف.

- يجب أن تتحقق بوب من أن المفتاح المؤقت لـ أليس هو نقطة
  صالحة على المنحنى هنا.

- يجب أن يقتصر الحشو على كمية معقولة. قد يرفض بوب الاتصالات
  ذات الحشو المفرط. يجب أن يحدد بوب خيارات الحشو الخاصة به
  في الرسالة 2. الحد الأدنى / أقصى الإرشادات التي سيتم تحديدها لاحقًا.
  حجم عشوائي من 0 إلى 31 بايت كحد أدنى؟
  (التوزيع لتحديد في الملحق A.)

- في حالة حدوث أي خطأ، بما في ذلك AEAD، DH، الطابع الزمني، التكرار الظاهر، أو
  فشل التحقق من الصحة، يجب أن يوقف بوب عملية معالجة الرسالة وإغلاق
  الاتصال دون الرد. يجب أن يكون ذلك إغلاقًا غير طبيعي (TCP RST).
  لمقاومة الفحص، بعد فشل AEAD، ينبغي على بوب
  تعيين مهلة عشوائية (نطاق سيتم تحديده لاحقًا) ثم قراء عدد
  عشوائي من البايتات (نطاق سيتم تحديده لاحقًا) قبل إغلاق المقبس.

- الحدف من الهجمات: DH هي عملية مكلفة نسبيًا. كما كان الحال مع بروتوكول NTCP السابق،
  يجب أن يتخذ الموجهات جميع التدابير اللازمة لمنع استنفاد وحدة المعالجة المركزية أو الاتصال.
  وضع حدود على اتصالات نشطة وعدة اتصالات تحت الإعداد في الوقت الواحد.
  فرض مهلة القراءة (لكل قراءة وإجمالية لـ "slowloris").
  حد الاتصال المتكرر أو المتزامن من نفس المصدر.
  الاحتفاظ بقائمة سوداء للمصادر التي تفشل بشكل متكرر.
  لا ترد على فشل AEAD.

- لتسهيل الكشف السريع عن الإصدار والمصافحة، يجب على
  التطبيقات أن تضمن أن أليس تحجز ثم تفرغ محتوى الرسالة الأولى
  بالكامل مرة واحدة، بما في ذلك الحشو. يزيد ذلك من احتمال أن تكون
  البيانات مضمّنة في حزمة TCP واحدة (إلا إذا تم تقسيمها بواسطة نظام التشغيل
  أو الوسطيات)، والوصول إليها جميعًا مرة واحدة من قبل بوب. هذا مهم أيضًا
  لتحقيق الكفاءة وضمان فعالية الحشو العشوائي.

- "حقل الإصدار: البروتوكول العام Noise، والامتدادات، وبروتوكول NTCP بما
  يشمل مواصفات الحمولة، يشير إلى NTCP2. يمكن استخدام هذا الحقل
  للإشارة إلى الدعم للتغييرات المستقبلية.

- طول الجزء 2 للرسالة 3: هذا هو حجم الإطار الثاني لـ AEAD
  (بما في ذلك 16 بايت MAC) الذي يحتوي على معلومات توجيه أليس
  و الحشو الاختياري، الذي سيتم إرساله في الرسالة 3 من الجزء 2. حيث
  تقوم أليس بشكل دوري بإعادة توليد وإعادة نشر معلومات الموجه
  الخاصة بها، قد يتغير حجم معلومات الموجه الحالية قبل
  إرسال الرسالة 3. يجب أن تختار التطبيقات استراتيجية واحدة من
  اثنتين:
  a) حفظ معلومات الموجه الحالية ليتم إرسالها في الرسالة 3، بحيث
  يكون الحجم معروفًا، وإضافة مساحة للحشو اختياريًا؛
  b) زيادة الحجم المحدد بما يكفي للسماح بزيادة محتملة في
  حجم معلومات التوجيه، وإضافة الحشو دائمًا عند إرسال الرسالة 3
  فعليًا.
  في كلتا الحالين، يجب أن يكون طول "m3p2len" المضمن في الرسالة 1
  بالضبط حجم ذلك الإطار عند إرساله في الرسالة 3.

- يجب أن تفشل بوب الاتصال في حالة وجود بيانات واردة بعد
  التحقق من صحة الرسالة 1 وقراءة الحشو. يجب ألا توجد بيانات إضافية من أليس،
  حيث لم ترد بوب بعد مع الرسالة 2.

- يتم استخدام حقل معرف الشبكة بسرعة لتحديد الاتصالات عبر الشبكة.
  إذا كان هذا الحقل غير صفري، ولا يتطابق مع معرف شبكة بوب،
  يجب على بوب قطع الاتصال وحظر الاتصالات المستقبلية.
  ابتداءً من 0.9.42. انظر الاقتراح 147 لمزيد من المعلومات.



### وظيفة التشفير المستمد (KDF) (للرسالة الثانية والثالثة المرحلة 1)

```
// خذ h المحفوظ من KDF للرسالة 1
// MixHash(ciphertext)
h = SHA256(h || 32 بايت payload مشفرة في الرسالة 1)

// MixHash(padding)
// فقط إذا كان طول الحشو غير صفر
h = SHA256(h || random padding من الرسالة 1)

هذا هو نمط الرسالة "e":

يقوم بوب بتوليد زوج المفتاح المؤقت الخاص به e.

// h من KDF للرسالة 1 للمصافحة

// مفتاح مؤقت لبوب Y
// MixHash(e.pubkey)
// || تعني الملاحقة أدناه
h = SHA256(h || e.pubkey);

// h يستخدم كبيانات مرتبطة لـ AEAD في الرسالة 2
// احتفظ بالـ Hash h لـ KDF للرسالة 3


نهاية نمط الرسالة "e".

هذا هو نمط الرسالة "ee":

// DH(e, re)
تعريف input_key_material = 32 بايت نتيجة DH لمفتاح أليس المؤقت ومفتاح بوب المؤقت
Set input_key_material = X25519 DH result
// مسح مفتاح أليس المؤقت في الذاكرة، لم تعد مطلوبة
// أليس:
e(public و private) = (all zeros)
// بوب:
re = (all zeros)

// MixKey(DH())

تعريف temp_key = 32 بايت
وهو المسؤول عن إنتاج مفتاح مؤقت من سلسلة التجزئة ونتيجة DH
// ck هي سلسلة التجزئة، من KDF للرسالة 1 للمصافحة
temp_key = HMAC-SHA256(ck, input_key_material)
// مسح نتيجة DH في الذاكرة، لم تعد مطلوبة
input_key_material = (all zeros)

// الإخراج 1
// تعيين سلسلة تجزئة جديدة من المفتاح المؤقت
// يمثل byte() s بايتًا واحدًا
ck =       HMAC-SHA256(temp_key, byte(0x01)).

// الإخراج 2
// توليد مفتاح تشفير k
تعريف k = 32 بايت
===%باقي الرد في المنشور الأول%===
```
