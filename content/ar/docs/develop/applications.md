---
title: "تطوير التطبيقات"
description: "لماذا نكتب تطبيقات خاصة بـ I2P، المفاهيم الأساسية، خيارات التطوير، ودليل بسيط للبدء"
slug: "applications"
lastUpdated: "2025-10"
accurateFor: "2.10.0"
type: docs
---

## لماذا نكتب كوداً خاصاً بـ I2P؟

هناك طرق متعددة لاستخدام التطبيقات في I2P. باستخدام [I2PTunnel](/docs/api/i2ptunnel/)، يمكنك استخدام التطبيقات العادية دون الحاجة إلى برمجة دعم صريح لـ I2P. هذا فعال جداً في سيناريوهات العميل-الخادم، حيث تحتاج إلى الاتصال بموقع ويب واحد. يمكنك ببساطة إنشاء tunnel باستخدام I2PTunnel للاتصال بذلك الموقع، كما هو موضح في الشكل 1.

إذا كان تطبيقك موزعاً، فسيتطلب اتصالات بعدد كبير من النظراء. باستخدام I2PTunnel، ستحتاج إلى إنشاء tunnel جديد لكل نظير تريد الاتصال به، كما هو موضح في الشكل 2. يمكن بالطبع أتمتة هذه العملية، لكن تشغيل العديد من نسخ I2PTunnel يخلق قدراً كبيراً من العبء الإضافي. بالإضافة إلى ذلك، مع العديد من البروتوكولات ستحتاج إلى إجبار الجميع على استخدام نفس مجموعة المنافذ لجميع النظراء — على سبيل المثال، إذا كنت تريد تشغيل محادثة DCC بشكل موثوق، يحتاج الجميع إلى الاتفاق على أن المنفذ 10001 هو أليس، والمنفذ 10002 هو بوب، والمنفذ 10003 هو تشارلي، وهكذا، نظراً لأن البروتوكول يتضمن معلومات خاصة بـ TCP/IP (المضيف والمنفذ).

غالبًا ما ترسل تطبيقات الشبكة العامة الكثير من البيانات الإضافية التي يمكن استخدامها لتحديد هوية المستخدمين. أسماء المضيفين، وأرقام المنافذ، والمناطق الزمنية، ومجموعات الأحرف، وغيرها غالبًا ما يتم إرسالها دون إعلام المستخدم. وبالتالي، فإن تصميم بروتوكول الشبكة مع وضع إخفاء الهوية في الاعتبار بشكل خاص يمكن أن يتجنب المساس بهويات المستخدمين.

هناك أيضًا اعتبارات كفاءة يجب مراجعتها عند تحديد كيفية التفاعل على I2P. تعمل مكتبة streaming والأشياء المبنية عليها بمصافحات مشابهة لـ TCP، بينما بروتوكولات I2P الأساسية (I2NP و I2CP) تعتمد بشكل صارم على الرسائل (مثل UDP أو في بعض الحالات raw IP). الفرق المهم هو أنه مع I2P، يعمل الاتصال عبر شبكة طويلة وواسعة — كل رسالة من طرف إلى طرف ستكون لها زمن انتقال غير تافه، لكنها قد تحتوي على حمولات تصل إلى عدة كيلوبايت. التطبيق الذي يحتاج إلى طلب واستجابة بسيطين يمكنه التخلص من أي حالة وإسقاط زمن الانتقال الناتج عن مصافحات البدء والإنهاء باستخدام datagrams (بأفضل جهد ممكن) دون الحاجة للقلق بشأن اكتشاف MTU أو تجزئة الرسائل.

<figure style="text-align:center; margin: 2rem 0;">
  <img src="/images/i2ptunnel_serverclient.png" alt="Creating a server-client connection using I2PTunnel only requires creating a single tunnel." />
  <figcaption>Figure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel.</figcaption>
</figure>
<figure style="text-align:center; margin: 2rem 0;">
  <img src="/images/i2ptunnel_peertopeer.png" alt="Setting up connections for a peer-to-peer applications requires a very large amount of tunnels." />
  <figcaption>Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels.</figcaption>
</figure>
باختصار، عدد من الأسباب لكتابة كود خاص بـ I2P:

- إنشاء عدد كبير من نسخ I2PTunnel يستهلك قدراً غير بسيط من الموارد، وهو أمر إشكالي للتطبيقات الموزعة (حيث يُطلب tunnel جديد لكل نظير).
- بروتوكولات الشبكة العامة غالباً ما ترسل الكثير من البيانات الإضافية التي يمكن استخدامها لتحديد هوية المستخدمين. البرمجة المخصصة لـ I2P تسمح بإنشاء بروتوكول شبكة لا يسرّب مثل هذه المعلومات، مما يحافظ على إخفاء هوية المستخدمين وأمانهم.
- بروتوكولات الشبكة المصممة للاستخدام على الإنترنت العادي قد تكون غير فعالة على I2P، وهي شبكة ذات زمن انتقال (latency) أعلى بكثير.

يدعم I2P واجهة [ملحقات](/docs/plugins/) قياسية للمطورين بحيث يمكن دمج التطبيقات وتوزيعها بسهولة.

التطبيقات المكتوبة بلغة Java والقابلة للوصول/التشغيل باستخدام واجهة HTML عبر webapps/app.war القياسية قد يتم النظر في إدراجها ضمن توزيعة I2P.

## المفاهيم الأساسية

هناك بعض التغييرات التي تتطلب التكيف معها عند استخدام I2P:

### الوجهات

التطبيق الذي يعمل على I2P يرسل الرسائل من ويستقبل الرسائل إلى نقطة نهاية فريدة محمية تشفيريًا — "destination". من حيث TCP أو UDP، يمكن اعتبار الـ destination (إلى حد كبير) معادلاً لزوج اسم المضيف بالإضافة إلى رقم المنفذ، على الرغم من وجود بعض الاختلافات.

- وجهة I2P نفسها هي بنية تشفيرية — جميع البيانات المرسلة إليها مشفرة كما لو كان هناك نشر شامل لـ IPsec مع توقيع موقع نقطة النهاية (المجهولة) كما لو كان هناك نشر شامل لـ DNSSEC.
- وجهات I2P هي معرفات متنقلة — يمكن نقلها من router I2P إلى آخر (أو يمكن حتى "تعدد المواقع" — العمل على عدة routers في وقت واحد). هذا يختلف تمامًا عن عالم TCP أو UDP حيث يجب أن تبقى نقطة نهاية واحدة (منفذ) على مضيف واحد.
- وجهات I2P معقدة وكبيرة — خلف الكواليس، تحتوي على مفتاح عام ElGamal بحجم 2048 بت للتشفير، ومفتاح عام DSA بحجم 1024 بت للتوقيع، وشهادة ذات حجم متغير، قد تحتوي على إثبات العمل أو بيانات مخفية.

هناك طرق موجودة للإشارة إلى هذه الوجهات الكبيرة والمعقدة بأسماء قصيرة وجميلة (مثل "irc.duck.i2p")، ولكن هذه التقنيات لا تضمن الفرادة العالمية (نظرًا لأنها مخزنة محليًا في قاعدة بيانات على جهاز كل شخص) والآلية الحالية ليست قابلة للتوسع أو آمنة بشكل خاص (تتم إدارة التحديثات لقائمة المضيفين باستخدام "الاشتراكات" في خدمات التسمية). قد يكون هناك نظام تسمية آمن وقابل للقراءة البشرية وقابل للتوسع وفريد عالميًا في يوم من الأيام، ولكن لا ينبغي للتطبيقات أن تعتمد على وجوده. تتوفر [معلومات إضافية عن نظام التسمية](/docs/overview/naming/).

بينما معظم التطبيقات لا تحتاج إلى التمييز بين البروتوكولات والمنافذ، فإن I2P *يدعم* ذلك. يمكن للتطبيقات المعقدة تحديد بروتوكول ومنفذ المصدر ومنفذ الوجهة، على أساس كل رسالة على حدة، لتعدد إرسال حركة البيانات على وجهة واحدة. راجع [صفحة datagram](/docs/api/datagrams/) للحصول على التفاصيل. تعمل التطبيقات البسيطة من خلال الاستماع إلى "جميع البروتوكولات" على "جميع المنافذ" الخاصة بوجهة معينة.

### عدم الكشف عن الهوية والسرية

يوفر I2P تشفيرًا شفافًا من طرف إلى طرف ومصادقة لجميع البيانات التي تمر عبر الشبكة — إذا أرسل بوب إلى وجهة أليس، فإن وجهة أليس فقط هي التي يمكنها استقبالها، وإذا كان بوب يستخدم مكتبة الرسائل القصيرة (datagrams) أو مكتبة البث (streaming)، فإن أليس تعلم على وجه اليقين أن وجهة بوب هي التي أرسلت البيانات.

بالطبع، I2P يُخفي هوية البيانات المرسلة بين أليس وبوب بشكل شفاف، لكنه لا يفعل شيئاً لإخفاء هوية محتوى ما يرسلونه. على سبيل المثال، إذا أرسلت أليس لبوب نموذجاً يحتوي على اسمها الكامل، وبطاقات الهوية الحكومية، وأرقام بطاقات الائتمان، فلا يوجد ما يمكن لـ I2P فعله. وبالتالي، يجب على البروتوكولات والتطبيقات أن تضع في اعتبارها المعلومات التي تحاول حمايتها والمعلومات التي ترغب في الكشف عنها.

### يمكن أن يصل حجم حزم I2P Datagrams إلى عدة كيلوبايت

يمكن اعتبار التطبيقات التي تستخدم datagrams في I2P (سواء الخام أو القابلة للرد) بشكل أساسي من حيث UDP — فإن datagrams غير مرتبة، بذل أفضل جهد، وبدون اتصال — ولكن على عكس UDP، لا تحتاج التطبيقات إلى القلق بشأن اكتشاف MTU ويمكنها ببساطة إرسال datagrams كبيرة. بينما الحد الأقصى اسميًا هو 32 كيلوبايت، يتم تجزئة الرسالة للنقل، وبالتالي ينخفض موثوقية الكل. لا يُنصح حاليًا باستخدام datagrams التي يزيد حجمها عن 10 كيلوبايت تقريبًا. راجع [صفحة datagram](/docs/api/datagrams/) للحصول على التفاصيل. بالنسبة للعديد من التطبيقات، 10 كيلوبايت من البيانات كافية لطلب أو استجابة كاملة، مما يسمح لها بالعمل بشفافية في I2P كتطبيق يشبه UDP دون الحاجة إلى كتابة التجزئة، وإعادة الإرسال، وما إلى ذلك.

## خيارات التطوير

هناك عدة طرق لإرسال البيانات عبر I2P، ولكل منها مزاياها وعيوبها. مكتبة streaming lib هي الواجهة الموصى بها، وتستخدمها غالبية تطبيقات I2P.

### مكتبة البث

[مكتبة البث الكاملة](/docs/specs/streaming/) هي الآن الواجهة القياسية. فهي تسمح بالبرمجة باستخدام مقابس (sockets) شبيهة بـ TCP، كما هو موضح في [دليل تطوير البث](#developing-with-the-streaming-library).

### BOB

BOB هو [Basic Open Bridge](/docs/legacy/bob/)، الذي يسمح لتطبيق بأي لغة برمجة بإنشاء اتصالات بث من وإلى I2P. في الوقت الحالي، لا يدعم UDP، لكن دعم UDP مخطط له في المستقبل القريب. يحتوي BOB أيضاً على عدة أدوات، مثل توليد مفاتيح الوجهة، والتحقق من أن العنوان يتوافق مع مواصفات I2P. يمكن العثور على معلومات محدثة والتطبيقات التي تستخدم BOB في هذا [موقع I2P](http://bob.i2p/).

### SAM, SAM V2, SAM V3

*لا يُنصح باستخدام SAM. SAM V2 مقبول، يُنصح باستخدام SAM V3.*

SAM هو بروتوكول [Simple Anonymous Messaging](/docs/legacy/sam/) (المراسلة المجهولة البسيطة)، والذي يسمح لأي تطبيق مكتوب بأي لغة برمجة بالتواصل مع جسر SAM عبر مقبس TCP عادي وجعل هذا الجسر يقوم بتعدد إرسال كل حركة مرور I2P الخاصة به، مع التنسيق الشفاف للتشفير/فك التشفير والمعالجة القائمة على الأحداث. يدعم SAM ثلاثة أنماط من التشغيل:

- التدفقات (streams)، عندما تريد أليس وبوب إرسال البيانات لبعضهما البعض بشكل موثوق ومرتب
- مخططات البيانات القابلة للرد (repliable datagrams)، عندما تريد أليس إرسال رسالة لبوب يمكن لبوب الرد عليها
- مخططات البيانات الخام (raw datagrams)، عندما تريد أليس الحصول على أقصى قدر من النطاق الترددي والأداء، ولا يهتم بوب بما إذا كان مُرسل البيانات موثقاً أم لا (مثلاً البيانات المنقولة تكون ذاتية التوثيق)

يهدف SAM V3 إلى نفس الهدف الذي يهدف إليه SAM وSAM V2، لكنه لا يتطلب تعدد الإرسال/إلغاء تعدد الإرسال. يتم التعامل مع كل I2P stream من خلال مقبس خاص به بين التطبيق وجسر SAM. بالإضافة إلى ذلك، يمكن إرسال واستقبال البيانات الصغيرة (datagrams) من قبل التطبيق من خلال اتصالات البيانات الصغيرة مع جسر SAM.

[SAM V2](/docs/legacy/samv2/) هو إصدار جديد يستخدمه imule يعالج بعض المشاكل الموجودة في [SAM](/docs/legacy/sam/).

[SAM V3](/docs/api/samv3/) يُستخدم من قبل imule منذ الإصدار 1.4.0.

### I2PTunnel

يتيح تطبيق I2PTunnel للتطبيقات بناء أنفاق محددة شبيهة بـ TCP إلى النظراء من خلال إنشاء إما تطبيقات I2PTunnel 'client' (التي تستمع على منفذ محدد وتتصل بوجهة I2P محددة كلما تم فتح مقبس لذلك المنفذ) أو تطبيقات I2PTunnel 'server' (التي تستمع إلى وجهة I2P محددة وكلما حصلت على اتصال I2P جديد تقوم بإعادة التوجيه إلى مضيف/منفذ TCP محدد). هذه التدفقات نظيفة 8-بت، ومصادق عليها ومؤمنة من خلال نفس مكتبة البث التي يستخدمها SAM، ولكن هناك عبء غير بسيط يتعلق بإنشاء عدة نسخ فريدة من I2PTunnel، حيث أن لكل منها وجهة I2P فريدة خاصة بها ومجموعتها الخاصة من الأنفاق والمفاتيح، إلخ.

### SOCKS

يدعم I2P بروكسي SOCKS V4 وV5. تعمل الاتصالات الصادرة بشكل جيد. قد تكون وظائف الاتصالات الواردة (الخادم) وUDP غير مكتملة وغير مختبرة.

### Ministreaming

*تمت الإزالة*

كانت هناك مكتبة "ministreaming" بسيطة، ولكن الآن ministreaming.jar يحتوي فقط على الواجهات (interfaces) لمكتبة streaming الكاملة.

### رسائل البيانات (Datagrams)

*موصى به لتطبيقات شبيهة بـ UDP*

تتيح [مكتبة Datagram](/docs/api/datagrams/) إرسال حزم بيانات شبيهة بـ UDP. من الممكن استخدام:

- مخططات البيانات القابلة للرد (Repliable datagrams)
- مخططات البيانات الخام (Raw datagrams)

### I2CP

*غير موصى به*

[I2CP](/docs/specs/i2cp/) نفسه بروتوكول مستقل عن لغة البرمجة، ولكن لتنفيذ مكتبة I2CP بلغة أخرى غير Java يتطلب كتابة كمية كبيرة من الكود (روتينات التشفير، تحويل الكائنات، معالجة الرسائل غير المتزامنة، إلخ). بينما يمكن لشخص ما كتابة مكتبة I2CP بلغة C أو لغة أخرى، سيكون من المفيد على الأرجح استخدام مكتبة SAM بلغة C بدلاً من ذلك.

### تطبيقات الويب

يأتي I2P مع خادم الويب Jetty، وتكوينه لاستخدام خادم Apache بدلاً من ذلك أمر بسيط. يجب أن تعمل أي تقنية تطبيقات ويب قياسية.

## ابدأ التطوير — دليل بسيط

التطوير باستخدام I2P يتطلب تثبيت I2P يعمل بشكل صحيح وبيئة تطوير من اختيارك. إذا كنت تستخدم Java، يمكنك البدء في التطوير باستخدام [مكتبة streaming](#developing-with-the-streaming-library) أو مكتبة datagram. باستخدام لغة برمجة أخرى، يمكن استخدام SAM أو BOB.

### التطوير باستخدام مكتبة Streaming

فيما يلي نسخة محدّثة ومختصرة من المثال الموجود في الصفحة الأصلية. للحصول على المثال الكامل، راجع الصفحة القديمة أو أمثلة Java الخاصة بنا في قاعدة الكود.

```java
// Server example (excerpt)
I2PSocketManager manager = I2PSocketManagerFactory.createManager();
I2PServerSocket server = manager.getServerSocket();
I2PSocket socket = server.accept();
BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
String s;
while ((s = br.readLine()) != null) {
    System.out.println("Received: " + s);
}
```
*مثال على الكود: خادم أساسي يستقبل البيانات.*

```java
// Client example (excerpt)
I2PSocketManager manager = I2PSocketManagerFactory.createManager();
Destination dest = new Destination(serverDestBase64);
I2PSocket socket = manager.connect(dest);
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
bw.write("Hello I2P!\n");
bw.flush();
```
*مثال على الكود: العميل يتصل ويرسل سطراً.*
