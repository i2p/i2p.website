---
title: "تنفيذ Tunnel القديم (إصدار قديم)"
description: "وصف مؤرشف لتصميم الـ tunnel (نفق) المستخدم قبل I2P 0.6.1.10."
slug: "old-implementation"
lastUpdated: "2005-06"
accurateFor: "0.6.1"
reviewStatus: "needs-review"
---

> **الحالة المتقادمة:** يُحتفَظ بهذا المحتوى كمرجع تاريخي فقط. يوثّق نظام tunnel الذي كان مُضمَّناً قبل I2P&nbsp;0.6.1.10، ولا ينبغي استخدامه في التطوير الحديث. راجع [التنفيذ الحالي](/docs/specs/implementation/) للحصول على إرشادات الإنتاج.

كان النظام الفرعي الأصلي لـ tunnel يستخدم أيضًا tunnels أحادية الاتجاه، لكنه اختلف في بنية الرسائل، وكشف التكرار، وإستراتيجية البناء. تعكس العديد من الأقسام أدناه بنية الوثيقة المُهملة لتيسير المقارنة.

## 1. نظرة عامة على Tunnel (نفق)

- كانت tunnels تُبنى كسلاسل مرتبة من الأقران يختارها المنشئ.
- تراوحت أطوال Tunnel بين 0–7 قفزات، مع عدة خيارات ضبط للحشو، وتقييد المعدل، وتوليد chaff (بيانات مضللة).
- كانت tunnels الواردة تسلّم الرسائل من بوابة غير موثوقة إلى المنشئ (نقطة النهاية)؛ وكانت tunnels الصادرة تدفع البيانات بعيداً عن المنشئ.
- كانت مدة حياة Tunnel تبلغ 10 دقائق، وبعدها كان يتم إنشاء tunnels جديدة (غالباً باستخدام الأقران أنفسهم ولكن بمعرّفات Tunnel مختلفة).

## 2. آلية العمل في التصميم القديم

### 2.1 المعالجة المسبقة للرسائل

جمعت البوابات ≤32&nbsp;KB من حمولة I2NP، واختارت الحشو، وأنتجت حمولة تحتوي على:

- حقل طول الحشو من بايتين، وذلك العدد من البايتات العشوائية
- تسلسل من أزواج `{instructions, I2NP message}` يصف وجهات الإيصال، والتجزئة، والتأخيرات الاختيارية
- رسائل I2NP كاملة محشوة حتى حدّ 16 بايت

قامت تعليمات التسليم بتعبئة معلومات التوجيه ضمن حقول بتية (نوع التسليم، أعلام التأخير، أعلام التجزئة، وامتدادات اختيارية). حملت الرسائل المجزأة معرّف رسالة بطول 4 بايت إضافةً إلى علم الفهرس/الجزء الأخير.

### 2.2 تشفير البوابة

ثبّت التصميم القديم طول الـ tunnel عند ثماني قفزات لمرحلة التشفير. قامت البوابات بتكديس AES-256/CBC مع كتل الـ checksum (المجموع الاختباري) لكي يتمكّن كل قفزة من التحقق من سلامة البيانات من دون تقليل حجم الحمولة. وكان الـ checksum نفسه كتلة مشتقة من SHA-256 مُضمّنة داخل الرسالة.

### 2.3 سلوك المشاركين

قام المشاركون بتتبع معرّفات tunnel الواردة، وتحققوا مبكراً من سلامة البيانات، وأسقطوا النسخ المكررة قبل إعادة التوجيه. ونظراً لأن الحشو وكتل التحقق كانت مضمنة، ظل حجم الرسالة ثابتاً بغض النظر عن عدد القفزات.

### 2.4 معالجة نقطة النهاية

قامت نقاط النهاية بفك تشفير الكتل الطبقية على نحو تسلسلي، وتحققت من المجاميع الاختبارية، وأعادت تجزئة الحمولة إلى تعليمات مُرمَّزة وإلى رسائل I2NP لمواصلة الإيصال.

## 3. إنشاء Tunnel (عملية مهملة)

1. **اختيار الأقران:** تم اختيار الأقران من ملفات تعريف مُدارة محلياً (استكشافية مقابل عميل). وقد شدد المستند الأصلي بالفعل على التخفيف من هجوم السلف عبر إعادة استخدام قوائم الأقران المرتَّبة لكل tunnel pool.
2. **تسليم الطلبات:** تم تمرير رسائل البناء قفزةً فَقَفزة مع أقسام مُشفّرة لكل نظير. نوقشت أفكار بديلة مثل الامتداد التلسكوبي، وإعادة التوجيه في منتصف المسار، أو إزالة كتل المجموع الاختباري كتجارب، لكنها لم تُعتمد قط.
3. **التجميع:** كانت كل وجهة محلية تحتفظ بـ inbound و outbound tunnel pools منفصلة. وشملت الإعدادات العدد المرغوب، وbackup tunnels، وتفاوت الطول، وتحديد المعدل، وسياسات الحشو.

## 4. مفاهيم تقييد المعدّل والخلط

اقترحت الوثيقة القديمة عدة استراتيجيات ساهمت في توجيه الإصدارات اللاحقة:

- الاستبعاد المبكر العشوائي المُوزَّن (WRED) للتحكم في الازدحام
- محددات معدل لكل tunnel تستند إلى المتوسطات المتحركة للاستخدام الحديث
- ضوابط chaff (حزم وهمية للتشويش) والتجميع الاختيارية (غير مُنفَّذة بالكامل)

## 5. البدائل المؤرشفة

تناولت أقسام من الوثيقة الأصلية أفكارا لم تُنفذ قط:

- إزالة كتل المجموع الاختباري لتقليص المعالجة لكل قفزة
- تمديد تدريجي لـtunnels (قنوات توجيه خاصة في I2P) أثناء التشغيل لتغيير تركيبة الأقران
- التحول إلى tunnels ثنائية الاتجاه (رُفضت في نهاية المطاف)
- استخدام تجزئات أقصر أو أنظمة حشو مختلفة

تظل هذه الأفكار سياقاً تاريخياً قيّماً لكنها لا تعكس القاعدة البرمجية الحديثة.

## المراجع

- أرشيف المستندات القديمة الأصلي (قبل 0.6.1.10)
- [نظرة عامة على Tunnel](/docs/overview/tunnel-routing/) للمصطلحات الحالية
- [تحليل ملفات تعريف الأقران واختيارهم](/docs/overview/tunnel-routing#peer-selection/) للاستدلالات الحديثة
