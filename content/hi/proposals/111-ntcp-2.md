```markdown
---
title: "NTCP 2"
number: "111"
author: "EinMByte, orignal, psi, str4d, zzz"
created: "2014-02-13"
lastupdated: "2019-08-13"
status: "Closed"
thread: "http://zzz.i2p/topics/1577"
supercedes: "106"
target: "0.9.36"
implementedin: "0.9.36"
editor: "manas, str4d, zzz"
---

## नोट
प्रस्ताव चरण बंद हो चुका है।
[SPEC](/en/docs/spec/ntcp2/) के लिए आधिकारिक विनिर्देश देखें।
यह प्रस्ताव संदर्भ के लिए अभी भी पृष्ठभूमि जानकारी के लिए संदर्भित किया जा सकता है।

## अवलोकन

यह प्रस्ताव विभिन्न प्रकार की ऑटोमेटेड पहचान और हमलों के प्रतिरोध को सुधारने के लिए एक सत्यापित कुंजी समझौता प्रोटोकॉल का वर्णन करता है।

प्रस्ताव को इस प्रकार से संगठित किया गया है: सुरक्षा लक्ष्यों को प्रस्तुत किया जाता है, इसके बाद बेसिक प्रोटोकॉल की चर्चा की जाती है। अगला, सभी प्रोटोकॉल संदेशों का पूरा विनिर्देश दिया जाता है। अंत में, राउटर पते और संस्करण पहचान पर चर्चा की गई है। सामान्य पैडिंग योजनाओं पर एक सामान्य हमले पर चर्चा करने वाला परिशिष्ट भी शामिल है, और सत्यापित सिफर के कई उम्मीदवारों वाले परिशिष्ट को भी शामिल किया गया है।

अन्य I2P परिवहनों की तरह, NTCP2 को विशेष रूप से बिंदु-से-बिंदु (राउटर-से-राउटर) I2NP संदेशों के परिवहन के लिए परिभाषित किया गया है।
यह कोई सामान्य-उद्देश्य डेटा पाइप नहीं है।

## प्रेरणा

[NTCP](/en/docs/transport/ntcp/) डेटा पहले संदेश के बाद एन्क्रिप्ट किया जाता है (और पहला संदेश रैंडम डेटा के रूप में दिखाई देता है), इस प्रकार प्रोटोकॉल पहचान को "पेलोड विश्लेषण" के माध्यम से रोकता है। यह अभी भी "प्रवाह विश्लेषण" के माध्यम से प्रोटोकॉल पहचान के लिए कमजोर है। क्योंकि पहले 4 संदेश (यानी हैंडशेक) निश्चित लंबाई (288, 304, 448, और 48 बाइट्स) के होते हैं।

प्रत्येक संदेश में यादृच्छिक मात्रा में यादृच्छिक डेटा जोड़कर, हम इसे बहुत कठिन बना सकते हैं।

लेखकों ने स्वीकार किया कि मानक सुरक्षा प्रथाएं सुझाएंगी कि TLS जैसे मौजूदा प्रोटोकॉल का उपयोग किया जाए, लेकिन यह [Prop104](/en/proposals/104/) है और इसके अपने मुद्दे हैं। जहां भी उपयुक्त हो, "भविष्य का कार्य" पैराग्राफ यह बताने के लिए जोड़े गए हैं कि क्या सुविधाएँ गायब हैं या चर्चा के विषय हैं।

## डिजाइन लक्ष्य

- एक एकल पोर्ट पर NTCP 1 और 2 का समर्थन करें, स्वचालित रूप से पहचानें, और NetDB में एक एकल "परिवहन" (जैसे कि [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) के रूप में प्रकाशित करें।

- संस्करण 1 केवल, 2 केवल, या 1+2 का समर्थन NetDB में एक अलग क्षेत्र में प्रकाशित करें, और संस्करण 1 केवल पर डिफ़ॉल्ट (किसी विशेष राउटर संस्करण के लिए संस्करण समर्थन को बाइंड न करें)।

- सुनिश्चित करें कि सभी कार्यान्वयन (Java/i2pd/Kovri/go) अपने स्वयं के अनुसूचियों पर संस्करण 2 समर्थन जोड़ सकें (या नहीं)।

- सभी NTCP संदेशों में हैंडशेक और डेटा संदेशों सहित रैंडम पैडिंग जोड़ें (यानी लंबाई अस्पष्टता ताकि सभी संदेश 16 बाइट्स के गुणक न हों) दोनों पक्षों को न्यूनतम और अधिकतम पैडिंग और/या पैडिंग वितरण का अनुरोध करने की अनुमति दें। पैडिंग वितरण के विवरण लागू होने पर निर्भर होते हैं और प्रोटोकॉल में निर्दिष्ट किए जा सकते हैं या नहीं।

- उन संदेशों की सामग्री को अस्पष्ट करें जो एन्क्रिप्टेड नहीं हैं (1 और 2), पर्याप्त रूप से ताकि DPI बॉक्स और AV हस्ताक्षर आसानी से उन्हें वर्गीकृत नहीं कर सकें। इसके अलावा सुनिश्चित करें कि एकल सहकर्मी या सहकर्मियों के सेट के लिए जा रहे संदेशों का भी बिट्स का पैटर्न समान नहीं है।

- Java प्रारूप के कारण DH में बिट खोने को ठीक करें [Ticket1112](https://trac.i2p2.i2p/ticket/1112), संभवतः (शायद?) X25519 पर स्विच करके।

- वास्तविक कुंजी व्युत्पत्ति फ़ंक्शन (KDF) पर स्विच करें बजाय इसके कि DH परिणाम का सीधे उपयोग करने के?

- "प्रोबिंग प्रतिरोध" जोड़ें (जैसा कि Tor इसे कहता है); इसमें पुन: प्रयास प्रतिरोध शामिल है।

- दो-तरफा सत्यापित कुंजी विनिमय (2W-AKE) बनाए रखें। 1W-AKE हमारे अनुप्रयोग के लिए पर्याप्त नहीं है।

- प्रामाणिकरण के एक हिस्से के रूप में चर-प्रकार, चर-लंबाई के हस्ताक्षर (प्रकाशित [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) हस्ताक्षर कुंजी से) का उपयोग करना जारी रखें। प्रामाणिकता के एक अन्य भाग के रूप में RouterInfo में प्रकाशित स्थिर सार्वजनिक कुंजी पर भरोसा करें।

- भविष्य के विस्तार योग्य तरीके के लिए हैंडशेक में विकल्प/संस्करण जोड़ें।

- यदि संभव हो तो दुर्भावनापूर्ण MitM TCP खंडन के लिए प्रतिरोध जोड़ें।

- कनेक्शन सेटअप के लिए आवश्यक CPU में काफ़ी वृद्धि न करें; यदि संभव हो तो इसे महत्वपूर्ण रूप से कम करें।

- संदेश प्रमाणीकरण (MAC) जोड़ें, संभवतः HMAC-SHA256 और Poly1305, और Adler चेकसम को हटा दें।

- I2NP हैडर को छोटा और सरल करें:
  समाप्ति को 4 बाइट्स तक छोटा करें, जैसा कि SSU में है।
  ट्रंकेटेड SHA256 चेकसम के एक बाइट को हटा दें।

- यदि संभव हो तो 4-संदेश, दो-राउंड-ट्रिप हैंडशेक को 3-संदेश, एक-राउंड-ट्रिप हैंडशेक तक कम कर दें, जैसा कि [SSU](/en/docs/transport/ssu/) में है। यह संदेश 4 में बॉब के हस्ताक्षर को संदेश 2 में स्थानांतरित करने की आवश्यकता होगी। दस साल पुराने ईमेल/स्थिति/बैठक अभिलेखागार में 4 संदेशों के कारण को शोध करें।

- पैडिंग से पहले प्रोटोकॉल ओवरहेड को न्यूनतम करें। जबकि पैडिंग जोड़ा जाएगा, और संभवतः काफी मात्रा में, पैडिंग से पहले का ओवरहेड अभी भी ओवरहेड है। कम-बैंडविड्थ नोड्स को NTCP2 का उपयोग करने में सक्षम होना चाहिए।

- रिप्ले और स्क्यू डिटेक्शन के लिए टाइमस्टैम्प बनाए रखें।

- टाइमस्टैम्प में किसी भी वर्ष 2038 के मुद्दों से बचें, कम से कम 2106 तक काम करना चाहिए।

- अधिकतम संदेश आकार को 16K से बढ़ाकर 32K या 64K करें।

- कोई भी नया क्रिप्टोग्राफिक प्राइमिटिव्स जावा (1.7), C++, और Go राउटर कार्यान्वयनों के लिए उपयोग के लिए किताबों में आसानी से उपलब्ध होना चाहिए।

- डिजाइन में जावा, C++, और Go राउटर डेवलपर्स के प्रतिनिधियों को शामिल करें।

- परिवर्तन को न्यूनतम करें (लेकिन फिर भी बहुत कुछ होगा)।

- सामान्य कोड सेट में दोनों संस्करणों का समर्थन करें (यह संभव नहीं हो सकता है और किसी भी मामले में यह कार्यान्वयन-निर्भर है)।

### गैर-लक्ष्य

- बुलेट-प्रूफ DPI प्रतिरोध... वह प्लगबल परिवहन होगा, [Prop109](/en/proposals/109/)।

- एक TLS-आधारित (या HTTPS-जैसी) परिवहन... वह [Prop104](/en/proposals/104/) होगा।

- सममित स्ट्रीम क्रिप्टोग्राफी को बदलना ठीक है।

- समयबद्ध DPI प्रतिरोध (अंतर-संदेश समय/विलंब कार्यान्वयन-निर्भर हो सकते हैं; अंतर-संदेश विलंब किसी भी समय पर शामिल हो सकते हैं, उदाहरण के लिए, यादृच्छिक पैडिंग भेजने से पहले शामिल किए जा सकते हैं)। कृत्रिम विलंब (obfs4 जिसे IAT या अन्तरागमन समय कहते हैं) प्रोटोकॉल ही से स्वतंत्र हैं।

- सत्र में भाग लेने का इंकार (वहां हस्ताक्षर हैं)।

जो गैर-लक्ष्य आंशिक रूप से पुनः विचार या चर्चा किए जा सकते हैं:

- गहरी पैकेट निरीक्षण (DPI) के खिलाफ सुरक्षा की डिग्री

- पोस्ट-क्वांटम (PQ) सुरक्षा

- प्रदर्शनीयता

### संबंधित लक्ष्य

- एक NTCP 1/2 परीक्षण सेटअप को लागू करना

## सुरक्षा लक्ष्य

हम तीन पार्टियों पर विचार करते हैं:

- एलिस, जो एक नई सत्र स्थापित करना चाहती है।
- बॉब, जिसके साथ एलिस सत्र स्थापित करना चाहती है।
- मालोरी, "मध्य में आदमी" जो एलिस और बॉब के बीच है।

अधिकतम दो प्रतिभागी सक्रिय हमलों में शामिल हो सकते हैं।

एलिस और बॉब दोनों की स्थिति कुंजी जोड़ी है, जो उनके [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) में मौजूद है।

प्रस्तावित प्रोटोकॉल निम्नलिखित आवश्यकताओं के तहत एलिस और बॉब को साझा गुप्त कुंजी (K) पर सहमत करने का प्रयास करता है:

1) निजी कुंजी सुरक्षा: बॉब या मालोरी एलिस की स्थिर निजी कुंजी के बारे में कुछ नहीं जान पाते। समान रूप से, एलिस बॉब की स्थिर निजी कुंजी के बारे में कुछ नहीं सीखती।

2) सत्र कुंजी K केवल एलिस और बॉब को ज्ञात है।

3) पूर्ण आगे की गोपनीयता: सहमति की गई सत्र कुंजी गुप्त रहती है, भले ही भविष्य में एलिस और/या बॉब की स्थिर निजी कुंजी प्रकट होने के बाद कुंजी पर सहमति हुई हो।

4) दो-तरफा प्रमाणीकरण: एलिस सुनिश्चित है कि उसने बॉब के साथ सत्र स्थापित किया है, और इसके विपरीत भी।

5) ऑनलाइन DPI प्रतिरोध: सुनिश्चित करें कि केवल सीधी पैकेट निरीक्षण (DPI) तकनीकों का उपयोग करके यह देखना सरल नहीं है कि एलिस और बॉब प्रोटोकॉल में लगे हुए हैं। नीचे देखें।

6) सीमित प्रदर्शनीयता: एलिस या बॉब में से कोई भी प्रोटोकॉल में भागीदारी से इंकार नहीं कर सकता है, लेकिन यदि साझा कुंजी में से कोई भी लीक करता है तो दूसरा पक्ष प्रेषित डेटा की सामग्री की प्रामाणिकता से इंकार कर सकता है।

वर्तमान प्रस्ताव STS प्रोटोकॉल [STS]_ (स्टेशन-टू-स्टेशन) के आधार पर सभी पाँच आवश्यकताओं को प्रदान करने का प्रयास करता है। ध्यान दें कि यह प्रोटोकॉल [SSU](/en/docs/transport/ssu/) प्रोटोकॉल का भी आधार है।

### अतिरिक्त DPI चर्चा

हम दो DPI घटकों पर विचार करते हैं:

1) ऑनलाइन DPI
`````````````

ऑनलाइन DPI सभी प्रवाहों की वास्तविक समय में निरीक्षण कर रहा है। जुड़ाव को अवरुद्ध किया जा सकता है या अन्यथा छेड़छाड़ की जा सकती है। जुड़ाव डेटा या मेटाडेटा की पहचान कर उसे ऑफ़लाइन विश्लेषण के लिए संग्रहित किया जा सकता है। ऑनलाइन DPI को I2P नेटवर्क डेटाबेस का एक्सेस नहीं है। ऑनलाइन DPI की केवल सीमित वास्तविक समय गणनात्मक क्षमता होती है, जिसमें लंबाई की गणना, फिल्ड का निरीक्षण, और सहज गणनाएँ जैसे कि XOR शामिल होती हैं। ऑनलाइन DPI तेज़ वास्तविक समय क्रिप्टोग्राफिक फ़ंक्शंस जैसे AES, AEAD, और हैशिंग की क्षमता रखता है, लेकिन इन्हें अधिकांश या सभी प्रवाहों पर लागू करना अत्यधिक महंगा होगा। इन क्रिप्टोग्राफिक कार्यों का कोई भी एप्लिकेशन केवल IP/पोर्ट संयोजनों पर लागू होगा जिन्हें पहले ऑफ़लाइन विश्लेषण द्वारा पहचाना गया हो। ऑनलाइन DPI हाई-ओवरहेड क्रिप्टोग्राफिक फंक्शंस जैसे DH या elligator2 का समर्थन नहीं करता है। ऑनलाइन DPI को विशेष रूप से I2P का पता लगाने के लिए डिज़ाइन नहीं किया गया है, हालांकि इसके पास उस उद्देश्य के लिए सीमित वर्गीकरण नियम हो सकते हैं।

प्रोटोकॉल पहचान को एक ऑनलाइन DPI द्वारा रोकना एक लक्ष्य है।

यहां "साधारण" DPI की धारणा को निम्नलिखित विरोधी क्षमताओं को शामिल करने के रूप में लिया गया है:

1) लक्ष्य द्वारा भेजे गए या प्राप्त सभी डेटा का निरीक्षण करने की क्षमता।

2) अवलोकित डेटा पर कार्य करने की क्षमता, जैसे कि ब्लॉक सिफर या हैश फंक्शंस को लागु करना।

3) पहले भेजे गए संदेशों को संग्रहीत और तुलना की क्षमता।

4) पैकेट को बदलने, विलंबित करने या खंडित करने की क्षमता।

हालांकि, ऑनलाइन DPI में निम्नलिखित प्रतिबंध हैं:

5) IP पतों को राउटर हैश के साथ मैप करने की अक्षम्यता। हालाँकि यह रियल-टाइम नेटवर्क डेटाबेस एक्सेस के साथ साधारण है, यह एक DPI सिस्टम की आवश्यकता होगी जो विशेष रूप से I2P को लक्षित करता है।

6) प्रोटोकॉल का पता लगाने के लिए समय जानकारी का उपयोग करने की अक्षम्यता।

7) सामान्य दृष्टिकोण से, ऑनलाइन DPI टूलबॉक्स में कोई भी अंतर्निहित टूल नहीं होता है जो विशेष रूप से I2P का पता लगाने के लिए डिज़ाइन किए गए हैं। इसका मतलब यह नहीं है कि यह एमएल सिस्टम या अत्यधिक विन्यासयोग्य DPI टूल्स का उपयोग नहीं कर सकता, जब तक कि वे अन्य आवश्यकताओं को पूरा करते हैं।

पेलोड विश्लेषण का सामना करने के लिए, यह सुनिश्चित किया जाता है कि सभी संदेश यादृच्छिक से अप्रभेद्य हैं। इसका मतलब यह भी है कि उनकी लंबाई को यादृच्छिक होना चाहिए, जो सिर्फ यादृच्छिक पैडिंग जोड़ने से अधिक जटिल है। वास्तव में, परिशिष्ट ए में, लेखक तर्क देते हैं कि एक सीधा (यानी समान) पैडिंग योजना समस्या का समाधान नहीं करती है। परिशिष्ट ए इसलिए या तो यादृच्छिक विलंब शामिल करने का प्रस्ताव करता है या एक वैकल्पिक पैडिंग योजना विकसित करने का जो प्रस्तावित हमले के लिए उचित सुरक्षा प्रदान कर सकती है।

ऊपर दिए गए छठे अंक के खिलाफ सुरक्षा के लिए, कार्यान्वयन को प्रोटोकॉल में यादृच्छिक विलंब शामिल करने चाहिए। ऐसी तकनीकें इस प्रस्ताव में शामिल नहीं हैं, लेकिन वे पैडिंग लंबाई के मुद्दों का भी समाधान कर सकती हैं। संक्षेप में, प्रस्ताव पेलोड विश्लेषण के खिलाफ अच्छी सुरक्षा प्रदान करता है (जब परिशिष्ट ए में विचारों को ध्यान में रखा जाता है), लेकिन प्रवाह विश्लेषण के खिलाफ केवल सीमित सुरक्षा प्रदान करता है।

2) ऑफलाइन DPI
``````````````

ऑफलाइन DPI डेटा की निरीक्षण कर रहा है जो बाद में विश्लेषण के लिए ऑनलाइन DPI द्वारा संग्रहीत किया गया हो। ऑफलाईन DPI को विशेष रूप से I2P का पता लगाने के लिए डिज़ाइन किया गया हो सकता है। ऑफलाइन DPI को वास्तविक समय में I2P नेटवर्क डेटाबेस का access प्राप्त होता है। ऑफलाइन DPI इस और अन्य I2P विनिर्देशों तक पहुंचता है। ऑफलाइन DPI की असीमित संगणना क्षमता होती है, जिसमें इस विनिर्देश में वर्णित सभी क्रिप्टोग्राफिक कार्यों का समावेश होता है।

ऑफलाइन DPI को चालू कनेक्शनों को ब्लॉक करने की क्षमता नहीं होती है। ऑफलाइन DPI के पास होस्ट/पोर्ट के पार्टियों को त्वरित समय (सेटअप के कुछ मिनटों के भीतर) भेजने की क्षमता होती है, जैसे कि TCP RST। ऑफलाइन DPI के पास त्वरित समय (सेटअप के कुछ मिनटों के भीतर) में पिछले संदेशों का पुन: प्लेबैक करने की क्षमता होती है (संशोधित या नहीं) "पिंग" या अन्य कारणों के लिए।

यह ऑफलाइन DPI द्वारा प्रोटोकॉल की पहचान को रोकने का लक्ष्य नहीं है।
पहले दो संदेशों में अस्पष्ट डेटा के सभी डिकोडिंग, जो I2P रूटर्स द्वारा कार्यान्वित किए जाते हैं, ऑफलाइन DPI द्वारा भी कार्यान्वित किया जा सकते हैं।

यह पुनः खेले गये पिछले संदेशों का उपयोग करने वाले असफल कनेक्शनों को अस्वीकार करने का लक्ष्य है।

भविष्य का कार्य
```````````````

- यह प्रोटोकॉल कैसा व्यवहार करता है जब हमलावर द्वारा पैकेट ड्रॉप हो जाते हैं या क्रमबद्ध किए जाते हैं इसका व्यवहार विचार करें। इस क्षेत्र में हाल का दिलचस्प कार्य [IACR-1150](https://eprint.iacr.org/2015/1150) में पाया जा सकता है।

- DPI सिस्टम्स का एक और अधिक सटीक वर्गीकरण प्रदान करें, विषय से संबंधित मौजूद साहित्य को ध्यान में रखते हुए।

- प्रस्तावित प्रोटोकॉल की औपचारिक सुरक्षा पर चर्चा करें, आदर्श रूप से DPI हमलावर मॉडल को ध्यान में रखते हुए।

## नॉइज़ प्रोटोकॉल फ्रेमवर्क

यह प्रस्ताव नॉइज़ प्रोटोकॉल फ्रेमवर्क [NOISE](http://noiseprotocol.org/) (संस्करण 33, 2017-10-04) पर आधारित आवश्यकताएं प्रदान करता है। Noise का गुणधर्म Station-To-Station प्रोटोकॉल [STS]_ के आधार पर समान होता है, जो [SSU](/en/docs/transport/ssu/) प्रोटोकॉल का आधार है। Noise के पार्लेंस में, एलिस इनिशिएटर होती है, और बॉब रिस्पॉन्डर होता है।

NTCP2 नॉइज़ प्रोटोकॉल Noise_XK_25519_ChaChaPoly_SHA256 पर आधारित है।
(प्रारंभिक कुंजी व्युत्पत्ति फ़ंक्शन के लिए वास्तविक पहचानकर्ता
"I2P एक्सटेंशन का संकेत देने के लिए Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256" है - नीचे KDF 1 अनुभाग देखें)
इस नॉइज़ प्रोटोकॉल में निम्न गुणधर्म होते हैं:

- हैंडशेक पैटर्न: XK
  एलिस बॉब को अपनी कुंजी ट्रांसमिट करती है (X)
  एलिस पहले से ही बॉब की स्थिर कुंजी जानती है (K)

- DH फंक्शन: X25519
  X25519 DH 32 बाइट्स की कुंजी लंबाई के साथ जैसा कि [RFC-7748](https://tools.ietf.org/html/rfc7748) में निर्दिष्ट है।

- सिफर फंक्शन: ChaChaPoly
  AEAD_CHACHA20_POLY1305 जैसा कि [RFC-7539](https://tools.ietf.org/html/rfc7539) धारा 2.8 में निर्दिष्ट किया गया है।
  12 बाइट नॉन्स, जिसमें पहले 4 रास्ते सेट करने की आवश्यकता होती है।

- हैश फंक्शन: SHA256
  मानक 32-बाइट हैश, जो I2P में व्यापक रूप से उपयोग किया जाता है।

## फ्रेमवर्क में अतिरिक्त जोड़

यह प्रस्ताव Noise_XK_25519_ChaChaPoly_SHA256 के लिए निम्नलिखित एन्हांसमेंट्स को परिभाषित करता है। ये सामान्यतः [NOISE](http://noiseprotocol.org/) धारा 13 के दिशा-निर्देशों का पालन करते हैं।

1) ज्ञात कुंजी और IV का उपयोग करते हुए AES एन्क्रिप्शन के साथ स्पष्ट संक्रमण कुंजियों को अस्पष्ट किया जाता है। यह elligator2 से तेज है।

2) संदेश 1 और 2 को स्पष्ट पेडिंग के साथ जोड़ा जाता है।
स्पष्ट पेडिंग हैंडशेक हैश (MixHash) गणना में शामिल होती है।
नीचे संदेश 2 और संदेश 3 हिस्से 1 के लिए KDF देखें।
संदेश 3 और डेटा चरण संदेशों में यादृच्छिक AEAD पेडिंग जोड़ा जाता है।

3) दो-बाइट फ्रेम लंबाई फ़ील्ड जोड़ा जाता है, जैसा कि TCP पर नॉइज़ के लिए आवश्यक है, और जैसा कि obfs4 में है। यह केवल डेटा चरण संदेशों में उपयोग किया जाता है।
संदेश 1 और 2 AEAD फ्रेम निश्चित लंबाई के हैं।
संदेश 3 हिस्से 1 AEAD फ्रेम की लंबाई संदेश 1 में निर्दिष्ट की गई है।

4) दो-बाइट फ्रेम लंबाई फ़ील्ड SipHash-2-4 के साथ अस्पष्ट किया जाता है,
जैसा कि obfs4 में है।

5) संदेश 1,2,3, और डेटा चरण के लिए पेलोड प्रारूप परिभाषित किया गया है।
स्वाभाविक रूप से, इसे नॉइज़ में परिभाषित नहीं किया गया है।

## I2P के लिए नए क्रिप्टोग्राफिक प्राइमिटिव्स

मौजूदा I2P राउटर कार्यान्वयन निम्नलिखित मानक क्रिप्टोग्राफिक प्राइमिटिव्स के लिए कार्यान्वयन की आवश्यकता होगी,
जो वर्तमान I2P प्रोटोकॉल के लिए आवश्यक नहीं हैं:

1) X25519 कुंजी उत्पन्नी और DH

2) AEAD_ChaCha20_Poly1305 (नीचे ChaChaPoly के रूप में संक्षिप्त)

3) SipHash-2-4

## प्रोसेसिंग ओवरहेड अनुमान

3 संदेशों के लिए संदेश आकार:

1) 64 बाइट्स + पेडिंग (NTCP था 288 बाइट्स)
2) 64 बाइट्स + पेडिंग (NTCP था 304 बाइट्स)
3) लगभग 64 बाइट्स + एलिस राउटर जानकारी + पेडिंग औसत राउटर जानकारी लगभग 750
   बाइट्स कुल औसत 814 बाइट्स पेडिंग से पहले (NTCP था 448 बाइट्स)
4) NTCP2 में आवश्यक नहीं (NTCP था 48 बाइट्स)

कुल पेडिंग से पहले:
NTCP2: 942 बाइट्स
NTCP: 1088 बाइट्स
ध्यान दें कि यदि एलिस बॉब से जुड़ा था ताकि वह अपने राउटर जानकारी का डेटाबेस स्टोर संदेश भेज सके, तो वह संदेश आवश्यक नहीं है,
लगभग 800 बाइट्स बचते हैं।

हैंडशेक समाप्त करने और डेटा चरण शुरू करने के लिए प्रत्येक पार्टी द्वारा आवश्यक निम्नलिखित क्रिप्टोग्राफिक ऑपरेशन:

- AES: 2
- SHA256: 7 (एलिस), 6 (बॉब) (सभी कनेक्शन के लिए प्रीकैलकुलेटेड 1 एलिस और 2 बॉब को छोड़कर) (HMAC-SHA256 को छोड़कर)
- HMAC-SHA256: 19
- ChaChaPoly: 4
- X25519 कुंजी उत्पन्नी: 1
- X25519 DH: 3
- हस्ताक्षर सत्यापन: 1 (बॉब) (एलिस ने अपने RI उत्पन्न करते हुए पहले ही हस्ताक्षर किया था) 
  संभवतः Ed25519 (RI हस्ताक्षर प्रकार पर निर्भर)

प्रत्येक डेटा चरण संदेश के लिए प्रत्येक पार्टी द्वारा आवश्यक निम्नलिखित क्रिप्टोग्राफिक ऑपरेशन:

- SipHash: 1
- ChaChaPoly: 1

## संदेश

सभी NTCP2 संदेश 65537 बाइट्स की लंबाई के सर्वाधिक या बराबर हैं। संदेश प्रारूप नॉइज़ संदेशों पर आधारित है, जिसमें फ्रेमिंग और अप्रभेद्यता के लिए संशोधन हैं।
मानक नॉइज़ लाइब्रेरी का उपयोग करने वाले कार्यान्वयनों को प्राप्त संदेशों को Noise संदेश प्रारूप से पहले-प्रसंस्करित करने की आवश्यकता हो सकती है। सभी एन्क्रिप्टेड क्षेत्रों का AEAD
सिफरटेक्स्टों के रूप में प्रतिनिधित्व किया जाएगा।

स्थापना अनुक्रम इस प्रकार है:
```html
  एलिस                           बॉब

  सत्र अनुरोध ------------------->
  <------------------- सत्र निर्मित
  सत्र पुष्टि ----------------->
```

Noise शब्दावली का उपयोग करते हुए, स्थापना और डेटा अनुक्रम इस प्रकार है:
(पेलोड सुरक्षा विशेषताएँ)

```html
  XK(s, rs):           प्रमाणीकरण   गोपनीयता
    <- s
    ...
    -> e, es                  0                2
    <- e, ee                  2                1
    -> s, se                  2                5
    <-                        2                5
```

एक बार एक सत्र स्थापित हो जाने के बाद, एलिस और बॉब डेटा संदेशों को आदान-प्रदान कर सकते हैं।

सभी संदेश प्रकार (सत्र अनुरोध, सत्र बनाए गए, सत्र पुष्टि, डेटा और टाइमसिंक) इस अनुभाग में निर्दिष्ट किए गए हैं।

कुछ संकेत::

  - RH_A = एलिस के लिए राउटर हैश (32 बाइट्स)
  - RH_B = बॉब के लिए राउटर हैश (32 बाइट्स)

### सत्यापित एन्क्रिप्शन

हैंडशेक चरण के दौरान एक अलग एन्क्रिप्टेड एन्क्रिप्शन उदाहरण (CipherStates) होता है।
डेटा चरण के लिए दो (प्रेषण और प्राप्त करें) होते हैं।
प्रत्येक के पास KDF से अपनी कुंजी होती है।

एन्क्रिप्टेड/सत्यापित डेटा के रूप में प्रदर्शित किया जाएगा 

```html
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   एन्क्रिप्टेड और सत्यापित डेटा      |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
```

ChaCha20/Poly1305
`````````````````

एन्क्रिप्टेड और सत्यापित डेटा प्रारूप।

एन्क्रिप्शन/डिक्रिप्शन फ़ंक्शंस का इनपुट:

```html
  k :: 32 बाइट सिफर कुंजी, जैसा कि KDF से उत्पन्न होता है

  nonce :: काउंटर आधारित नॉन्स, 12 बाइट्स।
           प्रत्येक संदेश के लिए 0 से शुरू होता है और बढ़ता है।
           पहले चार बाइट्स हमेशा शून्य होते हैं।
           अंतिम आठ बाइट्स छोटे-बड़े एन्डियन एन्कोडेड काउंटर होते हैं।
           अधिकतम मूल्य 2**64 - 2 होता है।
           कनेक्शन को गिराना और पुनः आरंभ करना चाहिए जब यह
           इस मूल्य पर पहुँच जाए।
           मूल्य 2**64 - 1 कभी नहीं भेजा जाना चाहिए।

  ad :: हैंडशेक चरण में:
        एसोसिएटेड डेटा, 32 बाइट्स।
        सभी पूर्ववर्ती डेटा का SHA256 हैश।
        डेटा चरण में:
        शून्य बाइट्स

  data :: सामान्य डेटा, 0 या अधिक बाइट्स

```

एन्क्रिप्शन फ़ंक्शन का आउटपुट, डिक्रिप्शन फ़ंक्शन का इनपुट:

```html
  +----+----+----+----+----+----+----+----+
  |ओब्फ्स लें |                             |
  +----+----+                             +
  |       ChaCha20 एन्क्रिप्टेड डेटा       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 संदेश प्रमाणीकरण कोड        |
  +              (MAC)                    +
  |             16 बाइट्स                  |
  +----+----+----+----+----+----+----+----+

  Obfs Len :: (एन्क्रिप्टेड डेटा + MAC) की लंबाई, 16 - 65535
              Obfuscation using SipHash (नीचे देखें)
              संदेश 1 या 2 में उपयोग नहीं किया गया है, जहां लंबाई निर्धारित होती है।
              संदेश 3 भाग 1 में उपयोग नहीं किया गया है, क्योंकि लंबाई संदेश 1 में निर्दिष्ट होती है।

  encrypted data :: सामान्य डेटा जितना ही आकार, 0 - 65519 बाइट्स

  MAC :: Poly1305 संदेश प्रमाणीकरण कोड, 16 बाइट्स

```

ChaCha20 के लिए, यहाँ वर्णित जो कुछ है वह [RFC-7539](https://tools.ietf.org/html/rfc7539) के अनुरूप है, जिसे TLS [RFC-7905](https://tools.ietf.org/html/rfc7905) में भी इसी तरह उपयोग किया जाता है।

नोट्स
`````
- चूंकि ChaCha20 एक स्ट्रीम सिफर है, पाठों को पैडिंग करने की आवश्यकता नहीं है।
  अतिरिक्त कीस्ट्रीम बाइट्स को छोड़ दिया जाता है।

- सिफर की कुंजी (256 बिट्स) SHA256 KDF के माध्यम से सहमत होती है।
  KDF के लिए प्रत्येक संदेश के विशिष्ट विवरण अलग-अलग अनुभागों में हैं।

- ChaChaPoly फ्रेम्स के लिए संदेश 1, 2 और संदेश 3 का पहला हिस्सा,
  ज्ञात आकार के होते हैं। द्वितीय भाग के संदेश 3 के बाद
  फ्रेम्स का आकार निराधारित होता है। संदेश 3 का भाग 1 आकार संदेश 1 में निर्दिष्ट होता है।
  डेटा चरण के साथ शुरू करके, फ्रेम में दो-बाइट लंबाई प्रेषित की जाती है
  SipHash के साथ obfuscated जैसा कि obfs4 में है।

- पैडिंग संदेश 1 और 2 के लिए प्रमाणित डेटा फ्रेम के बाहर होती है।
  पैडिंग को अगले संदेश के लिए KDF में उपयोग किया जाता है ताकि छेड़छाड़ जांची जा सके।
  संदेश 3 के साथ शुरू करके, पैडिंग प्रमाणित डेटा फ्रेम के भीतर होती है।

AEAD त्रुटि हैंडलिंग
``````````````````````
- संदेश 1, 2, और संदेश 3 के भाग 1 और 2 में, AEAD संदेश आकार पहले से ज्ञात होता है।
  AEAD प्रमाणीकरण विफलता पर, प्राप्तकर्ता को प्रतिक्रिया किए बिना आगे के संदेश प्रसंस्करण को रोकना चाहिए और कनेक्शन बंद कर देना चाहिए।
  यह एक असामान्य बंद होना चाहिए (TCP RST)।

- प्रोबिंग प्रतिरोध के लिए, संदेश 1 में, AEAD विफलता के बाद, बॉब को
  एक यादृच्छिक टाइमआउट सेट करना चाहिए (सीमा TBD) और फिर एक निश्चित संख्या में बाइट्स पढ़ें (सीमा TBD)
  सॉकेट को बंद करने से पहले। बॉब को
  विफलताओं के साथ दोहराए गए IP के लिए ब्लैकलिस्ट बनाए रखना चाहिए।

- डेटा चरण में, AEAD संदेश आकार SipHash के साथ "एन्क्रिप्टेड" (obfuscated) है।
  डिक्रिप्शन ऑरेकल बनाने से बचने के लिए सावधानी बरती जानी चाहिए।
  डेटा चरण AEAD प्रमाणीकरण विफलता पर, प्राप्तकर्ता को
  एक यादृच्छिक टाइमआउट सेट करना चाहिए (सीमा TBD) और फिर एक निश्चित संख्या में बाइट्स पढ़ें (सीमा TBD)। 
  पढ़ने के बाद, या पढ़ने के टाइमआउट पर, प्राप्तकर्ता को एक पेलोड भेजना चाहिए
  जिसमें "AEAD विफलता" कारण कोड के साथ एक समाप्ति ब्लॉक हो,
  और कनेक्शन बंद कर दें।

- डेटा चरण में गैरमान्य लंबाई फ़ील्ड मान के लिए वही त्रुटि कार्रवाई करें।


### कुंजी व्युत्पत्ति फ़ंक्शन (KDF) (हैंडशेक संदेश 1 के लिए)

KDF DH के परिणाम से हस्ताक्षर चरण सिफर कुंजी k उत्पन्न करता है,
HMAC-SHA256 (key, data) का उपयोग करके जैसा कि [RFC-2104](https://tools.ietf.org/html/rfc2104) में परिभाषित किया गया है। 
ये InitializeSymmetric(), MixHash(), और MixKey() फ़ंक्शंस होते हैं,
जो कि Noise स्पेक में बिल्कुल परिभाषित होते हैं।

```html
  यह "ई" संदेश पैटर्न है:

  // प्रोटोकॉल नाम को परिभाषित करें।
  प्रोटोकॉल_name = "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256"
   (48 बाइट्स, US-ASCII एन्कोडेड, कोई NULL समाप्ति नहीं)।

  // हैश h को परिभाषित करें = 32 बाइट्स
  h = SHA256(प्रोटोकॉल नाम);

  ck = चेनिंग कुंजी को परिभाषित करें। h डेटा को ck में कॉपी करें।
  सेट ck = h

  rs = बॉब की 32-बाइट स्थिर कुंजी जैसा कि RouterInfo में प्रकाशित होती है

  // MixHash(null prologue)
  h = SHA256(h);

  // यहाँ तक, एलिस द्वारा सभी आउटगोइंग कनेक्शनों के लिए पहले से गणना की जा सकती है

  // बॉब की स्थिर कुंजी को यहाँ जांचें कि यह वक्र पर वैध बिंदु हो या नहीं।

  // स्थिर कुंजी बॉब
  // MixHash(rs)
  // || नीचे का मतलब जोड़ना होता है
  h = SHA256(h || rs);

  // यहाँ तक, बॉब द्वारा सभी इनकमिंग कनेक्शनों के लिए पहले से गणना की जा सकती है

  यह "ई" संदेश पैटर्न है:

  एलिस अपनी संक्रमणीय DH कुंजी जोड़ी e उत्पन्न करती है।

  // एलिस संक्रमणीय कुंजी X
  // MixHash(e.pubkey)
  // || नीचे का मतलब जोड़ना होता है
  h = SHA256(h || e.pubkey);

  // h का उपयोग AEAD में हैंडशेक संदेश 1 के लिए एसोसिएटेड डेटा के रूप में किया जाता है
  // संदेश 2 KDF के लिए हैश h बनाए रखें

  "ई" संदेश पैटर्न का अंत।

  यह "es" संदेश पैटर्न है:

  // DH(e, rs) == DH(s, re)
  Define input_key_material = 32 बाइट DH परिणाम एलिस की ईफेमरल कुंजी और बॉब की स्थैतिक कुंजी का
  Set input_key_material = X25519 DH परिणाम

  // MixKey(DH())

  Define temp_key = 32 बाइट्स
  Define HMAC-SHA256(key, data) जैसा कि [RFC-2104](https://tools.ietf.org/html/rfc2104) में
  // किसी अस्थायी कुंजी को चेनिंग कुंजी और DH परिणाम से उत्पन्न करें
  // ck चेनिंग कुंजी है, जो ऊपर परिभाषित है
  temp_key = HMAC-SHA256(ck, input_key_material)
  // DH परिणाम को मेमोरी में अधिलेखित करें, अब इसकी आवश्यकता नहीं है
  input_key_material = (सभी शून्य)

  // आउटपुट 1
  // अस्थायी कुंजी से नई चेनिंग कुंजी निर्धारित करें
  // byte() नीचे का अर्थ एकल बाइट है
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // आउटपुट 2
  // सिफर कुंजी k उत्पन्न करें
  Define k = 32 बाइट्स
  // || नीचे का अर्थ जोड़ना है
  // byte() का अर्थ एकल बाइट है
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
  // temp_key को मेमोरी में अधिलेखित करें, अब इसकी आवश्यकता नहीं है
  temp_key = (सभी शून्य)

  // हैंडशेक संदेश 2 KDF के लिए चेनिंग कुंजी ck बनाए रखें

  "es" संदेश पैटर्न का अंत।

```

### 1) सत्र अनुरोध

एलिस बॉब को भेजती है।

Noise सामग्री: एलिस की संक्रमणीय कुंजी X
Noise पेलोड: 16 बाइट विकल्प ब्लॉक
गैर-नॉइज़ पेलोड: यादृच्छिक पैडिंग

(पेलोड सुरक्षा गुणधर्म)

```html
  XK(s, rs):           प्रमाणीकरण   गोपनीयता
    -> e, es                  0                2

    प्रमाणीकरण: कोई नहीं (0)।
    यह पेलोड किसी भी पार्टी द्वारा भेजा जा सकता है, जिसमें एक सक्रिय हमलावर शामिल है।

    गोपनीयता: 2।
    ज्ञात प्रापक के लिए एन्क्रिप्शन, केवल प्रेषक समझौता के लिए अग्रेषण गोपनीयता,
    रिप्ले करने के लिए कमजोर। यह पेलोड केवल DHs
    प्रापक के स्थिर कुंजी जोड़ी को शामिल करके एन्क्रिप्ट किया गया है। 
    यदि प्रापक की स्थिर निजी कुंजी से समझौता किया जाता है, 
    भविष्य में भी, यह पेलोड डिक्रिप्ट किया जा सकता है। 
    इस संदेश को भी रिप्ले किया जा सकता है, क्योंकि यहां प्रापन से कोई संक्रमणीय योगदान नहीं है।

    "e": एलिस एक नई संक्रमणीय कुंजी जोड़ी उत्पन्न करती है और इसे e
         वेरिएबल में संग्रहीत करती है, 
         और पुराने h के साथ संक्रमणीय सार्वजनिक कुंजी को हैश करती है 
         जिससे एक नया h उत्पन्न होता है।

    "es": DH प्राफ्ट की जाती है एलिस की संक्रमणीय कुंजी जोड़ी 
          और बॉब की स्थिर कुंजी जोड़ी के बीच।  
          परिणाम को पुराने ck के साथ हैश किया जाता है 
          जिससे एक नया ck और k उत्पन्न होता है 
          और n को शून्य पर सेट किया जाता है।

```

X मान को payload अप्रभेद्यता और अनूठेपन आश्वस्त करने के लिए एन्क्रिप्ट किया जाता है, जो आवश्यक हैं DPI प्रतिक्रिया उपायों के लिए। 
इसे प्राप्त करने के लिए हम AES एन्क्रिप्शन का उपयोग करते हैं, 
जैसा कि elligator2 जैसे कहीं अधिक संयोजी और धीमे विकल्प की बजाय। 
एलिसमेट्रिक एन्क्रिप्शन बॉब की राउटर सार्वजनिक कुंजी के लिए अस्वीकार्य रूप से धीमी होगी।
AES एन्क्रिप्शन बॉब की राउटर हैश को कुंजी के रूप में और बॉब की वर्तनी
नेटवर्क डेटाबेस में प्रकाशित IV का उपयोग करता है।

AES एन्क्रिप्शन केवल DPI प्रतिरोध के लिए होता है। 
कोई भी पक्ष जो बॉब की राउटर हैश और IV जानता है, जो नेटवर्क डेटाबेस में प्रकाशित होते हैं, 
पहले संदेश में X मान को डिक्रिप्ट कर सकता है।

पैडिंग एलिस द्वारा एन्क्रिप्ट नहीं की जाती है।
औचितिक हमलों को रोकने के लिए बॉब को पैडिंग डिक्रिप्ट करना आवश्यक हो सकता है।

अनप्रोसेस्ड सामग्री:

```html
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        RH_B के साथ अस्पष्ट            +
  |       AES-CBC-256 एन्क्रिप्टेड X      |
  +             (32 बाइट्स)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaChaPoly फ्रेम                     |
  +             (32 बाइट्स)               +
  |   संदेश 1 के लिए KDF में k परिभाषित   |
  +   n = 0                               +
  |   एसोसिएटेड डेटा के लिए KDF देखें     |
  +----+----+----+----+----+----+----+----+
  |     अप्रमाणिकृत सत्यापित पैडिंग       |
  ~         (वैकल्पिक)                    ~
  |     विकल्प ब्लॉक में लंबाई परिभाषित है|
  +----+----+----+----+----+----+----+----+

  X :: 32 बाइट्स, AES-256-CBC एन्क्रिप्टेड X25519 संक्रमणीय कुंजी, लिटिल एंडियन
          key: RH_B
          iv: बॉब के नेटवर्क डेटाबेस प्रवेश में प्रकाशित अनुसार

  padding :: यादृच्छिक डेटा, 0 या अधिक बाइट्स।
             कुल संदेश लंबाई 65535 बाइट्स से कम होनी चाहिए।
             यदि बॉब अपना पता NTCP के रूप में प्रकाशित कर रहा है तो
             कुल संदेश लंबाई 287 बाइट्स से कम होनी चाहिए
             (नीचे संस्करण पहचान अनुभाग देखें)।
             एलिस और बॉबKDF में संदेश 2 के लिए पैडिंग डेटा का उपयोग करेंगे।
             अर्थंटिकेट किया गया है ताकि कोई भी छेड़छाड़ अगला संदेश विफल कर देगी।

```

अप्रमाणिकृत डेटा (Poly1305 प्रमाणीकरण टैग नहीं दिखाया गया):

```html
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                   X                   |
  +              (32 बाइट्स)              +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               विकल्प                  |
  +              (16 बाइट्स)              +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     अप्रमाणिकृत सत्यापित पैडिंग       |
  +         (वैकल्पिक)                    +
  |     विकल्प ब्लॉक में लंबाई परिभाषित है|
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  X :: 32 बाइट्स, X25519 संक्रमणीय कुंजी, लिटिल एंडियन

  विकल्प :: विकल्प ब्लॉक, 16 बाइट्स, नीचे देखें

  padding :: यादृच्छिक डेटा, 0 या अधिक बाइट्स।
             कुल संदेश लंबाई 65535 बाइट्स से कम होनी चाहिए।
             यदि बॉब अपना पता "NTCP" के रूप में प्रकाशित कर रहा है तो
             कुल संदेश लंबाई 287 बाइट्स से कम होनी चाहिए
             (नीचे संस्करण पहचान अनुभाग देखें)
             एलिस और बॉब संदेश 2 के लिए KDF में पैडिंग डेटा का उपयोग करेंगे।
             यह सत्यापित है ताकि किसी भी छेड़छाड़ से
             अगला संदेश विफल हो जाएगा।

```

विकल्प ब्लॉक:
ध्यान दें: सभी फ़ील्ड्स बड़े एंडियन हैं।

```html
  +----+----+----+----+----+----+----+----+
  | id | ver|  padLen | m3p2len | Rsvd(0) |
  +----+----+----+----+----+----+----+----+
  |        tsA        |   सुरक्षित (0)    |
  +----+----+----+----+----+----+----+----+

  id :: 1 बाइट, नेटवर्क ID (वर्तमान में 2, परीक्षण नेटवर्क के लिए छोड़कर)
        0.9.42 के रूप में देखें। प्रस्ताव 147 देखें।

  ver :: 1 बाइट, प्रोटोकॉल संस्करण (वर्तमान में 2)

  padLen :: 2 बाइट्स, पैडिंग की लंबाई, 0 या अधिक
            मि/मैक्स दिशा-निर्देश TBD. 0 से 31 बाइट्स की यादृच्छिक लंबाई न्यूनतम?
            (वितरण निर्धारित किया जाना है, परिशिष्ट ए देखें।)

  m3p2Len :: 2 बाइट्स, संदेश की दूसरी AEAD फ्रेम की लंबाई पुष्टि हुई
             (संदेश 3 भाग 2) नोट्स नीचे देखें

  Rsvd :: 2 बाइट्स, 0 पर फ़्यूचर विकल्पों की संगतता के लिए सेट करें

  tsA :: 4 बाइट्स, Unix टाइमस्टैम्प, अपरिमित सेकंड।
         2106 में रैप्स हो जाता है

  सुरक्षित :: 4 बाइट्स, भविष्य के विकल्पों की संगतता के लिए 0 पर सेट करें

```

नोट्स
`````
- जब प्रकाशित पता "NTCP" होता है, बॉब एक ही पोर्ट पर NTCP और NTCP2 दोनों के
  लिए कनेक्शन को स्वीकार करता है और स्वचालित रूप से प्रोटोकॉल की पहचान करता है।
  संगतता के लिए, जब एलिस "NTCP" के रूप में प्रकाशित पते पर कनेक्शन बनाने का प्रयास
  करती है, तो उसे इस संदेश की अधिकतम लंबाई को सीमित करना चाहिए,
  जिसमें पैडिंग भी शामिल हो, 287 बाइट्स या कम।  यह स्वचालित प्रोटोकॉल
  पहचान को बॉब द्वारा सुविधाजनक बनाता है। "NTCP2" के रूप में प्रकाशित होने
  पर, कोई आकार प्रतिबंध नहीं होता है। प्रकाशित पते और संस्करण पहचान अनुभाग
  नीचे देखें।

- शुरुआती AES ब्लॉक में अद्वितीय X मान सुनिश्चित करता है कि सिफरटेक्स्ट हर
  सत्र के लिए अलग होता है।

- बॉब को उन कनेक्शनों को अस्वीकार करना चाहिए जहां टाइमस्टैम्प मान वर्तमान
  समय से बहुत दूर होता है। अधिकतम डीटा समय को "D" कहते हैं।  पुन: प्रयास
  हमलों को रोकने के लिए बॉब को पहले इस्तेमाल किए गए हैंडशेक मानों का एक
  स्थानीय कैश बनाए रखना चाहिए और डुप्लीकेट अस्वीकार करना चाहिए।  कैश में
  कम से कम 2*D की जीवन अवधि होनी चाहिए।  कैश मान कार्यान्वयन पर निर्भर होते
  हैं, हालाँकि 32-बाइट X मान (या इसके एन्क्रिप्टेड समतुल्य) का उपयोग किया
  जा सकता है।

- दीफ़ी-हेलमैन संक्रमणीय कुंजियां कभी भी पुन: उपयोग नहीं की जानी चाहियें, 
  ताकि क्रिप्टोग्राफिक हमलों को रोका जा सके, 
  और पुन: उपयोग को रिप्ले हमले के रूप में अस्वीकार कर दिया जाएगा।

- "KE" और "auth" विकल्प अनुकूल होना चाहिए, यानी साझा गुप्त K उपयुक्त आकार का होना चाहिए। यदि और "auth" विकल्प जोड़े जाते हैं, तो यह
  "KE" फ्लैग का अर्थ बदल सकता है जो कि एक अलग KDF या
  ट्रंकेशन आकार का उपयोग किया जाता है।

- बॉब की जाँच करनी चाहिए कि एलिस की संक्रमणीय कुंजी यहाँ वक्र पर मान्य बिंदु है या नहीं।

- पैडिंग को एक उचित मात्रा तक सीमित किया जाना चाहिए।  बॉब अनावश्यक पैडिंग वाले कनेक्शनों को अस्वीकार कर सकता है।  बॉब अपने पैडिंग विकल्पों को संदेश 2 में निर्दिष्ट करेगा।  मिन/मैक्स गाइडलाइन TBD। यादृच्छिक आकार न्यूनतम 0 से 31 बाइट्स? (वितरण परिशिष्ट A में निर्धारित किया जाना है।)

- किसी भी त्रुटि पर, AEAD, DH, टाइमस्टैम्प, स्पष्ट रिप्ले, या कुंजी
  मान्यता विफलता सहित, बॉब को आगे के संदेश प्रसंस्करण को रोकना होगा और कनेक्शन को बिना
  प्रतिक्रिया बंद करना होगा।  यह एक असाधारण बंद होना चाहिए (TCP RST)।
  प्रबोबिंग प्रतिरोध के लिए, एक AEAD विफलता के बाद, बॉब को
  एक यादृच्छिक समयआउट सेट करना चाहिए (सीमा TBD) और फिर एक निश्चित
  संख्या में बाइट्स पढ़ने का प्रयास करना चाहिए (सीमा TBD),
  सॉकेट को बंद करने से पहले।

- DoS शमन: DH एक अपेक्षाकृत महंगा ऑपरेशन है। पिछले NTCP प्रोटोकॉल की तरह
  राउटर्स को CPU या कनेक्शन exhaustion से बचने के लिए सभी आवश्यक उपाय करने चाहिए।
  अधिकतम सक्रिय कनेक्शनों और अधिकतम कनेक्शन सेटअप पर सीमा लगाएं।
  पढ़ने के समयआउट को लागू करें (दोनों प्रति-पढ़ाई और "slowloris" के लिए कुल समय)।
  एक ही स्रोत से दोहराई गई या साथ-साथ कनेक्शनों को सीमित करें।
  बार-बार विफल होने वाले स्रोतों के लिए ब्लैकलिस्ट बनाए रखें।
  AEAD विफलता का जवाब न दें।

- तेजी से संस्करण पहचान और हैंडशेक को सक्षम करने के लिए, कार्यान्वयन को यह सुनिश्चित करना चाहिए कि एलिस पूरे पहले संदेश की सम्�
  साधारण सजेशन को संगृहित करती है और फिर उसे फ्लश कर देती है, पैडिंग सहित। इससे यह संभावना बढ़ती है कि डेटा एक ही TCP पैकेट में समाहित होगा (जब तक कि ऑपरेटिंग सिस्टम या मिडलबॉक्स द्वारा खंडित न किया जाए), और बॉब द्वारा एक बार में प्राप्त किया जाएगा।  यह दक्षता के लिए भी है और यादृच्छिक पैडिंग की प्रभावशीलता सुनिश्चित करने के लिए भी है।

- "ver" फील्ड: Noise के लिए समग्र प्रोटोकॉल, एक्सटेंशन्स, और NTCP प्रोटोकॉल
  में payload विशिष्टताएँ, NTCP2 के संकेतार्थ। इस फील्ड का उपयोग भविष्य में
  संशोधनों के समर्थन का संकेत देने के लिए किया जा सकता है।

- संदेश 3 भाग 2 की लंबाई: यह इस फ्रेम की लंबाई है जिसमें दो AEAD फ्रेम और MAC शामिल होता है
  जो एलिस द्वारा संदेश 1 में भेजा जाता है।  इस संदेश के लिए महत्वपूर्ण
  नोट्स देखें कि कैसे यह सुनिश्चित किया जाए कि पर्याप्त पैडिंग की अनुमति है।

- संदेश 3 भाग 2 की सामग्री: इस फ्रेम का प्रारूप डेटा चरण के फ्रेम्स के समान होता है, सिवाय इसके कि इस संदेश का लंबाई
  एलिस द्वारा संदेश 1 में भेजा जाता है। नीचे डेटा चरण फ्रेम का प्रारूप देखें।
  इस फ्रेम में 1 से 3 ब्लॉक्स होते हैं निम्नलिखित क्रम में:
  1) एलिस की Router Info ब्लॉक (आवश्यक)
  2) Options ब्लॉक (वैकल्पिक)
  3) Padding ब्लॉक (वैकल्पिक)
  यह फ्रेम किसी अन्य ब्लॉक प्रकार में शामिल नहीं हो सकता।

- संदेश 3 भाग 2 में पैडिंग की आवश्यकता नहीं होती यदि एलिस संदेश 3 के अंत में एक डेटा चरण फ़्रेम जोड़ती है और उसे भेजती है (जो डेटा पाथ तक पहुँचने के लिए पैडिंग के साथ भेजा जा सकता है) जब तक कि मध्यवर्ती शैली इसमें शामिल नहीं हो जाते, इस तरह से यह एक बड़े धारा को देखती है।
  जैसा कि एलिस को बॉब के लिए एक I2NP संदेश भेजना आम तौर पर होगा
  (यहीं कारण है कि उसे बॉब के पास जुड़ना पड़ता है), यह अनुशंसित कार्यान्वयन है,
  प्रभावशीलता सुनिश्चित करने के लिए और यादृच्छिक पैडिंग की प्रभावशीलता सुनिश्चित करने के लिए भी ताकि यह प्रभावी हो।

- संदेश 3 के दोनों भागों के कुल AEAD फ्रेम की लंबाई (भाग 1 और भाग 2) 65535 बाइट्स है; भाग 1 48 बाइट्स होता है इसलिए भाग 2 अधिकतम फ्रेम लंबाई 65487 होती है;
  भाग 2 के मैक्सिम पेलोड अनक्रिप्टेड की लंबाई MAC को छोड़कर 65471 होती है।

### डेटा चरण के लिए कुंजी व्युत्पत्ति कार्य (KDF)

डेटा चरण को शून्य लंबाई वाले संबद्ध डेटा इनपुट का उपयोग किया जाता है।

KDF चेनिंग कुंजी ck से ऐलिस से बॉब को अपरेटिंग कुंजी उत्पन्न करता है,
HMAC-SHA256 (key, data) का उपयोग करके जैसा कि [RFC-2104](https://tools.ietf.org/html/rfc2104) में परिभाषित किया गया है।
यह Split() फ़ंक्शन है, जैसे Noise स्पेक में परिभाषित किया गया है।

```html
  ck = हैंडशेक चरण से

  // k_ab, k_ba = HKDF(ck, zerolen)
  // ask_master = HKDF(ck, zerolen, info="ask")

  // zerolen एक शून्य-लंबाई बाइट ऐरे है
  temp_key = HMAC-SHA256(ck, zerolen)
  // चेनिंग कुंजी को स्मृति में अधिलेखित करें, अब इसकी आवश्यकता नहीं है
  ck = (सभी शून्य)

  // आउटपुट 1
  // सिफर कुंजी, ऐलिस से बॉब को प्रेषित करने के लिए (Noise यह नहीं स्पष्ट करता कि कौन सा कौन सा है, लेकिन जावा कोड करता है)
  k_ab =   HMAC-SHA256(temp_key, byte(0x01)).

  // आउटपुट 2
  // सिफर कुंजी जो बॉब ऐलिस को प्रेषित करता है (Noise स्पष्ट नहीं करता कि कौन सा कौन सा है, लेकिन जावा कोड करता है)
  k_ba =   HMAC-SHA256(temp_key, k_ab || byte(0x02)).

  KDF SipHash के लिए लंबाई क्षेत्र के लिए:
  SipHash के लिए अतिरिक्त समरूपी कुंजी (ask) को उत्पन्न करें
  SipHash दो 8-बाइट कुंजियों (बड़े एंडियन) और पहले डेटा के लिए 8 बाइट IV का उपयोग करता है।

  // "ask" 3 बाइट्स है, US-ASCII, कोई null समाप्ति नहीं है
  ask_master = HMAC-SHA256(temp_key, "ask" || byte(0x01))
  // sip_master = HKDF(ask_master, h || "siphash")
  // "siphash" 7 बाइट्स है, US-ASCII, कोई null समाप्ति नहीं है
  // पिछले temp_key को स्मृति में अधिलेखित करें
  // h संदेश 3 भाग 2 के लिए KDF से है
  temp_key = HMAC-SHA256(ask_master, h || "siphash")
  // ask_master को स्मृति में अधिलेखित करें, अब इसकी आवश्यकता नहीं है
  ask_master = (सभी शून्य)
  sip_master = HMAC-SHA256(temp_key, byte(0x01))

  ऐलिस से बॉब SipHash k1, k2, IV:
  // sipkeys_ab, sipkeys_ba = HKDF(sip_master, zerolen)
  // पिछले temp_key को स्मृति में अधिलेखित करें
  temp_key = HMAC-SHA256(sip_master, zerolen)
  // sip_master को स्मृति में अधिलेखित करें, अब इसकी आवश्यकता नहीं है
  sip_master = (सभी शून्य)

  sipkeys_ab = HMAC-SHA256(temp_key, byte(0x01)).
  sipk1_ab = sipkeys_ab[0:7], छोटे एंडियन
  sipk2_ab = sipkeys_ab[8:15], छोटे एंडियन
  sipiv_ab = sipkeys_ab[16:23]

  बॉब से ऐलिस SipHash k1, k2, IV:

  sipkeys_ba = HMAC-SHA256(temp_key, sipkeys_ab || byte(0x02)).
  sipk1_ba = sipkeys_ba[0:7], छोटे एंडियन
  sipk2_ba = sipkeys_ba[8:15], छोटे एंडियन
  sipiv_ba = sipkeys_ba[16:23]

  // temp_key को स्मृति में अधिलेखित करें, अब इसकी आवश्यकता नहीं है
  temp_key = (सभी शून्य)

```

### 4) डेटा चरण

Noise पेलोड: नीचे परिभाषित विषयवस्तु, जिसमें यादृच्छिक पैडिंग शामिल है
गैर-Noise पेलोड: कोई नहीं

दूसरे भाग के संदेश 3 के साथ शुरू, सभी संदेश एक प्रामाणिक और एन्क्रिप्टेड ChaChaPoly "फ्रेम" में होते हैं
दो-बाइट्स की लंबाई के साथ जोड़ा गया।
सभी पैडिंग फ्रेम के अंदर होती है।
फ्रेम के अंदर एक मानक प्रारूप होता है जिसमें शून्य या अधिक "ब्लॉक्स" होते हैं।
प्रत्येक ब्लॉक में एक बाइट प्रकार और दो-बाइट लंबाई होती है।
प्रकार में दिनांक/समय, I2NP संदेश, विकल्प, समाप्ति, और पैडिंग शामिल हैं।

नोट: बॉब विकल्प के रूप में डेटा चरण में अपने पहले संदेश को ऐलिस के लिए
अपने RouterInfo के रूप में भेज सकता है।

(पेलोड सुरक्षा गुणधर्म)

```html
  XK(s, rs):           प्रमाणीकरण   गोपनीयता
    <-                        2                5
    ->                        2                5

    प्रमाणीकरण: 2।
    प्रेषक प्रमाणीकरण प्रमेखा-अंतर-दखल कमजोरियां (KCI) का प्रतिरोधी।
    प्रेषक प्रमाणीकरण एक एलिस के स्थैतिक के साथ एक अस्थाई-स्थैतिक DH ("es" या "se")
    जोड़ने के आधार पर है।
    स्थैतिक कुंजी दोनों पार्यों के संचार की स्थिर की जा रही होती है।
    मानते हुए कि सहस्‍त्रियां से निर्मित प्राइवेट कुंजियाँ सुरक्षित होती हैं, 
    इसे विजुआलाइज़ करना संभव नहीं होता है।

    गोपनीयता: 5।
    एक ज्ञात प्राप्तकर्ता के लिए एन्क्रिप्शन, मजबूत अग्रेषण गोपनीयता।
    यह पेलोड एक अस्थाई-अस्थाई DH पर एन्क्रिप्ट किया गया है जिसे एक अस्थाई-स्थैतिक DH के साथ भी है
    प्रापक के स्थैतिक कुंजी जोड़ी के साथ।
    अगर सहस्‍त्रजन प्राइवेट कुंजी सुरक्षित होती हैं, और यदि प्रापक को सक्रिय हमलाकर लें द्वारा झूठा प्रस्तुत नहीं किया गया,
    और अगर झूठाना नहीं होता है
    / कुंजी प्रस्तुत की गई है / प्रस्तुत की जाने वाली कुंजियां गलत हो, जिसे भेजा नहीं गया है।

```

नोट्स
`````
- दक्षता के लिए और लंबाई क्षेत्र की पहचान को न्यूनतम करने के लिए,
  कार्यान्वयन को यह सुनिश्चित करना चाहिए कि प्रेषक बफर का पूरा पदार्थ एक बार में फ्लश करता है
  संदेश के साथ, जिसमें लंबाई क्षेत्र और AEAD फ्रेम शामिल होते हैं।
  यह संभावना बढ़ाता है कि डेटा एकल TCP पैकेट में समाहित होगा
  (जब तक कि OS या मिडलबॉक्स द्वारा खंडित न किया जाए), और
  दूसरे पक्ष के लिए एक साथ प्राप्त किया जाता है।
  यह दक्षता के लिए भी है और यादृच्छिक पैडिंग की प्रभावशीलता सुनिश्चित करने के लिए भी है।

- राउटर दोषल सिंक की हर AEAD त्रुटि पर सत्र को समाप्त कर सकता है,
  या संचार करने के प्रयास जारी रख सकता है।
  यदि चल रहे हैं, तो राउटर को पुनरावर्ती त्रुटियों के बाद समाप्त करना चाहिए।

सिफाश ओब्फस्केटेड लंबाई
`````````````````````````
संदर्भ: [SipHash](https://www.131002.net/siphash/)

एक बार जब दोनों पक्षों ने हैंडशेक समापन कर लिया, तो वे पेलोड्स का स्थानांतर करते हैं
जो फिर ChaChaPoly "फ्रेम्स" में एन्क्रिप्टेड और साहचरित होते हैं।

प्रत्येक फ्रेम से पहले एक दो-बाइट लंबाई होती है, बड़े एंडियन।
यह लंबाई निम्नलिखित एन्क्रिप्टेड फ्रेम बाइट्स की संख्या निर्दिष्ट करती है,
MAC सहित।
स्ट्रीम में शीघ्रता से प्रकट लंबाई क्षेत्रों के प्रमेय करने के लिए, फ्रेम लंबाई
SipHash से के रहता ( मास्क) के साथ अस्पष्ट किया गया है
जो डेटा फेज़ KDF से प्रारंभ किया गया है।
ध्यान दें कि दो परिमाणों के लिए SipHash कुंजियों और IVs कुछ अन्य हैं।

```html
        sipk1, sipk2 = KDF से SipHash कुंजी।  (दो 8-बाइट्स लंबे इनटीजर्स)
      IV[0] = sipiv = KDF से SipHash IV। (8 बाइट्स)
      लंबाई बड़े एंडियन है।
      प्रत्येक फ्रेम के लिए:
        IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1])
        Mask[n] = IV[n] का पहला 2 बाइट्स
        obfuscatedLength = लंबाई ^ Mask[n]

      पहला लंबाई आउटपुट IV[1] के साथ XOR होगी।

```

रिसीवर के पास समान SipHash कुंजी और IV है।
लंबाई का डिकोडिंग मास्क को आसपास हटाने और इसे लंबाई प्राप्त करने के लिए किया जाता है।
फ्रेम की लंबाई कुल लंबाई होती है जिसमें एन्क्रोम्ड फ्रेम शामिल होता है MAC के साथ।

नोट्स
`````
- यदि आप एक SipHash लाइब्रेरी फ़ंक्शन का उपयोग करते हैं जो एक अनसाइन किए गए लंबे इंटीजर के रूप में लौटता है,
  मास्क के रूप में सबसे महत्वपूर्ण दो बाइट्स का उपयोग करें।
  अगले IV के रूप में छोटे एंडियन के रूप में लंबे इंटेजर को परिवर्तन करें।

विनिर्माण सामग्री
``````````````````
```html
  +----+----+----+----+----+----+----+----+
  | अस्पष्ट आकार |                           |
  +----+----+ वास्तविक                            +
  |                                             |
  +   ChaChaPoly फ्रेम                          +
  |   एन्क्रिप्टेड और सत्यापित                  |
  +   कुंजी k_ab एलिस से बॉब                  +
  |   कुंजी k_ba बॉब से एलिस                  |
  +   कुंजी डेटा चरण KDF के रूप में परिभाषित       +
  |   n उस दिशा में प्रत्येक फ्रेम के लिए 0 से शुरुआत करता है     +
  +   कोई सहयोगात्मक डेटा नहीं                      +
  |   न्यूनतम 16 बाइट्स                        +
  |                                             |
  ~               .   .   .                   ~
  |                                             |
  +----+----+----+----+----+----+----+----+

  अस्पष्ट आकार :: 2 बाइट्स लंबाई SipHash के साथ अस्पष्ट
              डी-अस्पष्ट होने पर: 16 - 65535

  लंबाई फ़ील्ड के साथ न्यूनतम आकार 18 बाइट्स है।
  लंबाई फ़ील्ड के साथ अधिकतम आकार 65537 बाइट्स है।
  अस्पष्ट लंबाई 2 बाइट्स है।
  अधिकतम ChaChaPoly फ्रेम 65535 बाइट्स है।  

```

असंबद्ध डेटा
`````````````````
एन्क्रिप्टेड फ्रेम में शून्य या अधिक ब्लॉक होते हैं।
प्रत्येक ब्लॉक में एक बाइट पहचानकर्ता, दो बाइट लंबाई, और
शून्य या अधिक बाइट्स की डेटा होती हैं।

विस्तारशीलता के लिए, रिसीवर को अज्ञात पहचानकर्ता वाले ब्लॉक्स को अनदेखा करना चाहिए,
और उन्हें पैडिंग के रूप में मानें।

एन्क्रिप्टेड डेटा का अधिकतम आकार 65535 बाइट्स होता है, जिसमें 16-बाइट प्रमाणीकरण हेडर शामिल होता है,
तो असंबद्ध डेटा का अधिकतम आकार 65519 बाइट्स होता है।

(Poly1305 प्रमाणीकरण टैग नहीं दिखाया गया):

```html
  +----+----+----+----+----+----+----+----+
| ब्लॉक |  आकार  |       डेटा             |
+----+----+----+                        +
|                                                 |
~               .   .   .                        ~
|                                                 |
+----+----+----+----+----+----+----+----+
| ब्लॉक |  आकार  |       डेटा             |
+----+----+----+                        +
|                                                 |
~               .   .   .                        ~
|                                                 |
+----+----+----+----+----+----+----+----+
~               .   .   .                        ~

ब्लॉक :: 1 बाइट
         0 समयअनुसार
         1 विकल्प
         2 RouterInfo
         3 I2NP संदेश
         4 समाप्ति
         224-253 आरक्षित परीक्षण सुविधाओं के लिए
         254 पैडिंग के लिए
         255 भविष्य के विस्तार के लिए आरक्षित
आकार :: 2 बाइट्स, बड़े एंडियन, अनुसरण करने के लिए डेटा के आकार के रूप में 2 बाइट्स के साथ,
          संदेश शरीर का आकार (अधिकतम 65516 बाइट्स)।

```

ब्लॉक क्रम नियम
`````````````````
हैंडशेक संदेश 3 भाग 2 में, आदेश होना चाहिए:
RouterInfo, यदि उपस्थित हो तो विकल्प के साथ, और अगर उपस्थित हो तो पैडिंग के साथ।
अन्य कोई ब्लॉक की अनुमति नहीं है।

डेटा चरण में, आदेश निर्दिष्ट नहीं है, इसके अलावा यह है कि
पैडिंग, यदि उपस्थित हो, को फ्रेम का अंतिम ब्लॉक होना चाहिए।
समापन, यदि उपस्थित हो, को पैडिंग के अलावा फ्रेम का अंतिम ब्लॉक होना चाहिए।

एक ही फ्रेम में कई I2NP ब्लॉक हो सकते हैं।
एक ही फ्रेम में भविष्य विधितया प्रकारों के लिए कई ब्लॉक की अनुमति नहीं हो सकती है।
दूसरे ब्लॉक प्रकार शायद एक ही फ्रेम में कई ब्लॉकों के साथ नहीं होंगे, लेकिन यह निषिद्ध नहीं है।

दिनांक समय
`````````````````

विशेश मामले के लिए समय समायोजन:

```html
  +----+----+----+----+----+----+----+
  | 0  |    4    |     टाइमस्टम्प     |
  +----+----+----+----+----+----+----+

  ब्लॉक :: 0
  आकार :: 2 बाइट्स, बड़े एंडियन, मूल्य = 4
  टाइमस्टम्प :: Unix टाइमस्टैंप, अपरिमित सेकंड।
               2106 में रैप्स हो जाता है

```

विकल्प
```````
संशोधित विकल्प पास करें।
विकल्प में: मिन और मैक्स पैडिंग होता है।

विकल्प ब्लॉक भी बदलती लंबाई का होता है।

```html
  +----+----+----+----+----+----+----+----+
  | 1  |  आकार  |tmin|tmax|rmin|rmax|tdmy|
  +----+----+----+----+----+----+----+----+
  |tdmy|  rdmy   |  tdelay |  rdelay |    |
  ~----+----+----+----+----+----+----+    ~
  |              अन्य विकल्प              |
  ~               .   .   .               ~
  |                                             |
  +----+----+----+----+----+----+----+----+

  ब्लॉक :: 1
  आकार :: 2 बाइट्स, बड़े एंडियन, अनुसरण करने के लिए विकल्प के आकार के रूप में, न्यूनतम 12 बाइट्स

  tmin, tmax, rmin, rmax :: पैडिंग सीमा के लिए अनुरोधित
      tmin और rmin बहुत अधिक ट्राफिक विश्लेषण प्रतिरोध के लिए चाहते हैं।
      tmax और rmax बैंडविड्थ सीमा के लिए चाहते हैं।
      tmin और tmax प्रेषित करता है उस रूट के लिए जिसमें यह विकल्प ब्लॉक भेजा जा रहा होता है।
      rmin और rmax प्राप्त करता है उस रूट के लिए जिसमें यह विकल्प ब्लॉक भेजा जा रहा होता है।
      प्रत्येक 4.4 स्थिर-बिंदु फ्लोट होते हैं जो 0 से 15.9375 का प्रतिनिधित्व करते हैं
      (या इसे unsigned 8-bit integer के रूप में समझें जो 16.0 से विभाजित किया गया हो)।
      यह पैडिंग का डेटा का अनुपात है। उदाहरण:
      0x00 का मूल्य कोई पैडिंग नहीं जोड़ता
      0x01 का मूल्य 6 प्रतिशत पैडिंग जोड़ता है
      0x10 का मूल्य 100 प्रतिशत पैडिंग जोड़ता है
      0x80 का मूल्य 800 प्रतिशत (8x) पैडिंग जोड़ता है
      ऐलिस और बॉब प्रत्येक दिशा में न्यूनतम और अधिकतम को बातचीत करेंगे।
      यह दिशानिर्देश हैं, कोई प्रवर्तन नहीं है।
      प्रेषक को प्राप्तकर्ता के अधिकतम का सम्मान करना चाहिए।
      प्रेषक प्राप्तकर्ता के न्यूनतम का सम्मान कर सकता है या नहीं, बैंडविड्थ प्रतिबंधों के भीतर।

  tdmy: अधिकतम डमी ट्रैफिक भेजने के लिए इच्छुक शर्त, 2 बाइट्स बड़े एंडियन, बाइट्स/सेकंड औसत
  rdmy: अनुरोधित डमी ट्रैफिक, 2 बाइट्स बड़े एंडियन, बाइट्स/सेकंड औसत
  tdelay: अधिकतम अंदरूनी संदेश विलंब जोड़ने के लिए इच्छुक शर्त, 2 बाइट्स बड़े एंडियन, मि. से. औसत
  rdelay: अनुरोधित अंदरूनी संदेश विलंब, 2 बाइट्स बड़े एंडियन, मि. से. औसत

  पैडिंग वितरण के रूप में निर्दिष्ट किया गया?
  यादृच्छिक विलंब के रूप में अतिरिक्त मापदंड निर्दिष्ट किया गया?

  अन्य विकल्प :: प्रारूप TBD

```

विकल्प मुद्दे
`````````````
- विकल्प प्रारूप TBD है।
- विकल्प बातचीत TBD है।

RouterInfo
``````````
एलिस का RouterInfo बॉब को भेजें।
हैंडशेक संदेश 3 भाग 2 में उपयोग किया गया।
डेटा चरण में, RouterInfo विकल्प के रूप में बॉब को भेज सकते हैं।

```html
  +----+----+----+----+----+----+----+----+
  | 2  |  आकार  |flg |    RouterInfo     |
  +----+----+----+----+                   +
  | (हैंडशेक msg 3 भाग 2 में एलिस RI)   |
  ~ (डेटा चरण में एलिस, बॉब, या थर्ड-पार्टी )  ~
  |  RI                              |
  ~               .   .   .               ~
  |                                             |
  +----+----+----+----+----+----+----+----+

  blk :: 2
  size :: 2 बाइट्स, बड़े एंडियन, आकार फ्लैग + राउटर जानकारी का अनुसरण करते हैं
  flg :: 1 बाइट flags
         बिट क्रम: 76543210
         बिट 0: 0 स्थानीय भंडारण के लिए, 1 बाढ़ अनुरोध के लिए
         बिट्स 7-1: अप्रयुक्त, भविष्य संगतता के लिए 0 पर सेट करें
  routerinfo :: एलिस या बॉब का RouterInfo

```

नोट्स
`````
- जब डेटा चरण में उपयोग किया जाता है, प्राप्तकर्ता (एलिस या बॉब) यह पुष्टि करें कि
  यह वही
