---
title: "ECIES-X25519-AEAD-Ratchet"
number: "144"
author: "zzz, chisana, orignal"
created: "2018-11-22"
lastupdated: "2025-03-05"
status: "Closed"
thread: "http://zzz.i2p/topics/2639"
target: "0.9.46"
implementedin: "0.9.46"
---

## नोट
नेटवर्क परिनियोजन और परीक्षण प्रगति पर है।
छोटे संशोधनों के अधीन।
आधिकारिक विशिष्टता के लिए [SPEC](/en/docs/spec/ecies/) देखें।

निम्नलिखित विशेषताएं 0.9.46 के रूप में लागू नहीं की गई हैं:

- संदेश संख्याएं, विकल्प, और समाप्ति ब्लॉक
- प्रोटोकॉल-स्तरीय प्रतिक्रियाएं
- शून्य स्थिर कुंजी
- मल्टीकास्ट


## अवलोकन

यह I2P की शुरुआत के बाद से पहले नए अंत-से-अंत एन्क्रिप्शन प्रकार के लिए एक प्रस्ताव है
ElGamal/AES+SessionTags [Elg-AES](/en/docs/spec/elgamal-aes/) को बदलने के लिए।

यह निम्नलिखित पिछले कार्यों पर निर्भर करता है:

- सामान्य संरचनाएं विशिष्ट [Common](/en/docs/spec/common-structures/)
- [I2NP](/en/docs/spec/i2np/) विशिष्टता जिसमें LS2 शामिल है
- ElGamal/AES+Session Tags [Elg-AES](/en/docs/spec/elgamal-aes/)
- http://zzz.i2p/topics/1768 नई एसिमेट्रिक क्रिप्टो अवलोकन
- निम्न-स्तरीय क्रिप्टो अवलोकन [CRYPTO-ELG](/en/docs/how/cryptography/)
- ECIES http://zzz.i2p/topics/2418
- [NTCP2](/en/docs/transport/ntcp2/) [Prop111](/en/proposals/111-ntcp2/)
- 123 नई netDB प्रविष्टियां
- 142 नया क्रिप्टो टेम्पलेट
- [Noise](https://noiseprotocol.org/noise.html) प्रोटोकॉल
- [Signal](https://signal.org/docs/specifications/doubleratchet/) डबल रैचेट एल्गोरिदम

उद्देश्य है नए एन्क्रिप्शन का समर्थन करना अंत-से-अंत,
गंतव्य-से-गंतव्य संचार के लिए।

डिज़ाइन एक नॉइज़ हैंडशेक और डेटा चरण का उपयोग करेगा जिसमें सिग्नल का डबल रैचेट शामिल होगा।

इस प्रस्ताव में सिग्नल और नॉइज़ का उल्लेख केवल पृष्ठभूमि जानकारी के लिए है।
इस प्रस्ताव को समझने या लागू करने के लिए सिग्नल और नॉइज़ प्रोटोकॉल का ज्ञान आवश्यक नहीं है।


### वर्तमान ElGamal उपयोग

समीक्षा के रूप में,
ElGamal 256-बाइट सार्वजनिक कुंजियां निम्नलिखित डेटा संरचनाओं में पाई जा सकती हैं।
संदर्भ के लिए सामान्य संरचनाओं की विशिष्टता देखें।

- एक राउटर पहचान में
  यह राउटर की एन्क्रिप्शन कुंजी है।

- एक गंतव्य में
  गंतव्य की सार्वजनिक कुंजी पुराने i2cp-से-i2cp एन्क्रिप्शन के लिए उपयोग की जाती थी
  जो संस्करण 0.6 में निष्क्रिय कर दी गई थी, यह वर्तमान में असमानित है सिवाय
  LeaseSet एन्क्रिप्शन के लिए IV के लिए, जो अप्रचलित है।
  LeaseSet में उपयोग की गई सार्वजनिक कुंजी का उपयोग किया जाता है।

- एक LeaseSet में
  यह गंतव्य की एन्क्रिप्शन कुंजी है।

- एक LS2 में
  यह गंतव्य की एन्क्रिप्शन कुंजी है।



### कुंजी प्रमाणपत्रों में एन्कटाइप्स

समीक्षा के रूप में,
हमने हस्ताक्षर प्रकारों का समर्थन जोड़ते समय एन्क्रिप्शन प्रकारों के लिए समर्थन जोड़ा।
एन्क्रिप्शन प्रकार फ़ील्ड हमेशा शून्य होता है, दोनों गंतव्यों और राउटर पहचान में।
क्या इसे कभी बदलना है वह TBD है।
सामान्य संरचनाओं की विशिष्टता देखें [Common](/en/docs/spec/common-structures/)।



### एसिमेट्रिक क्रिप्टो उपयोग

समीक्षा के रूप में, हम ElGamal का उपयोग करते हैं:

1) सुरंग निर्माण संदेशों के लिए (कुंजी राउटर पहचान में है)
   प्रतिस्थापन इस प्रस्ताव में शामिल नहीं है।
   प्रस्ताव 152 [Prop152](/en/proposals/152-ecies-tunnels/) देखें।

2) netdb और अन्य I2NP संदेशों के राउटर-से-राउटर एन्क्रिप्शन के लिए (कुंजी राउटर पहचान में है)
   इस प्रस्ताव पर निर्भर करता है।
   1) के लिए एक प्रस्ताव की भी आवश्यकता है, या कुंजी को RI विकल्पों में रखना।

3) ग्राहक अंत-से-अंत ElGamal+AES/SessionTag (कुंजी LeaseSet में है, गंतव्य कुंजी का उपयोग नहीं किया जाता है)
   प्रतिस्थापन इस प्रस्ताव में शामिल है।

4) NTCP1 और SSU के लिए अस्थायी DH
   प्रतिस्थापन इस प्रस्ताव में शामिल नहीं है।
   NTCP2 के लिए प्रस्ताव 111 देखें।
   SSU2 के लिए कोई वर्तमान प्रस्ताव नहीं है।


### लक्ष्य

- पुराने संस्करणों के साथ संगतता बनाए रखना
- LS2 (प्रस्ताव 123) के प्रस्तावना का उपयोग करता है और उस पर संकित करता है
- NTCP2 के लिए नए क्रिप्टो या प्राइमिटिव्स का लाभ उठाएं (प्रस्ताव 111)
- समर्थन के लिए किसी नए क्रिप्टो या प्राइमिटिव्स की आवश्यकता नहीं है
- क्रिप्टो और हस्ताक्षर के पृथक्करण को बनाए रखें; सभी वर्तमान और भविष्य के संस्करणों का समर्थन करता है
- गंतव्यों के लिए नए क्रिप्टो को सक्षम करना
- राउटर्स के लिए नए क्रिप्टो को सक्षम करना, परन्तु केवल गार्लिक संदेशों के लिए - सुरंग निर्माण के लिए एक अलग प्रस्ताव होगा
- कुछ भी टूटने न दें जो 32-बाइट बाइनरी गंतव्य हैश पर निर्भर करता है, जैसे कि बिटटोरेंट
- 0-RTT संदेश वितरण को अस्थायी-स्थिर DH का उपयोग करके बनाए रखें
- इस प्रोटोकॉल परत में संदेशों को बफरिंग/क्यूइंग की आवश्यकता का सामना न करें;
  दोनों दिशाओं में उत्तर की प्रतीक्षा किए बिना असीमित संदेश वितरण का समर्थन जारी रखें
- 1 RTT के बाद अस्थायी-अस्थायी DH में अपग्रेड करें
- आउट-ऑफ-ऑर्डर संदेशों को संभालना बनाए रखें
- 256-बिट सुरक्षा बनाए रखें
- आगे का गोपनीयता जोड़ें
- प्रमाणीकरण (AEAD) जोड़ें
- ElGamal की तुलना में कहीं अधिक सीपीयू-कुशल
- जयबा जिबिगी पर DH प्रक्रिया को कुशल बनाने के लिए अनुमति न दें
- DH ऑपरेशनों को न्यूनतम करें
- ElGamal (514-बाइट ElGamal ब्लॉक) की तुलना में कहीं अधिक बैंडविड्थ-कुशल
- यदि वांछित हो तो एक ही सुरंग पर नए और पुराने क्रिप्टो का समर्थन करें
- प्राप्तकर्ता सक्षम है नए से पुराने क्रिप्टो को एक ही सुरंग पर नीचे गलती से पहचानने
  कोई अन्य नई या भविष्य क्रिप्टो को पहचानने में सक्षम नहीं है
- नए बनाम मौजूदा सत्र की लंबाई वर्गीकरण को समाप्त करें (पैडिंग का समर्थन करें)
- कोई नया I2NP संदेश आवश्यक नहीं है
- AES पे लोड में SHA-256 चेकसम को AEAD के साथ बदलें
- इसे समर्थन देने का समर्थन करें ताकि
  प्रोटोकॉल के भीतर कमीशन हो सके, केवल ओउट-बैंड में नहीं।
  यह भी तुरंत गोपनीयता प्राप्त करने के लिए उत्तरों की अनुमति देगा।
- कुछ संदेशों (राउटर इंफो स्टोर्स) की अंत-से-अंत एन्क्रिप्शन को सक्षम करें
  जिन्हें वर्तमान में CPU अधिकता के कारण हम नहीं करते हैं।
- I2NP गार्लिक संदेश में कोई बदलाव नहीं
  या गार्लिक संदेश वितरण निर्देशस्वः प्रारूप।
- गार्लिक क्लोव सेट और क्लोव प्रारूपों में अप्राधिकृत या अतिक्रमण वाली फ़ील्ड्स को समाप्त करें।

कैस आज्ञार्था भाषाओं के मुद्दों को समाप्त करें, जिसमें शामिल हैं:

- पहले उत्तर तक AES का उपयोग नहीं कर पाने की असमर्थता
- विश्वसनीयता और त्वरकी प्रकार अपेक्षित वितरक होने पर अवरोध करना
- प्रथम वितरण पर बैंडविड्थ गैर-कुशल
- कैस आज्ञार्था को स्टोर करने के लिए बेंवाश अपव्यय
- टैग्स को वितरित करने के लिए बैंडविड्थ ओवरहेड्स बहुत अधिक
- अत्यंत जटिल, कार्यान्वयन करने में मुश्किल
- विविध उपयोग मामलों के लिए ट्यूने करने में कठिनाई
  (स्ट्रीमिंग बनाम डाटाग्राम, सर्वर बनाम क्लाइंट, उच्च बनाम निम्न बैंडविड्थ)
- टैग्स की डिलीवरी के कारण स्मृति थकान जोखिम


### गैर-लक्ष्य / स्कोप के बाहर

- LS2 प्रारूप परिवर्तन (प्रस्ताव 123 पूरा हो गया है)
- नया DHT रोटेशन एल्गोरिदम या साझा रैंडम जेनरेशन
- सुरंग निर्माण के लिए नई एन्क्रिप्शन।
  प्रस्ताव 152 [Prop152](/en/proposals/152-ecies-tunnels/) देखें।
- सुरंग लेयर एन्क्रिप्शन के लिए नई एन्क्रिप्शन।
  प्रस्ताव 153 [Prop153](/en/proposals/153-ecies-garlic/) देखें।
- I2NP DLM / DSM / DSRM संदेशों की एन्क्रिप्शन, ट्रांसमिशन और रिसेप्शन की विधियां।
  हाथलाना नहीं बदल रहा।
- कोई LS1-से-LS2 या ElGamal/AES-से-इस-प्रस्ताव संचार समर्थित नहीं है।
  यह प्रस्ताव एक द्विदिश प्रोटोकॉल है।
  गंतव्यों का बैकवर्ड संगतता को संभालने का विकल्प होता है दो लीसेट्स को प्रकाशित करने का
  वही सुरंगों का उपयोग करके, या LS2 में दोनों एन्क्रिप्शन प्रकार डालें।
- खतरा मॉडल में बदलाव
- कार्यान्वयन विवरण यहाँ नहीं बताए गए हैं और हर परियोजना पर छोड़ दिए गए हैं।
- (आशावादी) एन्हांसमेंट्स या हुक्स जोड़ें जो मल्टीकास्ट का समर्थन कर सके



### औचित्य

ElGamal/AES+SessionTag लगभग 15 वर्षों तक हमारी एकमात्र अंत-से-अंत प्रोटोकॉल रही है,
मूल रुप से प्रोटोकॉल में बिना किसी संशोधन के।
अब क्रिप्टोग्राफिक प्राइमिटिव्स हैं जो तेज़ हैं।
हमें प्रोटोकॉल की सुरक्षा को बढ़ाने की आवश्यकता है।
हमने प्रोटोकॉल के स्मृति और बैंडविड्थ अधिकता को कम करने के लिए ह्युरिस्टिक रणनीतियों और उपायों को भी विकसित किया है,
लेकिन वे रणनीतियाँ नाजुक हैं, उन्हें ट्यून करना मुश्किल है और प्रोटोकॉल को तोड़ने का कारण करते हैं
सत्र का गिरने का कारण बनता है।

लगभग उतने ही समय के लिए, ElGamal/AES+SessionTag विशिष्टता और संबंधित
दस्तावेज़ों ने बताया है कि सत्र टैग्स वितरित करना कितना बैंडविड्थ महंगा है,
और "सॉंक्रोनाइज्ड PRNG" के साथ सत्र टैग डिलीवरी को बदलने का प्रस्ताव दिया है।
एक सिंक्रोनाइज्ड PRNG दोनों सिरों पर उल्लेखनीय रूप से एक ही टैग उत्पन्न करता है,
एक सामान्य बीज से उत्पादित।
एक सिंक्रोनाइज्ड PRNG को एक "रैचेट" भी कहा जा सकता है।
यह प्रस्ताव (आखिरकार) उस रैचेट तंत्र को निर्दिष्ट करता है और टैग डिलीवरी करती है।

एक रैचेट का उपयोग करके (एक सिंक्रोनाइज्ड PRNG) सत्र टैग उत्पन्न करने के लिए,
हम नई सत्र संदेश में सत्र टैग भेजने के अधिकता को समाप्त करते हैं
और आवश्यक होने पर उसके बाद संदेशों में।
32 टैग्स के एक विशिष्ट टैग सेट के लिए, यह 1KB है।
यह टैग्स को भेजने वाले पक्ष पर सत्र टैग्स का स्टोर करने को भी समाप्त करता है,
इस प्रकार स्टोरेज आवश्यकताओं को आधा कर देता है।

स्टेशन-टू-स्टेशन प्रोटोकॉल (STP) की तरह, एक पूर्ण दो-तरफा हैंडशेक की आवश्यकता होती है
कुंजी समझौता प्रतिरूपण (KCI) हमलों से बचने के लिए।
[NOISE](https://noiseprotocol.org/noise.html) के नॉइज़ "पे लोड सिक्योरिटी प्रॉपर्टीज" तालिका देखें।
KCI पर और अधिक जानकारी के लिए, पेपर देखिए https://www.usenix.org/system/files/conference/woot15/woot15-paper-hlauschek.pdf



### खतरा मॉडल

खतरा मॉडल NTCP2 (प्रस्ताव 111) के लिए कुछ अलग है।
MitM नोड्स OBEP और IBGW हैं और वैश्विक NetDB के
वर्तमान या ऐतिहासिक पूर्ण दृश्य का धारणा करता है, फ्लडफिल्स के साथ सहयोग करके।

उद्देश्य यह है कि ये MitM ने नए और मौजूदा सत्र संदेशों के रूप में
या नए क्रिप्टो बनाम पुराने क्रिप्टो के रूप में ट्रैफिक को वर्गीकृत नहीं कर पाए।



## विस्तृत प्रस्ताव

यह प्रस्ताव ElGamal/AES+SessionTags को बदलने के लिए एक नया अंत-से-अंत प्रोटोकॉल परिभाषित करता है।
डिजाइन एक नॉइज़ हैंडशेक और डेटा चरण का उपयोग करेगा जिसमें सिग्नल का डबल रैचेट शामिल होगा।


### क्रिप्टोग्राफिक डिज़ाइन का संक्षेप

प्रोटोकॉल के पांच हिस्सों को फिर से डिज़ाइन करना है:


- 1) नए और मौजूदा सत्र कंटेनर प्रारूप
  नए स्वरूपों के साथ प्रतिस्थापित किए गए।
- 2) ElGamal (256 बाइट सार्वजनिक कुंजी, 128 बाइट निजी कुंजी) ECIES-X25519 (32 बाइट सार्वजनिक और निजी कुंजी) के साथ प्रतिस्थापित की जाएगी
- 3) AES को AEAD_ChaCha20_Poly1305 (नीचे ChaChaPoly के रूप में संक्षेपित किया गया है) के साथ प्रतिस्थापित किया जाएगा
- 4) SessionTags को रैचेटों के साथ प्रतिस्थापित किया जाएगा,
  जो कि मौलिक तौर पर एक क्रिप्टोग्राफिक, सिंक्रोनाइज्ड PRNG है।
- 5) ElGamal/AES+SessionTags विशिष्टता में परिभाषित AES पे लोड को NTCP2 में उस के समान एक ब्लॉक प्रारूप के साथ प्रतिस्थापित किया गया है।

प्रत्येक पांच परिवर्तनों की अपनी धारा नीचे है।


### I2P के लिए नए क्रिप्टोग्राफिक प्राइमिटिव्स

मौजूदा I2P राउटर कार्यान्वयन के लिए निम्नलिखित मानक क्रिप्टोग्राफिक प्राइमिटिव्स को लागू करने की आवश्यकता होगी,
जो वर्तमान I2P प्रोटोकॉल के लिए आवश्यक नहीं हैं:

- ECIES (लेकिन यह अनिवार्य रूप से X25519 है)
- Elligator2

मौजूदा I2P राउटर कार्यान्वयन जिन्होंने अभी तक [NTCP2](/en/docs/transport/ntcp2/) ([Prop111](/en/proposals/111-ntcp2/)) लागू नहीं किया है,
उनके लिए निम्नलिखित कार्यान्वयन की आवश्यकता होगी:

- X25519 कुंजी पीढ़ी और DH
- AEAD_ChaCha20_Poly1305 (नीचे ChaChaPoly के रूप में संक्षेपित)
- HKDF


### क्रिप्टो प्रकार

क्रिप्टो प्रकार (LS2 में उपयोग किया जाता है) 4 है।
यह एक लिटिल-एंडियन 32-बाइट X25519 सार्वजनिक कुंजी,
और इस प्रस्ताव में निर्दिष्ट अंत-से-अंत प्रोटोकॉल को इंगित करता है।

क्रिप्टो प्रकार 0 ElGamal है।
क्रिप्टो प्रकार 1-3 ECIES-ECDH-AES-SessionTag के लिए आरक्षित हैं, प्रस्ताव 145 [Prop145](/en/proposals/145-ecies/) देखें।


### नॉइज़ प्रोटोकॉल फ्रेमवर्क

यह प्रस्ताव नॉइज़ प्रोटोकॉल फ्रेमवर्क [NOISE](https://noiseprotocol.org/noise.html) (संशोधन 34, 2018-07-11) के आधार पर आवश्यकताओं को प्रदान करता है।
नॉइज़ की समान संपत्तियां स्टेशन-टू-स्टेशन प्रोटोकॉल [STS](https://en.wikipedia.org/wiki/Station-to-Station_protocol) के समान हैं,
जो [SSU](/en/docs/transport/ssu/) प्रोटोकॉल का आधार है। नॉइज़ की भाषा में, ऐलिस
आरंभकर्ता है, और बॉब प्रत्युत्तरकर्ता है।

यह प्रस्ताव नॉइज़ प्रोटोकॉल Noise_IK_25519_ChaChaPoly_SHA256 पर आधारित है।
(प्रारंभिक कुंजी उत्पत्ति फ़ंक्शन के वास्तविक पहचानकर्ता के लिए
I2P एक्सटेंशन्स को इंगित करने के लिए "Noise_IKelg2_25519_ChaChaPoly_SHA256"
देखें KDF 1 सेक्शन नीचे)
यह नॉइज़ प्रोटोकॉल निम्नलिखित मूलभूत चीजों का उपयोग करता है:

- इंटरैक्टिव हैंडशेक पैटर्न: IK
  ऐलिस तुरंत बॉब को उसकी स्थिर कुंजी भेजती है (I)
  ऐलिस पहले से ही बॉब की स्थिर कुंजी जानती है (K)

- वन-वे हैंडशेक पैटर्न: N
  ऐलिस बॉब को उसकी स्थिर कुंजी नहीं भेजती है (N)

- DH फ़ंक्शन: X25519
  X25519 DH 32 बाइट की कुंजी लंबाई के साथ [RFC-7748](https://tools.ietf.org/html/rfc7748) में निर्दिष्ट के रूप में।

- सिफर फ़ंक्शन: ChaChaPoly
  AEAD_CHACHA20_POLY1305 [RFC-7539](https://tools.ietf.org/html/rfc7539) धारा 2.8 में निर्दिष्ट के रूप में।
  12 बाइट का नॉन्स, जिसमें पहले 4 बाइट शून्य पर सेट होते हैं।
  [NTCP2](/en/docs/transport/ntcp2/) में समान।

- हैश फ़ंक्शन: SHA256
  मानक 32-बाइट हैश, I2P में व्यापक रूप से उपयोग होता है।


फ्रेमवर्क में जोड़
``````````````````````````````````

यह प्रस्ताव निम्नलिखित सुधार प्रदान करता है
Noise_IK_25519_ChaChaPoly_SHA256. ये आमतौर पर [NOISE](https://noiseprotocol.org/noise.html) धारा 13 में दिए गए निर्देशों का पालन करते हैं।

1) क्लीयरटेक्स्ट क्षणिक कुंजियों को [Elligator2](https://elligator.org/) से कोडित किया गया है।

2) उत्तर को एक क्लीयरटेक्स्ट टैग के साथ प्रीफिक्स किया गया है।

3) संदेशों 1, 2 और डेटा चरण के लिए पे लोड प्रारूप परिभाषित किया गया है।
   बेशक, यह नॉइज़ में परिभाषित नहीं है।

सभी संदेशों में [I2NP](/en/docs/spec/i2np/) गार्लिक संदेश हेडर शामिल होते हैं।
डेटा चरण नॉइज़ डेटा चरण के समान तरीके से एन्क्रिप्शन का उपयोग करता है, लेकिन संगत नहीं है।


### हैंडशेक पैटर्न

हैंडशेक [Noise](https://noiseprotocol.org/noise.html) हैंडशेक पैटर्न का उपयोग करते हैं।

निम्नलिखित अक्षर मैपिंग का उपयोग किया जाता है:

- e = एकबारगी क्षणिक कुंजी
- s = स्थिर कुंजी
- p = संदेश पे लोड

एकबारगी और अनबाउंड सत्र नॉइज़ N पैटर्न के समान हैं।

.. कच्चा:: HTML

  {% हाइलाइट lang='dataspec' %}
<- s
  ...
  e es p ->

{% endhighlight %}

बाउंड सत्र नॉइज़ IK पैटर्न के समान हैं।

.. कच्चा:: HTML

  {% हाइलाइट lang='dataspec' %}
<- s
  ...
  e es s ss p ->
  <- tag e ee se
  <- p
  p ->

{% endhighlight %}


### सत्र

वर्तमान ElGamal/AES+SessionTag प्रोटोकॉल एकदिश है।
इस स्तर पर, प्राप्तकर्ता यह नहीं जानता कि संदेश कहाँ से है।
आउटबाउंड और इनबाउंड सेशन जुड़े नहीं होते हैं।
प्रत्येक बैंड में किए गए त्रिबल डिलीवरीस्टेटस मैसेज का उपयोग करते हुए,
पे लोड का उत्तर आऊट-ऑफ़-बैंड होता है।

एक एकदिश प्रोटोकॉल में महत्वपूर्ण असक्षमता होती है।
कोई भी उत्तर भी एक महंगा 'नया सत्र' संदेश का उपयोग करना चाहिए।
यह उच्च बैंडविथ, सीपीयू, और स्मृति उपयोग का कारण बनता है।

एक एकदिश प्रोटोकॉल में सुरक्षा कमजोरियाँ भी होती हैं।
सभी सेशन अस्थायी-स्थिर DH पर आधारित होते हैं।
रिटर्न पथ के बिना, प्राप्तकर्ता के स्थिर कुंजी के लिए स्थायी कुंजी को पुनर्गणना करने का कोई तरीका नहीं है।
यह ज्ञात किए बगैर कि कोई संदेश कहाँ से है, प्राप्त अस्थायी कुंजी को आउटबाउंड संदेशों के लिए उपयोग करने का कोई तरीका नहीं है,
इसलिए प्रारंभिक उत्तर भी अस्थायी-स्थिर DH का उपयोग करता है।

इस प्रस्ताव के लिए, हम एक द्विदिश प्रोटोकॉल बनाने के लिए दो तंत्रों को परिभाषित करते हैं -
"जोड़ी बनाना" और "जोड़ना"।
ये तंत्र दक्षता और सुरक्षा में वृद्धि प्रदान करते हैं।


सत्र संदर्भ
```````````````

ElGamal/AES+SessionTags के साथ, सभी इनबाउंड और आउटबाउंड सत्र
एक दिए गए संदर्भ में होने चाहिए, चाहे वो राउटर का संदर्भ हो या
विशेष स्थानीय गंतव्य के लिए संदर्भ हो।
जावा I2P में, इस संदर्भ को सत्र कुंजी प्रबंधक कहा जाता है।

सत्रों को संदर्भ के बीच में साझा नहीं किया जाना चाहिए, क्योंकि वह
विभिन्न स्थानीय गंतव्यों के बीच सुसंबंधन की अनुमति देगा,
या एक स्थानीय गंतव्य और एक राउटर के बीच।

जब एक दिए गए गंतव्य हाल के ElGamal/AES+SessionTags
और इस प्रस्ताव को दोनों को समर्थन करता है, तो दोनों प्रकार के सत्र एक संदर्भ साझा कर सकते हैं।
सी खंड 1c) नीचे।"""


सत्र जोड़ी बनाना
`````````````````````````````````````````

जब मूलकर्ता (ऐलिस) पर एक आउटबाउंड सत्र बनाया जाता है,
एक नया इनबाउंड सत्र बनाया जाता है और आउटबाउंड सत्र से जोड़ी बनाई जाती है,
जब तक कोई उत्तर अपेक्षित नहीं होता (उदा. कच्चे डाटाग्राम के मामले में)।

जब एक उत्तर के बिना केवल एक नया इनबाउंड सत्र बनाया जा रहा हो,
सत्र को तत्काल हटा दिया जाता है (उदा. कच्चे डाटाग्राम के मामले में)।

यदि एक उत्तर अनुरोधित किया गया है और दूर-दूर के गंतव्य या राउटर पर बाध्य किया गया है,
उस नए आउटबाउंड सत्र को उस गंतव्य या राउटर तक प्रतिबंधित किया जाएगा,
और किसी भी पिछले आउटबाउंड सत्र को उस गंतव्य या राउटर तक बदल दिया जाएगा।

इनबाउंड और आउटबाउंड सत्र जोड़ी बनाने से एक द्विदिश प्रोटोकॉल प्रदान होता है
जिसमें DH कुंजी को पुनरावर्तित करने की योग्यता है।


सत्र और गंतव्य जोड़ना
````````````````````````````````````

किसी दिए गए गंतव्य या राउटर के लिए केवल एक आउटबाउंड सत्र होता है।
किसी दिए गए गंतव्य या राउटर से कई वर्तमान इनबाउंड सत्र हो सकते हैं।
सामान्यतः, जब एक नया इनबाउंड सत्र बनाया जाता है, और उस सत्र पर ट्रैफ़िक प्राप्त होता है
(जो ACK के रूप में कार्य करता है), तो अन्य सभी इनबाउंड सत्रों को
अन्य सभी इनबाउंड सत्रों को समाप्ति के लिए चिह्नित किया जाएगा,
प्राप्ति के एक मिनट के भीतर। पिछले भेजे गए संदेश मूल्य (PN) को जाँच की जाती है
और यदि पिछले इनबाउंड सत्र में कोई अनपढी संदेश नहीं होते हैं, जो स्वीकार्य न हों तो
पिछला सत्र तुरंत हटाया जा सकता है।


जब एक आउटबाउंड सत्र मूलकर्ता (ऐलिस) पर बनाया जाता है,
यह दूर-दूर के गंतव्य (बॉब) तक जोड़ दिया जाता है,
औरpaired inbound सत्र को भी दूर-दूर गंतव्य तक जोड़ दिया जाता है।
जैसा कि सत्र रैचेट करता है, वे दूर-दूर गंतव्य तक जोड़ जारी रहता है।

जब एक इनबाउंड सत्र प्राप्तकर्ता (बॉब) पर बनाया जाता है,
यह दूर-दूर गंतव्य (ऐलिस) तक जोड़ दिया जा सकता है, ऐलिस की पसंद के अनुसार।
यदि ऐलिस नई सत्र संदेश में बांधने की जानकारी (उसकी स्थिर कुंजी) शामिल करती है,
तो सत्र उस गंतव्य तक जोड़ दिया जाएगा,
और एक आउटबाउंड सत्र बनाया जाएगा और उसी गंतव्य तक जोड़ दिया जाएगा।
जैसा कि सत्र रैचेट करता है, वे दूर-दूर गंतव्य तक जोड़ जारी रहता है।


बाध्य और जोड़ी करने के लाभ
``````````````````````````````

आम, स्ट्रीमिंग मामले के लिए, हम उम्मीद करते हैं कि ऐलिस और बॉब प्रोटोकोल का निम्नलिखित तरीके से उपयोग करें:

- ऐलिस नया आउटबाउंड सत्र जोरी जोड़ने के लिए जोड़ती है
- ऐलिस तुरंत बांधने की जानकारी और हस्ताक्षर को शामिल करती है, और उत्तर अनुरोधित करती है,
  बॉब के पास एक नया आउटबाउंड सत्र जोड़ा जाता है और पहले दिन के गंतव्य (ऐलिस) तक जोड़ दिया जाता है।
- बॉब तुरंत बंद कर देता है और एक नए आउटबाउंड के लिए एक नया आउटबाउंड सत्र प्रसारण करता है, और पहले दिन के गंतव्य (ऐलिस) तक समर्थन करता है।
- बॉब ऐलिस के पास जाने के लिए एक नया सार्वजनिक कुंजी 호출 करता है, जो 'ACK' के रूप में आत्मस्वीकृत करेगा।
- इस सामर्थ्य के होने पर भी हम बॉब के पास कोई नया सार्वजनिक कुंजी नहीं भेजने के लिए प्रतिबंधित करेंगे।
- ऐलिस ऐलिस के साथ कोई नया सार्वजनिक कुंजी नहीं भेजती,
  यदि आवश्यक हो तो हम भी नए सार्वजनिक कुंजी के लिए आत्मस्वीकृति को छोड़ते हैं यदि यह कोई बदलाव नहीं होता है।
- ऐलिस ने बॉब का नया कुंजी भेजना बंद कर दिया है और एक नया त्यागाने योग्य इनबाउंड सत्र संभालने से समस्या हल करता है।
- बॉब ऐलिस के नए आउटबाउंड सत्र को प्रबंधित करता है और केवल उसी के लिए तैयार किए गए स्वयं को केवल नए आउटबाउंड सत्र में बाँधते हुए प्रसंस्करण करता है।
- ऐलिस और बॉब के उत्तर की आवश्यकता होती है यदि कोई भी आवश्यक है तो स्ट्रीमिंग के लिए भेज दिए जाते हैं।


### संदेश ACKs
````````````

ElGamal/AES+SessionTags में, क्लोव में भेजे गए अनुबंध के बाद
या टैग्स डिलीवरी के बाद, भेजे जाने वाला राउटर ACK की अनुज्ञा करता है।
यह टैग्स को क्लोव में पैक एक डिलीवरी स्टेटस संदेश के रूप में होता है।
अधिक सुरक्षा के लिए, डिलीवरी स्टेटस संदेश गार्लिक संदेश में पैक होता है।
इस मैकेनिज्म को प्रोटोकॉल के दृष्टिकोण से ऑफ-बैंड माना जाता है।

नए प्रोटोकॉल में, चूंकि इनबाउंड और आउटबाउंड सत्र जोड़ी बनाए गए हैं,
हम ACKs को इन-बैंड कर सकते हैं। क्लोव पैक की कोई अलग आवश्यकता नहीं है।

एक स्पष्ट ACK केवल एक मौजूदा सत्र संदेश के साथ कोई I2NP ब्लॉक नहीं है।
हालांकि अधिकांश मामलों में, एक स्पष्ट ACK से बचा जा सकता है, क्योंकि वहाँ रिवर्स ट्रैफिक होता है।
यह लागू हो सकता है कि कार्यान्वयन किसी स्पष्ट ACK को भेजने से Wait करें,
क्योंकि स्ट्रीमिंग या आवेदन परत प्रतिक्रिया करने से पहले लागू हो सकता है।

कार्यान्वयन संदेश प्रसंस्करण के बाद किसी भी ACK भेजने में विलंब की आवश्यकता होती है,
क्योंकि गार्लिक संदेश डेटाबेस स्टोर संदेश के साथ ब्लॉग कर सकता है
जिसके लिए हाल का लीज़ सेट आवश्यक हो सकता है, और दूरस्थ गंतव्य (लीज़ सेट में मौजूद),
 बाइंडिंग स्थिर कुंजी को सत्यापित करने के लिए आवश्यक होता है।


### सत्र समय सीमा
````````````````

आउटबाउंड सत्र हमेशा इनबाउंड सत्रों के साथ पहले समाप्त होना चाहिए।
एक आउटबाउंड सत्र समाप्त होने के बाद, और एक नया बनाया जाता है,
एक नया जोड़ित इनबाउंड सत्र भी बनाया जाएगा। यदि पुराना इनबाउंड सत्र था,
तो उसको समाप्ति के लिए अनुमति दी जाएगी।


### मल्टीकास्ट

TBD


### परिभाषाएँ
हम निम्नलिखित कार्यों का सम्मान करते हैं जो क्रिप्टोग्राफिक निर्माण संयोजन भागों के साथ संबंध रखते हैं।

ZEROLEN
    शून्य-लंबाई बाइट सरणी

CSRNG(n)
    n-बाइट का उत्पादन एक क्रिप्टोग्राफिकली-संगत रैंडम नंबर जनरेटर से।

H(p, d)
    SHA-256 हैश फ़ंक्शन जो एक व्यक्तिगतकरण स्ट्रिंग p और डेटा d लेता है, और
    32 बाइट लंबाई की रिटर्न आउटपुट पैदा करता है।
    [NOISE](https://noiseprotocol.org/noise.html) में परिभाषित किया गया है।
    || नीचे का मतलब है जोड़ना।

    SHA-256 को इस्तेमाल करें निम्नलिखित के समान::

        H(p, d) := SHA-256(p || d)

MixHash(d)
    SHA-256 हैश कार्य जो एक पिछले हैश h और नया डेटा d लेता है,
    और 32 बाइट लंबाई का उत्पादन करता है।
    || नीचे का मतलब है जोड़ना।

    SHA-256 को निम्नलिखित के रूप में प्रयोग करें::

        MixHash(d) := h = SHA-256(h || d)

STREAM
    [RFC-7539](https://tools.ietf.org/html/rfc7539) में निर्दिष्ट ChaCha20/Poly1305 AEAD।
    S_KEY_LEN = 32 और S_IV_LEN = 12।

    ENCRYPT(k, n, plaintext, ad)
        सिफर कुंजी k और अद्वितीय नॉन्स n का उपयोग प्रारम्भिक प्रकार (plaintext) के लिए एन्क्रिप्ट करता है।
        संबंधित डेटा ad वैकल्पिक है।
        एक ciphertext वापस करता है जो 16 बाइट के लिए प्लस के लिए प्रारम्भिक प्रकार का आकार है।

        यदि कुंजी गुप्त होती है तो पूरा ciphertext रैंडम से अगोचर होना चाहिए।

    DECRYPT(k, n, ciphertext, ad)
        सिफर कुंजी k और नॉन्स n का उपयोग ciphertext के लिए डिकोड करता है।
        संबंधित डेटा ad वैकल्पिक है।
        प्रारम्भिक प्रकार को वापस करता है।

DH
    X25519 सार्वजनिक कुंजी समझौता प्रणाली। 32 बाइट के निजी कुंजियाँ, 32
    बाइट के सार्वजनिक कुंजियाँ, 32 बाइट का आउटपुट उत्पन्न करता है। इसमें निम्नलिखित कलाकार होते हैं:

    GENERATE_PRIVATE()
        एक नई निजी कुंजी उत्पन्न करता है।

    DERIVE_PUBLIC(privkey)
        दी गई निजी कुंजी के अनुरुप सार्वजनिक कुंजी लौटाता है।

    GENERATE_PRIVATE_ELG2()
        ऐसी सार्वजनिक कुंजी के लिए एक नई निजी कुंजी उत्पन्न करता है जो Elligator2 एन्कोडिंग के लिए उपयुक्त होती है।
        ध्यान दें कि आधे रैंडमली उत्पन्न निजी कुंजियाँ उपयुक्त नहीं होंगी और उन्हें त्यागना होगा।

    ENCODE_ELG2(pubkey)
        दी गई सार्वजनिक कुंजी के अनुरुप एन्कोड की गई Elligator2-एन्कोडेड सार्वजनिक कुंजी लौटाता है (इनवर्स मैपिंग)।
        एन्कोड की गई कुंजियाँ लिटिल एंडियन हैंद।
        एन्कोड की गई कुंजी को 256 बिट्स रैंडम डेटा से अगोचर होना चाहिए।
        विनिर्देश के लिए नीचे देखिए Elligator2 अनुभाग।

    DECODE_ELG2(pubkey)
        दी गई Elligator2-एन्कोडेड सार्वजनिक कुंजी के अनुरुप सार्वजनिक कुंजी लौटाता है।
        विनिर्देश के लिए नीचे देखिए Elligator2 अनुभाग।

    DH(privkey, pubkey)
        दी गई निजी और सार्वजनिक कुंजियों से एक साझा गुप्त तैयार करता है।

HKDF(salt, ikm, info, n)
    एक क्रिप्टोग्राफिक कुंजी व्युत्पत्ति फ़ंक्शन जो कुछ इनपुट कुंजी सामग्री ikm (जिसमें अच्छा एंट्रॉपी होता है लेकिन
    एक समान रैंडम स्ट्रिंग होने की आवश्यकता नहीं होती है), 32 बाइट की लंबाई की एक नमक
    और एक संदर्भ-विशिष्ट 'जानकारी' मूल्य लेता है, और n बाइट का उत्पादन करता है जो
    कुंजी सामग्री के रूप में उपयोग के लिए उपयुक्त होता है।

    [RFC-5869](https://tools.ietf.org/html/rfc5869) में निर्दिष्ट HKDF का उपयोग करें, HMAC हैश फ़ंक्शन SHA-256
    [RFC-2104](https://tools.ietf.org/html/rfc2104) में निर्दिष्ट के रूप में। इसका मतलब है कि SALT_LEN 32 बाइट मैक्स है।

MixKey(d)
    पिछले श्रृंखला कुंजी और नए डेटा d के साथ HKDF() का उपयोग करें, और
    नई श्रृंखला कुंजी और k सेट करता है।
    [NOISE](https://noiseprotocol.org/noise.html) में परिभाषित के अनुसार।

    HKDF का इस तरह प्रयोग करें::

        MixKey(d) := output = HKDF(chainKey, d, "", 64)
                     chainKey = output[0:31]
                     k = output[32:63]



### 1) संदेश प्रारूप


वर्तमान संदेश प्रारूप की समीक्षा
```````````````````````````````````````

[I2NP](/en/docs/spec/i2np/) में निर्दिष्ट गार्लिक संदेश इस प्रकार से है।
एक डिज़ाइन लक्ष्य के रूप में, मध्यस्थ hops नए और पुराने क्रिप्टो को नहीं अलग कर सकते,
यह प्रारूप बदल नहीं सकता, यद्यपि लंबाई फ़ील्ड अतिरक्त है।
पूर्ण 16-बाइट हेडर के साथ प्रारूप दिखाया गया है, यद्यपि
वास्तविक हेडर परिवहन के अनुसार भिन्न हो सकता है।

जब डिक्रिप्ट करें तो डेटा गार्लिक क्लोव्स और अतिरिक्त
डेटा की श्रृंखला होती है, जिसे क्लोव सेट भी कहते हैं।

विवरण और पूर्ण विशिष्टता के लिए [I2NP](/en/docs/spec/i2np/) देखें।


.. कच्चा:: HTML

  {% हाइलाइट lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  | प्रकार |      msg_id       |  समाप्ति
  +----+----+----+----+----+----+----+----+
                           |  आकार   | chks |
  +----+----+----+----+----+----+----+----+
  |      लंबाई       |                   |
  +----+----+----+----+                   +
  |          एन्क्रिप्टेड डेटा               |
  ~                                       ~
  ~                                       ~
  |                                       |
  +----+----+----+----+----+----+----+----+

{% endhighlight %}


एन्क्रिप्टेड डेटा प्रारूप की समीक्षा
````````````````````````````````````

वर्तमान संदेश प्रारूप, जिसका उपयोग 15 से अधिक वर्षों से
किया गया है, वह ElGamal/AES+SessionTags है।
ElGamal/AES+SessionTags में, दो संदेश प्रारूप होते हैं:

1) नए सत्र:
- 514 बाइट ElGamal ब्लॉक
- AES ब्लॉक (128 बाइट न्यूनतम, 16 के गुणज)

2) मौजूदा सत्र:
- 32 बाइट सत्र टैग
- AES ब्लॉक (128 बाइट न्यूनतम, 16 के गुणज)

128 तक पैडिंग न्यूनतम है जैसा कि Javaya I2P में लागू किया गया है लेकिन स्वागत पर लागू नहीं किया गया है।

ये संदेश I2NP गार्लिक संदेश में संसूचिबद्ध होते हैं, जिसमें
एक लंबाई फ़ील्ड शामिल होती है, इसलिए लंबाई ज्ञात होती है।

ध्यान दें कि गैर-मॉड-16 लंबाई के लिए कोई पैडिंग परिभाषित नहीं की गई है,
इसलिए नए सत्र हमेशा (mod 16 == 2) होते हैं,
और एक मौजूदा सत्र हमेशा (mod 16 == 0) होता है।
हमें इसे ठीक करने की आवश्यकता है।

प्राप्तकर्ता पहले पहले 32 बाइट को सत्र टैग के रूप में देखता है।
यदि यह मिला तो, वह AES ब्लॉक को डिक्रिप्ट करता है।
यदि नहीं मिला, और डेटा कम से कम (514+16) लंबा है, वह ElGamal ब्लॉक को डिक्रिप्ट करने का प्रयास करता है,
और यदि सफल होता है, तो AES ब्लॉक को डिक्रिप्ट करता है।


नए सत्र टैग और सिग्नल की तुलना
````````````````````````````````````````

सिग्नल डबल रैचेट में, हैडर में शामिल होते हैं:

- DH: वर्तमान रैचेट सार्वजनिक कुंजी
- PN: पिछली चेन संदेश लंबाई
- N: संदेश नंबर

सिग्नल की "सेंडिंग चेन" लगभग हमारे टैग सेट्स के समरूप होती हैं।
एक सत्र टैग का उपयोग करके, हम इसका सर्वं निकाल सकते हैं।

नए सत्र में, हम हैडर में केवल सार्वजनिक कुंजी रखते हैं।

मौजूदा सत्र में, हम हैडर के लिए एक सत्र टैग का उपयोग करते हैं।
सत्र टैग वर्तमान रैचेट सार्वजनिक कुंजी के साथ जुड़ा होता है,
और संदेश नंबर के साथ।

दोनों नए और मौजूदा सत्र में, PN और N एन्क्रिप्टेड बॉडी में होते हैं।

सिग्नल में, चीजें लगातार रैचेट होती हैं। एक नई DH सार्वजनिक कुंजी प्राप्तकर्ता को रैचेट करने की आवश्यकता होती है और
एक नई सार्वजनिक कुंजी वापस भेजनी होती है, जो प्राप्त की गई सार्वजनिक कुंजी के लिए ACK के रूप में भी कार्य करती है।
यह हमारे लिए बहुत अधिक DH ऑपरेशंस होंगे।
इसलिए हमने प्राप्त कुंजी के ACK को एक नई सार्वजनिक कुंजी के ट्रांसमिशन से अलग कर दिया।
कोई संदेश जो नया DH सार्वजनिक कुंजी के साथ जेनरेट किया गया होता है, ACK के रूप में होता है।
हम एक नई सार्वजनिक कुंजी तब ही ट्रांसमिट करते हैं जब हम पुनर्गणना करना चाहते हैं।

DH को पुनर्गणना करने से पहले संदेशों की अधिकतम संख्या 65535 है।

जब एक सत्र कुंजी डिलीवर की जाती है, हम उस "टैग सेट" से उत्पन्न करते हैं,
बल्कि सत्र टैगस को वितरित करने की आवश्यकता होती है।
एक टैग सेट में अधिकतम 65536 टैग्स हो सकते हैं।
हालांकि, प्राप्तकर्ताओं को "लुक-अहेड" रणनीति लागू करनी चाहिए,
बल्कि सभी संभावित टैग्स एक बार में उत्पन्न करना चाहिए।
अधिकतम N टैग्स उत्पन्न करें पिछले प्राप्त अच्छे टैग से परे।
N सबसे अधिक 128 हो सकता है, लेकिन 32 या उससे भी कम एक बेहतर विकल्प हो सकता है।



### 1a) नए सत्र प्रारूप

नया सत्र एक बार की सार्वजनिक कुंजी (32 बाइट)
एन्क्रिप्टेड डेटा और MAC (शेष बाइट्स)

नया सत्र संदेश भेजने वाले की स्थिर सार्वजनिक कुंजी को शामिल कर सकता है या नहीं कर सकता है।
यदि यह शामिल है, तो रिवर्स सत्र उस कुंजी से बाधित हो जाता है।
स्थिर कुंजी को शामिल करना चाहिए यदि उत्तर अपेक्षित हैं,
उदाहरण के लिए, स्ट्रीमिंग के लिए और उत्तरयोग्य डाटाग्राम के लिए।
यह कच्चे डाटाग्राम के लिए शामिल नहीं किया जाना चाहिए।

नया सत्र संदेश एक-तरफा नॉइज़ [NOISE](https://noiseprotocol.org/noise.html) पैटर्न
"N" (यदि स्थिर कुंजी नहीं भेजी गई है),
या दो-तरफा पैटर्न "IK" (यदि स्थिर कुंजी भेजी गई है) के समान होता है।



### 1b) नए सत्र प्रारूप (बाध्य के साथ)

लंबाई 96 + पे लोड लंबाई है।
एन्क्रिप्टेड प्रारूप:

.. कच्चा:: HTML

  {% हाइलाइट lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   नए सत्र एक बार की सार्वजनिक कुंजी    |
  +             32 बाइट्स                +
  |     Elligator2 के साथ कोडेड           |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +         स्थिर कुंजी                    +
  |       ChaCha20 एन्क्रिप्टेड डेटा     |
  +            32 बाइट्स                +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 संदेश प्रमाणीकरण कोड         |
  +    (MAC) स्थिर कुंजी अनुभाग के लिए       +
  |             16 बाइट्स                |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +            पे लोड अनुभाग               +
  |       ChaCha20 एन्क्रिप्टेड डेटा     |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 संदेश प्रमाणीकरण कोड         |
  +       (MAC) पे लोड अनुभाग के लिए        +
  |             16 बाइट्स                |
  +----+----+----+----+----+----+----+----+

  सार्वजनिक कुंजी: 32 बाइट, लिटिल एंडियन, Elligator2, स्पष्ट पाठ

  स्थिर कुंजी एन्क्रिप्टेड डेटा: 32 बाइट्स

  पे लोड अनुभाग एन्क्रिप्टेड डेटा: शेष डेटा माइनस 16 बाइट्स

  MAC: Poly1305 संदेश प्रमाणीकरण कोड, 16 बाइट्स

{% endhighlight %}


नए सत्र के लिए क्षणिक कुंजी
`````````````````````````
क्षणिक कुंजी 32 बाइट्स की होती है, जिसे Elligator2 से कोडेड किया जाता है।
यह कुंजी कभी पुनः उपयोग नहीं होती; प्रत्येक संदेश के साथ एक नई कुंजी उत्पन्न की जाती है,
जिसमें पुनः ट्रांसमिशन्स शामिल होते हैं।

स्थिर कुंजी
````````````

डिक्रिप्शन पर, ऐलिस की X25519 स्थिर कुंजी, 32 बाइट्स।


पे लोड
```````

एन्क्रिप्टेड लंबाई पूरे डेटा की होती है।
डिक्रिप्शन लंबाई एन्क्रिप्टेड लंबाई से 16 कम होती है।
पे लोड में एक DateTime ब्लॉक शामिल होना चाहिए और आमतौर पर एक या अधिक गार्लिक क्लोव ब्लॉक शामिल होता है।
पे लोड अनुभाग के रूप में प्रारूप और अतिरिक्त आवश्यकताओं के लिए विवरण देखें।



### 1c) नए सत्र प्रारूप (बिना बाध्य के)

यदि कोई उत्तर आवश्यक नहीं है, तो कोई स्थिर कुंजी नहीं भेजी जाती है।


लंबाई 96 + पे लोड लंबाई है।
एन्क्रिप्टेड प्रारूप:

.. कच्चा:: HTML

  {% हाइलाइट lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   नए सत्र एक बार की सार्वजनिक कुंजी    |
  +             32 बाइट्स                +
  |     Elligator2 के साथ कोडेड           |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +           फ़्लैग अनुभाग                +
  |       ChaCha20 एन्क्रिप्टेड डेटा     |
  +            32 बाइट्स                +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 संदेश प्रमाणीकरण कोड         |
  +       (MAC) ऊपर के अनुभाग के लिए        +
  |             16 बाइट्स               |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +            पे लोड अनुभाग               +
  |       ChaCha20 एन्क्रिप्टेड डेटा     |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 संदेश प्रमाणीकरण कोड         |
  +       (MAC) पे लोड अनुभाग के लिए        +
  |             16 बाइट्स                |
  +----+----+----+----+----+----+----+----+

  सार्वजनिक कुंजी: 32 बाइट, लिटिल एंडियन, Elligator2, स्पष्ट पाठ

  फ़्लैग अनुभाग एन्क्रिप्टेड डेटा: 32 बाइट्स

  पे लोड अनुभाग एन्क्रिप्टेड डेटा: शेष डेटा माइनस 16 बाइट्स

  MAC: Poly1305 संदेश प्रमाणीकरण कोड, 16 बाइट्स

{% endhighlight %}

नए सत्र के लिए क्षणिक कुंजी
`````````````````````````

ऐलिस की क्षणिक कुंजी।
क्षणिक कुंजी 32 बाइट्स की होती है, जिसे Elligator2 से कोडेड किया जाता है, लिटिल एंडियन।
हर संदेश के साथ इससे एक नई कुंजी उत्पन्न होती है,
जिसमें पुनः ट्रांसमिशन्स शामिल होते हैं।


फ़्लैग अनुभाग डिक्रिप्टेड डेटा
```````````````````````````````

फ़्लैग अनुभाग में कुछ नहीं होता।
यह हमेशा 32 बाइट्स का होता है, क्योंकि यह स्थिर कुंजी के समान लंबाई होनी चाहिए
नए सत्र संदेशों के लिए बाधित।
बॉब निर्णय लेता है कि यह स्थिर कुंजी है या फ़्लैग अनुभाग
परिक्षण करके कि क्या ये 32 बाइट्स सभी अपार होते हैं।

यहां कोई फ़्लैग आवश्यक है?

पे लोड
```````

एन्क्रिप्टेड लंबाई पूरे डेटा की होती है।
डिक्रिप्शन लंबाई एन्क्रिप्टेड लंबाई से 16 कम होती है।
पे लोड में एक DateTime ब्लॉक शामिल होना चाहिए और आमतौर पर एक या अधिक गार्लिक क्लोव ब्लॉक शामिल होता है।
पे लोड अनुभाग के रूप में प्रारूप और अतिरिक्त आवश्यकताओं का विवरण देखें।




### 1d) वन-टाइम प्रकार (कोई बाध्य या सत्र नहीं)

यदि केवल एक ही संदेश भेजा जाने की उम्मीद है,
कोई सत्र सेटअप या स्थिर कुंजी की आवश्यकता नहीं है।


लंबाई 96 + पे लोड लंबाई है।
एन्क्रिप्टेड प्रारूप:

.. कच्चा:: HTML

  {% हाइलाइट lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |       क्षणिक सार्वजनिक कुंजी            |
  +             32 बाइट्स                +
  |     Elligator2 के साथ कोडेड           |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +           फ़्लैग अनुभाग                +
  |       ChaCha20 एन्क्रिप्टेड डेटा     |
  +            32 बाइट्स                +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 संदेश प्रमाणीकरण कोड         |
  +       (MAC) ऊपर के अनुभाग के लिए        +
  |             16 बाइट्स                |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +            पे लोड अनुभाग               +
  |       ChaCha20 एन्क्रिप्टेड डेटा     |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 संदेश प्रमाणीकरण कोड         |
  +       (MAC) पे लोड अनुभाग के लिए        +
  |             16 बाइट्स                |
  +----+----+----+----+----+----+----+----+

  सार्वजनिक कुंजी: 32 बाइट, लिटिल एंडियन, Elligator2, स्पष्ट पाठ

  फ़्लैग अनुभाग एन्क्रिप्टेड डेटा: 32 बाइट्स

  पे लोड अनुभाग एन्क्रिप्टेड डेटा: शेष डेटा माइनस 16 बाइट्स

  MAC: Poly1305 संदेश प्रमाणीकरण कोड, 16 बाइट्स

{% endhighlight %}


वन-टाइम के लिए नया सत्र की कुंजी
``````````````````````````````````````

वन-टाइम कुंजी 32 बाइट्स की होती है, जिसे Elligator2 से कोडेड किया जाता है, लिटिल एंडियन।
हर संदेश के साथ इससे एक नई कुंजी उत्पन्न होती है,
जिसमें पुनः ट्रांसमिशन्स शामिल होते हैं।


फ़्लैग अनुभाग डिक्रिप्टेड डेटा
````````````````````````````````````

फ़्लैग अनुभाग में कुछ नहीं होता।
यह हमेशा 32 बाइट्स का होता है, क्योंकि यह स्थिर कुंजी के समान लंबाई होनी चाहिए
नए सत्र संदेशों के लिए बाधित।
बॉब निर्णय लेता है कि यह स्थिर कुंजी है या फ़्लैग अनुभाग
परिक्षण करके कि क्या ये 32 बाइट्स सभी अपार होते हैं।

यहां कोई फ़्लैग आवश्यक है?

.. कच्चा:: HTML

  {% हाइलाइट lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                                       |
  +             सभी शून्य                 +
  |              32 बाइट्स                |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+

  zeros:: सभी शून्य, 32 बाइट्स।

{% endhighlight %}


पे लोड
```````

एन्क्रिप्टेड लंबाई पूरे डेटा की होती है।
डिक्रिप्शन लंबाई एन्क्रिप्टेड लंबाई से 16 कम होती है।
पे लोड में एक DateTime ब्लॉक शामिल होना चाहिए और आमतौर पर एक या अधिक गार्लिक क्लोव ब्लॉक शामिल होता है।
पे लोड अनुभाग के रूप में प्रारूप और अतिरिक्त आवश्यकताओं का विवरण देखें।



### 1f) KDFs के लिए नया सत्र संदेश

प्रारंभिक चेन कुंजी के लिए KDF
``````````````````````````````

यह मानक [NOISE](https://noiseprotocol.org/noise.html) है IK के लिए एक संशोधित प्रोटोकॉल नाम के साथ।
ध्यान दें कि हम सभी आउटगोइंग कनेक्शनों के लिए ऐलिस द्वारा पहले से गणना की गई
"IK" पैटर्न के शुरुआती अध्यायक के लिए भी उपयोग करते हैं।

प्रोटोकॉल नाम को संशोधित करने के दो कारण हैं।
पहला, यह संकेत देने के लिए कि क्षणिक कुंजियाँ Elligator2 से कोडेड की गई हैं,
और दूसरा, hsdhs यहाँ पर नदी के लिए "नॉइज़" टैग मूल्य के साथ मिक्स हैश() को मिलाएं।

.. कच्चा:: HTML

  {% हाइलाइट lang='text' %}
  
यह "e" संदेश पैटर्न है:

  // प्रोटोकॉल_नाम को परिभाषित करें।
  सेट प्रोटोकॉल_नाम = "Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256"
   (40 बाइट्स, ASCII एन्कोडेड, बिना नल समाप्ति के)।

  // हैश h को परिभाषित करें (हैश = 32 बाइट)
  h = SHA256(प्रोटोकॉल_नाम);

  Define ck = 32-byte चेनिंग कुंजी। 
  h डेटा को ck में कॉपी करें। 
  चेन कुंजी = h सेट करें

  // MixHash(null prologue)
  h = SHA256(h);

  // यहां तक ​​कि, ऐलिस सभी आउटगोइंग कनेक्शनों के लिए पहले से गणना कर सकती है।

{% endhighlight %}


फ़्लैग्स/स्थिर कुंजी अनुभाग के एन्क्रिप्टेड सामग्री के लिए KDF
`````````````````````````````````````````````````````

.. कच्चा:: HTML

  {% हाइलाइट lang='text' %}

यह "e" संदेश पैटर्न है:

  // बॉब की X25519 स्थिर कुंजियाँ
  // bpk लीज़ सेट में प्रकाशित होता है
  bsk = नई निजी कुंजी उत्पन्न करता है()
  bpk = bsk से सार्वजनिक कुंजी प्राप्त करता है()

  // बॉब स्थिर सार्वजनिक कुंजी
  // MixHash(bpk)
  // || उल्लिखित जोड़ है
  h = SHA256(h || bpk);

  // यहां तक ​​कि, सभी इनकमिंग कनेक्शनों के लिए बॉब द्वारा पहले से गणना किया जा सकता है।

  // ऐलिस की X25519 क्षणिक कुंजियाँ
  aesk = नई निजी कुंजी उत्पन्न करता है()
  aepk = aesk से सार्वजनिक कुंजी प्राप्त करता है()

  // ऐलिस क्षणिक सार्वजनिक कुंजी
  // MixHash(aepk)
  // || उल्लिखित जोड़ है
  h = SHA256(h || aepk);

  // New Session संदेश में AEAD के लिए सहयोगी डेटा के रूप में h का उपयोग किया जाता है।
  // New Session Reply KDF के लिए हैश h को बनाए रखें।
  // eapk New Session संदेश की शुरुआत में स्पष्ट पाठ में भेजा जाता है।
  elg2_aepk = ENCODE_ELG2(aepk)
  // जैसा कि बॉब द्वारा डिकोड जाने के रूप में
  aepk = DECODE_ELG2(elg2_aepk)

  "e" संदेश पैटर्न का अंत।

  यह "es" संदेश पैटर्न है:

  // Noise es
  sharedSecret = DH(aesk, bpk) = DH(bsk, aepk)

  // MixKey(DH())
  //[चेन कुंजी, k] = MixKey(sharedSecret)
  // ChaChaPoly पैरामीटर को एन्क्रिप्ट/डिक्रिप्ट करने के लिए
  keydata = HKDF(chainKey, sharedSecret, "", 64)
  chainKey = keydata[0:31]

  // AEAD पैरामीटर
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, फ्लैग्स/स्थिर कुंजी अनुभाग, ad)

  "es" संदेश पैटर्न का अंत।

  यह "s" संदेश पैटर्न है:

  // MixHash(ciphertext)
  // New Session Reply KDF के लिए सुरक्षित
  h = SHA256(h || ciphertext)

  // ऐलिस की X25519 स्थिर कुंजियाँ
  ask = नई निजी कुंजी उत्पन्न करता है()
  apk = ask से सार्वजनिक कुंजी प्राप्त करता है()

  "s" संदेश पैटर्न का अंत।
  
{% endhighlight %}


पे लोड अनुभाग के लिए KDF (ऐलिस स्थिर कुंजी के साथ)
`````````````````````````````````````````````````

.. कच्चा:: HTML

  {% हाइलाइट lang='text' %}
यह "ss" संदेश पैटर्न है:

  // Noise ss
  sharedSecret = DH(ask, bpk) = DH(bsk, apk)

  // MixKey(DH())
  //[चेन कुंजी, k] = MixKey(sharedSecret)
  // ChaChaPoly पैरामीटर को एन्क्रिप्शन/डिकोड करने के लिए
  // स्थिर कुंजी अनुभाग से चेन कुंजी
  सेट sharedSecret = X25519 DH का परिणाम
  keydata = HKDF(chainKey, sharedSecret, "", 64)
  chainKey = keydata[0:31]

  // AEAD पैरामीटर
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, पे लोड, ad)

  "ss" संदेश पैटर्न का अंत।

  // MixHash(ciphertext)
  // New Session Reply KDF के लिए सुरक्षित
  h = SHA256(h || ciphertext)

{% endhighlight %}


पे लोड अनुभाग के लिए KDF (ऐलिस स्थिर कुंजी के बिना)
````````````````````````````````````````````````````

ध्यान दें कि यह नॉइज़ "N" पैटर्न है, लेकिन हम ऐसे ही "IK" प्रारंभकर्ता का उपयोग करते हैं
जैसा कि बाध्य सत्रों के लिए होता है।

New Session संदेशों की पहचान इसमें शामिल ऐलिस की स्थिर कुंजी के रूप में नहीं की जा सकती है,
जब तक कि स्थिर कुंजी को डिक्रिप्ट नहीं किया जाता और जांचा नहीं जाता कि वे सभी शून्य हैं या नहीं।
इसलिए, सभी New Session संदेशों के लिए रिसीवर को "IK" स्थिति मशीन का उपयोग करना चाहिए।
यदि स्थिर कुंजी सभी शून्य है, तो "ss" संदेश पैटर्न को छोड़ दिया जाना चाहिए।



.. कच्चा:: HTML

  {% हाइलाइट lang='text' %}
चेन कुंजी = फ्लैग्स/स्थिर कुंजी अनुभाग से
  k = फ्लैग्स/स्थिर कुंजी अनुभाग से
  n = 1
  ad = फ्लैग्स/स्थिर कुंजी अनुभाग से h
  ciphertext = ENCRYPT(k, n, पे लोड, ad)

{% endhighlight %}



### 1g) नए सत्र उत्तर प्रारूप

एक ही New Session संदेश के जवाब में एक या अधिक New Session उत्तर भेजे जा सकते हैं।
प्रत्येक उत्तर एक नोट से पहले होता है, जो सत्र के लिए एक TagSet से उत्पन्न होता है।

New Session उत्तर दो भागों में होता है।
पहला भाग नॉइज़ IK हैंडशेक पूरा होता है जो एक टैग के साथ प्रीफिक्स किया गया होता है।
पहला भाग की लंबाई 56 बाइट्स होती है।
दूसरा भाग डेटा चरण पे लोड होता है।
दूसरे भाग की लंबाई 16 + पे लोड लंबाई होती है।

कुल लंबाई 72 + पे लोड लंबाई होती है।
एन्क्रिप्टेड प्रारूप:

.. कच्चा:: HTML

  {% हाइलाइट lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |       सत्र टैग   8 बाइट्स           |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        क्षणिक सार्वजनिक कुंजी           +
  |                                       |
  +            32 बाइट्स                   +
  |     Elligator2 के साथ कोडेड           |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 संदेश प्रमाणीकरण कोड         |
  +  (MAC) के लिए कुंजी अनुभाग (कोई डेटा नहीं) +
  |             16 बाइट्स                  |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +            पे लोड अनुभाग               +
  |       ChaCha20 एन्क्रिप्टेड डेटा     |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 संदेश प्रमाणीकरण कोड         |
  +       (MAC) पे लोड अनुभाग के लिए        +
  |             16 बाइट्स                  |
  +----+----+----+----+----+----+----+----+

  टैग: 8 बाइट्स, स्पष्ट पाठ

  सार्वजनिक कुंजी: 32 बाइट्स, लिटिल एंडियन, Elligator2, स्पष्ट पाठ

  MAC: Poly1305 संदेश प्रमाणीकरण कोड, 16 बाइट्स
         ध्यान दें: ChaCha20 प्लेनटेक्स्ट डेटा खाली है (ZEROLEN)

  पे लोड अनुभाग एन्क्रिप्टेड डेटा: शेष डेटा माइनस 16 बाइट्स

  MAC: Poly1305 संदेश प्रमाणीकरण कोड, 16 बाइट्स

{% endhighlight %}

सत्र टैग
```````````
टैग सत्र के लिए TagSet से उत्पन्न होता है,
जो DH प्रारंभिक KDF से नीचे दिए गए KDF का उपयोग करता है।
चरखी सेशन कुंजी का उपयोग नहीं किया जाता।


नए सत्र उत्तर क्षणिक कुंजी
````````````````````````````````

बॉब की क्षणिक कुंजी।
क्षणिक कुंजी 32 बाइट्स की होती है, जिसे Elligator2 से कोडेड किया जाता है, लिटिल एंडियन।
हर संदेश के साथ इससे एक नई कुंजी उत्पन्न होती है,
जिसमें पुनः ट्रांसमिशन्स शामिल होते हैं।


पे लोड
```````
एन्क्रिप्टेड लंबाई पूरे डेटा की होती है।
डिक्रिप्शन लंबाई एन्क्रिप्टेड लंबाई से 16 कम होती है।
पे लोड में आमतौर पर एक या अधिक गार्लिक क्लोव ब्लॉक शामिल होते हैं।
पे लोड अनुभाग के रूप में प्रारूप और अतिरिक्त आवश्यकताओं का विवरण देखें।


उत्तर TagSet के लिए KDF
`````````````````````

सत्र के लिए TagSet को प्रारंभ करने के लिए, एक या अधिक टैग उत्पन्न किए जाते हैं।
नीचे दिए गए DH प्रारंभिक KDF का उपयोग करते हुए।

.. कच्चा:: HTML

  {% हाइलाइट lang='text' %}
// Generate tagset
  tagsetKey = HKDF(chainKey, ZEROLEN, "SessionReplyTags", 32) 
  tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey)

{% endhighlight %}


उत्तर कुंजी अनुभाग एन्क्रिप्टेड सामग्री के लिए KDF
````````````````````````````````````````````

.. कच्चा:: HTML

  {% हाइलाइट lang='text' %}

नए सत्र संदेश से कुंजी
  // ऐलिस की X25519 कुंजियाँ
  // apk और aepk मूल मास्टर न्यू सत्र संदेश में भेजा गया है
  // ask = ऐलिस निजी स्थिर कुंजी
  // apk = ऐलिस सार्वजनिक स्थिर कुंजी
  // aesk = ऐलिस क्षणिक निजी कुंजी
  // aepk = ऐलिस क्षणिक सार्वजनिक कुंजी
  // बॉब की X25519 स्थिर कुंजियाँ
  // bsk = बॉब निजी स्थिर कुंजी
  // bpk = बॉब सार्वजनिक स्थिर कुंजी

  // टैग उत्पन्न करें
  tagsetEntry = tagset_nsr.GET_NEXT_ENTRY()
  tag = tagsetEntry.SESSION_TAG

  // MixHash(tag)
  h = SHA256(h || tag)

  यह "e" संदेश पैटर्न है:

  // बॉब की X25519 क्षणिक कुंजियाँ
  besk = NEW_PRIVATE_ELG2()
  bepk = DERIVE_PUBLIC(besk)

  // बॉब की क्षणिक सार्वजनिक कुंजी
  // MixHash(bepk)
  // || नीचे जोड़ है
  h = SHA256(h || bepk);

  // elg2_bepk स्पष्ट पाठ में भेजा जाता है
  // नए सत्र संदेश की शुरुआत में
  elg2_bepk = ENCODE_ELG2(bepk)
  // जैसा कि बॉब द्वारा डिकोड जाने के अनुरूप
  bepk = DECODE_ELG2(elg2_bepk)

  "e" संदेश पैटर्न का अंत।

  यह "ee" संदेश पैटर्न है:

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  // ChaChaPoly पैरामीटर को एन्क्रिप्शन/डिकोड करने के लिए
  // मूल New Session Payload Section से चेन कुंजी
  sharedSecret = DH(aesk, bepk) = DH(besk, aepk)
  keydata = HKDF(chainKey, sharedSecret, "", 32)
  chainKey = keydata[0:31]

  "ee" संदेश पैटर्न का अंत।

  यह "se" संदेश पैटर्न है:

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  sharedSecret = DH(ask, bepk) = DH(besk, apk)
  keydata = HKDF(chainKey, sharedSecret, "", 64)
  chainKey = keydata[0:31]

  // AEAD पैरामीटर
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, ZEROLEN, ad)

  "se" संदेश पैटर्न का अंत।

  // MixHash(ciphertext)
  h = SHA256(h || ciphertext)

  chainKey को नीचे दिए गए चेन के रैचेट में उपयोग किया जाता है।

{% endhighlight %}


पे लोड अनुभाग एन्क्रिप्टेड सामग्री के लिए KDF
``````````````````````````````````````````

यह पहले मौजूदा सत्र संदेश के समान है,
पोस्ट-स्प्लिट, लेकिन एक अलग टैग के बिना।
इसके अतिरिक्त, हम Payload को NSR संदेश के लिए हेश से बांधें।


.. कच्चा:: HTML

  {% हाइलाइट lang='text' %}
// split() 
  keydata = HKDF(chainKey, ZEROLEN, "", 64) 
  k_ab = keydata[0:31]
  k_ba = keydata[32:63]
  tagset_ab = DH_INITIALIZE(chainKey, k_ab)
  tagset_ba = DH_INITIALIZE(chainKey, k_ba)

  // एईएडी पैरामीटर के लिए नए सत्र उत्तर पे लोड
  k = HKDF(k_ba, ZEROLEN, "AttachPayloadKDF", 32)
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, पे लोड, ad)

{% endhighlight %}


### नोट्स

प्रत्येक नए सत्र संदेश के जवाब में एक या अधिक अनुरोध भेजे जा सकते हैं, जो अद्वितीय क्षणिक कुंजियों के साथ होते हैं।
प्रत्यक्ष में प्राप्तकर्ता को प्रत्येक NSR संदेश भेजना आवश्यक है।

यह ध्वनि किया जाना चाहिए कि নতুন सत्र संदेशों के लिए किसी भी DH प्लेन की इस्तेमाल की गई श्रृंखला (डेटा) के टैग का मेल करते ही स्थिति को माना जाना चाहिए।

ऐलिस को बॉब के NSR संदेशों में से एक प्राप्त करना चाहिए ताकि मौजूदा सत्र (ES) संदेश भेज सके,
और बॉब को ऐलिस से एक ES संदेश प्राप्त करना चाहिए ताकि ES संदेश भेज सके।

बॉब के NSR Payload Section से chainKey और k को इनपुट के रूप में
मौजूदा सत्रों के लिए DH रैचेट्स के लिए उपयोग किया जा सकता है। ं


{% endif %}


{% highlight lang='text' %}
// सप्लिट() 
  keydata = HKDF(chainKey, ZEROLEN, "", 64) 
  k_ab = keydata[0:31]
  k_ba = keydata[32:63]
  tagset_ab = DH_INITIALIZE(chainKey, k_ab)
  tagset_ba = DH_INITIALIZE(chainKey, k_ba)

  // एईएडी पैरामीटर के लिए नए सत्र उत्तर पे लोड
  k = HKDF(k_ba, ZEROLEN, "AttachPayloadKDF", 32)
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, पे लोड, ad)

{% endhighlight %}


### टिप्पणियाँ

एक या अधिक NSR संदेश भेजे जा सकते हैं जो विभिन्न ऐलिस में प्रेषित किए गए होते हैं।

ऐलिस को बॉब के NSR संदेशों में से एक प्राप्त करना चाहिए ताकि मौजूदा सत्र (ES) संदेश भेज सके,
और बॉब को ऐलिस से एक ES संदेश प्राप्त करना चाहिए ताकि ES संदेश भेज सके।

bob's NSR Payload Section chainKey और k के परिणाम का उपयोग
मौजूदा सत्र DH रैचेट्स (दोनों दिशाओं) के लिए इनपुट के रूप में किया जाता है।
बस उन्हें भेजने वाले ES संदेशों के लिए।


{% endif %}


### 1h) मौजूदा सत्र प्रारूप

सत्र टैग (8 बाइट्स)
एन्क्रिप्टेड डेटा और MAC (प्रकरण 3 में देखें)


प्रारूप
```````
एन्क्रिप्टेड:

.. कच्चा:: HTML

  {% हाइलाइट lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |       सत्र टैग                     |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +            पे लोड अनुभाग               +
  |       ChaCha20 एन्क्रिप्टेड डेटा     |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 संदेश प्रमाणीकरण कोड         |
  +              (MAC)                    +
  |             16 बाइट्स                |
  +----+----+----+----+----+----+----+----+

  सत्र टैग: 8 बाइट्स, स्पष्ट पाठ

  पे लोड अनुभाग एन्क्रिप्टेड डेटा: शेष डेटा माइनस 16 बाइट्स

  MAC: Poly1305 संदेश प्रमाणीकरण कोड, 16 बाइट्स

