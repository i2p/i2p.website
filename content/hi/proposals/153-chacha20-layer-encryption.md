---
title: "ChaCha टनल लेयर एन्क्रिप्शन"
number: "153"
author: "चिसाना"
created: "2019-08-04"
lastupdated: "2019-08-05"
status: "खुला"
thread: "http://zzz.i2p/topics/2753"
toc: true
---

## अवलोकन

यह प्रस्ताव प्रस्ताव 152 के परिवर्तनों पर आधारित है और उसकी आवश्यकता है: ECIES टनल।

केवल वे टनल जो ECIES-X25519 टनल के लिए BuildRequestRecord प्रारूप का समर्थन करने वाले हॉप्स के माध्यम से निर्मित होते हैं, इस विनिर्देशन को लागू कर सकते हैं।

यह विनिर्देशन टनल लेयर एन्क्रिप्शन प्रकार को इंगित करने के लिए टनल बिल्ड विकल्प प्रारूप और लेयर AEAD कुंजियों के प्रसारण की आवश्यकता रखता है।

### उद्देश्य

इस प्रस्ताव के उद्देश्य हैं:

- स्थापित टनल IV और लेयर एन्क्रिप्शन के लिए AES256/ECB+CBC को ChaCha20 से प्रतिस्थापित करना
- अंतर-हॉप AEAD सुरक्षा के लिए ChaCha20-Poly1305 का उपयोग करना
- मौजूदा टनल लेयर एन्क्रिप्शन से गैर-टनल प्रतिभागियों द्वारा पहचान योग्य नहीं होना
- टनल संदेश की कुल लंबाई में कोई परिवर्तन नहीं करना

### स्थापित टनल संदेश प्रसंस्करण

इस अनुभाग में परिवर्तन का वर्णन किया गया है:

- आउटबाउंड और इनबाउंड गेटवे पूर्व-प्रसंस्करण + एन्क्रिप्शन
- प्रतिभागी एन्क्रिप्शन + पश्च-प्रसंस्करण
- आउटबाउंड और इनबाउंड एंडपॉइंट एन्क्रिप्शन + पश्च-प्रसंस्करण

वर्तमान टनल संदेश प्रसंस्करण का अवलोकन पाने के लिए, [Tunnel Implementation](/docs/tunnels/implementation/) स्पेक देखें।

केवल उन राउटर के लिए परिवर्तन चर्चित हैं जो ChaCha20 लेयर एन्क्रिप्शन का समर्थन करते हैं।

AES लेयर एन्क्रिप्शन के साथ मिश्रित टनल के लिए कोई बदलाव नहीं किया गया है, जब तक कि 128 बिट AES IV को 64 बिट ChaCha20 नॉनस में परिवर्तित करने के लिए एक सुरक्षित प्रोटोकॉल तैयार नहीं किया जा सकता।
ब्लूम फिल्टर पूर्ण IV के लिए अद्वितीयता की गारंटी देते हैं, लेकिन अद्वितीय IVs के पहले आधे भाग समान हो सकते हैं।

इसका अर्थ है कि लेयर एन्क्रिप्शन टनल के सभी हॉप्स के लिए समान होना चाहिए और टनल निर्माण प्रक्रिया के दौरान टनल बिल्ड विकल्पों का उपयोग करके स्थापित किया जाना चाहिए।

सभी गेटवे और टनल प्रतिभागियों को दो स्वतंत्र नॉनस के प्रमाणन के लिए एक ब्लूम फिल्टर बनाए रखने की आवश्यकता होगी।

``nonceKey`` प्रस्तावित कुंजी का IVKey स्थान लेता है जिसका उपयोग AES लेयर एन्क्रिप्शन में किया गया था।
इसे प्रस्ताव 152 से एक ही KDF का उपयोग कर उत्पन्न किया गया है।

### हॉप-टू-हॉप संदेशों का AEAD एन्क्रिप्शन

प्रत्येक लगातार हॉप्स के जोड़े के लिए एक अतिरिक्त अद्वितीय ``AEADKey`` उत्पन्न करने की आवश्यकता होगी।
इस कुंजी का उपयोग लगातार हॉप्स द्वारा ChaCha20-Poly1305 एन्क्रिप्ट और डिक्रिप्ट करने के लिए किया जाएगा
आंतरिक ChaCha20 एन्क्रिप्टेड टनल संदेश।

टनल संदेशों को Poly1305 MAC के लिए स्थान समायोजित करने के लिए आंतरिक एन्क्रिप्टेड फ्रेम की लंबाई को 16 बाइट्स घटाना होगा।

AEAD को सीधे संदेशों पर उपयोग नहीं किया जा सकता है, क्योंकि आउटबाउंड टनल्स द्वारा आवर्ती डिक्रिप्शन की आवश्यकता होती है।
आवर्ती डिक्रिप्शन को केवल ChaCha20 का उपयोग करके ही उस तरह से प्राप्त किया जा सकता है, जैसा कि अभी उपयोग किया जा रहा है।

.. raw:: html

  {% highlight lang='dataspec' -%}
+----+----+----+----+----+----+----+----+
  |    टनल आईडी      |   टनल नॉनस     |
  +----+----+----+----+----+----+----+----+
  | टनल नॉनस जारी   |    ऑफब्स नॉनस      |
  +----+----+----+----+----+----+----+----+
  |  ऑफब्स नॉनस जारी  |                   |
  +----+----+----+----+                   +
  |                                        |
  +           एन्क्रिप्टेड डेटा              +
  ~                                        ~
  |                                        |
  +                   +----+----+----+----+
  |                   |    Poly1305 MAC   |
  +----+----+----+----+                   +  
  |                                        |
  +                   +----+----+----+----+
  |                   |
  +----+----+----+----+

  टनल आईडी :: `TunnelId`
         4 बाइट्स
         अगले हॉप का आईडी

  टनल नॉनस ::
         8 बाइट्स
         टनल लेयर नॉनस

  ऑफब्स नॉनस ::
         8 बाइट्स
         टनल लेयर नॉनस एन्क्रिप्शन नॉनस

  एन्क्रिप्टेड डेटा ::
         992 बाइट्स
         एन्क्रिप्टेड टनल संदेश

  Poly1305 MAC ::
         16 बाइट्स

  कुल आकार: 1028 बाइट्स
```

आंतरिक हॉप्स (पूर्ववर्ती और अनुवर्ती हॉप्स के साथ), दो ``AEADKeys`` होंगे, एक पूर्व हॉप का AEAD लेयर डीक्रिप्ट करने के लिए, और अगले हॉप को AEAD लेयर एन्क्रिप्ट करने के लिए।

सभी आंतरिक हॉप प्रतिभागियों के अपने BuildRequestRecords में 64 अतिरिक्त बाइट्स की कुंजी सामग्री शामिल होगी।

आउटबाउंड एंडपॉइंट और इनबाउंड गेटवे को केवल 32 अतिरिक्त बाइट्स की कुंजी जानकारी की आवश्यकता होगी,
क्योंकि वे एक-दूसरे के बीच संदेशों की टनल लेयर एन्क्रिप्ट नहीं करते हैं।

आउटबाउंड गेटवे अपनी ``outAEAD`` कुंजी उत्पन्न करता है, जो पहली
आउटबाउंड हॉप की ``inAEAD`` कुंजी के समान है।

इनबाउंड एंडपॉइंट अपनी ``inAEAD`` कुंजी उत्पन्न करता है, जो अंतिम
इनबाउंड हॉप की ``outAEAD`` कुंजी के समान है।

आंतरिक हॉप्स ``inAEADKey`` और ``outAEADKey`` प्राप्त करेंगे जो लाएगा
आगामी संदेशों को AEAD एन्क्रिप्ट और डिक्रिप्ट करेगा, क्रमशः।

उदाहरण के रूप में, ओबीजीडब्ल्यू, ए, बी, ओबीईपी के साथ एक टनल में:

- ए की ``inAEADKey`` ओबीजीडब्ल्यू की ``outAEADKey`` के समान है
- बी की ``inAEADKey`` ए की ``outAEADKey`` के समान है
- बी की ``outAEADKey`` ओबीईपी की ``inAEADKey`` के समान है

कुंजियाँ हॉप जोड़े के लिए अद्वितीय होती हैं, इसलिए ओबीईपी की ``inAEADKey`` ए की ``inAEADKey`` से अलग होगी,
ए की ``outAEADKey`` बी की ``outAEADKey`` से अलग होगी, आदि।

### गेटवे और टनल निर्माता संदेश प्रसंस्करण

गेटवे संदेशों को वैसे ही टुकड़े-टुकड़े करेंगे और बंडल करेंगे, Poly1305 MAC के लिए निर्देश-फ्रैगमेंट फ्रेम के बाद स्थान आरक्षित करेंगे।

आंतरिक I2NP संदेशों में AEAD फ़्रेम (MAC सहित) को खंडों में विभाजित किया जा सकता है,
लेकिन कोई भी ड्रॉप किए गए खंड एंडपॉइंट पर असफल AEAD डीक्रिप्शन (असफल MAC सत्यापन) के परिणामस्वरूप होंगे।

### गेटवे पूर्व-प्रसंस्करण और एन्क्रिप्शन

जब टनल ChaCha20 लेयर एन्क्रिप्शन का समर्थन करते हैं, तो गेटवे प्रत्येक संदेश सेट के लिए दो 64-बिट नॉनस उत्पन्न करेंगे।

इनबाउंड टनल्स:

- ChaCha20 का उपयोग कर IV और टनल संदेश(ओं) को एन्क्रिप्ट करें
- ``टंलनांनस`` और ``ऑब्फ्सनांनस`` का 8-बाइट का उपयोग करें टनल की जीवनकाल अवधि के अनुसार
- ``टंलनांनस`` के एन्क्रिप्शन के लिए 8-बाइट का ``ऑब्फ्सनांनस`` का उपयोग करें
- टनल का नाश करें 2^(64 - 1) - 1 संदेश सेट के पहले: 2^63 - 1 = 9,223,372,036,854,775,807

  - 64-बिट नॉनस के संभावित समरूपता से बचने के लिए सीमा
  - यह सीमा लगभग कभी भी पहुंची जा सकती है, क्योंकि 10 मिनट की टनल्स के लिए यह लगभग ~15,372,286,728,091,294 संदेश/सेकंड होगा

- अपेक्षित तत्वों की उचित संख्या के आधार पर ब्लूम फ़िल्टर को ट्यून करें (128 संदेश/सेकंड, 1024 संदेश/सेकंड? TBD)

टनल का इनबाउंड गेटवे (आईबीजीडब्ल्यू), दूसरे टनल के आउटबाउंड एंडपॉइंट से प्राप्त संदेशों को प्रसंस्कर करता है।

इस समय, बाहरी संदेश लेयर बिंदु-से-बिंदु ट्रांसपोर्ट एन्क्रिप्शन का उपयोग कर एन्क्रिप्टेड होता है। I2NP संदेश शीर्षकों को, टनल लेयर पर, ओबीईपी और आईबीजीडब्ल्यू द्वारा देखा जा सकता है।
आंतरिक I2NP संदेश लहसुन की लौंग में लिपटे होते हैं, जिसका उपयोग कर एन्क्रिप्शन करते हैं।

आईबीजीडब्ल्यू संदेशों को उपयुक्त रूप से प्रारूपित टनल संदेशों में पूर्व-प्रसंस्करित करता है, और निम्नलिखित के अनुसार एन्क्रिप्ट करता है:

```text

// आईबीजीडब्ल्यू हर नॉनस के विरुद्ध अद्वितीयता के लिए उसके ब्लूम फ़िल्टर में कोई समरूपता नहीं सुनिश्चित करता
  tunnelNonce = Random(len = 64-bits)
  obfsNonce = Random(len = 64-bits)
  // IBGW ChaCha20 प्रत्येक पूर्वप्रसंस्करित टनल संदेश को उसके tunnelNonce और layerKey के साथ "एन्क्रिप्ट" करता है
  encMsg = ChaCha20(msg = tunnel msg, nonce = tunnelNonce, key = layerKey)

  // ChaCha20-Poly1305 प्रत्येक संदेश के एन्क्रिप्टेड डेटा फ्रेम को tunnelNonce और outAEADKey के साथ एन्क्रिप्ट करता है
  (encMsg, MAC) = ChaCha20-Poly1305-Encrypt(msg = encMsg, nonce = tunnelNonce, key = outAEADKey)
```

टनल संदेश प्रारूप थोड़ा बदल जाएगा, 16 बाइट IV के स्थान पर दो 8-बाइट नॉनस का उपयोग कर रहा है।
``ऑब्फ्सनांनस`` का उपयोग एन्क्रिप्टेड ``टंलनांनस`` और हॉप की ``नान्के`` के साथ एन्क्रिप्ट करते हुए 8-बाइट ``टंलनांनस`` पर जोड़ा जाता है।

एक बार संदेश सेट का पूर्व-प्रसंस्करित डीक्रिप्शन प्रत्येक हॉप के लिए किया गया है, आउटबाउंड गेटवे
प्रत्येक टनल संदेश के सिफरटेक्स्ट भाग को ``टंलनांनस`` और इसके ``outAEADKey`` का उपयोग करते हुए ChaCha20-Poly1305 AEAD एन्क्रिप्ट करता है।

आउटबाउंड टनल्स:

- आवर्ती डिक्रिप्ट टनल संदेश
- ChaCha20-Poly1305 एन्क्रिप्ट पूर्व-प्रसंस्करित डिक्रिप्टेड टनल संदेश एन्क्रिप्टेड फ्रेम
- परत नॉनस के लिए वही नियम का प्रयोग करें जैसा कि इनबाउंड टनल्स के लिए होता है
- जनरेट करें यादृच्छिक नॉनस प्रति सेट प्रति टनल संदेश भेजे गए

```text


// प्रत्येक संदेश सेट के लिए, अनूठे, यादृच्छिक नॉनस उत्पन्न करें
  tunnelNonce = Random(len = 64-bits)
  obfsNonce = Random(len = 64-bits)

  // प्रत्येक हॉप के लिए, पिछला tunnelNonce के साथ ChaCha20 वर्तमान हॉप के IV कुंजी का उपयोग करके
  tunnelNonce = ChaCha20(msg = prev. tunnelNonce, nonce = obfsNonce, key = hop's nonceKey)

  // प्रत्येक हॉप के लिए, टनल संदेश को ChaCha20 के साथ डिक्रिप्ट "करें" वर्तमान हॉप के tunnelNonce और layerKey के साथ
  decMsg = ChaCha20(msg = tunnel msg(s), nonce = tunnelNonce, key = hop's layerKey)

  // प्रत्येक हॉप के लिए, ChaCha20 के साथ obfsNonce को "डिक्रिप्ट" करें प्राप्‍त टनल_nonce और हॉप की nonceKey के साथ
  obfsNonce = ChaCha20(msg = obfsNonce, nonce = tunnelNonce, key = hop's nonceKey)

  // हॉप प्रसंस्करण के बाद, प्रत्येक टनल संदेश के "डिक्रिप्टेड" डेटा फ्रेम को टॉन्च करें पहले हॉप की encrypted tunnelNonce और inAEADKey के साथ
  (encMsg, MAC) = ChaCha20-Poly1305-Encrypt(msg = decMsg, nonce = first hop's encrypted tunnelNonce, key = first hop's inAEADKey / GW outAEADKey)
```

### प्रतिभागी प्रसंस्करण

प्रतिभागी देखे गए संदेशों को उसी तरह से ट्रैक करेंगे, विघटित होने वाले ब्लूम फिल्टर का उपयोग करते हुए।

टनल नॉनस में से प्रत्येक को हमले की पुष्टि के रोकथाम के लिए प्रति-हॉप एन्क्रिप्ट करने की आवश्यकता होगी
के द्वारा गैर-अनुगामी, मिलीभगत हॉप्स।

हॉप्स नॉनस को एन्क्रिप्ट करेंगे ताकि पहले और बाद के हॉप्स के बीच पुष्टि के हमलों को रोका जा सके,
यानी, मिलीभगत, गैर-अनुगामी हॉप्स यह बता पाएं कि वे एक ही टनल से संबंधित हैं।

प्राप्त ``टंलनांनस`` और ``ऑब्फ्सनांनस`` की वैधता की पुष्टि करने के लिए, प्रतिभागी प्रत्येक नॉनस को उसकी अनूठता के लिए एकत्रित करते हैं
अपने ब्लूम फिल्टर के विरुद्ध।

सत्यापन के बाद, प्रतिभागी:

- प्रत्येक टनल संदेश के AEAD सिफरटेक्स्ट को प्राप्त ``टंलनांनस`` और इसके ``inAEADKey`` के साथ ChaCha20-Poly1305 डिक्रिप्ट करता है
- प्राप्त ``टंलनांनस`` और ``ऑब्फ्सनांनस`` के साथ अपनी ``नान्के`` का उपयोग कर ``टंलनांनस`` को ChaCha20 एन्क्रिप्ट करता है
- प्राप्त ``टंलनांनस`` और इसकी ``layerKey`` का उपयोग कर प्रत्येक टनल संदेश के एन्क्रिप्टेड डेटा फ्रेम को ChaCha20 एन्क्रिप्ट करता है
- प्राप्त ``टंलनांनस`` और इसकी ``outAEADKey`` का उपयोग कर प्रत्येक टनल संदेश के एन्क्रिप्टेड डेटा फ्रेम को ChaCha20-Poly1305 एन्क्रिप्ट करता है 
- प्राप्त टंलनांनस और इसकी नान्के का उपयोग कर ऑफ़्सनांनस को ChaCha20 एन्क्रिप्ट करता है
- अगले हॉप को युग्म {``nextTunnelId``, एन्क्रिप्टेड (``टंलनांनस`` || ``ऑब्फ्सनांनस``), AEAD सिफरटेक्स्ट || MAC} भेजता है।

```text

// सत्यापन के लिए, टनल हॉप्स को प्राप्त हर नॉनस के अनूठेपन के लिए अपने ब्लूम फ़िल्टर को जांचना चाहिए
  // सत्यापन के बाद, एईएडी फ्रेम(s) को अनरैप करें द्वारा ChaCha20-Poly1305 प्रत्येक टनल संदेश के एन्क्रिप्टेड फ्रेम को डिक्रिप्ट करें
  // प्राप्त tunnelNonce और inAEADKey के साथ 
  encTunMsg = ChaCha20-Poly1305-Decrypt(msg = received encMsg \|\| MAC, nonce = received tunnelNonce, key = inAEADKey)

  // प्राप्त टंलनांनस और नान्के के साथ हॉप के निर्धारण के लिए दिये गये ऑफ़्सनांनस में इसे बिना संदेह में एन्क्रिप्ट करें
  tunnelNonce = ChaCha20(msg = received tunnelNonce, nonce = received obfsNonce, key = nonceKey)

  // एन्क्रिप्ट किये गए टंलनांनस और हॉप के layerKey के साथ हर टनल मैसेज के एन्क्रिप्टेड डेटा फ्रेम को ChaCha20 एन्क्रिप्ट करते हैं
  encMsg = ChaCha20(msg = encTunMsg, nonce = tunnelNonce, key = layerKey)

  // AEAD सुरक्षा के लिए, प्रत्येक संदेश के एन्क्रिप्टेड डेटा फ्रेम को भी ChaCha20-Poly1305 एन्क्रिप्ट करें
  // एन्क्रिप्टेड टंलनांनस और हॉप की outAEADKey के साथ
  (encMsg, MAC) = ChaCha20-Poly1305-Encrypt(msg = encMsg, nonce = tunnelNonce, key = outAEADKey)

  // प्राप्त टंलनांनस और हॉप के nonceKey के साथ प्राप्त ऑफ़्सनांनस को ChaCha20 एन्क्रिप्ट करें
  obfsNonce = ChaCha20(msg = obfsNonce, nonce = tunnelNonce, key = nonceKey)
```

### इनबाउंड एंडपॉइंट प्रसंस्करण

ChaCha20 टनल्स के लिए, निम्नलिखित योजना प्रत्येक टनल संदेश को डिक्रिप्ट करने के लिए उपयोग की जाएगी:

- प्राप्त ``टंलनांनस`` और ``ऑब्फ्सनांनस`` की व्यक्तिगत रूप से उसके ब्लूम फ़िल्टर पर सत्यापित करें
- प्राप्त ``टंलनांनस`` और अपने ``inAEADKey`` का उपयोग करते हुए एन्क्रिप्टेड डेटा फ्रेम को ChaCha20-Poly1305 डिक्रिप्ट करें
- प्राप्त ``टंलनांनस`` और हॉप की ``layerKey`` का उपयोग करते हुए एन्क्रिप्टेड डेटा फ्रेम को ChaCha20 डिक्रिप्ट करें
- हॉप की ``नान्के`` और प्राप्त ``टंलनांनस`` का उपयोग करते हुए ``ऑब्फ्सनांनस`` को ChaCha20 डिक्रिप्ट करें ताकि पिछले ``ऑब्फ्सनांनस`` को प्राप्त किया जा सके
- हॉप की ``नान्के`` और डिक्रिप्टेड ``ऑब्फ्सनांनस`` का उपयोग करके प्राप्त ``टंलनांनस`` को ChaCha20 डिक्रिप्ट करें ताकि पिछले ``टंलनांनस`` को प्राप्त किया जा सके
- डिक्रिप्टेड ``टंलनांनस`` और पिछले हॉप की ``layerKey`` का उपयोग कर एन्क्रिप्टेड डेटा को ChaCha20 डिक्रिप्ट करें
- प्रत्येक हॉप के लिए टनल में नॉनस और लेयर डीक्रिप्शन के लिए चरणों को दोहराएं, वापस आईबीजीडब्ल्यू तक
- AEAD फ्रेम डीक्रिप्शन की आवश्यकता केवल पहले दौर में होती है

```text

// पहले दौर के लिए, प्रत्येक संदेश के एन्क्रिप्टेड डेटा फ्रेम + MAC को ChaCha20-Poly1305 डिक्रिप्ट करें
  // प्राप्त टंलनांनस और inAEADKey का उपयोग करते हुए
  msg = encTunMsg \|\| MAC
  tunnelNonce = प्राप्त टंलनांनस
  encTunMsg = ChaCha20-Poly1305-Decrypt(msg, nonce = tunnelNonce, key = inAEADKey)

  // IBGW से वापस टनल में प्रत्येक हॉप के लिए दोहराएं
  // हर दौर के लिए, ChaCha20 को एन्क्रिप्ट करें हर हॉप की परत एन्क्रिप्शन प्रत्येक संदेश के एन्क्रिप्टेड डेटा फ्रेम
  // प्रत्येक हॉप के लिए प्रत्येक दौर की डिक्रिप्टेड टंलनांनस के साथ प्राप्त टंलनांनस को प्रतिस्थापित करें
  decMsg = ChaCha20(msg = encTunMsg, nonce = tunnelNonce, key = layerKey)
  obfsNonce = ChaCha20(msg = obfsNonce, nonce = tunnelNonce, key = nonceKey)
  tunnelNonce = ChaCha20(msg = tunnelNonce, nonce = obfsNonce, key = nonceKey)
```

### ChaCha20+ChaCha20-Poly1305 टनल लेयर एन्क्रिप्शन के लिए सुरक्षा विश्लेषण

AES256/ECB+AES256/CBC को ChaCha20+ChaCha20-Poly1305 में बदलने के कई फायदे हैं, और नई सुरक्षा प्रक्रियाएं हैं।

सबसे बड़ी सुरक्षा विचार करने के लिए यह है कि ChaCha20 और ChaCha20-Poly1305 के नॉनस प्रति-संदेश अद्वितीय होने चाहिए,
उपयोग की जा रही कुंजी की जीवन अवधि के लिए।

विभिन्न संदेशों पर एक ही कुंजी के साथ अद्वितीय नॉनस का उपयोग करने में विफल होना ChaCha20 और ChaCha20-Poly1305 दोनों को तोड़ देता है।

एक अनुलग्न ``ऑब्फ्सनांनस`` का उपयोग करना IBEP को टनल के हर हॉप की परत एन्क्रिप्शन के लिए ``टंलनांनस`` को डिक्रिप्ट करने की अनुमति देता है,
पहले की नॉनस को पुनः प्राप्त करता है।

``ऑब्फ्सनांनस`` के साथ ``टंलनांनस`` मिलकर टनल हॉप्स को कोई नई जानकारी नहीं प्रदान करता,
क्योंकि ``ऑब्फ्सनांनस`` एन्क्रिप्टेड ``टंलनांनस`` का उपयोग करके एन्क्रिप्ट किया गया है। यह IBEP को ``टंलनांनस`` की तरह ``ऑब्फ्सनांनस`` को पुनः प्राप्त करने की अनुमति देता है।

सबसे बड़ा सुरक्षा लाभ यह है कि ChaCha20 के खिलाफ कोई पुष्टि या ओरेकल हमला नहीं है,
और हॉप्स के बीच ChaCha20-Poly1305 का उपयोग आउट-ऑफ-बैंड मैन-इन-द-मिडल हमलावरों से सिफरटेक्स्ट छेड़छाड़ के खिलाफ AEAD सुरक्षा जोड़ता है।

AES256/ECB + AES256/CBC के खिलाफ व्यावहारिक ओरेकल हमले होते हैं, जब कुंजी का पुन: उपयोग किया जाता है (जैसा कि टनल लेयर एन्क्रिप्शन में होता है)।

AES256/ECB के खिलाफ ओरेकल हमले काम नहीं करेंगे, क्योंकि उपयोग की गई डबल एन्क्रिप्शन और एन्क्रिप्शन में एकल ब्लॉक पर होता है (टनल IV)।

AES256/CBC के खिलाफ पैडिंग ओरेकल हमले काम नहीं करेंगे, क्योंकि कोई पैडिंग उपयोग नहीं की जाती है। यदि टनल संदेश की लंबाई कभी गैर-मॉड-16 लंबाई में बदल दी जाती है, तो भी AES256/CBC असुरक्षित नहीं होगा क्योंकि दोगुनी IV को अस्वीकार कर दिया जाता है।

दोनों हमले भी एक ही IV का उपयोग करके कई oracle कॉल्स की अनुमति नहीं देने से अवरुद्ध होते हैं, क्योंकि दोगुना IV अस्वीकार कर दिए जाते हैं।

## संदर्भ

* [Tunnel-Implementation](/docs/tunnels/implementation/)
