---
title: "प्रदर्शन"
description: "I2P नेटवर्क प्रदर्शन: आज यह कैसे व्यवहार करता है, ऐतिहासिक सुधार, और भविष्य की ट्यूनिंग के लिए विचार"
slug: "performance"
lastUpdated: "2025-10"
accurateFor: "2.10.0"
reviewStatus: "needs-review"
---

## I2P नेटवर्क प्रदर्शन: गति, कनेक्शन और संसाधन प्रबंधन

I2P नेटवर्क पूरी तरह से गतिशील है। प्रत्येक क्लाइंट अन्य नोड्स के लिए जाना जाता है और स्थानीय रूप से ज्ञात नोड्स की पहुंच और क्षमता का परीक्षण करता है। केवल पहुंच योग्य और सक्षम नोड्स को स्थानीय NetDB में सहेजा जाता है। tunnel निर्माण प्रक्रिया के दौरान, इस पूल से सर्वोत्तम संसाधनों का चयन tunnels बनाने के लिए किया जाता है। क्योंकि परीक्षण लगातार होता रहता है, नोड्स का पूल बदलता रहता है। प्रत्येक I2P नोड NetDB के एक अलग हिस्से को जानता है, जिसका अर्थ है कि प्रत्येक router के पास tunnels के लिए उपयोग किए जाने वाले I2P नोड्स का एक अलग सेट होता है। भले ही दो routers के पास ज्ञात नोड्स का एक ही सबसेट हो, पहुंच और क्षमता के परीक्षण संभवतः अलग-अलग परिणाम दिखाएंगे, क्योंकि जब एक router परीक्षण कर रहा हो तो अन्य routers लोड के अधीन हो सकते हैं, लेकिन जब दूसरा router परीक्षण करे तो वे मुक्त हो सकते हैं।

यह वर्णन करता है कि प्रत्येक I2P नोड के पास tunnels बनाने के लिए अलग-अलग नोड क्यों होते हैं। क्योंकि हर I2P नोड की latency और bandwidth अलग होती है, tunnels (जो उन नोड्स के माध्यम से बनाए जाते हैं) की latency और bandwidth values अलग-अलग होती हैं। और क्योंकि हर I2P नोड के पास अलग-अलग tunnels बनाए जाते हैं, किन्हीं भी दो I2P नोड्स के पास समान tunnel sets नहीं होते हैं।

एक सर्वर/क्लाइंट को "destination" के रूप में जाना जाता है और प्रत्येक destination में कम से कम एक inbound और एक outbound tunnel होता है। डिफ़ॉल्ट रूप से प्रति tunnel 3 hops होते हैं। यह एक पूर्ण राउंड ट्रिप client → server → client के लिए कुल 12 hops (12 विभिन्न I2P nodes) बनता है।

प्रत्येक डेटा पैकेज को 6 अन्य I2P nodes के माध्यम से भेजा जाता है जब तक कि वह सर्वर तक नहीं पहुँच जाता:

client - hop1 - hop2 - hop3 - hopa1 - hopa2 - hopa3 - server

और वापसी के रास्ते में 6 अलग-अलग I2P nodes:

server - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - client

नेटवर्क पर ट्रैफिक को नया डेटा भेजने से पहले ACK की आवश्यकता होती है; इसे तब तक इंतजार करना पड़ता है जब तक सर्वर से ACK वापस नहीं आता: डेटा भेजें, ACK का इंतजार करें, अधिक डेटा भेजें, ACK का इंतजार करें। चूंकि RTT (Round Trip Time) प्रत्येक व्यक्तिगत I2P node की latency और इस round trip पर प्रत्येक connection से जुड़ता है, इसलिए आमतौर पर client को ACK वापस आने में 1–3 सेकंड का समय लगता है। TCP और I2P transport डिज़ाइन के कारण, एक data package का आकार सीमित होता है। साथ में ये स्थितियाँ प्रति tunnel अधिकतम bandwidth की सीमा लगभग 20–50 kB/s निर्धारित करती हैं। हालाँकि, यदि tunnel में केवल एक hop के पास खर्च करने के लिए केवल 5 kB/s bandwidth है, तो पूरी tunnel 5 kB/s तक सीमित है, latency और अन्य सीमाओं से स्वतंत्र।

एन्क्रिप्शन, लेटेंसी, और tunnel कैसे बनाया जाता है, यह CPU time के लिहाज से काफी महंगा होता है। इसीलिए एक destination को डेटा ट्रांसपोर्ट करने के लिए अधिकतम 6 inbound और 6 outbound tunnels रखने की अनुमति है। प्रति tunnel अधिकतम 50 kB/s की रफ़्तार से, एक destination लगभग 300 kB/s ट्रैफ़िक (संयुक्त रूप से) उपयोग कर सकता है (वास्तव में यह अधिक हो सकता है यदि कम या बिना anonymity के छोटे tunnels उपयोग किए जाएं)। उपयोग किए गए tunnels हर 10 मिनट में discard कर दिए जाते हैं और नए बनाए जाते हैं। tunnels का यह बदलाव, और कभी-कभी clients जो shutdown हो जाते हैं या network से अपना connection खो देते हैं, कभी-कभी tunnels और connections को तोड़ देंगे। इसका एक उदाहरण IRC2P Network पर connection के नुकसान (ping timeout) में या eepget उपयोग करते समय देखा जा सकता है।

सीमित गंतव्यों के एक सेट और प्रति गंतव्य सीमित tunnels के साथ, एक I2P नोड केवल अन्य I2P नोड्स के पार tunnels के एक सीमित सेट का उपयोग करता है। उदाहरण के लिए, यदि कोई I2P नोड उपरोक्त छोटे उदाहरण में "hop1" है, तो यह केवल क्लाइंट से उत्पन्न होने वाली एक participating tunnel देखता है। यदि हम पूरे I2P नेटवर्क का योग करें, तो केवल सीमित मात्रा में bandwidth के साथ एक सीमित संख्या में participating tunnels बनाई जा सकती हैं। यदि कोई इन सीमित संख्याओं को I2P नोड्स की संख्या में वितरित करता है, तो उपयोग के लिए केवल उपलब्ध bandwidth/क्षमता का एक अंश उपलब्ध होता है।

गुमनाम बने रहने के लिए, पूरे नेटवर्क द्वारा tunnels बनाने के लिए एक router का उपयोग नहीं किया जाना चाहिए। यदि एक router सभी I2P nodes के लिए tunnel router के रूप में कार्य करता है, तो यह विफलता का एक वास्तविक केंद्रीय बिंदु बन जाता है और साथ ही clients से IPs और data एकत्र करने का एक केंद्रीय बिंदु भी बन जाता है। यही कारण है कि नेटवर्क tunnel building प्रक्रिया में nodes के बीच ट्रैफिक वितरित करता है।

प्रदर्शन के लिए एक और विचार वह तरीका है जिससे I2P mesh networking को संभालता है। प्रत्येक कनेक्शन hop-to-hop I2P nodes पर एक TCP या UDP कनेक्शन का उपयोग करता है। 1000 कनेक्शन के साथ, कोई 1000 TCP कनेक्शन देखता है। यह काफी अधिक है, और कुछ घरेलू और छोटे कार्यालय के routers केवल सीमित संख्या में कनेक्शन की अनुमति देते हैं। I2P इन कनेक्शन को प्रति UDP और प्रति TCP प्रकार 1500 से कम रखने का प्रयास करता है। यह एक I2P node के माध्यम से route किए जाने वाले ट्रैफ़िक की मात्रा को भी सीमित करता है।

यदि कोई नोड reachable है, और उसकी bandwidth सेटिंग >128 kB/s shared है और वह 24/7 reachable है, तो कुछ समय बाद उसे participating traffic के लिए उपयोग किया जाना चाहिए। यदि बीच में यह down हो जाता है, तो अन्य नोड्स द्वारा किए गए I2P नोड की testing उन्हें बता देगी कि यह reachable नहीं है। यह अन्य नोड्स पर कम से कम 24 घंटों के लिए एक नोड को block कर देता है। इसलिए, वे अन्य नोड्स जिन्होंने उस नोड को down के रूप में test किया था, वे 24 घंटों तक tunnels बनाने के लिए उस नोड का उपयोग नहीं करेंगे। यही कारण है कि आपके I2P router के restart/shutdown के बाद कम से कम 24 घंटों के लिए आपका traffic कम हो जाता है।

इसके अतिरिक्त, अन्य I2P nodes को किसी I2P router को reachability और capacity के लिए परीक्षण करने के लिए उसे जानना आवश्यक है। यह प्रक्रिया तेज हो सकती है जब आप network के साथ interact करते हैं, उदाहरण के लिए applications का उपयोग करके या I2P sites पर जाकर, जिसके परिणामस्वरूप अधिक tunnel building होगी और इसलिए network पर nodes द्वारा परीक्षण के लिए अधिक activity और reachability होगी।

## प्रदर्शन इतिहास (चयनित)

वर्षों में, I2P में कई उल्लेखनीय प्रदर्शन सुधार देखे गए हैं:

### Native math

GNU MP लाइब्रेरी (GMP) के JNI बाइंडिंग्स के माध्यम से लागू किया गया है ताकि BigInteger `modPow` को तेज़ किया जा सके, जो पहले CPU समय पर हावी था। प्रारंभिक परिणामों ने public‑key cryptography में नाटकीय गति वृद्धि दिखाई। देखें: /misc/jbigi/

### Garlic wrapping a "reply" LeaseSet (tuned)

पहले, जवाबों में अक्सर प्रेषक के LeaseSet के लिए network database lookup की आवश्यकता होती थी। प्रारंभिक garlic में प्रेषक के LeaseSet को बंडल करने से जवाब की latency में सुधार होता है। अब यह चयनात्मक रूप से किया जाता है (कनेक्शन की शुरुआत में या जब LeaseSet बदलता है) ताकि overhead को कम किया जा सके।

### नेटिव गणित

ट्रांसपोर्ट हैंडशेक में कुछ सत्यापन चरणों को पहले स्थानांतरित किया गया है ताकि खराब peers को जल्द अस्वीकार किया जा सके (गलत clocks, खराब NAT/firewall, असंगत संस्करण), जिससे CPU और bandwidth की बचत होती है।

### गार्लिक रैपिंग एक "reply" LeaseSet (tuned)

संदर्भ-जागरूक टनल परीक्षण का उपयोग करें: उन tunnels का परीक्षण करने से बचें जो पहले से ही डेटा पास कर रहे हैं; निष्क्रिय होने पर परीक्षण को प्राथमिकता दें। यह ओवरहेड को कम करता है और विफल tunnels का पता लगाने में तेजी लाता है।

### अधिक कुशल TCP अस्वीकरण

किसी दिए गए कनेक्शन के लिए चयनों को बनाए रखना out-of-order delivery को कम करता है और streaming library को window sizes बढ़ाने की अनुमति देता है, जिससे throughput में सुधार होता है।

### टनल परीक्षण समायोजन

GZip या समान तकनीक verbose structures (जैसे, RouterInfo options) के लिए bandwidth को कम करती है जहाँ उपयुक्त हो।

### स्थायी टनल/lease चयन

सरलीकृत "ministreaming" प्रोटोकॉल का प्रतिस्थापन। आधुनिक streaming में चयनात्मक ACKs और I2P के अनाम, संदेश-उन्मुख सब्सट्रेट के लिए अनुकूलित congestion control शामिल है। देखें: /docs/api/streaming/

## Future Performance Improvements (historical ideas)

नीचे दिए गए विचार ऐतिहासिक रूप से संभावित सुधारों के रूप में प्रलेखित किए गए हैं। कई पुराने हो चुके हैं, लागू किए जा चुके हैं, या आर्किटेक्चरल परिवर्तनों द्वारा प्रतिस्थापित किए जा चुके हैं।

### चयनित डेटा संरचनाओं को संपीड़ित करें

टनल निर्माण के लिए राउटर किस प्रकार peers का चुनाव करते हैं, इसमें सुधार करें ताकि धीमे या अधिक भार वाले peers से बचा जा सके, जबकि शक्तिशाली विरोधियों द्वारा Sybil attacks के प्रति प्रतिरोधी बने रहें।

### पूर्ण स्ट्रीमिंग प्रोटोकॉल

जब keyspace स्थिर हो तो अनावश्यक exploration को कम करें; lookups में कितने peers return किए जाते हैं और कितनी concurrent searches की जाती हैं, इसे tune करें।

### Session Tag tuning and improvements (legacy)

लीगेसी ElGamal/AES+SessionTag स्कीम के लिए, स्मार्ट एक्सपायरेशन और रिप्लेनिशमेंट स्ट्रैटेजी ElGamal फॉलबैक और बर्बाद टैग्स को कम करती हैं।

### बेहतर पीयर प्रोफाइलिंग और चयन

नए सेशन स्थापना के दौरान सीडेड सिंक्रोनाइज़्ड PRNG से टैग जेनरेट करें, जो पहले से डिलीवर किए गए टैग से प्रति‑संदेश ओवरहेड को कम करता है।

### नेटवर्क डेटाबेस ट्यूनिंग

लंबे tunnel लाइफटाइम को healing के साथ मिलाने से rebuild ओवरहेड कम हो सकते हैं; इसे anonymity और reliability के साथ संतुलित करें।

### सत्र टैग ट्यूनिंग और सुधार (लीगेसी)

अमान्य peers को पहले अस्वीकार करें और tunnel परीक्षणों को अधिक context‑aware बनाएं ताकि contention और latency कम हो सके।

### SessionTag को synchronized PRNG में माइग्रेट करें (legacy)

Selective LeaseSet bundling, compressed RouterInfo विकल्प, और पूर्ण streaming प्रोटोकॉल को अपनाने से बेहतर अनुभूत प्रदर्शन में योगदान मिलता है।

---

मानक I2P टनल का उपयोग करते हुए IRC

यह गाइड बताती है कि कैसे standard I2P tunnels का उपयोग करके IRC से कनेक्ट करें।

## आवश्यकताएं

- एक चालू I2P router
- एक IRC client (जैसे HexChat, Irssi, WeeChat)

## सेटअप

1. अपना I2P router शुरू करें और सुनिश्चित करें कि यह चल रहा है
2. I2P router console में जाएं (आमतौर पर `http://127.0.0.1:7657`)
3. "I2PTunnel" section में जाएं
4. पहले से configured IRC tunnels की तलाश करें या एक नया बनाएं

## IRC tunnel बनाना

यदि आपके पास पहले से IRC tunnel नहीं है:

1. I2PTunnel configuration page में "Add New Client Tunnel" पर क्लिक करें
2. Tunnel type के रूप में "IRC Client" चुनें
3. आवश्यक जानकारी भरें:
   - Tunnel name (उदाहरण: "IRC")
   - Local port (उदाहरण: `6668`)
   - Destination (I2P IRC server का पता)
4. Tunnel को save और start करें

## अपने IRC client को configure करना

अपने IRC client में:

1. एक नया server connection बनाएं
2. Server address को `127.0.0.1` पर सेट करें
3. Port को उस port पर सेट करें जो आपने I2PTunnel में configure किया है (उदाहरण: `6668`)
4. SSL/TLS को disable करें (I2P tunnel पहले से ही encrypted है)
5. Server से कनेक्ट करें

## सामान्य I2P IRC servers

- `irc.echelon.i2p` - मुख्य I2P IRC network
- `irc.dg.i2p` - वैकल्पिक I2P IRC network

नोट: ये .i2p addresses हैं जिन्हें आपको I2PTunnel configuration में destination के रूप में उपयोग करना चाहिए।

## समस्या निवारण

यदि आप कनेक्ट नहीं कर पा रहे हैं:

1. जांचें कि आपका I2P router चल रहा है और shared clients को स्वीकार कर रहा है
2. सत्यापित करें कि I2PTunnel चल रहा है और active है
3. सुनिश्चित करें कि आप अपने IRC client में सही port का उपयोग कर रहे हैं
4. I2P router logs में errors की जांच करें
5. सुनिश्चित करें कि destination address सही है और server ऑनलाइन है

यह भी देखें:

- [Tunnel Routing](/docs/overview/tunnel-routing/)
- [Peer Selection](/docs/overview/tunnel-routing/)
- [Transports](/docs/overview/transport/)
- [SSU2 विनिर्देश](/docs/specs/ssu2/) और [NTCP2 विनिर्देश](/docs/specs/ntcp2/)
