---
title: "एप्लिकेशन विकास"
description: "I2P-विशिष्ट ऐप्स क्यों लिखें, मुख्य अवधारणाएं, विकास विकल्प, और एक सरल शुरुआती गाइड"
slug: "applications"
lastUpdated: "2025-10"
accurateFor: "2.10.0"
type: docs
---

## I2P-विशिष्ट कोड क्यों लिखें?

I2P में एप्लिकेशन का उपयोग करने के कई तरीके हैं। [I2PTunnel](/docs/api/i2ptunnel/) का उपयोग करके, आप सामान्य एप्लिकेशन का उपयोग बिना स्पष्ट I2P समर्थन को प्रोग्राम किए कर सकते हैं। यह क्लाइंट-सर्वर परिदृश्यों के लिए बहुत प्रभावी है, जहां आपको किसी एकल वेबसाइट से कनेक्ट करने की आवश्यकता होती है। आप उस वेबसाइट से कनेक्ट करने के लिए I2PTunnel का उपयोग करके एक tunnel बना सकते हैं, जैसा कि चित्र 1 में दिखाया गया है।

यदि आपका एप्लिकेशन वितरित है, तो इसे बड़ी संख्या में peers से कनेक्शन की आवश्यकता होगी। I2PTunnel का उपयोग करते हुए, आपको प्रत्येक peer के लिए एक नई tunnel बनानी होगी जिससे आप संपर्क करना चाहते हैं, जैसा कि चित्र 2 में दिखाया गया है। इस प्रक्रिया को निश्चित रूप से स्वचालित किया जा सकता है, लेकिन बहुत सारे I2PTunnel instances चलाने से बड़ी मात्रा में ओवरहेड उत्पन्न होता है। इसके अलावा, कई प्रोटोकॉल के साथ आपको सभी को सभी peers के लिए पोर्ट्स के एक ही सेट का उपयोग करने के लिए बाध्य करना होगा — उदाहरण के लिए यदि आप विश्वसनीय रूप से DCC चैट चलाना चाहते हैं, तो सभी को सहमत होना होगा कि पोर्ट 10001 Alice है, पोर्ट 10002 Bob है, पोर्ट 10003 Charlie है, और इसी तरह, क्योंकि प्रोटोकॉल में TCP/IP विशिष्ट जानकारी (होस्ट और पोर्ट) शामिल होती है।

सामान्य नेटवर्क एप्लिकेशन अक्सर बहुत सारा अतिरिक्त डेटा भेजते हैं जिसका उपयोग उपयोगकर्ताओं की पहचान करने के लिए किया जा सकता है। होस्टनेम, पोर्ट नंबर, टाइम ज़ोन, कैरेक्टर सेट आदि अक्सर उपयोगकर्ता को सूचित किए बिना भेजे जाते हैं। इस प्रकार, नेटवर्क प्रोटोकॉल को विशेष रूप से गुमनामी को ध्यान में रखते हुए डिज़ाइन करने से उपयोगकर्ता की पहचान से समझौता करने से बचा जा सकता है।

I2P के ऊपर इंटरैक्ट करने के तरीके को निर्धारित करते समय दक्षता संबंधी विचारों की समीक्षा करना भी आवश्यक है। streaming library और उसके ऊपर बनाई गई चीजें TCP के समान handshakes के साथ काम करती हैं, जबकि मुख्य I2P protocols (I2NP और I2CP) पूरी तरह से message आधारित हैं (UDP की तरह या कुछ मामलों में raw IP की तरह)। महत्वपूर्ण अंतर यह है कि I2P के साथ, संचार एक long fat network पर काम कर रहा है — प्रत्येक end to end message में महत्वपूर्ण विलंबताएं होंगी, लेकिन इसमें कई KB तक के payloads हो सकते हैं। एक ऐसे application को जिसे एक सरल request और response की आवश्यकता है, वह किसी भी state से छुटकारा पा सकता है और (best effort) datagrams का उपयोग करके startup और teardown handshakes द्वारा होने वाली विलंबता को कम कर सकता है, बिना MTU detection या messages के fragmentation की चिंता किए।

<figure style="text-align:center; margin: 2rem 0;">
  <img src="/images/i2ptunnel_serverclient.png" alt="Creating a server-client connection using I2PTunnel only requires creating a single tunnel." />
  <figcaption>Figure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel.</figcaption>
</figure>
<figure style="text-align:center; margin: 2rem 0;">
  <img src="/images/i2ptunnel_peertopeer.png" alt="Setting up connections for a peer-to-peer applications requires a very large amount of tunnels." />
  <figcaption>Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels.</figcaption>
</figure>
संक्षेप में, I2P-विशिष्ट कोड लिखने के कई कारण:

- बड़ी संख्या में I2PTunnel instances बनाने से संसाधनों की काफी खपत होती है, जो वितरित अनुप्रयोगों के लिए समस्याग्रस्त है (प्रत्येक peer के लिए एक नई tunnel की आवश्यकता होती है)।
- सामान्य नेटवर्क प्रोटोकॉल अक्सर बहुत अधिक अतिरिक्त डेटा भेजते हैं जिसका उपयोग उपयोगकर्ताओं की पहचान करने के लिए किया जा सकता है। I2P के लिए विशेष रूप से प्रोग्रामिंग करने से एक ऐसा नेटवर्क प्रोटोकॉल बनाया जा सकता है जो ऐसी जानकारी को लीक नहीं करता, उपयोगकर्ताओं को गुमनाम और सुरक्षित रखता है।
- नियमित इंटरनेट पर उपयोग के लिए डिज़ाइन किए गए नेटवर्क प्रोटोकॉल I2P पर अकुशल हो सकते हैं, जो कि बहुत अधिक latency वाला नेटवर्क है।

I2P डेवलपर्स के लिए एक मानक [plugins इंटरफ़ेस](/docs/plugins/) का समर्थन करता है ताकि एप्लिकेशन को आसानी से एकीकृत और वितरित किया जा सके।

Java में लिखे गए और मानक webapps/app.war के माध्यम से HTML इंटरफ़ेस का उपयोग करके सुलभ/चलाने योग्य एप्लिकेशन को I2P वितरण में शामिल करने के लिए विचार किया जा सकता है।

## महत्वपूर्ण अवधारणाएं

I2P का उपयोग करते समय कुछ बदलाव हैं जिनके लिए समायोजन की आवश्यकता होती है:

### गंतव्य

I2P पर चलने वाला एक एप्लिकेशन एक अद्वितीय क्रिप्टोग्राफिक रूप से सुरक्षित अंतिम बिंदु — एक "destination" से संदेश भेजता है और प्राप्त करता है। TCP या UDP के संदर्भ में, एक destination को (मुख्यतः) hostname और port number की जोड़ी के समकक्ष माना जा सकता है, हालांकि कुछ अंतर हैं।

- एक I2P destination स्वयं एक क्रिप्टोग्राफिक संरचना है — इसे भेजा गया सभी डेटा एन्क्रिप्टेड होता है मानो IPsec की सार्वभौमिक तैनाती हो, जिसमें अंतिम बिंदु का (गुमनाम) स्थान हस्ताक्षरित होता है मानो DNSSEC की सार्वभौमिक तैनाती हो।
- I2P destinations मोबाइल पहचानकर्ता हैं — इन्हें एक I2P router से दूसरे में स्थानांतरित किया जा सकता है (या यह "मल्टीहोम" भी हो सकता है — एक साथ कई routers पर संचालित हो सकता है)। यह TCP या UDP की दुनिया से काफी अलग है जहां एक एकल अंतिम बिंदु (पोर्ट) को एक ही होस्ट पर रहना होता है।
- I2P destinations भद्दे और बड़े होते हैं — पर्दे के पीछे, इनमें एन्क्रिप्शन के लिए एक 2048 बिट ElGamal सार्वजनिक कुंजी, हस्ताक्षर के लिए एक 1024 बिट DSA सार्वजनिक कुंजी, और एक परिवर्तनशील आकार का प्रमाणपत्र होता है, जिसमें proof of work या ब्लाइंडेड डेटा हो सकता है।

इन बड़े और जटिल destinations को छोटे और सुंदर नामों (जैसे "irc.duck.i2p") से संदर्भित करने के मौजूदा तरीके हैं, लेकिन वे तकनीकें वैश्विक रूप से विशिष्टता की गारंटी नहीं देती हैं (क्योंकि वे प्रत्येक व्यक्ति की मशीन पर स्थानीय रूप से एक डेटाबेस में संग्रहीत होते हैं) और वर्तमान तंत्र विशेष रूप से स्केलेबल या सुरक्षित नहीं है (होस्ट सूची के अपडेट को नामकरण सेवाओं की "सदस्यताओं" का उपयोग करके प्रबंधित किया जाता है)। भविष्य में कोई सुरक्षित, मानव-पठनीय, स्केलेबल और वैश्विक रूप से विशिष्ट नामकरण प्रणाली हो सकती है, लेकिन अनुप्रयोगों को इसके लागू होने पर निर्भर नहीं होना चाहिए। नामकरण प्रणाली पर [अधिक जानकारी](/docs/overview/naming/) उपलब्ध है।

जबकि अधिकांश एप्लिकेशन को प्रोटोकॉल और पोर्ट्स में अंतर करने की आवश्यकता नहीं होती है, I2P इन्हें *समर्थन* करता है। जटिल एप्लिकेशन प्रति-संदेश के आधार पर एक प्रोटोकॉल, from port, और to port निर्दिष्ट कर सकते हैं, ताकि एकल destination पर ट्रैफ़िक को multiplex किया जा सके। विवरण के लिए [datagram page](/docs/api/datagrams/) देखें। सरल एप्लिकेशन एक destination के "सभी प्रोटोकॉल" पर "सभी पोर्ट्स" को सुनकर काम करते हैं।

### गुमनामी और गोपनीयता

I2P में नेटवर्क पर भेजे गए सभी डेटा के लिए पारदर्शी एंड-टू-एंड एन्क्रिप्शन और प्रमाणीकरण है — यदि Bob, Alice के destination को भेजता है, तो केवल Alice का destination ही इसे प्राप्त कर सकता है, और यदि Bob datagrams या streaming लाइब्रेरी का उपयोग कर रहा है, तो Alice निश्चित रूप से जानती है कि Bob का destination ही वह है जिसने डेटा भेजा है।

निःसंदेह, I2P एलिस और बॉब के बीच भेजे गए डेटा को पारदर्शी रूप से गुमनाम बनाता है, लेकिन यह उनके द्वारा भेजी गई सामग्री को गुमनाम बनाने के लिए कुछ नहीं करता। उदाहरण के लिए, यदि एलिस बॉब को अपने पूरे नाम, सरकारी पहचान पत्र और क्रेडिट कार्ड नंबर वाला एक फॉर्म भेजती है, तो I2P कुछ नहीं कर सकता। इस प्रकार, प्रोटोकॉल और एप्लिकेशन को यह ध्यान में रखना चाहिए कि वे किस जानकारी को सुरक्षित करने का प्रयास कर रहे हैं और किस जानकारी को उजागर करने के लिए तैयार हैं।

### I2P डेटाग्राम कई KB तक हो सकते हैं

I2P datagrams का उपयोग करने वाले एप्लिकेशन (चाहे raw हों या repliable) को मूल रूप से UDP के संदर्भ में समझा जा सकता है — datagrams अव्यवस्थित, सर्वोत्तम प्रयास, और connectionless होते हैं — लेकिन UDP के विपरीत, एप्लिकेशन को MTU detection की चिंता करने की आवश्यकता नहीं है और वे बड़े datagrams को सीधे भेज सकते हैं। जबकि ऊपरी सीमा नाममात्र रूप से 32 KB है, संदेश को परिवहन के लिए खंडित किया जाता है, इस प्रकार संपूर्ण की विश्वसनीयता कम हो जाती है। वर्तमान में लगभग 10 KB से अधिक के datagrams की अनुशंसा नहीं की जाती है। विवरण के लिए [datagram page](/docs/api/datagrams/) देखें। कई एप्लिकेशन के लिए, 10 KB डेटा एक संपूर्ण अनुरोध या प्रतिक्रिया के लिए पर्याप्त है, जो उन्हें I2P में UDP-जैसे एप्लिकेशन के रूप में पारदर्शी रूप से संचालित करने की अनुमति देता है बिना fragmentation, resends, आदि लिखने की आवश्यकता के।

## विकास विकल्प

I2P पर डेटा भेजने के कई तरीके हैं, प्रत्येक के अपने फायदे और नुकसान हैं। streaming lib अनुशंसित इंटरफ़ेस है, जिसका उपयोग अधिकांश I2P अनुप्रयोगों द्वारा किया जाता है।

### स्ट्रीमिंग लाइब

[पूर्ण streaming लाइब्रेरी](/docs/specs/streaming/) अब मानक इंटरफ़ेस है। यह TCP-जैसे सockets का उपयोग करके प्रोग्रामिंग की अनुमति देता है, जैसा कि [Streaming विकास गाइड](#developing-with-the-streaming-library) में समझाया गया है।

### BOB

BOB [Basic Open Bridge](/docs/legacy/bob/) है, जो किसी भी भाषा में एप्लिकेशन को I2P से और I2P की ओर streaming connections बनाने की अनुमति देता है। इस समय इसमें UDP समर्थन की कमी है, लेकिन निकट भविष्य में UDP समर्थन की योजना है। BOB में कई उपकरण भी शामिल हैं, जैसे destination key generation, और यह सत्यापन कि कोई address I2P specifications के अनुरूप है। अद्यतन जानकारी और BOB का उपयोग करने वाले एप्लिकेशन इस [I2P Site](http://bob.i2p/) पर मिल सकते हैं।

### SAM, SAM V2, SAM V3

*SAM अनुशंसित नहीं है। SAM V2 ठीक है, SAM V3 अनुशंसित है।*

SAM [Simple Anonymous Messaging](/docs/legacy/sam/) प्रोटोकॉल है, जो किसी भी भाषा में लिखे गए एप्लिकेशन को एक सामान्य TCP सॉकेट के माध्यम से SAM bridge से संवाद करने की अनुमति देता है और वह bridge इसके सभी I2P ट्रैफ़िक को multiplex करता है, encryption/decryption और event आधारित handling को पारदर्शी रूप से समन्वयित करता है। SAM तीन प्रकार के संचालन का समर्थन करता है:

- streams, जब Alice और Bob एक-दूसरे को विश्वसनीय रूप से और क्रम में डेटा भेजना चाहते हैं
- repliable datagrams, जब Alice Bob को एक संदेश भेजना चाहती है जिसका Bob जवाब दे सके
- raw datagrams, जब Alice अधिकतम बैंडविड्थ और प्रदर्शन प्राप्त करना चाहती है, और Bob को इस बात की परवाह नहीं है कि डेटा का प्रेषक प्रमाणित है या नहीं (जैसे स्थानांतरित डेटा स्वयं-प्रमाणित है)

SAM V3 का लक्ष्य SAM और SAM V2 के समान है, लेकिन इसमें multiplexing/demultiplexing की आवश्यकता नहीं होती है। प्रत्येक I2P stream को एप्लिकेशन और SAM bridge के बीच अपने स्वयं के socket द्वारा संभाला जाता है। इसके अलावा, SAM bridge के साथ datagram संचार के माध्यम से एप्लिकेशन द्वारा datagram भेजे और प्राप्त किए जा सकते हैं।

[SAM V2](/docs/legacy/samv2/) एक नया संस्करण है जिसका उपयोग imule द्वारा किया जाता है और जो [SAM](/docs/legacy/sam/) की कुछ समस्याओं को ठीक करता है।

[SAM V3](/docs/api/samv3/) का उपयोग imule द्वारा संस्करण 1.4.0 से किया जाता है।

### I2PTunnel

I2PTunnel एप्लिकेशन अनुप्रयोगों को विशिष्ट TCP-जैसी tunnels बनाने की अनुमति देता है जो peers से जुड़ती हैं, या तो I2PTunnel 'client' एप्लिकेशन बनाकर (जो एक विशिष्ट पोर्ट पर सुनते हैं और जब भी उस पोर्ट पर कोई सॉकेट खुलता है तो एक विशिष्ट I2P destination से कनेक्ट होते हैं) या I2PTunnel 'server' एप्लिकेशन बनाकर (जो एक विशिष्ट I2P destination को सुनते हैं और जब भी उसे नया I2P कनेक्शन मिलता है तो यह एक विशिष्ट TCP host/port पर outproxy करता है)। ये streams 8-bit clean हैं, और उसी streaming library के माध्यम से प्रमाणित और सुरक्षित हैं जिसका SAM उपयोग करता है, लेकिन कई अद्वितीय I2PTunnel instances बनाने में एक महत्वपूर्ण ओवरहेड शामिल है, क्योंकि प्रत्येक का अपना अद्वितीय I2P destination और अपना tunnels, keys आदि का सेट होता है।

### SOCKS

I2P एक SOCKS V4 और V5 proxy का समर्थन करता है। आउटबाउंड कनेक्शन अच्छी तरह से काम करते हैं। इनबाउंड (server) और UDP कार्यक्षमता अधूरी और परीक्षण रहित हो सकती है।

### Ministreaming

*हटाया गया*

पहले एक सरल "ministreaming" library थी, लेकिन अब ministreaming.jar में केवल पूर्ण streaming library के लिए interfaces हैं।

### डेटाग्राम

*UDP-जैसे अनुप्रयोगों के लिए अनुशंसित*

[Datagram library](/docs/api/datagrams/) UDP-जैसे पैकेट भेजने की अनुमति देता है। इसका उपयोग करना संभव है:

- उत्तर देने योग्य डेटाग्राम
- कच्चे डेटाग्राम

### I2CP

*अनुशंसित नहीं*

[I2CP](/docs/specs/i2cp/) स्वयं एक भाषा स्वतंत्र प्रोटोकॉल है, लेकिन Java के अलावा किसी अन्य भाषा में I2CP लाइब्रेरी को लागू करने के लिए काफी मात्रा में कोड लिखना पड़ता है (encryption रूटीन, object marshalling, asynchronous message handling, आदि)। हालांकि कोई व्यक्ति C या किसी अन्य भाषा में I2CP लाइब्रेरी लिख सकता है, फिर भी इसके बजाय C SAM लाइब्रेरी का उपयोग करना अधिक उपयोगी होगा।

### वेब अनुप्रयोग

I2P, Jetty webserver के साथ आता है, और इसके बजाय Apache server का उपयोग करने के लिए कॉन्फ़िगर करना सरल है। कोई भी मानक वेब ऐप तकनीक काम करनी चाहिए।

## विकास शुरू करें — एक सरल मार्गदर्शिका

I2P का उपयोग करके विकास करने के लिए एक कार्यशील I2P इंस्टॉलेशन और आपकी अपनी पसंद का एक विकास वातावरण आवश्यक है। यदि आप Java का उपयोग कर रहे हैं, तो आप [streaming library](#developing-with-the-streaming-library) या datagram library के साथ विकास शुरू कर सकते हैं। किसी अन्य प्रोग्रामिंग भाषा का उपयोग करते समय, SAM या BOB का उपयोग किया जा सकता है।

### स्ट्रीमिंग लाइब्रेरी के साथ विकास करना

नीचे मूल पृष्ठ में दिए गए उदाहरण का एक संक्षिप्त और आधुनिक संस्करण है। पूर्ण उदाहरण के लिए, legacy पृष्ठ या codebase में हमारे Java उदाहरण देखें।

```java
// Server example (excerpt)
I2PSocketManager manager = I2PSocketManagerFactory.createManager();
I2PServerSocket server = manager.getServerSocket();
I2PSocket socket = server.accept();
BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
String s;
while ((s = br.readLine()) != null) {
    System.out.println("Received: " + s);
}
```
*कोड उदाहरण: डेटा प्राप्त करने वाला बुनियादी सर्वर।*

```java
// Client example (excerpt)
I2PSocketManager manager = I2PSocketManagerFactory.createManager();
Destination dest = new Destination(serverDestBase64);
I2PSocket socket = manager.connect(dest);
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
bw.write("Hello I2P!\n");
bw.flush();
```
*कोड उदाहरण: क्लाइंट कनेक्ट करना और एक लाइन भेजना।*
