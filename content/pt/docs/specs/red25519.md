---
title: "Esquema de assinatura Red25519"
description: "Esquema de assinatura re-aleatorizável para a criação de Destinos cegos"
slug: "red25519"
lastUpdated: "2025-10"
accurateFor: "2.10.0"
---

## Visão geral

Este documento especifica um esquema de assinatura re-randomizável, adequado para criar Destinations (endereços de destino do I2P) que podem ser cegados. Além disso, pode ser usado para cegar Destinations Ed25519 existentes, com uma ligeira redução de eficácia.

Red25519 tem estado totalmente operacional em I2P routers desde a versão 0.9.39 (lançada em 21 de março de 2019). Esta especificação foi finalizada na versão 0.9.47 (agosto de 2020) após 17 meses de implantação em produção. O esquema de assinatura opera como o tipo de assinatura 11 (RedDSA_SHA512_Ed25519) na rede I2P.

## Motivação

A Proposta 123 (Novas entradas no netDB) define um formato de LeaseSet2 criptografado que incorpora o Princípio da Menor Autoridade: cada participante da rede recebe apenas as informações necessárias para sua função. Em particular, um LeaseSet2 criptografado publicado em um floodfill não revela o Destino ao qual se destina, e as Leases (registros temporários de túnel) só podem ser visualizadas por alguém com conhecimento prévio do Destino. No entanto, os floodfills ainda precisam ser capazes de autenticar os LeaseSet2 criptografados quando são publicados, e os clientes precisam, adicionalmente, garantir que a autenticação foi aplicada pelo próprio Destino.

A Proposta 123 realiza isso aplicando cegamento às chaves de assinatura de Destinations (identidade/endereço de serviço no I2P). As chaves cegadas podem ser usadas para criar assinaturas verificáveis pelos floodfills, e os clientes podem ter certeza de que somente a Destination poderia ter criado as assinaturas. Portanto, é necessário especificar um esquema de assinatura que possa ser usado para cegamento.

**Nota sobre o status da Proposta 123**: Partes da Proposta 123 foram implementadas e implantadas progressivamente desde a versão 0.9.38, com suporte a Red25519 adicionado na 0.9.39. A funcionalidade de LeaseSet2 criptografado está pronta para produção e é usada ativamente na rede I2P para serviços ocultos com privacidade aprimorada.

## Projeto

### Esquema de assinatura principal

O esquema de assinatura especificado aqui, Red25519, é uma instanciação de RedDSA conforme definido na Seção 5.4.6 da Especificação do Protocolo Zcash (Sapling e posteriores). RedDSA é um esquema de assinatura baseado em Schnorr que suporta re-randomização de chaves. Ele possui as seguintes funções:

**GENERATE_PRIVATE()** : Retorna uma chave privada aleatória com distribuição uniforme.

**DERIVE_PUBLIC(sk)** : Retorna a chave pública correspondente à chave privada fornecida.

**GENERATE_RANDOM()** : Retorna um escalar aleatório adequado para re-randomizar um par de chaves.

**RANDOMIZE_PRIVATE(sk, alpha)** : Aleatoriza novamente uma chave privada, usando um escalar secreto alpha.

**RANDOMIZE_PUBLIC(vk, alpha)** : Re-randomiza uma chave pública, usando um escalar secreto alpha.

**SIGN(sk, m)** : Retorna uma assinatura com a chave privada sk sobre a mensagem m fornecida.

**VERIFY(vk, m, sig)** : Verifica a assinatura sig com base na chave pública vk e na mensagem m. Retorna verdadeiro se a assinatura for válida, falso caso contrário.

Para um dado par de chaves (sk, vk), verifica-se a seguinte relação:

```
RANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha))
```
### Convertendo chaves Ed25519 para Red25519

As chaves Ed25519 PODEM ser convertidas, de forma transitória e unidirecional, em chaves Red25519, a fim de suportar a rerandomização de Destinos Ed25519 existentes. Outros tipos de assinatura não são compatíveis.

Definimos as seguintes funções de conversão:

**CONVERT_ED25519_PRIVATE(privkey)** : Retorna a chave privada Red25519 (forma derivada de Ed25519) correspondente à chave privada Ed25519 fornecida.

**CONVERT_ED25519_PUBLIC(pubkey)** : Retorna a chave pública Red25519 correspondente à chave pública Ed25519 fornecida.

Para um determinado par de chaves Ed25519 (algoritmo de assinatura digital de curva elíptica) (privkey, pubkey), verifica-se a seguinte relação:

```
CONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey))
```
## Especificação

### Definições

**B** : O ponto base do Ed25519 conforme definido no [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html).

**L** : A ordem de Ed25519 é 2^252 + 27742317777372353535851937790883648493, como no [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html).

**[s] B** : Multiplicação escalar de base fixa do ponto base por s.

**[s] A** : Multiplicação escalar de base variável de A por s.

**x || y** : Concatenar dois arrays de bytes x e y.

### Red25519 (algoritmo de assinatura digital baseado em Ed25519 utilizado no I2P)

O esquema Red25519 especializa o RedDSA com:

- G := o grupo de pontos na forma de Edwards da Curve25519. Em particular, isso significa que a Red25519 usa o subgrupo de ordem L (sendo L primo), e o cofator h_G é 8.
- P_G := o ponto base B da Ed25519.
- l_H := 512
- H(x) := SHA-512("I2P_Red25519H(x)" || x)

**Nota sobre a escolha da função de hash**: Red25519 usa SHA-512 em vez de BLAKE2b-512 (como usado em Zcash RedDSA). Essa escolha de design é compensada pela proteção por prefixação de comprimento descrita abaixo. I2P Proposal 148 sugere uma migração futura para BLAKE2b-512 para oferecer proteção aprimorada contra identificação de mensagens duplicadas (DMI) e ataques de extensão de comprimento (LEA), além de desempenho aprimorado.

RedDSA pressupõe que H(x) é instanciada com uma função hash criptográfica que é segura contra ataques de extensão de comprimento. SHA-512 não satisfaz isso por si só. Para corrigir isso, exigimos que as mensagens sejam precedidas por uma codificação livre de prefixo do seu comprimento:

```
len_u16(M) || M
```
onde `len_u16(M)` é a representação de 2 bytes do comprimento de M, em little-endian (para ser consistente com a codificação little-endian de escalares e pontos).

As mensagens não devem exceder 65534 bytes. Um tamanho de 65535 está reservado para possíveis extensões futuras.

**Nota de Segurança**: A inclusão da chave pública (vk) na função de hash, combinada com 80 bytes aleatórios na assinatura, garante proteção contra vulnerabilidades de SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack — inforgeabilidade forte com chaves re-randomizadas sob ataque de mensagem escolhida) descobertas em projetos iniciais do RedDSA. Esta implementação incorpora as correções de segurança da auditoria do NCC Group sobre o Zcash (Achado NCC-Zcash2018-009).

### Codificação e decodificação

As chaves privadas Red25519 são escalares mod L, codificadas na representação little-endian (ordem de bytes do menos significativo para o mais significativo). Definimos as funções `DECODE_SCALAR` e `ENCODE_SCALAR` para converter entre o array de bytes e a forma inteira de um escalar.

As chaves públicas Red25519 são pontos na forma de Edwards da Curve25519. Elas são codificadas como a representação little-endian de 255 bits da coordenada y, seguida por um único bit indicando o sinal da coordenada x. É a mesma codificação usada em Ed25519. Definimos as funções `DECODE_POINT` e `ENCODE_POINT` para converter entre o array de bytes e a forma em coordenadas de um ponto.

### Funções do RedDSA

Para facilitar a implementação, apresentamos explicitamente abaixo as funções RedDSA (bem como várias funções auxiliares) já especializadas para Red25519. Os implementadores devem consultar a seção 5.4.6 da Zcash Protocol Specification para a especificação geral das funções RedDSA.

```
HStar(prefix1, prefix2, m) :=
    h = SHA-512()
    h.input("I2P_Red25519H(x)")
    h.input(prefix1)
    h.input(prefix2)

    h.input(len(m) & 0xff)
    h.input((len(m) >> 8) & 0xff)
    h.input(m)

    s = h.digest()
    return s mod L

GENERATE_PRIVATE :=
    s = 64 random bytes
    return s mod L

DERIVE_PUBLIC(sk) := [sk] B

GENERATE_RANDOM :=
    s = 64 random bytes
    return s mod L

RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L

RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B

SIGN(sk, m) :=
    T = 80 random bytes
    vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk))
    r = HStar(T, vkBytes, m)

    R = [r] B
    Rbytes = ENCODE_POINT(R)

    c = HStar(Rbytes, vkBytes, m)
    S = (r + (c * sk)) mod L

    return Rbytes || ENCODE_SCALAR(S)

VERIFY(vk, m, sig) :=
    Rbytes = sig[0..32]
    Sbytes = sig[32..64]

    R = DECODE_POINT(Rbytes)
    if R is invalid:
        return false

    S = DECODE_SCALAR(Sbytes)
    if S >= L:
        return false

    vkBytes = ENCODE_POINT(vk)
    c = HStar(Rbytes, vkBytes, m)
    return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity()
```
### Funções de conversão

```
CONVERT_ED25519_PRIVATE(privkey) :=
    s = SHA-512(privkey)[0..32]
    s[0] = s[0] & 248
    s[31] = (s[31] & 63) | 64
    return s

CONVERT_ED25519_PUBLIC(pubkey) := pubkey
```
Observe que a implementação de `CONVERT_ED25519_PRIVATE` é equivalente ao cálculo do escalar secreto s ao derivar uma chave pública Ed25519 a partir de uma chave privada Ed25519, conforme especificado nas etapas 1-3 da seção 5.1.5 do [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html).

## Implicações de segurança

Re-randomizar um Destino Red25519 e, em seguida, gerar assinaturas com ele não revela nenhuma informação sobre o Destino, porque a distribuição de chaves privadas Red25519 geradas via `RANDOMIZE_PRIVATE` é idêntica à distribuição de chaves privadas geradas via `GENERATE_PRIVATE`, e `DERIVE_PUBLIC` é determinístico.

Converter chaves privadas Ed25519 para Red25519 via `CONVERT_ED25519_PRIVATE` não resulta na mesma distribuição. No entanto, consideramos a redução na segurança aceitável pelos seguintes motivos:

- O espaço de escalares de Ed25519 (algoritmo de assinatura de curva elíptica) é aproximadamente metade do tamanho do espaço de escalares de Red25519 (há 2^251 escalares possíveis de Ed25519, e L ~= 2^252 escalares possíveis de Red25519). Assim, a perda de segurança é, no máximo, um fator de aproximadamente 2, ou cerca de 1 bit (porque poderíamos ter escolhido por coincidência um escalar de Red25519 que também é um escalar válido de Ed25519).
- Destinos Ed25519 existentes já foram expostos historicamente na rede, e deve-se presumir que floodfills maliciosos já os enumeraram.

**Importante**: Usuários que estejam preocupados com essa redução de segurança devem usar Red25519 (tipo de assinatura 11) como o tipo de assinatura para seus Destinos em vez de Ed25519 (tipo de assinatura 7).

Observe que o argumento acima não se aplica ao escalar de re-aleatorização alpha; informação sobre a chave é revelada toda vez que um alpha enviesado é escolhido, porque a re-aleatorização aditiva se comporta como uma cifra de uso único.

### Status da auditoria de segurança

**Divulgação Importante**: O I2P, incluindo Red25519, nunca passou por uma auditoria formal de segurança por terceiros. O design subjacente do RedDSA passou por uma revisão de segurança pelo NCC Group como parte da auditoria do protocolo Zcash Sapling em 2018, na qual problemas de segurança foram identificados e corrigidos. No entanto, a instanciação específica do I2P com SHA-512 (em vez de BLAKE2b-512) e a separação de domínio do I2P não passaram por análise independente.

A implementação de referência ed25519-java, de str4d, passou por uma auditoria independente de terceiros, mas isso antecedeu a implementação do Red25519 e cobriu apenas a funcionalidade do Ed25519, não as extensões do Red25519.

Usuários que estiverem implantando Red25519 (um esquema de assinatura criptográfica) devem compreender essa limitação e avaliar os compromissos de segurança com base no seu modelo de ameaça.

## Compatibilidade

As versões do I2P que suportam Red25519 (algoritmo de assinatura) (versão 0.9.39 e posteriores) poderão verificar estruturas de dados de rede assinadas com Red25519. As versões do I2P que não suportam Red25519 irão tratá-la como uma assinatura desconhecida e PODEM descartar as estruturas de dados.

**Cronograma de implantação**: - **0.9.39** (março de 2019): Primeira implementação com suporte a Encrypted LS2 (LS2 = versão 2 de leaseSet) em floodfills - **0.9.40** (maio de 2019): Autorização por cliente para Encrypted LS2 - **0.9.41** (agosto de 2019): Meta LS2 e Encrypted LS2 com chaves offline - **0.9.43** (fevereiro de 2020): Suporte a b32 para Encrypted LS2 - **0.9.47** (agosto de 2020): Finalização da especificação - **2.10.0** (outubro de 2025): Versão atual da rede (equivalente a 0.9.67+)

Os usuários devem esperar que a confiabilidade das estruturas de dados assinadas com Red25519 seja boa para casos de uso do LeaseSet2 criptografado, já que a rede teve mais de seis anos para se atualizar desde a implementação inicial. No entanto, métricas de adoção para o uso geral de destinos não estão publicamente disponíveis.

**Caso de uso principal**: Red25519 é usado principalmente para a funcionalidade de LeaseSet2 criptografado, onde o cegamento de chave é necessário. Para destinos padrão sem requisitos de leaseset criptografado, Ed25519 (tipo de assinatura 7) continua sendo a escolha recomendada devido à compatibilidade mais ampla e ao histórico mais longo e comprovado.

## Notas de implementação

Red25519 é implementado no router Java do I2P em `net.i2p.crypto.eddsa.RedDSAEngine` e utiliza a biblioteca ed25519-java de str4d (Jack Grigg) como dependência do Maven `net.i2p.crypto:eddsa` (versões 0.1.0 a 0.3.0).

A implementação do i2pd em C++ também suporta Red25519 (signaturetype=11) para a publicação de LeaseSet criptografados.

Exemplo de configuração para o i2pd:

```
signaturetype=11
i2cp.leaseSetType=5
```
**Compatibilidade do Encrypted LeaseSet2**: A especificação de Encrypted LeaseSet exige que a chave pública de assinatura no unblinded destination (destino não cegado) seja Ed25519 (tipo de assinatura 7) ou Red25519 (tipo de assinatura 11). Nenhum outro tipo de assinatura é suportado para a funcionalidade de leaseSet criptografado.

## Vetores de teste

Os vetores de teste a seguir são fornecidos para validação da implementação. Cada vetor inclui:

- `edsk`: chave privada Ed25519 (aleatória)
- `edpk`: chave pública Ed25519 correspondente a edsk
- `sk`: CONVERT_ED25519_PRIVATE(edsk)
- `vk`: CONVERT_ED25519_PUBLIC(edpk)
- `msg`: Mensagem a ser assinada
- `sig`: SIGN(sk, msg)
- `alpha`: GENERATE_RANDOM()
- `rsk`: RANDOMIZE_PRIVATE(sk, alpha)
- `rvk`: RANDOMIZE_PUBLIC(vk, alpha)
- `rsig`: SIGN(rsk, msg)

**Nota de Implementação**: Esses vetores de teste devem ser integrados a suítes de testes unitários automatizadas para validação contínua. Os implementadores devem verificar se todas as conversões, assinaturas e operações de re-randomization (realeatorização) correspondem a esses valores esperados.

### Vetor de teste 1

```
edsk:  0101010101010101010101010101010101010101010101010101010101010101
edpk:  8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c
sk:    58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e
vk:    8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c
msg:   0202020202020202020202020202020202020202020202020202020202020202
sig:   61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a
       6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f
alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08
rsk:   8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107
rvk:   6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3
rsig:  533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5
       b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001
```
### Vetor de teste 2

```
edsk:  0202020202020202020202020202020202020202020202020202020202020202
edpk:  8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394
sk:    a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e
vk:    8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394
msg:   0303030303030303030303030303030303030303030303030303030303030303
sig:   0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d
       5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a
alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203
rsk:   9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402
rvk:   527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177
rsig:  9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51
       3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f
```
**Observação**: Os vetores de teste adicionais 3 a 10 seguem o mesmo formato e podem ser encontrados na implementação de referência.

## Referências

- [Proposta 123: Novas entradas no netDB](/proposals/123-new-netdb-entries/) - Partes implementadas e implantadas nas versões 0.9.38, 0.9.39 e posteriores
- [Especificação do Protocolo Zcash, Seção 5.4.6: RedDSA, RedJubjub e RedPallas](https://zips.z.cash/protocol/protocol.pdf) - RedDSA é definido como parte da especificação do protocolo Zcash; auditoria de segurança realizada pela NCC Group (janeiro de 2019)
- [RFC 8032: Algoritmo de Assinatura Digital de Curva de Edwards (EdDSA)](https://www.rfc-editor.org/rfc/rfc8032.html)
- [Proposta 148: RedDSA-BLAKE2b-Ed25519](/proposals/148-eddsa-blake2b-ed25519/) - Proposta, mas ainda não implementada; sugere migração futura para BLAKE2b-512
- [Especificação de LeaseSet Criptografado](/docs/specs/encryptedleaseset/)
- [Especificação de Criptografia de Baixo Nível](/docs/specs/cryptography/)
