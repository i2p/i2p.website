---
title: "I2P Entwicklertreffen - 07. Februar 2006"
date: 2006-02-07
author: "jrandom"
description: "Protokoll des I2P-Entwicklertreffens vom 07. Februar 2006."
categories: ["meeting"]
---

## Kurze Zusammenfassung

<p class="attendees-inline"><strong>Anwesend:</strong> bar, cervantes, Complication, jrandom, KBlup, modulus, tethra, tmp</p>

## Sitzungsprotokoll

<div class="irc-log"> 15:36 &lt;jrandom&gt; 0) hi 15:36 &lt;jrandom&gt; 1) Netzstatus 15:36 &lt;jrandom&gt; 2) _PRE-Netz-Fortschritt 15:36 &lt;jrandom&gt; 3) I2Phex 0.1.1.37 15:36 &lt;jrandom&gt; 4) ??? 15:36 &lt;jrandom&gt; 0) hi 15:37  * jrandom winkt 15:37 &lt;jrandom&gt; Wöchentliche Statusnotizen veröffentlicht unter @ http://dev.i2p.net/pipermail/i2p/2006-February/001258.html 15:37 &lt;bar&gt; hallo 15:38 &lt;jrandom&gt; Während ihr euch durch dieses ach so spannende Material wühlt, springen wir rüber zu 1) Netzstatus 15:38 &lt;jrandom&gt; Im Live-Netz hat sich aus I2P-Sicht in der letzten Woche nicht viel geändert, daher habe ich hier nicht viel hinzuzufügen 15:39 &lt;jrandom&gt; Hat jemand etwas zum aktuellen Netzstatus? 15:39 &lt;KBlup&gt; Ich habe schlimme Spitzen von ausfallenden Clients gesehen, wenn I2P lange läuft... keine Ahnung, ob das zu 1) passt 15:39 &lt;jrandom&gt; KBlup: korreliert das mit hoher CPU-Last oder Bandbreitenverbrauch? 15:40 &lt;KBlup&gt; führt zu msg-delay&gt; 10000ms :-/ 15:40 &lt;jrandom&gt; ah, sehr wahrscheinlich einer der Gründe, warum das _PRE-Netz entwickelt wird :) 15:40 &lt;KBlup&gt; Ich denke, es versucht dann neue tunnels aufzubauen und scheitert ständig, was manchmal in 300+ jobs resultiert... 15:41 &lt;KBlup&gt; Meine Maschine ist ziemlich stark, aber damit überlastet... 15:41 &lt;jrandom&gt; jau, das wurde auf dem Weg zu 0.6.1.10 alles überarbeitet, haltet durch, bis das fertig ist 15:43 &lt;jrandom&gt; ok, noch etwas zu 1), oder sollen wir gemütlich rüber zu 2) _PRE-Netz-Fortschritt schlendern 15:43 &lt;+Complication&gt; 0.6.1.10 scheint tatsächlich erhebliche Änderungen zu enthalten 15:45 &lt;jrandom&gt; ja, hier steckt eine Menge drin. Der aktuelle Stand ist, dass der neue Erstellungscode vorhanden ist und offenbar korrekt funktioniert, aber ich nutze jetzt die Gelegenheit, einige der zugrunde liegenden Probleme weiter zu debuggen 15:46 &lt;+Complication&gt; Du hast erwähnt, dass man im Voraus viel CPU-Zeit aufbringen muss 15:47 &lt;+Complication&gt; Wäre diese Kosten nun mit dem Aufbau jeglicher Art von tunnel verbunden? 15:48 &lt;+Complication&gt; (heißt: vor dem Aufbau, für kurze Zeit, müsste man einen Schwung schwere Krypto berechnen) 15:48 &lt;jrandom&gt; ja, alle Anfragen zum Erstellen von tunnels müssen k aufwendige Krypto-Operationen durchführen (wobei k = Anzahl der Hops im zu bauenden tunnel) 15:49 &lt;+Complication&gt; Was ich fragen wollte ... ist das Intervall nur enger als zuvor, oder ist die Menge auch größer? 15:50 &lt;jrandom&gt; Die Menge ist sowohl größer, kleiner als auch straffer. Straffer, weil alles im Voraus erledigt wird. Größer, weil wir nicht mehr abkürzen und die Verschlüsselung für einen Hop auslassen können, wenn ein früherer Hop sie ablehnt, und kleiner, weil frühere Hops viel seltener fehlschlagen 15:51 &lt;jrandom&gt; außerdem verwenden wir – anders als in früheren Releases – für die tunnel-Anfragen nicht mehr ElGamal/AES+SessionTag, sondern (ziemlich) pures ElGamal 15:52 &lt;+Complication&gt; ...und das ließe sich nicht vorab berechnen, es sei denn, man wüsste die endgültige Menge, die erfolgreich sein wird? 15:52 &lt;jrandom&gt; das bedeutet, dass wir zwar früher ohne eine asymmetrische Operation tricksen konnten, wir versuchen es aber nicht mehr (da das Tricksen selbst eine Klasse von Angriffen ermöglicht hat) 15:53 &lt;+Complication&gt; (Menge der Peers) 15:53 &lt;jrandom&gt; hmm, es könnte sicherlich vorab berechnet werden, vorausgesetzt, man weiß, welche Peers im tunnel angefragt werden sollen 15:54 &lt;jrandom&gt; der neue tunnel-Erstellungsprozess läuft in einem separaten Thread, damit er unter Last nicht die Haupt-Job-Queue verstopft und sich besser drosseln kann 15:54 &lt;+Complication&gt; Könnte man auch annehmen, dass man – sofern sich das verfügbare Wissen nicht ändert – ein paar kennt, die man als Nächstes fragen wird, falls Versuche scheitern? 15:54 &lt;jrandom&gt; hmm, ich bin mir nicht ganz sicher, ob ich folge 15:55 &lt;+Complication&gt; Oder ist es nutzlos, sie schon zu kennen, weil die Struktur komplett neu aufgebaut werden muss? 15:56 &lt;+Complication&gt; (sprich: die ElGamal-Verschlüsselungen zumindest komplett neu machen) 15:56 &lt;jrandom&gt; ah, die Struktur ist http://dev.i2p.net/cgi-bin/cvsweb.cgi/i2p/router/doc/tunnel-alt-creation.html?rev=HEAD#tunnelCreate.requestRecord 15:56 &lt;jrandom&gt; also ja, wenn sich der nächste Hop ändert, muss das ElGamal neu gemacht werden 15:56 &lt;jrandom&gt; (wenn du vorrechnest) 15:56 &lt;+Complication&gt; Richtig, da war ich mir nicht sofort sicher genug 15:57 &lt;+Complication&gt; Jetzt ist es mir allerdings klar 15:57 &lt;jrandom&gt; andererseits versuchen wir wirklich, unsere Erfolgsrate beim Erstellen zu erhöhen, und der neue Erstellungsprozess sollte sich anpassen können, um unnötige Erstellungen zu minimieren 15:58 &lt;+Complication&gt; Wie sieht es in der Praxis aus? 15:58 &lt;jrandom&gt; (oh, diese Struktur wurde im _PRE-Branch leicht geändert: http://dev.i2p.net/cgi-bin/cvsweb.cgi/~checkout~/i2p/router/doc/tunnel-alt-creation.html?rev=1.1.2.1;content-type=text%2Fhtml#tunnelCreate.requestRecord ) 15:59 &lt;+Complication&gt; Mir ist das Detail aufgefallen, dass ElGamal-Verschlüsselungen einen Sprung in Richtung Schnelligkeit machen... 15:59 &lt;jrandom&gt; nun, die Erfolgsrate beim Erstellen ist viel, viel höher als im Live-Netz, aber das kann einfach an der kleinen Größe des _PRE-Netzes liegen 16:00 &lt;jrandom&gt; ja, das Erzeugen einer 2-Hop-Struktur dauert beispielsweise im Durchschnitt 44 ms über 1120 Durchläufe, verglichen mit der ElGamal-Verschlüsselungszeit im Live-Netz von 542 ms (über 1344 Durchläufe) 16:02 &lt;jrandom&gt; (auf derselben Maschine) 16:02 &lt;+Complication&gt; Sind die 542 auch mit Wiederholungen bei Fehlschlägen, oder nur das reine Erstellen? 16:02 &lt;+Complication&gt; Wenn es reines Erstellen ist, muss ich meinen Unterkiefer suchen ... er liegt irgendwo auf dem Boden. :P 16:02 &lt;KBlup&gt; wegen der Änderung des Exponenten: in welchem Maß beeinflusst das die Anonymität? 16:02 &lt;jrandom&gt; nein, das ist die reine ElGamal-Statistik, da das Live-Netz die neue _PRE-Netz-Struktur nicht erstellt 16:04 &lt;jrandom&gt; KBlup: Anonymität? keine. Sicherheit? Nach dem, was ich gelesen habe, sind 228 Bit mehr als ausreichend, um 2048-bit-ElGamal zu entsprechen 16:04  * Complication weiß nicht viel über ElGamals x und y 16:04 &lt;+Complication&gt; Nicht genug, um sinnvoll zu kommentieren 16:06 &lt;+Complication&gt; Wenn ernsthafte Forscher das kürzere x für ausreichend hart halten und diese Krypto-Nerds nicht schreiend davongelaufen sind... 16:06 &lt;@cervantes&gt; nun, nicht nur das, sondern auch die Implikationen, auf 1024/160 herunterzugehen 16:07 &lt;KBlup&gt; ich schätze, ich muss das Paper später lesen ;) 16:07 &lt;+Complication&gt; cervantes: ja, es ist sicher besser als das 16:08 &lt;+Complication&gt; Außerdem: Was ist der wichtigste Angriff, den diese Chiffre abwehren muss, und wie lange ist der Angriff praktikabel? 16:09 &lt;+Complication&gt; Könnte es etwas sein, das dir nur nützt, wenn du es schnell brichst, oder nützt es auch, wenn du es irgendwann später brichst? 16:11 &lt;+Complication&gt; Wenn ich richtig verstehe, ist das unmittelbare Geheimnis, das sie schützt, der nächste tunnel-Teilnehmer, richtig? 16:11 &lt;+Complication&gt; (genauer gesagt: der übernächste) 16:11 &lt;@modulus&gt; Meeting noch im Gange? 16:11 &lt;+Complication&gt; (den nur der nächste kennt) 16:11 &lt;@cervantes&gt; modulus: ayre 16:11 &lt;@cervantes&gt; -r 16:11 &lt;jrandom&gt; für einen praktischen (wenn auch wahnsinnig mächtigen) Gegner wäre es notwendig, sie während der Lebensdauer des tunnels zu brechen. Sie nach dieser Lebensdauer zu brechen, würde nur helfen, wenn du den gesamten Netzwerkverkehr geloggt hättest und alle tunnels brechen würdest (also nachdem du die ephemere Transportschicht-Krypto gebrochen hast und an der tunnel-Schicht-Krypto arbeitest) 16:11 &lt;jrandom&gt; wir reden hier also von Minuten, nicht von Jahrzehnten 16:12 &lt;jrandom&gt; (also sind 1024 Bit wahrscheinlich sogar Overkill) 16:12 &lt;@cervantes&gt; gibt es eine Möglichkeit, das Risiko sinnvoll zu messen? 16:13 &lt;+Complication&gt; Außerdem müsste der Gegner bei einem tunnel mit mehr Hops mehrere brechen, oder? 16:13 &lt;+Complication&gt; (obwohl der Ersteller auch mehrere bauen müsste) 16:13 &lt;@cervantes&gt; wenn wir nicht mehr als 1024 Bit brauchen, ist es dann wirklich nötig, mehr zu verwenden?  16:14 &lt;@cervantes&gt; wir können immer in 3 Jahren einen stärkeren Algo verwenden, wenn wir deutlich leistungsfähigere Quantencomputer haben 16:14 &lt;@modulus&gt; jrandom: Wenn der Gegner wüsste, dass um hh:mm etwas Wichtiges getunnelt wird, ist es wahrscheinlich, dass er es irgendwie durch Logging brechen könnte? 16:14 &lt;jrandom&gt; Complication: genau, sie müssten mehrere brechen (und die DH-Schlüssel, die die Transportschicht schützen) 16:14 &lt;@modulus&gt; soweit ich weiß, ist 1024 Bit mit viel Power break()able 16:15 &lt;jrandom&gt; viel Power und ein Jahrzehnt 16:15 &lt;jrandom&gt; (oder drei) 16:15 &lt;@cervantes&gt; jrandom: ist es schwierig, die schwächere Chiffre auszuprobieren? 16:15 &lt;@modulus&gt; ich war der Meinung, dass 1024-Bit-Komposite heutzutage in ein paar Monaten faktorisierbar sind. 16:15 &lt;@cervantes&gt; könnten wir es im PRE-Netz ausrollen  16:15 &lt;@cervantes&gt; und sehen, ob es tatsächlich viel Nutzen bringt 16:16 &lt;@cervantes&gt; modulus: ja, aber sie müssten mehrere brechen 16:16 &lt;@modulus&gt; wenn das auf dem diskreten Logarithmus und all dem Kram basiert, weiß ich nichts 16:16 &lt;@modulus&gt; cervantes: aha 16:16 &lt;jrandom&gt; cervantes: das erfordert Änderungen an vielen Strukturen, da wir derzeit 512-Byte-Slots verwenden. Vielleicht könnten wir für Tests einfach die ersten 256 Bytes mit 0x00 füllen 16:17 &lt;jrandom&gt; modulus: ElGamal basiert auf dem diskreten Logarithmus 16:17 &lt;@cervantes&gt; jrandom: einen Test wert? 16:17 &lt;@modulus&gt; genau, ich hatte an RSA gedacht 16:17 &lt;@cervantes&gt; oder besser auf andere Dinge konzentrieren und bei Bedarf darauf zurückkommen 16:18 &lt;jrandom&gt; definitiv einen Test wert, aber im Moment hacke ich an einigen Transportschicht-Evaluierungen herum 16:18 &lt;+Complication&gt; Ich schätze, es hängt davon ab, wie sich ihre Berechnung in der Praxis bewältigen lässt. 16:18 &lt;jrandom&gt; (und die 44 ms Verschlüsselungszeit ist fürs Erste gut genug, obwohl 4 ms noch besser wären :) 16:19 &lt;+Complication&gt; Wenn es mit aktuellen Rechnern zusammenhält, wird es sich mit neueren Maschinen verbessern. 16:19 &lt;@modulus&gt; insbesondere wenn Krypto-HW kommt, wie es bei einigen gerade anfängt 16:19 &lt;jrandom&gt; aber natürlich wird dieser Parameter nicht leichtfertig oder sofort geändert. Wenn jemand einen guten Grund hat, ihn zu vermeiden, bitte melden 16:21 &lt;jrandom&gt; modulus: Ich habe von dedizierten AES- und RSA-Chips gehört, aber nichts zu DH/ElGamal. Andererseits, wenn man die NSA/etc als Gegner betrachtet, die ihre eigenen bauen können, ist es möglich 16:22 &lt;@cervantes&gt; sie haben Krypto-Maschinen, gebaut auf Ring-Donut-Technologie mit Streuseln 16:23  * Complication ist bereit, den Celeron 300 auf einen Athlon 600 aufzurüsten, wenn er der Flut von Ring-Donuts mit Streuseln standhält :D 16:23 &lt;tethra&gt; heheh 16:24 &lt;jrandom&gt; mmMMmm Donuts 16:25 &lt;jrandom&gt; ok, hat noch jemand etwas zu 2) _PRE-Netz-Fortschritt? 16:25 &lt;jrandom&gt; wenn nicht, springen wir rüber zu 3) I2Phex 0.1.1.37 16:26 &lt;jrandom&gt; Complication: magst du uns die Kurzfassung geben? 16:26 &lt;+Complication&gt; Nun, es scheint zu funktionieren. :) 16:26 &lt;+Complication&gt; Es gibt Hoffnung, bald mehr Webcaches für zusätzliche Redundanz zu bekommen. 16:27 &lt;jrandom&gt; word 16:27 &lt;jrandom&gt; hmm, brauchen wir deiner Meinung nach mehr Webcaches? Reicht nicht, wenn einer up ist? Mehr schadet natürlich nicht 16:27 &lt;+Complication&gt; (falls legion es schafft, die Mysterien zu lösen, die seinen ersten Versuch heimgesucht haben) 16:27 &lt;+Complication&gt; Es gibt auch einen mysteriösen Bug, aber er beißt nicht hart, und ich versuche, ihn zu finden. 16:28 &lt;+Complication&gt; Einer, der up ist, reicht 16:28 &lt;+Complication&gt; Mehr erhöht nur die Chance, dass einer up ist 16:28 &lt;jrandom&gt; cool 16:28 &lt;+Complication&gt; Denn im derzeitigen Stadium werden Webcaches nie als schlecht verworfen. Insgesamt sind es zu wenige. 16:29 &lt;+Complication&gt; (diese Routine wird aktiv, wenn es mehr als 10 gibt) 16:29 &lt;+Complication&gt; (wenn ich mich recht erinnere) 16:29 &lt;+Complication&gt; Zum Bug: Nach langer Laufzeit hängt sich das Webcache-Subsystem manchmal auf 16:30 &lt;+Complication&gt; Wahrscheinlich, weil sich ein GET-Request des httpclient nicht erfolgreich abbrechen lässt 16:31 &lt;@modulus&gt; also muss es von Zeit zu Zeit sterben? 16:31 &lt;+Complication&gt; Es ist unkritisch und scheint frisch beigetretene Maschinen nie zu beißen 16:31 &lt;jrandom&gt; hmm, was bedeutet das funktional? Hört es nach einer Weile auf, sich beim Webcache zu registrieren, sodass neuen Leuten keine Referenzen auf sie gegeben werden? 16:31 &lt;+Complication&gt; Wenn es eine bereits gut integrierte Maschine beißt, kann diese genug Peers von den Peers bekommen, mit denen sie bereits verbunden ist 16:31 &lt;+Complication&gt; Der Einfluss scheint derzeit also nahezu 0 zu sein 16:31 &lt;@modulus&gt; cool 16:32 &lt;+Complication&gt; Es ist nur kurios 16:32 &lt;@modulus&gt; keine Regel, wann es ausfällt oder so? 16:32 &lt;+Complication&gt; modulus: im Allgemeinen nicht vor 20 Stunden 16:33 &lt;+Complication&gt; Und da ich keinen Weg habe, es herbeizuführen, ist das Debuggen etwas langsam 16:33 &lt;@modulus&gt; :_) 16:34 &lt;+Complication&gt; So oder so: Wenn ich ihn finde, fix ich ihn, und wenn nicht, finde ich anderes Zeug zum Basteln :) 16:34 &lt;jrandom&gt; :) 16:34 &lt;jrandom&gt; klingt, als wäre es nur ein Symptom einiger Bugs, die wir in der streaming lib / eepproxy gesehen haben, also sollte das Fixen dieser auch das hier beheben 16:35 &lt;+Complication&gt; Könnte sein 16:38 &lt;jrandom&gt; ok, super, gute Arbeit, Complication 16:38 &lt;jrandom&gt; hat noch jemand etwas zu 3) I2Phex 0.1.1.37, oder springen wir rüber zum Sammelpunkt, 4) ??? 16:41 &lt;jrandom&gt; (betrachte uns als gesprungen) 16:41 &lt;jrandom&gt; ok, hat noch jemand etwas fürs Meeting? 16:42 &lt;tmp&gt; Oder für immer die Luft anhalten? 16:43 &lt;jrandom&gt; und immer und ewig 16:43  * jrandom holt aus 16:43  * jrandom *baf*t das Meeting zu </div>
