---
title: "I2P-Entwicklertreffen - 25. April 2005"
date: 2005-04-25
author: "jrandom"
description: "Protokoll der I2P-Entwicklungsbesprechung vom 25. April 2005."
categories: ["meeting"]
---

## Kurze Zusammenfassung

<p class="attendees-inline"><strong>Anwesend:</strong> cervantes, Complication, inkeystring, jdot, jrandom, lsmith, perv, spinky</p>

## Sitzungsprotokoll

<div class="irc-log"> 16:12 &lt;jrandom&gt; 0) hi 16:12 &lt;jrandom&gt; 1) Netzstatus und 0.6.1.17 16:12 &lt;jrandom&gt; 2) I2Phex 16:13 &lt;jrandom&gt;  3) ??? 16:13 &lt;jrandom&gt; 0) hi 16:13  * jrandom winkt 16:13 &lt;@cervantes&gt; 'lo 16:13 &lt;jrandom&gt; Wöchentliche Statusnotizen veröffentlicht @ http://dev.i2p.net/pipermail/i2p/2006-April/001283.html 16:14 &lt;jrandom&gt; während ihr euch das kurz anschaut, springen wir zu 1) Netzstatus  16:14 &lt;jrandom&gt; also, wie die meisten von euch gesehen haben, haben wir ein neues Release herausgebracht, und bisher sind die Ergebnisse ziemlich positiv 16:15 &lt;@cervantes&gt; (yay!) 16:15 &lt;jrandom&gt; noch nicht da, wo wir hinmüssen, aber es räumt die Hauptprobleme, die wir gesehen haben, weitgehend aus 16:15 &lt;jrandom&gt; ja, es ist schön, wieder halbwegs brauchbare tunnel-Bauraten zu haben, bei 2+ Hop tunnels :) 16:16  * jrandom hat 50%+ Erfolgsraten auf einem anderen router mit 1-Hop tunnels 16:17 &lt;jrandom&gt; Ich denke, die letzten Änderungen in 0.6.1.17 sollten auch künftig helfen, diese Art von Kongestionskollaps zu vermeiden 16:17 &lt;jrandom&gt; für Nutzer sichtbar ist allerdings, dass wir gelegentlich lease-Abläufe sehen werden, aber statt sich hochzuschaukeln, fährt es dann zurück 16:17  * cervantes startet azureus 16:18 &lt;+Complication&gt; Heute Morgen habe ich client tunnel (Länge 2 +/- 1) Erfolgsraten von nahe 35% aufgezeichnet 16:18 &lt;+Complication&gt; Aktuell ist es niedriger, da ich einige Änderungen ausprobiert habe und die letzte davon nicht so toll war :D 16:18 &lt;@cervantes&gt; jrandom: gut gemacht, das herauszufinden – wir fingen schon an, ein wenig wie freenet auszusehen :) 16:19 &lt;jrandom&gt; *hust* ;) 16:20 &lt;+fox&gt; &lt;inkeystring&gt; jrandom: würdest du kurz den Backoff-Mechanismus beschreiben? ich arbeite gerade an etwas Ähnlichem für freenet 0.7 16:21 &lt;jrandom&gt; inkeystring: wir hatten auf der Transportschicht einen Backoff-Mechanismus, um Übertragungen zu einem Peer zu verringern, wenn die Transportschicht überlastet ist, aber das war nicht ausreichend 16:21 &lt;@cervantes&gt; *hust* sagte ich freenet, ich meinte tor 16:21 &lt;+fox&gt; &lt;inkeystring&gt; :-) 16:22 &lt;jrandom&gt; inkeystring: die neue Änderung war, das nach oben auf eine höhere Ebene zu propagieren, sodass wir aufhören, tunnels zu bauen, wenn unsere Kommunikationsschicht gesättigt ist 16:22 &lt;jrandom&gt; (statt noch mehr tunnel-Bauversuche zu senden) 16:22 &lt;+fox&gt; &lt;inkeystring&gt; danke – macht die Transportschicht nur Backoff bei Paketverlust, oder gibt es eine Möglichkeit für den Empfänger, den Fluss zu steuern? 16:23  * jrandom erinnert sich, mit toad ein paar Mal (auf irc und in meinem alten Flog) die Auswirkungen von Congestion vs. Routing diskutiert zu haben, allerdings erinnere ich keine netto-positive Lösung :/ 16:23 &lt;jrandom&gt; der Empfänger kann NACKen, und wir haben Hooks für ECN, aber sie waren nicht nötig 16:23 &lt;+fox&gt; &lt;inkeystring&gt; ja, die Debatte ist auf freenet-dev wieder aufgeflammt :-) noch immer keine Wunderwaffe 16:24 &lt;+fox&gt; &lt;inkeystring&gt; cool, danke für die Information 16:24 &lt;+Complication&gt; Verwenden die heutzutage nicht auch UDP? 16:24 &lt;jrandom&gt; derzeit haben stark überlastete Peers Probleme nicht mit der per-Peer-Drosselung, sondern mit der Breite der Peer-Kommunikation 16:24 &lt;+Complication&gt; (als Transportprotokoll) 16:24 &lt;+fox&gt; &lt;inkeystring&gt; Breite = Anzahl der Peers? 16:24 &lt;jrandom&gt; ja 16:25 &lt;jrandom&gt; mit den erhöhten tunnel-Erfolgsraten müssen Peers nicht mehr mit Hunderten Peers sprechen, nur um einen tunnel gebaut zu bekommen 16:25 &lt;jrandom&gt; sie kommen also mit nur 20-30 Peers aus 16:25 &lt;jrandom&gt; (direkt verbundene Peers, wohlgemerkt) 16:26 &lt;+fox&gt; &lt;inkeystring&gt; ich schätze, das sind gute Nachrichten für NAT Hole Punching, Keepalives usw.? 16:26 &lt;jrandom&gt; andererseits, mit 2-300 aktiven SSU-Verbindungen wird eine 6KBps-Leitung Probleme haben 16:26 &lt;jrandom&gt; ja 16:26 &lt;+fox&gt; &lt;inkeystring&gt; Complication: ja 16:27 &lt;+fox&gt; &lt;inkeystring&gt; (in der 0.7-Alpha) 16:27 &lt;+Complication&gt; Aha, dann stehen sie wahrscheinlich vor ähnlichen Dingen 16:27 &lt;+Complication&gt; Ich hoffe, jemand findet die Wunderwaffe :D 16:27 &lt;jrandom&gt; allerdings auf andere Weise.  die Transportschicht ist ein relativ einfaches Thema 16:27 &lt;+fox&gt; &lt;inkeystring&gt; ich denke, sie haben vielleicht etwas des SSU-Codes wiederverwendet ... oder zumindest darüber gesprochen 16:27 &lt;jrandom&gt; (sprich seit 30+ Jahren gut erforscht) 16:28 &lt;jrandom&gt; aber die Lastverteilung in i2p (und freenet) arbeitet auf einer höheren Ebene als Punkt-zu-Punkt-Verbindungen und hat andere Anforderungen 16:28 &lt;+fox&gt; &lt;inkeystring&gt; ja, die Interaktion mit dem Routing ist knifflig 16:29 &lt;jrandom&gt; ja, wobei i2p es einfacher hat (wir müssen nicht spezifische Peers mit den betreffenden Daten finden, sondern nur irgendwelche mit Kapazität, an unseren tunnels teilzunehmen) 16:30 &lt;+fox&gt; &lt;inkeystring&gt; also gibt es keinen Effizienzverlust, wenn man einen überlasteten Peer meidet... 16:30 &lt;+fox&gt; &lt;inkeystring&gt; während in freenet das Routing um einen überlasteten Peer die Pfadlänge erhöhen kann 16:30 &lt;+fox&gt; &lt;inkeystring&gt; wie auch immer sorry fürs OT 16:31 &lt;jrandom&gt; kein Problem, wobei es relevant war zu erklären, warum die Änderungen in 0.6.1.17 unseren Kongestionskollaps beeinflusst haben :) 16:31 &lt;jrandom&gt; ok, hat noch jemand etwas zu 1) Netzstatus? 16:32 &lt;+Complication&gt; Nun, wie schon erwähnt, beim Betrieb mit reinem .17 habe ich eine spürbare Periodizität bei Bandbreite und aktiven Peers beobachtet 16:32 &lt;+Complication&gt; Und ein paar andere scheinen es auch zu erleben, obwohl ich keine Ahnung habe, wie verbreitet es ist 16:33 &lt;+Complication&gt; Ich habe über die Hauptursachen gerätselt, vor allem aus der Perspektive der tunnel-Drosselung, aber noch keine Lösung 16:33 &lt;+Complication&gt; Ich habe es geschafft, meine eigenen Graphen flacher aussehen zu lassen, aber nur zum Preis einiger allgemeiner Verschlechterungen 16:33 &lt;+Complication&gt; Habe Änderungen wie diese ausprobiert: 16:34 &lt;+Complication&gt;&gt; _log.error("Allowed was " + allowed + ", but we were overloaded, so ended up allowing " + Math.min(allowed,1)); 16:34 &lt;+Complication&gt; (das sollte verhindern, dass es für seine eigenen tunnels völlig auf Bauversuche verzichtet) 16:35 &lt;jrandom&gt; ach richtig 16:35 &lt;+Complication&gt; (oh, und natürlich ist das Loglevel schräg, da ich das zum Testen geändert habe) 16:35 &lt;jrandom&gt; wir haben dort etwas Code, der versucht, die Periodizität etwas zu verschieben, aber das funktioniert nicht ganz richtig (offensichtlich) 16:36  * perv hat gerade sein System geschossen :( 16:36 &lt;+Complication&gt; Aber ich habe Dinge wie diese probiert und versucht, den Wachstumsfaktor für die Anzahl der tunnel zu reduzieren 16:36 &lt;perv&gt; gibt es ein Undelete für reiser4? 16:36 &lt;jrandom&gt; grundsätzlich sollte es helfen, wenn wir so tun, als würden tunnels (zufällig) früher ablaufen, als sie es tatsächlich tun 16:36 &lt;+Complication&gt; Lese gerade die große Funktion "countHowManyToBuild" in TunnelPool.java :D 16:36 &lt;+Complication&gt; Aber ich habe sie noch nicht durchgelesen 16:37 &lt;jrandom&gt; (auch wenn das offensichtlich die Häufigkeit des tunnel-Aufbaus erhöhen würde, was vor 0.6.1.17 nicht sinnvoll gewesen wäre) 16:37 &lt;+Complication&gt; perv: da gibt es etwas 16:37 &lt;jrandom&gt; hmm, dort eine Randomisierung einzubauen wäre schwierig, Complication, da wir diese Funktion ziemlich häufig aufrufen 16:38  * perv erwägt, zu retten und auf gentoo zu wechseln 16:38 &lt;jrandom&gt; was ich empfehlen würde, wäre, die Ablaufzeit erfolgreich aufgebauter tunnels zu randomisieren 16:38 &lt;+Complication&gt; perv: mit reiser bist du besser bedient als mit ext3, auf jeden Fall 16:38 &lt;+Complication&gt; perv: aber ich weiß es nicht auswendig 16:38 &lt;+Complication&gt; jrandom: stimmt, manchmal könnte es so zu viel bauen 16:38 &lt;jrandom&gt; (so dass die bestehende countHowManyToBuild denkt, sie braucht sie, bevor sie es tatsächlich tut) 16:38 &lt;+Complication&gt; (und manchmal baut es zwangsläufig zu viel, wenn tunnels brechen und es hastig wird) 16:40 &lt;+Complication&gt; Hmm, eine Möglichkeit, die ich nicht bedacht habe... 16:41 &lt;+Complication&gt; Wie auch immer, ich spiele auch damit, aber noch keine hilfreichen Beobachtungen 16:42 &lt;jrandom&gt; cool, ich habe ein paar Tweaks, mit denen ich dazu experimentiere; vielleicht bekommen wir das bis zum nächsten Build zusammen, um zu sehen, wie es im halbwegs brauchbaren Netz funktioniert ;) 16:43 &lt;spinky&gt; Gibt es eine Statistik, in der man sehen kann, wie viel Overhead das i2p-Netz dem Anwendungsdatenverkehr hinzufügt? 16:43 &lt;jrandom&gt; „Overhead“ ist so ein aufgeladener Begriff... ;) 16:43 &lt;jrandom&gt; wir nennen es die Kosten der Anonymität ;) 16:43 &lt;spinky&gt; hehe 16:45 &lt;jrandom&gt; (bzw. nicht wirklich.  Nutzlast auf Anwendungsebene erreicht in einem perfekten Netz mit 0 Congestion & 1+1 Hops etwa 70–80% Effizienz an den Endpunkten) 16:45 &lt;jrandom&gt; ((als ich das zuletzt gemessen habe)) 16:45 &lt;jrandom&gt; aber das sind wirklich Laborbedingungen 16:45 &lt;jrandom&gt; das Live-Netz ist viel komplizierter 16:47 &lt;spinky&gt; Genau, ich meinte nur die Menge an zusätzlichen Daten für das Einrichten von tunnels, Schlüssel, Padding usw.  16:47 &lt;spinky&gt; ...verglichen mit den übertragenen Anwendungsdaten 16:47 &lt;jrandom&gt; hängt vom Framing der Nachrichten, Congestion, den Erfolgsraten beim tunnel-Aufbau usw. ab 16:48 &lt;jrandom&gt; ein 2-Hop tunnel kann gebaut werden, wobei das Netz etwa 20KB tragen muss 16:48 &lt;+Complication&gt; Ich wollte das schon mal testen, primär mit dem Ziel, die „Verschwendungs“-Rate von Massentransferanwendungen wie BitTorrent und I2Phex abzuschätzen 16:48 &lt;+Complication&gt; Aber ich bin nie dazu gekommen, eine saubere Messung zwischen meinen zwei Nodes zu machen 16:48 &lt;+Complication&gt; Irgendwann gehe ich das aber an 16:49 &lt;jrandom&gt; Complication: das ist bei geschwätzigen Apps ziemlich schwierig, viel einfacher ist es, wget zu messen :) 16:49 &lt;+Complication&gt; Wie wahr 16:50 &lt;+Complication&gt; Bei dem, was ich ausprobiert habe, war keine Spur von Präzision dabei 16:54 &lt;jrandom&gt; ok, wenn es zu 1) nichts Weiteres gibt, gehen wir über zu 2) I2Phex 16:55 &lt;jrandom&gt; Complication: woran arbeitest du?  :) 16:55 &lt;+Complication&gt; Nun, der gestrige Commit war ein Fix für bestimmte Probleme, die einige Leute mit meinem albernen First-Run-Detektor erlebt haben 16:56 &lt;+Complication&gt; Der First-Run-Detektor ist jetzt weniger albern, und bar berichtete, dass er sich nun normal zu verhalten scheint 16:56 &lt;+Complication&gt; Allerdings, da I2Phex unter den aktuellen Netzbedingungen bereits lauffähig scheint, 16:56 &lt;+Complication&gt; werde ich auch versuchen, den Rehash-Bug zu finden. 16:57 &lt;+Complication&gt; Wenn ich nur kann 16:57 &lt;jrandom&gt; cool, ich weiß, der verfolgt dich schon seit Monaten  16:57 &lt;+Complication&gt; Interessant ist, dass Mainline-Phex ihn vielleicht auch hat, und ihre Beobachtungen zu finden und zu lesen werde ich ebenfalls versuchen 16:58 &lt;jrandom&gt; aber schön zu hören, dass der Startup-Fix drin ist 16:58 &lt;jrandom&gt; ah, alles klar 16:58 &lt;+Complication&gt; =ist das 16:58 &lt;+Complication&gt; Ich kann derzeit jedoch nicht bestätigen, ob Mainline-Phex ihn hat oder nicht – habe ihn dort persönlich nie gesehen 16:59 &lt;jrandom&gt; (sporadische Bugs)-- 16:59 &lt;+Complication&gt; Es ist schwer, ihn kontrolliert hervorzurufen, und daher schwer zu finden 17:00 &lt;+Complication&gt; Und von meiner Seite war's das fürs Erste 17:00 &lt;+Complication&gt; Später habe ich mich gefragt, ob es sinnvoll wäre, die Anzahl der parallelen Peer-Kontaktversuche zu begrenzen, die I2Phex auf einmal abfeuert 17:01 &lt;jrandom&gt; ja, wahrscheinlich 17:01 &lt;+Complication&gt; Weil sie in kurzer Zeit eine ganze Menge NetDB-Lookups erzeugen würden, was aus Sicht eines I2P router potenziell nicht so schön ist 17:02 &lt;jrandom&gt; und neue Destination-Kontakte benötigen elG statt aes 17:02 &lt;+Complication&gt; Aber ich habe noch keinen Code dafür gelesen oder geschrieben 17:04 &lt;jrandom&gt; ok, kein Problem.  vielleicht bringt der mythische i2phex/phex-Merge eine Lösung mit :) 17:04 &lt;+Complication&gt; Und von meiner Seite war's das an Neuigkeiten von der I2Phex-Front... 17:04 &lt;jrandom&gt; cool, danke für das Update und die Mühe beim Nachforschen! 17:05 &lt;jrandom&gt; ok, springen wir weiter zu 3) ??? 17:05 &lt;jrandom&gt; hat noch jemand etwas für das Meeting? 17:05 &lt;lsmith&gt; hallo! ich möchte die devs nur für die fantastischen Verbesserungen im neuesten Release loben, meine Gesamtbandbreite zeigt 0.9/1.4 KBps und ich bleibe mit irc verbunden... das ist... wahnsinnig cool :) 17:05 &lt;+Complication&gt; :D 17:06 &lt;jrandom&gt; danke für eure Geduld auf dem Weg – die Unterstützung von Nutzern mit niedriger Bandbreite ist entscheidend 17:06 &lt;@cervantes&gt; lsmith: das ist wirklich gut zu 17:06 &lt;@cervantes&gt; * Verbindung zurückgesetzt 17:06 &lt;jrandom&gt; heh 17:07 &lt;lsmith&gt; :) 17:09 &lt;jrandom&gt; oh, eine weitere bemerkenswerte Sache ist, dass zzz zurück ist, und mit ihm kommt stats.i2p :) 17:09 &lt;jrandom&gt; [wewt] 17:11 &lt;+Complication&gt; Eine ziemlich nützliche Quelle für Vergleichsdaten :) 17:11 &lt;jrandom&gt; definitiv 17:11 &lt;jrandom&gt; ok, hat noch jemand etwas für das Meeting? 17:13 &lt;jrandom&gt; wenn nicht... 17:13 &lt;jdot&gt; ich habe ein oder zwei Post-baf-Fragen 17:13 &lt;jrandom&gt; heh ok, dann bringen wir den Baffer ins Rollen :) 17:13  * jrandom holt aus... 17:13  * jrandom *baf*t das Meeting zu </div>
