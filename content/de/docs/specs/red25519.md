---
title: "Red25519-Signaturschema"
description: "Re-randomisierbares Signaturschema zur Erzeugung verblindeter Destinations (I2P-Zieladressen)"
slug: "red25519"
lastUpdated: "2025-10"
accurateFor: "2.10.0"
---

## Übersicht

Dieses Dokument spezifiziert ein re-randomisierbares Signaturschema, das sich zur Erstellung von Destinations (I2P-Zieladressen) eignet, die verblindet werden können. Zusätzlich kann es verwendet werden, um bestehende Ed25519 Destinations zu verblinden, mit einer leichten Verringerung der Wirksamkeit.

Red25519 (ein auf Ed25519 basierendes RedDSA-Signaturschema) ist seit Version 0.9.39 (veröffentlicht am 21. März 2019) in I2P routers voll funktionsfähig. Diese Spezifikation wurde nach 17 Monaten produktiven Einsatzes in Version 0.9.47 (August 2020) finalisiert. Das Signaturschema wird im I2P-Netzwerk als Signaturtyp 11 (RedDSA_SHA512_Ed25519) eingesetzt.

## Motivation

Vorschlag 123 (Neue netDB-Einträge) definiert ein verschlüsseltes LeaseSet2-Format, das das Prinzip der geringsten Autorität verkörpert: Jeder Netzwerkteilnehmer erhält nur die Informationen, die für seine Rolle erforderlich sind. Insbesondere offenbart ein verschlüsseltes LeaseSet2, das bei einem floodfill veröffentlicht wird, nicht, für welche Destination (Zielidentität) es bestimmt ist, und die Leases können nur von jemandem eingesehen werden, der die Destination bereits kennt. Floodfills müssen jedoch weiterhin die verschlüsselten LeaseSet2s bei der Veröffentlichung authentifizieren können, und Clients müssen zusätzlich sicherstellen, dass die Authentifizierung von der Destination selbst erzwungen wurde.

Vorschlag 123 erreicht dies, indem die Signierschlüssel der Destinations (I2P‑Adressen) verblindet werden. Die verblindeten Schlüssel können verwendet werden, um Signaturen zu erzeugen, die von floodfills verifizierbar sind, und Clients können sicher sein, dass nur die Destination die Signaturen erzeugt haben kann. Es ist daher notwendig, ein Signaturschema festzulegen, das zum Verblinden verwendet werden kann.

**Hinweis zum Status von Vorschlag 123**: Teile von Vorschlag 123 wurden seit Version 0.9.38 schrittweise implementiert und bereitgestellt, wobei Unterstützung für Red25519 in 0.9.39 hinzugefügt wurde. Die verschlüsselte LeaseSet2-Funktionalität ist produktionsreif und wird im I2P-Netzwerk aktiv für datenschutzverbesserte versteckte Dienste eingesetzt.

## Entwurf

### Kern-Signaturverfahren

Das hier spezifizierte Signaturschema, Red25519, ist eine Instanziierung von RedDSA, wie in Abschnitt 5.4.6 der Zcash Protocol Specification (Sapling und später) definiert. RedDSA ist ein Schnorr-basiertes Signaturverfahren, das die Schlüssel-Re-Randomisierung unterstützt. Es bietet die folgenden Funktionen:

**GENERATE_PRIVATE()** : Gibt einen gleichverteilten privaten Schlüssel zurück.

**DERIVE_PUBLIC(sk)** : Gibt den öffentlichen Schlüssel zurück, der dem angegebenen privaten Schlüssel entspricht.

**GENERATE_RANDOM()** : Gibt einen zufälligen Skalar zurück, der zur erneuten Randomisierung eines Schlüsselpaars geeignet ist.

**RANDOMIZE_PRIVATE(sk, alpha)** : Randomisiert einen privaten Schlüssel erneut, mit einem geheimen Skalar alpha.

**RANDOMIZE_PUBLIC(vk, alpha)** : Randomisiert einen öffentlichen Schlüssel erneut, unter Verwendung eines geheimen Skalars alpha.

**SIGN(sk, m)** : Gibt eine Signatur mit dem privaten Schlüssel sk über die angegebene Nachricht m zurück.

**VERIFY(vk, m, sig)** : Überprüft die Signatur sig anhand des öffentlichen Schlüssels vk und der Nachricht m. Gibt true zurück, wenn die Signatur gültig ist, andernfalls false.

Für ein gegebenes Schlüsselpaar (sk, vk) gilt die folgende Beziehung:

```
RANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha))
```
### Umwandlung von Ed25519-Schlüsseln in Red25519

Ed25519-Schlüssel DÜRFEN vorübergehend mittels Einweg-Umwandlung in Red25519-Schlüssel konvertiert werden, um die erneute Randomisierung bestehender Ed25519 Destinations (I2P-Zieladressen) zu unterstützen. Andere Signaturtypen sind nicht kompatibel.

Wir definieren die folgenden Konvertierungsfunktionen:

**CONVERT_ED25519_PRIVATE(privkey)** : Gibt den Red25519-Privatschlüssel zurück, der dem angegebenen Ed25519-Privatschlüssel entspricht.

**CONVERT_ED25519_PUBLIC(pubkey)** : Gibt den Red25519-öffentlichen Schlüssel zurück, der dem angegebenen Ed25519-öffentlichen Schlüssel entspricht.

Für ein gegebenes Ed25519-Schlüsselpaar (privkey, pubkey) gilt die folgende Beziehung:

```
CONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey))
```
## Spezifikation

### Definitionen

**B** : Der Ed25519-Basispunkt wie in [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html) beschrieben.

**L** : Die Ed25519-Ordnung 2^252 + 27742317777372353535851937790883648493 wie in [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html).

**[s] B** : Skalarmultiplikation mit fester Basis des Basispunkts mit dem Skalar s.

**[s] A** : Skalarmultiplikation mit variabler Basis von A mit dem Skalar s.

**x || y** : Verkettet zwei Byte-Arrays x und y.

### Red25519

Das Schema Red25519 ist eine Spezialisierung von RedDSA mit:

- G := die Gruppe der Punkte auf der Edwards-Form von Curve25519. Insbesondere bedeutet dies, dass Red25519 die Untergruppe von Primzahlordnung mit Ordnung L verwendet und der Kofaktor h_G 8 ist.
- P_G := der Ed25519-Basispunkt B.
- l_H := 512
- H(x) := SHA-512("I2P_Red25519H(x)" || x)

**Hinweis zur Wahl der Hashfunktion**: Red25519 verwendet SHA-512 statt BLAKE2b-512 (wie es in Zcash RedDSA verwendet wird). Diese Designentscheidung wird durch den unten beschriebenen Schutz durch Längenpräfixierung kompensiert. I2P Proposal 148 schlägt eine zukünftige Migration zu BLAKE2b-512 vor, um den Schutz vor Erkennung doppelter Nachrichten (DMI) und Längenverlängerungsangriffen (LEA) zu verbessern sowie die Leistung zu steigern.

RedDSA setzt voraus, dass H(x) mit einer kryptografischen Hashfunktion instanziiert wird, die gegen Längenerweiterungsangriffe sicher ist. SHA-512 erfüllt dies nicht von selbst. Um dem abzuhelfen, verlangen wir, dass den Nachrichten eine präfixfreie Kodierung ihrer Länge vorangestellt wird:

```
len_u16(M) || M
```
wobei `len_u16(M)` die 2-Byte-Darstellung der Länge von M im Little-Endian-Format ist (um mit der Little-Endian-Kodierung von Skalaren und Punkten konsistent zu sein).

Nachrichten dürfen nicht länger als 65534 Bytes sein. Eine Länge von 65535 ist für mögliche zukünftige Erweiterungen reserviert.

**Sicherheitshinweis**: Die Einbeziehung des öffentlichen Schlüssels (vk) in die Hashfunktion, kombiniert mit 80 zufälligen Bytes bei der Signierung, gewährleistet Schutz vor SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack; starke Nichtfälschbarkeit mit re-randomisierten Schlüsseln unter gewähltem Nachrichtenangriff)‑Schwachstellen, die in frühen RedDSA-Designs entdeckt wurden. Diese Implementierung integriert die Sicherheitskorrekturen aus dem NCC Group Zcash Audit (Finding NCC-Zcash2018-009).

### Kodierung und Dekodierung

Red25519-Privatschlüssel sind Skalare mod L, die in Little-Endian-Darstellung kodiert sind. Wir definieren die Funktionen `DECODE_SCALAR` und `ENCODE_SCALAR` zur Umwandlung zwischen der Byte-Array- und der Ganzzahlform eines Skalars.

Öffentliche Red25519-Schlüssel sind Punkte auf der Edwards-Form von Curve25519. Sie werden als 255-Bit-Little-Endian-Darstellung der y-Koordinate kodiert, gefolgt von einem einzelnen Bit, das das Vorzeichen der x-Koordinate angibt. Dies ist dieselbe Kodierung wie bei Ed25519. Wir definieren die Funktionen `DECODE_POINT` und `ENCODE_POINT`, um zwischen der Byte-Array- und der Koordinatenform eines Punktes zu wechseln.

### Funktionen von RedDSA (kryptografisches Signaturverfahren)

Zur Erleichterung der Implementierung geben wir nachfolgend die RedDSA-Funktionen (Signaturschema) sowie mehrere Hilfsfunktionen explizit in der bereits für Red25519 (RedDSA-Variante über Ed25519) spezialisierten Form an. Implementierende sollten für die allgemeine Spezifikation der RedDSA-Funktionen Abschnitt 5.4.6 der Zcash-Protokollspezifikation konsultieren.

```
HStar(prefix1, prefix2, m) :=
    h = SHA-512()
    h.input("I2P_Red25519H(x)")
    h.input(prefix1)
    h.input(prefix2)

    h.input(len(m) & 0xff)
    h.input((len(m) >> 8) & 0xff)
    h.input(m)

    s = h.digest()
    return s mod L

GENERATE_PRIVATE :=
    s = 64 random bytes
    return s mod L

DERIVE_PUBLIC(sk) := [sk] B

GENERATE_RANDOM :=
    s = 64 random bytes
    return s mod L

RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L

RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B

SIGN(sk, m) :=
    T = 80 random bytes
    vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk))
    r = HStar(T, vkBytes, m)

    R = [r] B
    Rbytes = ENCODE_POINT(R)

    c = HStar(Rbytes, vkBytes, m)
    S = (r + (c * sk)) mod L

    return Rbytes || ENCODE_SCALAR(S)

VERIFY(vk, m, sig) :=
    Rbytes = sig[0..32]
    Sbytes = sig[32..64]

    R = DECODE_POINT(Rbytes)
    if R is invalid:
        return false

    S = DECODE_SCALAR(Sbytes)
    if S >= L:
        return false

    vkBytes = ENCODE_POINT(vk)
    c = HStar(Rbytes, vkBytes, m)
    return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity()
```
### Konvertierungsfunktionen

```
CONVERT_ED25519_PRIVATE(privkey) :=
    s = SHA-512(privkey)[0..32]
    s[0] = s[0] & 248
    s[31] = (s[31] & 63) | 64
    return s

CONVERT_ED25519_PUBLIC(pubkey) := pubkey
```
Beachten Sie, dass die Implementierung von `CONVERT_ED25519_PRIVATE` der Berechnung des geheimen Skalars s entspricht, die beim Ableiten eines Ed25519-öffentlichen Schlüssels aus einem Ed25519-privaten Schlüssel erfolgt, wie in den Schritten 1-3 in Abschnitt 5.1.5 von [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html) spezifiziert.

## Sicherheitsauswirkungen

Die Re-Randomisierung einer Red25519 Destination (Zielidentität im I2P‑Netz) und das anschließende Erzeugen von Signaturen damit gibt keine Informationen über die Destination preis, weil die Verteilung der mittels `RANDOMIZE_PRIVATE` erzeugten Red25519-Privatschlüssel identisch mit der Verteilung der mittels `GENERATE_PRIVATE` erzeugten Privatschlüssel ist und `DERIVE_PUBLIC` deterministisch ist.

Die Umwandlung von Ed25519-Privatschlüsseln zu Red25519 über `CONVERT_ED25519_PRIVATE` führt nicht zur gleichen Verteilung. Wir halten die Verringerung der Sicherheit jedoch aus den folgenden Gründen für akzeptabel:

- Der Raum der Ed25519-Skalare ist ungefähr halb so groß wie der Raum der Red25519-Skalare (es gibt 2^251 mögliche Ed25519-Skalare, und L ~= 2^252 mögliche Red25519-Skalare). Daher beträgt der Sicherheitsverlust höchstens ungefähr den Faktor 2 bzw. etwa 1 Bit (weil wir zufällig einen Red25519-Skalar gewählt haben könnten, der auch ein gültiger Ed25519-Skalar ist).
- Bestehende Ed25519-Destinations (Ziele) waren in der Vergangenheit im Netzwerk sichtbar, und es sollte davon ausgegangen werden, dass bösartige floodfills sie bereits aufgelistet haben.

**Wichtig**: Benutzer, die sich wegen dieser Verringerung der Sicherheit Sorgen machen, sollten Red25519 (Signaturtyp 11) als Signaturtyp für ihre Destinations (I2P-Zieladressen) verwenden statt Ed25519 (Signaturtyp 7).

Beachten Sie, dass das obige Argument nicht auf den Re-Randomisierungs-Skalar alpha zutrifft; Informationen über den Schlüssel werden jedes Mal preisgegeben, wenn alpha mit Verzerrung gewählt wird, da sich additive Re-Randomisierung wie ein One-Time Pad (Einmalschlüssel) verhält.

### Status des Sicherheitsaudits

**Wichtiger Hinweis**: I2P, einschließlich Red25519, ist niemals einer formalen Sicherheitsprüfung durch Dritte unterzogen worden. Das zugrunde liegende RedDSA-Design wurde 2018 von der NCC Group im Rahmen des Audits des Zcash-Sapling-Protokolls einer Sicherheitsüberprüfung unterzogen, wobei Sicherheitsprobleme identifiziert und behoben wurden. Die spezifische I2P-Instanziierung mit SHA-512 (anstelle von BLAKE2b-512) und der I2P domain separation (Domänenseparation) wurde jedoch nicht unabhängig analysiert.

Die ed25519-java-Referenzimplementierung von str4d wurde einem unabhängigen Audit durch Dritte unterzogen, jedoch ging dies der Red25519-Implementierung voraus und deckte nur die Ed25519-Funktionalität ab, nicht die Red25519-Erweiterungen.

Anwender, die Red25519 einsetzen, sollten diese Einschränkung verstehen und die Sicherheitsabwägungen auf Grundlage ihres Bedrohungsmodells bewerten.

## Kompatibilität

I2P-Versionen, die Red25519 (ein Signaturalgorithmus) unterstützen (Version 0.9.39 und höher), können Netzwerkdatenstrukturen verifizieren, die damit signiert sind. I2P-Versionen, die Red25519 nicht unterstützen, behandeln es als unbekannte Signatur und KÖNNEN die Datenstrukturen verwerfen.

**Bereitstellungszeitplan**: - **0.9.39** (März 2019): Erste Implementierung mit Unterstützung für Encrypted LS2 in floodfills - **0.9.40** (Mai 2019): Pro-Client-Autorisierung für Encrypted LS2 - **0.9.41** (August 2019): Meta LS2 und Encrypted LS2 mit Offline-Schlüsseln - **0.9.43** (Februar 2020): b32-Unterstützung für Encrypted LS2 - **0.9.47** (August 2020): Finalisierung der Spezifikation - **2.10.0** (Oktober 2025): Aktuelle Netzwerkversion (entspricht 0.9.67+)

Nutzer sollten erwarten, dass die Zuverlässigkeit von Red25519-signierten Datenstrukturen für Anwendungsfälle mit Encrypted LeaseSet2 gut ist, da das Netzwerk seit der ersten Implementierung über sechs Jahre Zeit für Aktualisierungen hatte. Allerdings sind Adoptionskennzahlen zur allgemeinen Destination (Zieladresse)-Nutzung nicht öffentlich verfügbar.

**Hauptanwendungsfall**: Red25519 wird in erster Linie für die verschlüsselte LeaseSet2-Funktionalität verwendet, bei der Schlüsselblindung erforderlich ist. Für Standard-Destinationen ohne Anforderungen an ein verschlüsseltes leaseset bleibt Ed25519 (Signaturtyp 7) aufgrund der breiteren Kompatibilität und der längeren bewährten Erfolgsbilanz die empfohlene Wahl.

## Hinweise zur Implementierung

Red25519 ist im I2P Java router unter `net.i2p.crypto.eddsa.RedDSAEngine` implementiert und verwendet die ed25519-java-Bibliothek von str4d (Jack Grigg) als Maven-Abhängigkeit `net.i2p.crypto:eddsa` (Versionen 0.1.0 bis 0.3.0).

Die i2pd-C++-Implementierung unterstützt auch Red25519 (signaturetype=11) für die Veröffentlichung verschlüsselter LeaseSets.

Beispielkonfiguration für i2pd:

```
signaturetype=11
i2cp.leaseSetType=5
```
**Kompatibilität von Encrypted LeaseSet2**: Die Encrypted LeaseSet-Spezifikation erfordert, dass der öffentliche Signierschlüssel in der unverblindeten Destination (Zieladresse) Ed25519 (Signaturtyp 7) oder Red25519 (Signaturtyp 11) sein muss. Keine anderen Signaturtypen werden für die verschlüsselte leaseset-Funktionalität unterstützt.

## Testvektoren

Die folgenden Testvektoren werden zur Validierung der Implementierung bereitgestellt. Jeder Vektor enthält:

- `edsk`: Privater Ed25519-Schlüssel (zufällig)
- `edpk`: Öffentlicher Ed25519-Schlüssel, der zu edsk gehört
- `sk`: CONVERT_ED25519_PRIVATE(edsk)
- `vk`: CONVERT_ED25519_PUBLIC(edpk)
- `msg`: Zu signierende Nachricht
- `sig`: SIGN(sk, msg)
- `alpha`: GENERATE_RANDOM()
- `rsk`: RANDOMIZE_PRIVATE(sk, alpha)
- `rvk`: RANDOMIZE_PUBLIC(vk, alpha)
- `rsig`: SIGN(rsk, msg)

**Implementierungshinweis**: Diese Testvektoren sollten zur kontinuierlichen Validierung in automatisierte Unit-Test-Suiten integriert werden. Implementierende sollten überprüfen, dass alle Konvertierungen, Signaturen und Re-Randomisierungsoperationen mit diesen erwarteten Werten übereinstimmen.

### Testvektor 1

```
edsk:  0101010101010101010101010101010101010101010101010101010101010101
edpk:  8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c
sk:    58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e
vk:    8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c
msg:   0202020202020202020202020202020202020202020202020202020202020202
sig:   61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a
       6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f
alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08
rsk:   8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107
rvk:   6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3
rsig:  533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5
       b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001
```
### Testvektor 2

```
edsk:  0202020202020202020202020202020202020202020202020202020202020202
edpk:  8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394
sk:    a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e
vk:    8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394
msg:   0303030303030303030303030303030303030303030303030303030303030303
sig:   0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d
       5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a
alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203
rsk:   9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402
rvk:   527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177
rsig:  9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51
       3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f
```
**Hinweis**: Zusätzliche Testvektoren 3–10 folgen demselben Format und sind in der Referenzimplementierung zu finden.

## Referenzen

- [Vorschlag 123: Neue netDB-Einträge](/proposals/123-new-netdb-entries/) - Teilweise in 0.9.38, 0.9.39 und späteren Versionen implementiert und bereitgestellt
- [Zcash-Protokollspezifikation, Abschnitt 5.4.6: RedDSA, RedJubjub und RedPallas](https://zips.z.cash/protocol/protocol.pdf) - RedDSA (Signaturverfahren) ist als Teil der Zcash-Protokollspezifikation definiert; Sicherheitsaudit durch die NCC Group (Januar 2019)
- [RFC 8032: Edwards-Kurven-Digitalsignatur-Algorithmus (EdDSA)](https://www.rfc-editor.org/rfc/rfc8032.html)
- [Vorschlag 148: RedDSA-BLAKE2b-Ed25519](/proposals/148-eddsa-blake2b-ed25519/) - Vorgeschlagen, aber noch nicht implementiert; schlägt eine zukünftige Migration auf BLAKE2b-512 vor
- [Spezifikation für verschlüsseltes LeaseSet](/docs/specs/encryptedleaseset/)
- [Spezifikation für Kryptografie auf niedriger Ebene](/docs/specs/cryptography/)
