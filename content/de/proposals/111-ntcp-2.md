---
title: "NTCP 2"
number: "111"
author: "EinMByte, orignal, psi, str4d, zzz"
created: "2014-02-13"
lastupdated: "2019-08-13"
status: "Closed"
thread: "http://zzz.i2p/topics/1577"
supercedes: "106"
target: "0.9.36"
implementedin: "0.9.36"
editor: "manas, str4d, zzz"
---

## Hinweis
Vorschlagsphase ist geschlossen.
Siehe [SPEC](/en/docs/spec/ntcp2/) für die offizielle Spezifikation.
Dieser Vorschlag kann immer noch für Hintergrundinformationen herangezogen werden.


## Überblick

Dieser Vorschlag beschreibt ein authentifiziertes Schlüsselvereinbarungsprotokoll zur Verbesserung des Widerstands von [NTCP](/en/docs/transport/ntcp/) gegen verschiedene Formen automatisierter Identifikation und Angriffe.

Der Vorschlag ist wie folgt gegliedert: Die Sicherheitsziele werden vorgestellt, gefolgt von einer Diskussion über das grundlegende Protokoll. Anschließend wird eine vollständige Spezifikation aller Protokollnachrichten gegeben. Schließlich werden Router-Adressen und Versionsidentifikation diskutiert. Ein Anhang, der einen generischen Angriff auf übliche Polsterungsschemata diskutiert, ist ebenfalls enthalten, sowie ein Anhang mit einer Reihe von Kandidaten für das authentifizierte Chiffre.

Wie bei anderen I2P-Transporten ist NTCP2 ausschließlich für den Punkt-zu-Punkt-Transport (Router-zu-Router) von I2NP-Nachrichten definiert. Es ist keine Datenleitung für allgemeine Zwecke.


## Motivation

Die [NTCP](/en/docs/transport/ntcp/) Daten werden nach der ersten Nachricht verschlüsselt (und die erste Nachricht erscheint als zufällige Daten), was eine Protokollidentifikation durch "Payload-Analyse" verhindert. Es ist weiterhin anfällig für Protokollidentifikation durch "Flow-Analyse". Das liegt daran, dass die ersten 4 Nachrichten (also der Handshake) eine feste Länge haben (288, 304, 448 und 48 Bytes).

Indem zufällige Mengen an Zufallsdaten zu jeder der Nachrichten hinzugefügt werden, können wir es erheblich erschweren.

Die Autoren erkennen an, dass Standard-Sicherheitspraktiken vorschlagen würden, ein vorhandenes Protokoll wie TLS zu verwenden, aber dies ist [Prop104](/en/proposals/104/) und es hat seine eigenen Probleme. Wo immer geeignet, wurden "Zukunftsarbeit"-Absätze hinzugefügt, um fehlende Funktionen oder Diskussionsthemen anzuzeigen.


## Designziele

- Unterstützung von NTCP 1 und 2 auf einem einzigen Port, automatische Erkennung und Veröffentlichung als ein einziger "Transport" (d. h. [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) im [NetDB](/en/docs/how/network-database/).

- Unterstützung für Version 1 nur, 2 nur oder 1+2 im NetDB in einem separaten Feld veröffentlichen und standardmäßig nur auf Version 1 festlegen (binden Sie die Versionsunterstützung nicht an eine bestimmte Routerversion)

- Sicherstellen, dass alle Implementierungen (Java/i2pd/Kovri/go) die Unterstützung für Version 2 (oder nicht) nach ihren eigenen Zeitplänen hinzufügen können

- Zufällige Polsterung zu allen NTCP-Nachrichten einschließlich Handshake und Datennachrichten hinzufügen (d. h. Längenverschleierung, damit alle Nachrichten keine Vielfache von 16 Bytes sind). Mechanismus zur Bereitstellung von Optionen für beide Seiten, um minimale und maximale Polsterung und/oder Polsterungsverteilung anzufordern. Die spezifischen Polsterungsverteilungen sind implementierungsabhängig und müssen im Protokoll selbst möglicherweise nicht spezifiziert sein.

- Den Inhalt von Nachrichten, die nicht verschlüsselt sind (1 und 2), so verschleiern, dass DPI-Boxen und AV-Signaturen sie nicht leicht klassifizieren können. Stellen Sie außerdem sicher, dass die Nachrichten zu einem einzelnen Partner oder einer Gruppe von Partnern kein ähnliches Bitmuster aufweisen.

- Verlust von Bits in DH aufgrund des Java-Formats [Ticket1112](https://trac.i2p2.i2p/ticket/1112) beheben, möglicherweise (wahrscheinlich?) durch Umstellung auf X25519.

- Zu einer echten Schlüsselableitungsfunktion (KDF) wechseln, anstatt das DH-Ergebnis unverändert zu verwenden?

- "Sondierungsresistenz" hinzufügen (wie Tor es nennt); dies beinhaltet Wiedergaberesistenz.

- Zweiwege-authentifizierten Schlüsselaustausch (2W-AKE) beibehalten. 1W-AKE ist für unsere Anwendung nicht ausreichend.

- Weiterhin die variablen Typen, variablen Signaturlängen (aus dem veröffentlichten [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) Signaturschlüssel) als Teil der Authentifizierung verwenden. Verlassen Sie sich auf einen statischen öffentlichen Schlüssel, der in der RouterInfo als ein weiterer Teil der Authentifizierung veröffentlicht ist.

- Optionen/Version im Handshake für zukünftige Erweiterbarkeit hinzufügen.

- Widerstand gegen böswillige MitM-TCP-Segmentierung, wenn möglich, hinzufügen.

- Fügen Sie nicht erheblich CPU-Belastung für die Verbindungsherstellung hinzu; reduzieren Sie sie nach Möglichkeit erheblich.

- Nachrichten-Authentifizierung (MAC) hinzufügen, möglicherweise HMAC-SHA256 und Poly1305, und Adler-Prüfsumme entfernen.

- I2NP-Header verkürzen und vereinfachen:
  Verfallszeit auf 4 Bytes verkürzen, wie in SSU.
  Ein-Byte-verkürzte SHA256-Prüfsumme entfernen.

- Wenn möglich, reduzieren Sie den 4-Nachrichten-, zwei-Roundtrip-Handshake auf einen 3-Nachrichten-, ein-Roundtrip-Handshake, wie in [SSU](/en/docs/transport/ssu/). Dies würde erfordern, Bobs Signatur in Nachricht 4 in Nachricht 2 zu verschieben. Untersuchen Sie den Grund für 4 Nachrichten in den zehn Jahre alten E-Mail-/Status-/Meeting-Archiven.

- Reduzieren Sie den Protokoll-Overhead vor dem Polstern. Während Polsterung hinzugefügt wird und möglicherweise viel davon, bleibt der Overhead vor dem Polstern immer noch Overhead. Knoten mit geringer Bandbreite müssen NTCP2 verwenden können.

- Zeitstempel für Wiedergabe- und Verzögerungserkennung beibehalten.

- Vermeiden Sie jegliche Jahr-2038-Probleme in Zeitstempeln, muss bis mindestens 2106 funktionieren.

- Maximale Nachrichtengröße von 16K auf 32K oder 64K erhöhen.

- Neue kryptographische Primitive sollten in Bibliotheken für die Verwendung in Java (1.7), C++ und Go-Router-Implementierungen problemlos verfügbar sein.

- Vertreter von Java-, C++- und Go-Router-Entwicklern in das Design einbeziehen.

- Änderungen minimieren (aber es wird trotzdem viele geben).

- Unterstützen Sie beide Versionen in einem gemeinsamen Codesatz (dies ist möglicherweise nicht möglich und ist in jedem Fall implementierungsabhängig).


### Nicht-Ziele

- Abhör-Festigkeit... das wären anschließbare Transporte, [Prop109](/en/proposals/109/).

- Ein TLS-basierter (oder HTTPS-ähnlicher) Transport... das wäre [Prop104](/en/proposals/104/).

- Es ist in Ordnung, die symmetrische Stream-Verschlüsselung zu ändern.

- Timing-basierte DPI-Resistenz (zwischen Nachrichten Timings/Verzögerungen können implementierungsabhängig sein; innerhalb einer Nachricht Verzögerungen können jederzeit, einschließlich vor dem Senden der Zufallspolsterung, eingeführt werden). Künstliche Verzögerungen (was obfs4 IAT oder Zwischenankunftszeit nennt) sind unabhängig vom Protokoll selbst.

- Abstreitbarkeit der Teilnahme an einer Sitzung (es sind Signaturen vorhanden).

Nicht-Ziele, die teilweise neu überdacht oder diskutiert werden können:

- Der Grad des Schutzes gegen Deep Packet Inspection (DPI)

- Post-Quantum (PQ) Sicherheit

- Abstreitbarkeit



### Verwandte Ziele

- Eine NTCP 1/2 Testumgebung implementieren


## Sicherheitsziele

Wir betrachten drei Parteien:

- Alice, die eine neue Sitzung etablieren möchte.
- Bob, mit dem Alice eine Sitzung aufbauen möchte.
- Mallory, der "Mann in der Mitte" zwischen Alice und Bob.

Maximal zwei Teilnehmer können aktive Angriffe durchführen.

Alice und Bob sind beide im Besitz eines statischen Schlüsselpaares, das in ihrem [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) enthalten ist.

Das vorgeschlagene Protokoll versucht, Alice und Bob zu erlauben, einen gemeinsamen geheimen Schlüssel (K) zu vereinbaren, unter den folgenden Anforderungen:

1) Sicherheit des privaten Schlüssels: Weder Bob noch Mallory erfahren etwas über Alices statischen privaten Schlüssel. Symmetrisch erfährt Alice nichts über Bobs statischen privaten Schlüssel.

2) Der Sitzungsschlüssel K ist nur Alice und Bob bekannt.

3) Perfekte Vorwärtsgeheimhaltung: der vereinbarte Sitzungsschlüssel bleibt auch dann geheim, wenn die statischen privaten Schlüssel von Alice und/oder Bob nachträglich bekannt werden.

4) Zweiseitige Authentifizierung: Alice ist sich sicher, dass sie eine Sitzung mit Bob aufgebaut hat, und umgekehrt.

5) Schutz gegen Online-DPI: Sicherstellen, dass es nicht trivial ist zu erkennen, dass Alice und Bob das Protokoll nutzen, nur mit einfachen Deep Packet Inspection (DPI) Techniken. Siehe unten.

6) Begrenzte Abstreitbarkeit: Weder Alice noch Bob können die Teilnahme am Protokoll leugnen, aber wenn einer den gemeinsamen Schlüssel preisgibt, kann die andere Partei die Echtheit des Inhalts der übertragenen Daten leugnen.

Der vorliegende Vorschlag versucht, alle fünf Anforderungen auf der Basis des Station-To-Station (STS) Protokolls [STS]_ zu erfüllen. Beachten Sie, dass dieses Protokoll auch die Grundlage für das [SSU](/en/docs/transport/ssu/) Protokoll ist.


### Zusätzliche DPI-Diskussion

Wir gehen von zwei DPI-Komponenten aus:

1) Online-DPI
`````````````

Online-DPI untersucht alle Datenströme in Echtzeit. Verbindungen können blockiert oder anderweitig manipuliert werden. Verbindungsdaten oder Metadaten können identifiziert und zur Offline-Analyse gespeichert werden. Das Online-DPI hat keinen Zugriff auf die I2P-Netzwerkdatenbank. Das Online-DPI hat nur begrenzte Echtzeit-Berechnungsfähigkeit, einschließlich Längenberechnung, Felderinspektion und einfacher Berechnungen wie XOR.  Das Online-DPI hat die Möglichkeit, schnelle Echtzeit-kryptographische Funktionen wie AES, AEAD und Hashing durchzuführen, aber diese wären zu teuer, um auf die meisten oder alle Datenströme angewendet zu werden. Jede Anwendung dieser kryptographischen Operationen würde nur auf Flows angewendet, die zuvor durch Offline-Analyse identifiziert wurden.  Das Online-DPI verfügt nicht über die Fähigkeit von kryptographischen Hochleistungsfunktionen wie DH oder elligator2.  Das Online-DPI nicht speziell für die Erkennung von I2P entwickelt, obwohl es möglicherweise eingeschränkte Klassifizierungsregeln dafür hat.

Es ist ein Ziel, die Protokollidentifizierung durch ein Online-DPI zu verhindern.

Der Begriff Online-DPI oder "einfache" DPI umfasst hier die folgenden Angreiferfähigkeiten:

1) Die Fähigkeit, alle gesendeten oder empfangenen Daten des Ziels zu inspizieren.

2) Die Fähigkeit, Operationen an den beobachteten Daten durchzuführen, wie z. B. das Anwenden von Blockchiffren oder Hash-Funktionen.

3) Die Fähigkeit, Daten zu speichern und mit zuvor gesendeten Nachrichten zu vergleichen.

4) Die Fähigkeit, Pakete zu verändern, zu verzögern oder zu fragmentieren.

Jedoch wird angenommen, dass das Online-DPI die folgenden Einschränkungen hat:

5) Die Unfähigkeit, IP-Adressen den Router-Hashes zuzuordnen. Während dies mit Echtzeitzugriff auf die Netzwerkdatenbank trivial ist, würde es ein DPI-System erfordern, das speziell darauf ausgelegt ist, I2P anzuvisieren.

6) Die Unfähigkeit, Timing-Informationen zur Erkennung des Protokolls zu nutzen. 

7) Im Allgemeinen enthält das Online-DPI-Werkzeugkasten keine eingebauten Tools, die speziell für die I2P-Erkennung entwickelt wurden. Dies schließt das Erstellen von "Honeypots" ein, die beispielsweise nicht-randomisierte Polsterung in ihre Nachrichten einfügen würden. Beachten Sie, dass dies Maschinelles Lernen oder hochgradig konfigurierbare DPI-Tools nicht ausschließt, solange sie die anderen Anforderungen erfüllen.

Um Payload-Analysen entgegenzuwirken, wird sichergestellt, dass alle Nachrichten von zufälligen nicht unterscheidbar sind. Dies erfordert auch, dass ihre Länge zufällig ist, was komplizierter ist als nur das Hinzufügen von zufälliger Polsterung. In der Tat argumentieren die Autoren in Anhang A, dass ein naives (d. h. gleichverteiltes) Polsterungsschema das Problem nicht löst. Anhang A schlägt daher vor, entweder zufällige Verzögerungen einzufügen oder ein alternatives Polsterungsschema zu entwickeln, das angemessenen Schutz für den vorgeschlagenen Angriff bietet.

Um dem sechsten Punkt oben entgegenzuwirken, sollten Implementierungen zufällige Verzögerungen im Protokoll einschließen. Solche Techniken werden in diesem Vorschlag nicht behandelt, könnten jedoch auch die Probleme der Polsterungslänge lösen. Zusammenfassend bietet der Vorschlag guten Schutz gegen Payload-Analyse (wenn die Überlegungen in Anhang A berücksichtigt werden), jedoch nur begrenzten Schutz gegen Flow-Analyse.


2) Offline-DPI
``````````````

Offline-DPI inspiziert die von der Online-DPI gespeicherten Daten zur späteren Analyse. Das Offline-DPI kann speziell für die Erkennung von I2P entwickelt sein. Das Offline-DPI hat in Echtzeit Zugriff auf die I2P-Netzwerkdatenbank. Das Offline-DPI hat Zugriff auf diese und andere I2P-Spezifikationen. Das Offline-DPI hat uneingeschränkte Berechnungsfähigkeit, einschließlich aller in dieser Spezifikation definierten kryptographischen Funktionen.

Das Offline-DPI hat nicht die Möglichkeit, bestehende Verbindungen zu blockieren.  Das Offline-DPI hat die Fähigkeit, in nahezu Echtzeit (innerhalb von Minuten nach der Einrichtung) an Host/Port von Parteien zu senden, zum Beispiel TCP RST.  Das Offline-DPI hat die Fähigkeit, in nahezu Echtzeit (innerhalb von Minuten nach der Einrichtung) die Wiedergabe früherer Nachrichten (modifiziert oder nicht) für "Sondierung" oder andere Gründe durchzuführen.

Es ist kein Ziel, die Protokollidentifizierung durch ein Offline-DPI zu verhindern. Alle von I2P-Routern implementierten Entschlüsselungen verschleierter Daten in den ersten beiden Nachrichten können auch vom Offline-DPI implementiert werden.

Es ist ein Ziel, Verbindungsversuche mit Wiedergabe vorheriger Nachrichten abzulehnen.


Zukunftsarbeit
`````````````

- Berücksichtigen Sie das Verhalten des Protokolls, wenn Pakete von einem Angreifer gelöscht oder umgeordnet werden. Aktuell interessante Arbeiten in diesem Bereich finden sich in [IACR-1150](https://eprint.iacr.org/2015/1150).

- Eine genauere Klassifizierung der DPI-Systeme liefern, unter Berücksichtigung der bestehenden Literatur zum Thema.

- Die formale Sicherheit des vorgeschlagenen Protokolls diskutieren, idealerweise unter Berücksichtigung des DPI-Angreifermodells.


## Noise-Protokollrahmen

Dieser Vorschlag erfüllt die Anforderungen basierend auf dem Noise-Protokollrahmen [NOISE](http://noiseprotocol.org/) (Revision 33, 2017-10-04). Noise hat ähnliche Eigenschaften wie das Station-To-Station-Protokoll [STS]_, das die Basis für das [SSU](/en/docs/transport/ssu/) ist. In der Noise-Terminologie ist Alice der Initiator und Bob der Empfänger.

NTCP2 basiert auf dem Noise-Protokoll Noise_XK_25519_ChaChaPoly_SHA256. (Der tatsächliche Bezeichner für die initiale Schlüsselableitungsfunktion ist "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256", um auf I2P-Erweiterungen hinzuweisen - siehe KDF 1 Abschnitt unten). Dieses Noise-Protokoll verwendet die folgenden Primitiven:

- Handshake-Muster: XK
  Alice überträgt ihren Schlüssel an Bob (X)
  Alice kennt den statischen Schlüssel von Bob bereits (K)

- DH-Funktion: X25519
  X25519 DH mit einer Schlüssellänge von 32 Bytes, wie in [RFC-7748](https://tools.ietf.org/html/rfc7748) spezifiziert.

- Chiffre-Funktion: ChaChaPoly
  AEAD_CHACHA20_POLY1305 wie in [RFC-7539](https://tools.ietf.org/html/rfc7539) Abschnitt 2.8 spezifiziert.
  12-Byte-Nonce, wobei die ersten 4 Bytes auf Null gesetzt sind.

- Hash-Funktion: SHA256
  Standard-32-Byte-Hash, der bereits umfangreich in I2P verwendet wird.


## Ergänzungen zum Framework

Dieser Vorschlag definiert die folgenden Erweiterungen von Noise_XK_25519_ChaChaPoly_SHA256. Diese folgen im Allgemeinen den Richtlinien in [NOISE](http://noiseprotocol.org/) Abschnitt 13.

1) Klartext-Ephemeralschlüssel werden mit AES-Verschlüsselung unter Verwendung eines bekannten Schlüssels und IV verschleiert. Dies ist schneller als elligator2.

2) Zufällige Klartext-Polsterung wird zu Nachrichten 1 und 2 hinzugefügt. Die Klartext-Polsterung wird in die Berechnung des Handshake-Hashes (MixHash) einbezogen. Siehe die KDF-Abschnitte unten für Nachricht 2 und Nachricht 3 Teil 1. Zufällige AEAD-Polsterung wird zu Nachricht 3 und Nachrichten der Datenphase hinzugefügt.

3) Ein zweibytegroßes Feld für die Rahmengröße wird hinzugefügt, wie es für Noise über TCP erforderlich ist und wie in obfs4. Dies wird nur in den Nachrichten der Datenphase verwendet. Nachrichten 1 und 2 AEAD-Rahmen haben eine feste Länge. Nachricht 3, Teil 1, AEAD-Rahmenlänge ist fest. Nachricht 3, Teil 2, AEAD-Rahmenlänge ist in Nachricht 1 angegeben.

4) Das zweibytegroße Feld für die Rahmengröße wird mit SipHash-2-4 verschleiert, wie in obfs4.

5) Das Payload-Format wird für Nachrichten 1, 2, 3 und die Datenphase definiert. Natürlich ist dies in Noise nicht definiert.


## Neue kryptographische Primitive für I2P

Bereits existierende I2P-Router-Implementierungen benötigen Implementierungen für die folgenden Standard-kryptographischen Primitive, die für aktuelle I2P-Protokolle nicht erforderlich sind:

1) X25519-Schlüsselerzeugung und DH

2) AEAD_ChaCha20_Poly1305 (abgekürzt als ChaChaPoly unten)

3) SipHash-2-4


## Verarbeitungskostenabschätzung

Nachrichtengrößen für die 3 Nachrichten:

1) 64 Bytes + Polsterung (NTCP waren 288 Bytes)
2) 64 Bytes + Polsterung (NTCP waren 304 Bytes)
3) ca. 64 Bytes + Alice-Routerinfo + Polsterung. Durchschnittliche Routerinfo ist etwa 750 Bytes. Gesamtdurchschnitt 814 Bytes vor dem Polstern (NTCP waren 448 Bytes)
4) nicht erforderlich in NTCP2 (NTCP waren 48 Bytes)

Gesamt vor dem Polstern:
NTCP2: 942 Bytes
NTCP: 1088 Bytes
Beachten Sie, dass, wenn Alice mit Bob verbunden ist, um eine DatabaseStore-Nachricht ihrer RouterInfo zu senden, diese Nachricht nicht erforderlich ist, was ungefähr 800 Bytes spart.

Die folgenden kryptographischen Operationen sind erforderlich, damit jede Partei den Handshake abschließt und die Datenphase startet:

- AES: 2
- SHA256: 7 (Alice), 6 (Bob) (ohne 1 Alice, 2 Bob vorab berechnet für alle Verbindungen) (ohne HMAC-SHA256)
- HMAC-SHA256: 19
- ChaChaPoly: 4
- X25519 Schlüsselerzeugung: 1
- X25519 DH: 3
- Signaturüberprüfung: 1 (Bob) (Alice hat bei der Erzeugung ihrer RI zuvor unterschrieben)
  Vermutlich Ed25519 (abhängig vom RI-Signaturtyp)


Die folgenden kryptographischen Operationen sind erforderlich, damit jede Partei für jede Datenphasenachricht:

- SipHash: 1
- ChaChaPoly: 1



## Nachrichten

Alle NTCP2 Nachrichten sind kleiner oder gleich 65537 Bytes lang. Das Nachrichtenformat basiert auf Noise-Nachrichten, mit Änderungen für Rahmung und Ununterscheidbarkeit. Implementierungen, die standardmäßige Noise-Bibliotheken verwenden, müssen möglicherweise empfangene Nachrichten vor/nach dem Noise-Nachrichtenformat vorverarbeiten. Alle verschlüsselten Felder sind AEAD-Chiffretexte.


Die Aufbaufolge ist wie folgt:

Alice                           Bob

  SessionRequest ------------------->
  <------------------- SessionCreated
  SessionConfirmed ----------------->
Verwendet man die Noise-Terminologie, ist die Aufbau- und Datenfolge wie folgt:
(Payload-Sicherheitseigenschaften)

XK(s, rs):           Authentifizierung   Vertraulichkeit
    <- s
    ...
    -> e, es                  0                2
    <- e, ee                  2                1
    -> s, se                  2                5
    <-                        2                5
Sobald eine Sitzung etabliert wurde, können Alice und Bob Datennachrichten austauschen.

Alle Nachrichtentypen (SessionRequest, SessionCreated, SessionConfirmed, Daten und TimeSync) sind in diesem Abschnitt spezifiziert.

Einige Notationen::

  - RH_A = Router Hash für Alice (32 Bytes)
  - RH_B = Router Hash für Bob (32 Bytes)


### Authentifizierte Verschlüsselung

Es gibt drei separate authentifizierte Verschlüsselungsinstanzen (CipherStates). Eine während der Handshake-Phase und zwei (Senden und Empfangen) für die Datenphase. Jede hat ihren eigenen Schlüssel von einem KDF.

Verschlüsselte/authentifizierte Daten werden dargestellt als 

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   Verschlüsselte und authentifizierte  |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
ChaCha20/Poly1305
`````````````````

Format der verschlüsselten und authentifizierten Daten.

Eingaben in die Verschlüsselungs-/Entschlüsselungsfunktionen:

k :: 32-Byte-Schlüssel, wie von KDF generiert

  nonce :: Zählerbasierter Nonce, 12 Bytes.
           Beginnt bei 0 und wird mit jeder Nachricht inkrementiert.
           Die ersten vier Bytes sind immer null.
           Die letzten acht Bytes sind der Zähler, little-endian kodiert.
           Maximaler Wert ist 2**64 - 2.
           Verbindung muss abgebrochen und neu gestartet werden, wenn
           dieser Wert erreicht ist.
           Der Wert 2**64 - 1 darf niemals gesendet werden.

  ad :: In der Handshake-Phase:
        Assoziierte Daten, 32 Bytes.
        Der SHA256-Hash aller vorausgegangenen Daten.
        In der Datenphase:
        Null-Bytes

  data :: Klartextdaten, 0 oder mehr Bytes

Ausgabe der Verschlüsselungsfunktion, Eingabe der Entschlüsselungsfunktion:

+----+----+----+----+----+----+----+----+
  |Obfs Len |                             |
  +----+----+                             +
  |       ChaCha20 verschlüsselte Daten   |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Nachrichtenauthentifizierung |
  +                (MAC)                  +
  |               16 Bytes                |
  +----+----+----+----+----+----+----+----+

  Obfs Len :: Länge der (verschlüsselten Daten + MAC), die folgen, 16 - 65535
              Verschleierung mit SipHash (siehe unten)
              Wird nicht in Nachricht 1 oder 2 oder Nachricht 3 Teil 1 verwendet, wo die Länge fest ist
              Wird nicht in Nachricht 3 Teil 1 verwendet, da die Länge in Nachricht 1 angegeben ist

  verschlüsselte Daten :: Gleiche Größe wie Klartextdaten, 0 - 65519 Bytes

  MAC :: Poly1305 Nachrichtenauthentifizierungscode, 16 Bytes

Für ChaCha20, was hier beschrieben wird, entspricht [RFC-7539](https://tools.ietf.org/html/rfc7539), das ähnlich auch in TLS [RFC-7905](https://tools.ietf.org/html/rfc7905) verwendet wird.

Bemerkungen
`````
- Da ChaCha20 eine Stream-Chiffre ist, müssen Klartexte nicht gepolstert werden.
  Zusätzliche Schlüsselstrombytes werden verworfen.

- Der Schlüssel für die Chiffre (256 Bit) wird durch eine SHA256-KDF vereinbart.
  Die Details der KDF für jede Nachricht sind in separaten Abschnitten unten beschrieben.

- ChaChaPoly-Rahmen für Nachrichten 1, 2 und den ersten Teil der Nachricht 3
  haben eine bekannte Größe. Beginnend mit dem zweiten Teil der Nachricht 3
  haben Rahmen variable Größen. Die Nachricht 3 Teil 1 Größe wird in Nachricht 1 angegeben.
  Beginnend mit der Datenphase werden die Rahmen mit einer zweibytegroßen Länge versehen,
  die mit SipHash wie in obfs4 verschleiert ist.

- Polsterung ist außerhalb des authentifizierten Datenrahmens für Nachrichten 1 und 2.
  Die Polsterung wird in der KDF für die nächste Nachricht verwendet, sodass Manipulationen
  erkannt werden. Ab Nachricht 3 erfolgt die Polsterung innerhalb des authentifizierten
  Datenrahmens.


AEAD-Fehlerbehandlung
`````````````````````
- In Nachrichten 1, 2 und Nachricht 3 Teil 1 und 2 ist die AEAD-Nachrichtengröße im Voraus bekannt.
  Bei einem AEAD-Authentifizierungsfehler muss der Empfänger die weitere Nachrichtenverarbeitung stoppen und die Verbindung ohne Antwort schließen.  Dies sollte ein anormaler Abschluss (TCP RST) sein.

- Zum Schutz gegen Sondierungen sollte Bob nach einem AEAD-Fehler einen zufälligen Timeout (Bereich TBD) setzen und dann eine zufällige Anzahl von Bytes (Bereich TBD) lesen, bevor er den Socket schließt. Bob sollte eine Blacklist von IPs mit wiederholten Fehlern führen.

- In der Datenphase ist die AEAD-Nachrichtengröße mit SipHash "verschlüsselt" (verschleiert).
  Vorsicht ist geboten, um nicht eine Entschlüsselungsorientierung zu schaffen.
  Bei einem AEAD-Authentifizierungsfehler in der Datenphase sollte der Empfänger einen zufälligen Timeout (Bereich TBD) setzen und dann eine zufällige Anzahl von Bytes (Bereich TBD) lesen.
  Nach dem Lesen oder bei Lese-Timeout sollte der Empfänger eine Nutzlast mit einem Beendigungscode "AEAD-Fehler" senden und die Verbindung schließen.

- Die gleiche Fehleraktion bei einem ungültigen Längenfeldwert in der Datenphase durchführen.


### Schlüsselableitungsfunktion (KDF) (für Handshake Nachr. 1)

Die KDF erzeugt einen Chiffreschlüssel k für die Handshake-Phase aus dem DH-Ergebnis, unter Verwendung von HMAC-SHA256(key, data) wie definiert in [RFC-2104](https://tools.ietf.org/html/rfc2104).
Dies sind die InitializeSymmetric(), MixHash() und MixKey()-Funktionen,
genau wie im Noise-Standard definiert.

Dies ist das "e"-Nachrichtenmuster:

  // Protokollname definieren.
  Setze protocol_name = "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256"
   (48 Bytes, US-ASCII kodiert, ohne NULL-Beendigung).

  // Hash h = 32 Bytes definieren
  h = SHA256(protocol_name).

  Definiere ck = 32-Byte-Chaining-Schlüssel. Kopiere die h-Daten in ck.
  Setze ck = h

  Definiere rs = Bobs 32-Byte-statischer Schlüssel, wie in der RouterInfo veröffentlicht

  // MixHash(null Prolog)
  h = SHA256(h).

  // Bis hierhin kann alles von Alice für alle ausgehenden Verbindungen vorab berechnet werden

  // Alice muss hier validieren, dass Bobs statischer Schlüssel ein gültiger Punkt auf der Kurve ist.

  // Bob statischer Schlüssel
  // MixHash(rs)
  // || unten bedeutet anhängen
  h = SHA256(h || rs).

  // Bis hierhin kann alles von Bob für alle eingehenden Verbindungen vorab berechnet werden

  Dies ist das "e"-Nachrichtenmuster:

  Alice generiert ihr ephemeres DH-Schlüsselpaar e.

  // Alice ephemerer Schlüssel X
  // MixHash(e.pubkey)
  // || unten bedeutet anhängen
  h = SHA256(h || e.pubkey).

  // h wird als die srichtung für die AEAD in Nachricht 1 verwendet
  // Bewahre den Hash h für die Nachricht 2 KDF

  Ende des "e"-Nachrichtenmusters.

  Dies ist das "es" Nachrichtenmuster:

  // DH(e, rs) == DH(s, re)
  Definiere input_key_material = 32-Byte-DH-Ergebnis von Alices ephemerem Schlüssel und Bobs statischem Schlüssel
  Setze input_key_material = X25519 DH-Ergebnis

  // MixKey(DH())

  Definiere temp_key = 32 Bytes
  Definiere HMAC-SHA256(key, data) wie in [RFC-2104](https://tools.ietf.org/html/rfc2104)
  // Generiere einen temporären Schlüssel aus dem Chaining Key und dem DH-Ergebnis
  // ck ist der Chaining-Schlüssel, der oben definiert ist
  temp_key = HMAC-SHA256(ck, input_key_material)
  // Überschreibe das DH-Ergebnis im Speicher, nicht mehr benötigt
  input_key_material = (alle Nullen)

  // Ausgabe 1
  // Setze einen neuen Chaining-Schlüssel aus dem temporären Schlüssel
  // byte() unten bedeutet ein einzelnes Byte
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // Ausgabe 2
  // Generiere den Chiffreschlüssel k
  Definiere k = 32 Bytes
  // || unten bedeutet anhängen
  // byte() unten bedeutet ein einzelnes Byte
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
  // Überschreibe den temp_key im Speicher, nicht mehr benötigt
  temp_key = (alle Nullen)

  // Behalte den Chaining-Schlüssel ck für Nachricht 2 KDF

  Ende des "es" Nachrichtenmusters.

### 1) SessionRequest

Alice sendet an Bob.

Noise-Inhalt: Alices ephemerer Schlüssel X
Noise-Nutzlast: 16-Byte-Optionsblock
Nicht-Noise-Nutzlast: Zufallspolsterung

(Sicherheitseigenschaften der Nutzlast)

XK(s, rs):           Authentifizierung   Vertraulichkeit
    -> e, es                  0                2

    Authentifizierung: Keine (0).
    Diese Nutzlast könnte von jeder Partei gesendet worden sein, einschließlich eines aktiven Angreifers.

    Vertraulichkeit: 2.
    Verschlüsselung an einen bekannten Empfänger, Vorwärtsgeheimnis nur für Sendekompromittierung, anfällig für Wiederholungen. Diese Nutzlast wird nur basierend auf DHs verschlüsselt, die das statische Schlüsselpaar des Empfängers beinhalten. Wenn der statische private Schlüssel des Empfängers kompromittiert wird, selbst zu einem späteren Zeitpunkt, kann diese Nutzlast entschlüsselt werden. Diese Nachricht kann auch wiederholt werden, da es keinen ephemeren Beitrag des Empfängers gibt.

    "e": Alice generiert ein neues ephemeres Schlüsselpaar und speichert es in der e-Variablen, schreibt den ephemeren öffentlichen Schlüssel als Klartext in den Nachrichtenpuffer und hasht den öffentlichen Schlüssel zusammen mit dem alten h, um ein neues h abzuleiten.

    "es": Ein DH wird zwischen Alices ephemerem Schlüsselpaar und Bobs statischem Schlüsselpaar durchgeführt. Das Ergebnis wird zusammen mit dem alten ck gehasht, um einen neuen ck und k abzuleiten, und n wird auf null gesetzt.


Der X-Wert wird verschlüsselt, um die Ununterscheidbarkeit der Nutzlast zu gewährleisten,
was notwendige DPI-Gegenmaßnahmen sind.
Wir verwenden die AES-Verschlüsselung, um dies zu erreichen,
nicht komplexere und langsamere Alternativen wie elligator2.
Asymmetrische Verschlüsselung mit Bobs Router-Öffentlichen Schlüssel wäre viel zu langsam.
Die AES-Verschlüsselung verwendet Bobs Router-Hash als Schlüssel und Bobs IV, wie es in der Netzwerkdatenbank veröffentlicht wurde.

Die AES-Verschlüsselung ist nur für DPI-Resistenz.
Jede Partei, die Bobs Router-Hash und IV kennt, welche in der Netzwerkdatenbank veröffentlicht sind,
kann den X-Wert in dieser Nachricht entschlüsseln.

Die Polsterung wird von Alice nicht verschlüsselt.
Es kann notwendig sein, dass Bob die Polsterung entschlüsselt,
um Timing-Angriffe zu unterbinden.


Rohinhalte:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        verschleiert mit RH_B           +
  |       AES-CBC-256 verschlüsseltes X    |
  +             (32 Bytes)                 +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaChaPoly-Rahmen                    |
  +             (32 Bytes)                +
  |   k im KDF für Nachricht 1 definiert  |
  +   n = 0                               +
  |   siehe KDF für assoziierte Daten     |
  +----+----+----+----+----+----+----+----+
  |     unverschlüsselte authentifizierte  |
  ~         Polsterung (optional)          ~
  |     Länge im Optionsblock definiert     |
  +----+----+----+----+----+----+----+----+

  X :: 32 Bytes, AES-256-CBC verschlüsselter X25519-ephemerer Schlüssel, little-endian
          Schlüssel: RH_B
          iv: Wie in Bobs Netzwerkdatenbankeintrag veröffentlicht

  Polsterung: Zufallsdaten, 0 oder mehr Bytes.
                Die gesamte Nachrichtenlänge darf 65535 Bytes nicht überschreiten.
                Die gesamte Nachrichtenlänge darf 287 Bytes nicht überschreiten, wenn
                Bob seine Adresse als NTCP veröffentlicht
                (siehe Abschnitt Versionsdetektion unten).
              Alice und Bob verwenden die Polsterungsdaten im KDF für Nachricht 2.
                Es ist authentifiziert, damit jede Manipulation die nächste Nachricht zum Scheitern bringt.

Unverschlüsselte Daten (Poly1305-Authentifizierungs-Tag nicht gezeigt):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                   X                   |
  +              (32 Bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               Optionen                 |
  +              (16 Bytes)                +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     unverschlüsselte authentifizierte  |
  +         Polsterung (optional)          +
  |     Länge im Optionsblock definiert     |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  X :: 32 Bytes, X25519-ephemerer Schlüssel, little-endian

  Optionen :: Optionsblock, 16 Bytes, siehe unten

  Polsterung :: Zufallsdaten, 0 oder mehr Bytes.
                Die gesamte Nachrichtenlänge darf 65535 Bytes nicht überschreiten.
                Die gesamte Nachrichtenlänge darf 287 Bytes nicht überschreiten, wenn
                Bob seine Adresse als "NTCP" veröffentlicht
                (siehe Abschnitt Versionsdetektion unten)
                Alice und Bob verwenden die Polsterungsdaten im KDF für Nachricht 2.
                Es ist authentifiziert, damit jede Manipulation die
                nächste Nachricht zum Scheitern bringt.

Optionsblock:
Hinweis: Alle Felder sind big-endian.

+----+----+----+----+----+----+----+----+
  | id | ver|  padLen | m3p2len | Rsvd(0) |
  +----+----+----+----+----+----+----+----+
  |        tsA        |   Reserviert (0)    |
  +----+----+----+----+----+----+----+----+

  id :: 1 Byte, die Netzwerk-ID (derzeit 2, außer für Testnetzwerke)
        Ab 0.9.42. Siehe Vorschlag 147.

  ver :: 1 Byte, Protokollversion (derzeit 2)

  padLen :: 2 Bytes, Länge der Polsterung, 0 oder mehr
            Min/max Richtlinien TBD. Zufällige Größe von 0 bis mindestens 31 Bytes?
            (Verteilung TBD, siehe Anhang A.)

  m3p2Len :: 2 Bytes, Länge des zweiten AEAD-Rahmens in SessionConfirmed
             (Nachricht 3, Teil 2) Siehe Anmerkungen unten

  Rsvd :: 2 Bytes, auf 0 setzen für Kompatibilität mit zukünftigen Optionen

  tsA :: 4 Bytes, Unix-Zeitstempel, unsignierte Sekunden.
         Wickelt sich um im Jahr 2106

  Reserviert :: 4 Bytes, auf 0 setzen für Kompatibilität mit zukünftigen Optionen

Bemerkungen
`````
- Wenn die veröffentlichte Adresse "NTCP" ist, unterstützt Bob sowohl NTCP als auch NTCP2 auf dem
  gleichen Port. Aus Kompatibilitätsgründen muss Alice, wenn sie versucht, eine Verbindung zu einer Adresse
  herzustellen, die als "NTCP" veröffentlicht ist, die maximale Größe dieser Nachricht,
  einschließlich Polsterung, auf 287 Bytes oder weniger beschränken.  Dies erleichtert die
  automatische Protokollidentifikation durch Bob.  Wenn sie als "NTCP2" veröffentlicht ist,
  gibt es keine Größenbeschränkung.  Siehe die veröffentlichen Adressen und
  den Abschnitt Versionsdetektion unten.

- Das eindeutige X in dem initialen AES-Block sorgt dafür, dass der Chiffretext
  für jede Sitzung anders ist.

- Bob muss Verbindungen ablehnen, bei denen der Zeitstempelwert zu weit vom
  aktuellen Zeitpunkt entfernt ist. Nennen Sie die maximale Zeitdifferenz "D".  Bob muss
  einen lokalen Cache von zuvor verwendeten Handshake-Werten führen und Duplikate ablehnen, um
  Replay-Angriffe zu verhindern. Werte im Cache müssen eine Lebensdauer von mindestens
  2 * D haben.  Die Cachewerte sind implementierungsabhängig, jedoch
  kann der 32-Byte-X-Wert (oder sein verschlüsseltes Äquivalent) verwendet werden.

- Diffie-Hellman-ephemere Schlüssel dürfen niemals wiederverwendet werden, um kryptographische Angriffe zu verhindern,
  und Wiederverwendung wird als Replay-Angriff abgelehnt.

- Die "KE"- und "auth"-Optionen müssen kompatibel sein, d. h. das gemeinsam genutzte Geheimnis K muss
  die richtige Größe haben. Werden mehr "auth"-Optionen hinzugefügt, könnte dies
  implizit die Bedeutung des "KE"-Flags ändern, um eine andere KDF oder eine
  andere Kürzung zu verwenden.

- Bob muss validieren, dass Alices ephemerer Schlüssel ein gültiger Punkt auf der Kurve
  ist.

- Polsterung sollte auf ein vernünftiges Maß beschränkt werden.  Bob mag Verbindungen
  mit übermäßiger Polsterung ablehnen.  Bob wird seine Polsterungsoptionen in Nachricht 2
  spezifizieren.  Min/max Richtlinien TBD. Zufällige Größe von 0 bis mindestens 31 Bytes?
  (Verteilung TBD, siehe Anhang A.)

- Bei jedem Fehler, einschließlich AEAD, DH, Zeitstempel, scheinbare Replay- oder
  Schlüsselerkennungsfehler, muss Bob die weitere Nachrichtenverarbeitung stoppen und die Verbindung
  ohne Antwort schließen.  Dies sollte ein anormaler Abschluss (TCP RST) sein.
  Um die Sondierungsresistenz zu erhöhen, sollte Bob nach einem AEAD-Fehler einen
  zufälligen Timeout (Bereich TBD) setzen und dann eine zufällige Anzahl von Bytes (Bereich TBD)
  lesen, bevor er den Socket schließt.

- DoS-Minderung: DH ist eine relativ teure Operation. Wie beim vorherigen NTCP-Protokoll,
  sollten Router alle notwendigen Maßnahmen ergreifen, um CPU- oder Verbindungsausfälle zu verhindern.
  Begrenzen Sie die maximale Anzahl von aktiven Verbindungen und die maximale Anzahl von Verbindungsaufbauten, die gerade im Gange sind.
  Durchsetzen von Lese-Timeouts (sowohl pro Lesevorgang als auch insgesamt für "slowloris").
  Begrenzen Sie wiederholte oder gleichzeitige Verbindungen von der gleichen Quelle.
  Führen Sie Blacklists für Quellen mit wiederholten Fehlern.
  Antworten Sie nicht auf AEAD-Fehler.

- Um eine schnelle Versionserkennung und Handshaking zu erleichtern, müssen Implementierungen
  sicherstellen, dass Alice den gesamten Inhalt der ersten Nachricht auf einmal puffert und dann freigibt, einschließlich der Polsterung.
  Dies erhöht die Wahrscheinlichkeit, dass die Daten in einem einzigen TCP-Paket enthalten sind
  (es sei denn, sie werden vom Betriebssystem oder durch Mittler segmentiert), und von Bob auf einmal empfangen werden.
  Dies ist auch aus Effizienzgründen und um die Wirksamkeit der zufälligen Polsterung zu gewährleisten.

- Feld "ver": Das Gesamte Noise-Protokoll, Erweiterungen und NTCP-Protokoll
  einschließlich Nutzlastspezifikationen, Anzeige NTCP2.
  Dieses Feld kann verwendet werden, um Unterstützung für zukünftige Änderungen zu kennzeichnen.

- Länge der Nachricht 3 Teil 2: Dies ist die Größe des zweiten AEAD-Rahmens (einschließlich 16-Byte-MAC)
  die Alices Router-Info und optionale Polsterung enthält, die in der
  Nachricht SessionConfirmed gesendet wird. Da Router regelmäßig ihre Router-Info regenerieren und
  erneut veröffentlichen, kann sich die Größe der aktuellen Router-Info ändern, bevor
  Nachricht 3 gesendet wird. Implementierungen müssen eine von zwei Strategien wählen:
  a) die aktuelle Router-Info sichern, die in Nachricht 3 gesendet wird, so dass die Größe bekannt ist,
  und optional Platz für Polsterung lassen;
  b) Die spezifizierte Größe genug erhöhen, um eine mögliche Vergrößerung
  der Router-Info zu ermöglichen, und immer Polsterung hinzufügen, wenn die
  Nachricht 3 tatsächlich gesendet wird. In beiden Fällen muss die in
  Nachricht 1 angegebene "m3p2len"-Länge genau die Größe dieses Rahmens sein, wenn er in Nachricht 3 gesendet wird.

- Bob muss die Verbindung abbrechen, wenn nach der Validierung
  von Nachricht 1 und dem Einlesen der Polsterung Daten verbleiben. Es sollten keine
  zusätzlichen Daten von Alice kommen, da Bob noch nicht mit
  Nachricht 2 geantwortet hat.

- Das Netzwerk-ID-Feld wird verwendet, um schnell netzwerkübergreifende Verbindungen zu identifizieren.
  Wenn dieses Feld ungleich null ist, und nicht mit Bobs-Netzwerk-ID übereinstimmt,
  sollte Bob die Verbindung trennen und zukünftige Verbindungen blockieren.
  Ab 0.9.42. Siehe Vorschlag 147 für weitere Informationen.



### Schlüsselableitungsfunktion (KDF) (für Nachricht 2 und Nachr. 3 Teil 1)

```
// h aus Nachricht 1 KDF nehmen
// MixHash(chiffretext)
h = SHA256(h || 32-Byte-verschlüsselte Payload aus Nachricht 1)

// MixHash(polsterung)
// Nur wenn Polsterlänge ungleich null ist
h = SHA256(h || zufällige Polsterung aus Nachricht 1)

Dies ist das "e"-Nachrichtenmuster:

Bob generiert sein ephemeres DH-Schlüsselpaar e.

// h ist aus KDF für Handshake Nachricht 1
// Bob ephemerer Schlüssel Y
// MixHash(e.pubkey)
// || unten bedeutet anhängen
h = SHA256(h || e.pubkey).

// h wird als die srichtung für die AEAD in Nachricht 2 verwendet
// Bewahre den Hash h für die Nachricht 3 KDF

Ende des "e"-Nachrichtenmusters.

Dies ist das "ee"-Nachrichtenmuster:

// DH(e, re)
Definiere input_key_material = 32-Byte-DH-Ergebnis von Alices ephemerem Schlüssel und Bobs ephemerem Schlüssel
Setze input_key_material = X25519 DH-Ergebnis
// überschreibe Alices ephemeren Schlüssel im Speicher, nicht mehr benötigt
// Alice:
e(öffentlich und privat) = (alle Nullen)
// Bob:
re = (alle Nullen)

// MixKey(DH())

Definiere temp_key = 32 Bytes
Definiere HMAC-SHA256(key, data) wie in [RFC-2104](https://tools.ietf.org/html/rfc2104)
// Generiere einen temporären Schlüssel aus dem Chaining Key und dem DH-Ergebnis
// ck ist der Chaining-Schlüssel, aus dem KDF für Handshake Nachricht 1
temp_key = HMAC-SHA256(ck, input_key_material)
// Überschreibe das DH-Ergebnis im Speicher, nicht mehr benötigt
input_key_material = (alle Nullen)

// Ausgabe 1
// Setze einen neuen Chaining-Schlüssel aus dem temporären Schlüssel
// byte() unten bedeutet ein einzelnes Byte
ck =       HMAC-SHA256(temp_key, byte(0x01)).

// Ausgabe 2
// Generiere den Chiffreschlüssel k
Definiere k = 32 Bytes
// || unten bedeutet anhängen
// byte() unten bedeutet ein einzelnes Byte
k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
// Überschreibe den temp_key im Speicher, nicht mehr benötigt
temp_key = (alle Nullen)

// Behalte den Chaining-Schlüssel ck für Nachricht 3 KDF

Ende des "ee" Nachrichtenmusters.
```

### 2) SessionCreated

Bob sendet an Alice.

Noise-Inhalt: Bobs ephemerer Schlüssel Y
Noise-Nutzlast: 16-Byte-Optionsblock
Nicht-Noise-Nutzlast: Zufallspolsterung

(Sicherheitseigenschaften der Nutzlast)

XK(s, rs):           Authentifizierung   Vertraulichkeit
    <- e, ee                  2                1

    Authentifizierung: 2.
    Absenderauthentifizierung resistent gegenüber Schlüsselkompromittierungs-Impersonierung (KCI).
    Die Absenderauthentifizierung basiert auf einem ephemer-statischen DH ("es" oder "se")
    zwischen dem statischen Schlüsselpaar des Absenders und dem ephemeren Schlüsselpaar des Empfängers.
    Vorausgesetzt, die entsprechenden privaten Schlüssel sind sicher, kann diese Authentifizierung nicht gefälscht werden.

    Vertraulichkeit: 1.
    Verschlüsselung an einen ephemeren Empfänger.
    Diese Nutzlast besitzt Vorwärtsgeheimnis, da die Verschlüsselung ein ephemer-ephemeres DH ("ee") beinhaltet.
    Allerdings hat der Absender den Empfänger nicht authentifiziert,
    sodass diese Nutzlast an jede Partei, einschließlich eines aktiven Angreifers, gesendet werden könnte.


    "e": Bob generiert ein neues ephemeres Schlüsselpaar und speichert es in der e-Variablen,
    schreibt den ephemeren öffentlichen Schlüssel als Klartext in den Nachrichtenpuffer,
    und hasht den öffentlichen Schlüssel zusammen mit dem alten h, um ein neues h abzuleiten.

    "ee": Ein DH wird zwischen Bobs ephemerem Schlüsselpaar und Alices ephemerem Schlüsselpaar durchgeführt.
    Das Ergebnis wird zusammen mit dem alten ck gehasht, um einen neuen ck und k abzuleiten, und n wird auf null gesetzt.

Der Y-Wert wird verschlüsselt, um die Ununterscheidbarkeit der Nutzlast und die Einzigartigkeit zu gewährleistenss
was notwendige DPI-Gegenmaßnahmen sind.  Wir verwenden die AES-Verschlüsselung, um dies zu erreichen,
nicht komplexere und langsamere Alternativen wie elligator2.
Asymmetrische Verschlüsselung mit Alices Router-Öffentlichen Schlüssel wäre viel zu langsam.  Die AES
Verschlüsselung verwendet Bobs Router-Hash als Schlüssel und den AES-Zustand von Nachricht 1
(die mit Bobs IV initialisiert wurde, wie in der Netzwerkdatenbank veröffentlicht).

Die AES-Verschlüsselung ist nur für DPI-Resistenz.  Jede Partei, die Bobs Router-Hash
und IV kennt, die in der Netzwerkdatenbank veröffentlicht sind, und die ersten 32
Bytes von Nachricht 1 erfasst hat, kann den Y-Wert in dieser Nachricht entschlüsseln.


Rohinhalte:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        verschleiert mit RH_B           +
  |       AES-CBC-256 verschlüsseltes Y    |
  +              (32 Bytes)                +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |   ChaChaPoly-Rahmen                    |
  +   Verschlüsselte und authentifizierte  +
  |   32 Bytes                             |
  +   k im KDF für Nachricht 2 definiert  +
  |   n = 0; siehe KDF für assoziierte Daten |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     unverschlüsselte authentifizierte  |
  +         Polsterung (optional)          +
  |     Länge im Optionsblock definiert     |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 Bytes, AES-256-CBC verschlüsselter X25519 ephemerer Schlüssel, little-endian
          Schlüssel: RH_B
          iv: Verwendet AES-Zustand aus Nachricht 1

Unverschlüsselte Daten (Poly1305-Authentifizierungs-Tag nicht gezeigt):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                  Y                    |
  +              (32 Bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               Optionen                 |
  +              (16 Bytes)                +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     unverschlüsselte authentifizierte  |
  +         Polsterung (optional)          +
  |     Länge im Optionsblock definiert     |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 Bytes, X25519 ephemerer Schlüssel, little-endian

  Optionen :: Optionsblock, 16 Bytes, siehe unten

  Polsterung :: Zufallsdaten, 0 oder mehr Bytes.
                Die gesamte Nachrichtenlänge darf 65535 Bytes nicht überschreiten.
                Alice und Bob verwenden die Polsterungsdaten im KDF für Nachricht 3 Teil 1.
                Es ist authentifiziert, damit jede Manipulation die
                nächste Nachricht zum Scheitern bringt.

Bemerkungen
`````

- Alice muss hier validieren, dass Bobs ephemerer Schlüssel ein gültiger Punkt auf der Kurve
  ist.

- Polsterung sollte auf ein vernünftiges Maß beschränkt werden.
  Alice mag Verbindungen mit übermäßiger Polsterung ablehnen.
  Alice wird ihre Polsterungsoptionen in Nachricht 3 spezifizieren.
  Min/max Richtlinien TBD. Zufällige Größe von 0 bis mindestens 31 Bytes?
  (Verteilung TBD, siehe Anhang A.)

- Bei jedem Fehler, einschließlich AEAD, DH, Zeitstempel, scheinbarem Replay oder Schlüsselerkennungsfehler, muss Alice die weitere Nachrichtenverarbeitung stoppen und die Verbindung ohne Antwort schließen.  Dies sollte ein anormaler Abschluss (TCP RST) sein.

- Um eine schnelle Handshaking zu erleichtern, müssen Implementierungen sicherstellen, dass Bob den gesamten Inhalt der ersten Nachricht auf einmal puffert und dann freigibt, einschließlich der Polsterung.  Dies erhöht die Wahrscheinlichkeit, dass die Daten in einem einzigen TCP-Paket enthalten sind (es sei denn, sie werden vom Betriebssystem oder durch Mittler segmentiert), und von Alice auf einmal empfangen werden.  Dies ist auch aus Effizienzgründen und um die Wirksamkeit der zufälligen Polsterung zu gewährleisten.

- Alice muss die Verbindung abbrechen, wenn nach der Validierung
  von Nachricht 2 und dem Einlesen der Polsterung zusätzliche Daten verbleiben. Es sollten keine
  zusätzlichen Daten von Bob kommen, da Alice noch nicht mit
  Nachricht 3 geantwortet hat.


Optionsblock:
Hinweis: Alle Felder sind big-endian.

+----+----+----+----+----+----+----+----+
  | Rsvd(0) | padLen  |   Reserviert (0)   |
  +----+----+----+----+----+----+----+----+
  |        tsB        |   Reserviert (0)   |
  +----+----+----+----+----+----+----+----+

  Reserviert :: Insgesamt 10 Bytes, auf 0 setzen für Kompatibilität mit zukünftigen Optionen

  padLen :: 2 Bytes, big-endian, Länge der Polsterung, 0 oder mehr
            Min/max Richtlinien TBD. Zufällige Größe von 0 bis mindestens 31 Bytes?
            (Verteilung TBD, siehe Anhang A.)

  tsB :: 4 Bytes, big-endian, Unix-Zeitstempel, unsignierte Sekunden.
         Wickelt sich im Jahr 2106 um

Bemerkungen
`````
- Alice muss Verbindungen ablehnen, bei denen der Zeitstempelwert zu weit vom
  aktuellen Zeitpunkt entfernt ist. Nennen Sie die maximale Zeitdifferenz "D".  Alice muss
  einen lokalen Cache von zuvor verwendeten Handshake-Werten führen und Duplikate ablehnen, um
  Replay-Angriffe zu verhindern. Werte im Cache müssen eine Lebensdauer von mindestens
  2 * D haben.  Die Cachewerte sind implementierungsabhängig, jedoch kann der
  32-Byte-Wert Y (oder sein verschlüsseltes Äquivalent) verwendet werden.

Probleme
``````
- Min/max Polsterungsoptionen hier enthalten?



### Verschlüsselung für Nachrichtenmuster 3 Teil 1, mit Nachricht 2 KDF

```
// h aus Nachricht 2 KDF nehmen
// MixHash(chiffretext)
h = SHA256(h || 24 Byte verschlüsselte Nutzlast aus Nachricht 2)

// MixHash(polsterung)
// Nur wenn Polsterlänge ungleich null ist
h = SHA256(h || zufällige Polsterung aus Nachricht 2)
// h wird als die srichtung für die AEAD in Nachricht 3 Teil 1, unten verwendet

Dies ist das "s"-Nachrichtenmuster:

Definiere s = Alices statischer öffentlicher Schlüssel, 32 Bytes

// EncryptAndHash(s.publickey)
// EncryptWithAd(h, s.publickey)
// AEAD_ChaCha20_Poly1305(key, nonce, associatedData, data)
// k ist aus Handshake  Nachricht 1
// n ist 1
chiffriertext = AEAD_ChaCha20_Poly1305(k, n++, h, s.publickey)
// MixHash(chiffriertext)
// || unten bedeutet anhängen
h = SHA256(h || chiffriertext).

// h wird als die srichtung für die AEAD in Nachricht 3 Teil 2 verwendet

Ende des "s"-Nachrichtenmusters.
```

### Schlüsselableitungsfunktion (KDF) (für Handshake Nachr. 3 Teil 2)

Dies ist das "se"-Nachrichtenmuster:

  // DH(s, re) == DH(e, rs)
  Definiere input_key_material = 32-Byte-DH-Ergebnis von Alices statischem Schlüssel und Bobs ephemerem Schlüssel
  Setze input_key_material = X25519 DH-Ergebnis
  // Überschreibe Bobs ephemeren Schlüssel im Speicher, nicht mehr benötigt
  // Alice:
  re = (alle Nullen)
  // Bob:
  e(öffentlich und privat) = (alle Nullen)

  // MixKey(DH())

  Definiere temp_key = 32 Bytes
  Definiere HMAC-SHA256(key, data) wie in [RFC-2104](https://tools.ietf.org/html/rfc2104)
  // Generiere einen temporären Schlüssel aus dem Chaining Key und dem DH-Ergebnis
  // ck ist der Chaining-Schlüssel, aus dem KDF für Handshake Nachricht 1
  temp_key = HMAC-SHA256(ck, input_key_material)
  // Überschreibe das DH-Ergebnis im Speicher, nicht mehr benötigt
  input_key_material = (alle Nullen)

  // Ausgabe 1
  // Setze einen neuen Chaining-Schlüssel aus dem temporären Schlüssel
  // byte() unten bedeutet ein einzelnes Byte
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // Ausgabe 2
  // Generiere den Chiffreschlüssel k
  Definiere k = 32 Bytes
  // || unten bedeutet anhängen
  // byte() unten bedeutet ein einzelnes Byte
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).

  // h aus Nachricht 3 Teil 1 wird als die srichtung für die AEAD in Nachricht 3 Teil 2 verwendet

  // EncryptAndHash(nutzlast)
  // EncryptWithAd(h, Nutzlast)
  // AEAD_ChaCha20_Poly1305(key, nonce, associatedData, data)
  // n ist 0
  chiffriertext = AEAD_ChaCha20_Poly1305(k, n++, h, nutzlast)
  // MixHash(chiffriertext)
  // || unten bedeutet anhängen
  h = SHA256(h || chiffriertext).

  // Behalte den Chaining-Schlüssel ck für die KDF der Datenphase
  // Behalte den Hash h für die Zusätzliche Symmetrische Schlüssel (SipHash) KDF der Datenphase

  Ende des "se" Nachrichtenmusters.

  // Überschreibe den temp_key im Speicher, nicht mehr benötigt
  temp_key = (alle Nullen)

### 3) SessionConfirmed

Alice sendet an Bob.

Noise-Inhalt: Alices statischer Schlüssel
Noise-Nutzlast: Alices RouterInfo und Zufallspolsterung
Nicht-Noise-Nutzlast: keine

(Sicherheitseigenschaften der Nutzlast)


XK(s, rs):           Authentifizierung   Vertraulichkeit
    -> s, se                  2                5

    Authentifizierung: 2.
    Absenderauthentifizierung resistent gegenüber Schlüsselkompromittierungs-Impersonierung (KCI).  Die
    Absenderauthentifizierung basiert auf einem ephemer-statischen DH ("es" oder "se")
    zwischen dem statischen Schlüsselpaar des Absenders und dem ephemeren Schlüsselpaar des Empfängers. 
    Vorausgesetzt, die entsprechenden privaten Schlüssel sind sicher, kann diese
    Authentifizierung nicht gefälscht werden.

    Vertraulichkeit: 5.
    Verschlüsselung an einen bekannten Empfänger, starkes Vorwärtsgeheimnis.  Diese Nutzlast ist
    verschlüsselt basierend auf einem ephemer-ephemeren DH sowie einem
    ephemer-statischen DH mit dem statischen Schlüsselpaar des Empfängers. Vorausgesetzt
    die ephemeren privaten Schlüssel sind sicher, und der Empfänger wird nicht aktiv
    von einem Angreifer, der seinen statischen privaten Schlüssel gestohlen hat, imitiert, kann diese
    Nutzlast nicht entschlüsselt werden.

    "s": Alice schreibt ihren statischen öffentlichen Schlüssel aus der s-Variable in den
    Nachrichtenpuffer, verschlüsselt ihn, und hasht die Ausgabe zusammen mit dem alten h
    um ein neues h abzuleiten.

    "se": Ein DH wird durchgeführt zwischen dem statischen Schlüsselpaar von Alice und dem
    ephemeren Schlüsselpaar von Bob.  Das Ergebnis wird zusammen mit dem alten ck gehasht, um ein
    neues ck und k abzuleiten, und n wird auf null gesetzt.

Dies enthält zwei ChaChaPoly-Rahmen.
Der erste ist Alices verschlüsselter statischer öffentlicher Schlüssel.
Der zweite ist die Noise-Nutzlast: Alices verschlüsselte RouterInfo, optionale
Optionen und optionale Polsterung. Sie verwenden verschiedene Schlüssel, da die MixKey()
Funktion dazwischen aufgerufen wird.


Rohinhalte:

+----+----+----+----+----+----+----+----+
  |                                       |
  +   ChaChaPoly-Rahmen (48 Bytes)        +
  |   Verschlüsselt und authentifiziert   |
  +   Alice statischer Schlüssel S        +
  |      (32 Bytes)                       |
  +                                       +
  |     k im KDF für Nachricht 2 definiert  |
  +     n = 1                             +
  |     siehe KDF für assoziierte Daten     |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +     Länge in Nachricht 1 spezifiziert   +
  |                                       |
  +   ChaChaPoly-Rahmen                    +
  |   Verschlüsselt und authentifiziert    |
  +                                       +
  |       Alice RouterInfo                |
  +       using block format 2            +
  |       Alice Optionen (optional)       |
  +       using block format 1            +
  |       Willkürliche Polsterung         |
  +       using block format 254          +
  |                                       |
  +                                       +
  | k im KDF für Nachricht 3 Teil 2 definiert |
  +     n = 0                             +
  |     siehe KDF für assoziierte Daten     |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  S :: 32 Byte, ChaChaPoly verschlüsseltes Alices X25519 statischer Schlüssel, little-endian
       im 48-Byte-ChaChaPoly-Rahmen

Unverschlüsselte Daten (Poly1305-Authentifizierungs-Tag nicht gezeigt):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |              S                        |
  +       Alice statischer Schlüssel      +
  |          (32 Bytes)                   |
  +                                       +
  |                                       |
  +                                       +
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                                       |
  +                                       +
  |       Alice RouterInfo block          |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       Optional Options block          +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       Optional Padding block          +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  S :: 32 Bytes, Alices X25519 statischer Schlüssel, little-endian


Anmerkungen
`````
- Bob muss die gewöhnliche Router-Info-Validierung durchführen.
  Sicherstellen, dass der Signaturtyp unterstützt wird, die Signatur validieren,
  überprüfen, ob der Zeitstempel innerhalb der Grenzen liegt, und alle anderen notwendigen Überprüfungen.

- Bob muss überprüfen, dass der in Teil 1 der empfangenen Nachricht enthaltene statische Schlüssel von Alice
  mit dem statischen Schlüssel in der Router-Info übereinstimmt. Bob sollte zuerst in der Router-Info nach
  einer NTCP oder NTCP2 Router-Adresse mit einer übereinstimmenden Version (v) suchen.
  Siehe Veröffentliche Router-Info und Nichtveröffentliche Router-Info-Abschnitte unten.

- Wenn Bob eine ältere Version von Alices Router-Info in seinem Netz-DB hat, validiere
  dass der statische Schlüssel in der Router-Info der gleiche in beiden ist, wenn vorhanden,
  und wenn die ältere Version nicht älter als XXX ist (siehe Schlüssel-Zeit unten)

- Bob muss hier validieren, dass Alices statischer Schlüssel ein gültiger Punkt auf der Kurve ist.

- Optionen sollten enthalten sein, um Polstervorgaben anzugeben.

- Bei jedem Fehler, einschließlich AEAD, RI, DH, Zeitstempel oder Schlüsselerkennungsfehler, 
  muss Bob die weitere Nachrichtenverarbeitung stoppen und die Verbindung ohne Antwort schließen.  Dies sollte ein anormaler Abschluss (TCP RST) sein.

- Um eine schnelle Handshaking zu erleichtern, müssen Implementierungen sicherstellen, dass Alice
  den gesamten Inhalt der dritten Nachricht auf einmal puffert und dann freigibt,
  einschließlich beider AEAD-Rahmen.
  Dies erhöht die Wahrscheinlichkeit, dass die Daten in einem einzigen TCP-Paket enthalten sind
  (es sei denn, sie werden vom Betriebssystem oder durch Mittler segmentiert), und von Bob auf einmal empfangen werden.
  Dies ist auch aus Effizienzgründen und um die Wirksamkeit der zufälligen Polsterung zu gewährleisten.

- Länge des Nachricht 3 Teil 2 Rahmens: Die Länge dieses Rahmens (inklusive MAC) ist
  von Alice in Nachricht 1 gesendet. Siehe diese Nachricht für wichtige Hinweise zur
  ausreichenden Berücksichtigung der Polsterung.

- Inhalt des Nachricht 3 Teil 2 Rahmens: Dieses Format des Rahmens ist dasselbe wie das
  Format von Datenphasenrahmen, außer dass die Länge des Rahmens von Alice in Nachricht 1 gesendet wird.
  Siehe unten für das Format des Datenphasenrahmens.
  Der Rahmen muss 1 bis 3 Blöcke in der folgenden Reihenfolge enthalten:
  1) Alice's Router-Info-Block (erforderlich)
  2) Optionsblock (optional)
  3) Polsterungsblock (optional)
  Dieser Rahmen darf keinen anderen Blocktyp enthalten.

- Nachricht 3 Teil 2 Polsterung ist nicht erforderlich, wenn Alice einen Datenphasenrahmen
  (optionalerweise Polsterung enthaltend) an das Ende von Nachricht 3 anhängt und beide gleichzeitig sendet,
  da es wie ein großer Datenstrom für einen Beobachter erscheinen wird.
  Da Alice im Allgemeinen, aber nicht immer, eine I2NP-Nachricht an Bob zu senden hat
  (deshalb hat sie sich mit ihm verbunden), ist dies die empfohlene Implementierung,
  aus Effizienzgründen und um die Wirksamkeit der zufälligen Polsterung zu gewährleisten.

- Gesamtlänge beider Nachricht 3 AEAD-Rahmen (Teile 1 und 2) beträgt 65535 Bytes;
  Teil 1 ist 48 Bytes, so dass die maximale Rahmengröße von Teil 2 65487 beträgt;
  Teil 2 maximale Klartextlänge ohne MAC beträgt 65471.


### Schlüsselableitungsfunktion (KDF) (für die Datenphase)

Die Datenphase verwendet eine Eingabe ohne Länge der zugehörigen Daten.


Die KDF erzeugt zwei Chiffreschlüssel k_ab und k_ba aus dem Chaining-Schlüssel ck,
unter Verwendung von HMAC-SHA256(key, data) wie in [RFC-2104](https://tools.ietf.org/html/rfc2104) definiert.
Dies ist die Split()-Funktion, genau wie im Noise-Standard definiert.

ck = aus der Handshake-Phase

  // k_ab, k_ba = HKDF(ck, zerolen)
  // ask_master = HKDF(ck, zerolen, info="ask")

  // zerolen ist ein Array mit null Länge
  temp_key = HMAC-SHA256(ck, zerolen)
  // Überschreibe den Chaining-Schlüssel im Speicher, nicht mehr benötigt
  ck = (alle Nullen)

  // Ausgabe 1
  // Chiffreschlüssel, für Alice sendet an Bob (Noise macht nicht klar, welcher welcher ist, aber Java-Code tut es)
  k_ab =   HMAC-SHA256(temp_key, byte(0x01)).

  // Ausgabe 2
  // Chiffreschlüssel, für Bob sendet an Alice (Noise macht nicht klar, welcher welcher ist, aber Java-Code tut es)
  k_ba =   HMAC-SHA256(temp_key, k_ab || byte(0x02)).


  KDF für SipHash für Längenfeld:
  Generiere einen Zusätzlichen Symmetrischen Schlüssel (ask) für SipHash
  SipHash verwendet zwei 8-Byte-Schlüssel (big endian) und 8 Byte IV für die ersten Daten.

  // "ask" ist 3 Bytes, US-ASCII, ohne null- Abschluß
  ask_master = HMAC-SHA256(temp_key, "ask" || byte(0x01))
  // sip_master = HKDF(ask_master, h || "siphash")
  // "siphash" ist 7 Bytes, US-ASCII, ohne null- Abschluß
  // Überschreibe vorherigen temp_key im Speicher
  // h ist von KDF für Nachricht 3 Teil 2
  temp_key = HMAC-SHA256(ask_master, h || "siphash")
  // Überschreibe ask_master im Speicher, nicht mehr benötigt
  ask_master = (alle Nullen)
  sip_master = HMAC-SHA256(temp_key, byte(0x01))

  Alice an Bob SipHash k1, k2, IV:
  // sipkeys_ab, sipkeys_ba = HKDF(sip_master, zerolen)
  // Überschreibe vorherigen temp_key im Speicher
  temp_key = HMAC-SHA
