---
title: "SSU2"
number: "159"
author: "eyedeekay, orignal, zlatinb, zzz"
created: "2021-09-12"
lastupdated: "2025-03-05"
status: "Closed"
thread: "http://zzz.i2p/topics/2612"
target: "0.9.56"
---

## Status

Rollout-Plan:


| Funktion | Testen (nicht Standard) | Standardmäßig aktiviert |
|----------|-------------------------|-------------------------|
| Lokaler Testcode | 2022-02 |
| Gemeinsamer Testcode | 2022-03 |
| Gemeinsamer Test im Netzwerk | 0.9.54 | 2022-05 |
| Grundprotokoll einfrieren | 0.9.54 | 2022-05 |
| Basis-Session | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Adressvalidierung (Retry) | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Fragmentiertes RI im Handshake | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Neues Token | 0.9.55 | 2022-08 | 0.9.57 | 2022-11 |
| Erweitertes Protokoll einfrieren 0.9.55 | 2022-08 |
| Relais | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Peer-Test | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Aktivierung für zufällige 2 % | 0.9.55 | 2022-08 |
| Pfadvalidierung | 0.9.55+ dev | 0.9.56 | 2022-11 |
| Verbindungsmigration | 0.9.55+ dev | 0.9.56 | 2022-11 |
| Sofortiges ACK-Flag | 0.9.55+ dev | 0.9.56 | 2022-11 |
| Schlüsseldrehung | 0.9.57 | 2023-02 | 0.9.58 | 2023-05 |
| SSU 1 (i2pd) deaktivieren | 0.9.56 | 2022-11 |
| SSU 1 (Java I2P) deaktivieren | 0.9.58 | 2023-05 | 0.9.61 | 2023-12 |

Die Basis-Session umfasst die Handshake- und Datenphase.
Das erweiterte Protokoll umfasst Relais und Peer-Test.



## Überblick

Dieser Vorschlag beschreibt ein authentifiziertes Schlüsselaustauschprotokoll zur Verbesserung der Widerstandsfähigkeit von [SSU](/en/docs/transport/ssu/) gegen verschiedene Formen automatisierter Identifizierung und Angriffe.

Der Vorschlag ist wie folgt organisiert: Zuerst werden die Sicherheitsziele vorgestellt, gefolgt von einer Diskussion des Basisprotokolls. Anschließend wird eine vollständige Spezifikation aller Protokollnachrichten gegeben. Schließlich werden Routeradressen und Versionsidentifikation erörtert.

Wie bei anderen I2P-Transporten ist SSU2 für den Punkt-zu-Punkt-Transport (Router-zu-Router) von I2NP-Nachrichten definiert. Es ist keine universelle Datenleitung. Wie [SSU](/en/docs/transport/ssu/) bietet es auch zwei zusätzliche Dienste: Relaying für NAT-Traversal und Peer Testing zur Bestimmung der eingehenden Erreichbarkeit. Zudem bietet es einen dritten Dienst, der in SSU nicht vorhanden ist, für die Verbindungsmigration, wenn ein Peer die IP oder den Port ändert.


## Motivation

SSU ist die einzige verbleibende Protokollschicht, die ElGamal erfordert, das sehr langsam ist. Die Flusskontrolle für SSU ist komplex und funktioniert nicht gut. Teile von SSU sind anfällig für Adressfälschungsangriffe. Der Handshake verwendet kein Noise.



## Designziele

- Reduzierung der CPU-Auslastung durch Eliminierung von ElGamal. Verwendung von X25519 für den DH.

- Aufrechterhaltung der Funktionen Peer-Test und Relais und Erhöhung der Sicherheit dafür.

- Vereinfachung der Implementierung durch Zulassen von Standard-Flusssteuerungsalgorithmen.

- Reduzierung der Einrichtungsverzögerung.
  Die mittlere Einrichtungszeit beträgt derzeit etwa 135 ms für NTCP2 und 187 ms für SSU, obwohl NTCP2 eine zusätzliche Rundreise hat; das Ersetzen von ElGamal in SSU2 sollte diese reduzieren, aber andere Änderungen könnten ebenfalls helfen.

- Aufrechterhaltung oder Erhöhung des maximalen Durchsatzes im Vergleich zu SSU 1, gemessen über eine Reihe von simulierten Latenzen und Paketverlustprozentsätzen in einem Testnetz.

- Verhinderung von Verkehrsverstärkungs- und Fehlleitungsangriffen von gefälschten Quelladressen durch "Adressvalidierung".

- Einfachere Paketidentifikation, um die Abhängigkeit von Rückfällen und Heuristiken zu reduzieren, die den Code übermäßig komplex machen.

- Formalisierung und Verbesserung der Verbindungsmigration, wenn sich die IP oder der Port des Peers ändert. Keine Migration von Verbindungen, bis die Adressvalidierung abgeschlossen ist, um Angriffe zu verhindern. Einige SSU 1-Implementierungen verwenden teure Heuristiken, um Portänderungen aufgrund von NAT-Rebinding zu bewältigen. Keine bekannten SSU 1-Implementierungen können überhaupt IP-Änderungen handhaben.

- Unterstützung von SSU 1 und 2 auf einem einzigen Port, automatische Erkennung und Veröffentlichung als einzelnes "Transport" (d.h. [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) im [NetDB](/en/docs/how/network-database/).

- Unterstützung für Version 1 nur, 2 nur oder 1+2 im NetDB in einem separaten Feld veröffentlichen und standardmäßig auf Version 1 beschränken (die Versionsunterstützung nicht an eine bestimmte Router-Version binden).

- Sicherstellen, dass alle Implementierungen (Java/i2pd/Go) Version 2-Unterstützung (oder nicht) in ihren eigenen Zeitplänen hinzufügen können.

- Zufällige Polsterung zu allen Nachrichten, einschließlich Handshake- und Daten-Nachrichten, hinzufügen. Alle Polsterungen müssen vom MAC abgedeckt werden, im Gegensatz zu den Paketend-Polsterungen in SSU 1. Bereitstellen eines Optionsmechanismus für beide Seiten zur Anforderung minimaler und maximaler Polsterungen und/oder einer Polsterverteilung. Spezifika der Polsterverteilung sind implementierungsabhängig und müssen möglicherweise nicht im Protokoll selbst spezifiziert werden.

- Verschleierung der Header und Inhalte von Nachrichten, die nicht vollständig verschlüsselt sind, ausreichend, damit DPI-Boxen und AV-Signaturen sie nicht leicht klassifizieren können. Sicherstellen, dass die Nachrichten, die an einen einzelnen Peer oder eine Gruppe von Peers gesendet werden, kein ähnliches Bitmuster haben.

- Behebung des Verlusts von Bits in DH aufgrund des Java-Formats [Ticket1112](http://{{ i2pconv('trac.i2p2.i2p') }}/ticket/1112) und Beschleunigung des DH durch Wechsel zu X25519.

- Wechsel zu einer realen Schlüsselableitungsfunktion (KDF) anstelle der Verwendung des DH-Ergebnisses wie es ist.

- Hinzufügen von "Abtastresistenz" (wie Tor es nennt); dies umfasst Wiederstandsresistenz.

- Aufrechterhaltung des 2-Wege-authentifizierten Schlüsselaustauschs (2W-AKE). 1W-AKE ist für unsere Anwendung nicht ausreichend.

- Abhängigkeit vom statischen öffentlichen Schlüssel, der in der RouterInfo veröffentlicht wird, als ein weiterer Teil der Authentifizierung.

- Optionen/Version im Handshake für zukünftige Erweiterbarkeit hinzufügen.

- Keine signifikante Erhöhung der CPU-Anforderungen für die Verbindungsherstellung; wenn möglich, diese signifikant reduzieren.

- Entfernung der Anforderung für Polsterung auf ein Vielfaches von 16 Bytes durch AES-Verschlüsselung in SSU 1 auferlegt.

- Verwendung von standardmäßigen ChaCha/Poly1305 für Verschlüsselung und MAC, Ersetzen der AES-Verschlüsselung und des nicht standardmäßigen HMAC-MD5-128 MAC, das in SSU 1 verwendet wird.

- Verwendung von separaten Verschlüsselungsschlüsseln für Senden und Empfangen anstelle der gemeinsamen Schlüssel für beide Richtungen, die in SSU 1 verwendet werden.

- Verwendung eines 3-Nachrichten-Handshakes mit einem Rundgang, wie in [NTCP2](/en/proposals/111-ntcp-2/). Entfernung der Verzögerung beim Warten auf Daten-Nachrichten, die [SSU](/en/docs/transport/ssu/) effektiv zu einem zwei-Rundgang-Handshake machen.

- Drastische Verbesserung der Effizienz von ACKs und NACKs, die in SSU 1 schrecklich sind. Reduzierung der für ACKs und NACKs erforderlichen Bandbreite und Erhöhung der verfügbaren Paketgröße für Daten. Effizientes Codieren von NACKs für einen Ausbruch fehlender Nachrichten, was über WiFi häufig vorkommt.

- Reduzierung der Komplexität, die erforderlich ist, um I2NP-Nachrichten-Fragmentierung zu implementieren. Umgehen von Fragmentierungsmechanismen und Codierung für vollständige I2NP-Nachrichten.

- Minimierung des Protokoll-Overheads vor der Polsterung, insbesondere für ACKs. Während Polsterung hinzugefügt wird, bleibt Overhead vor der Polsterung immer noch Overhead. Knoten mit niedriger Bandbreite müssen in der Lage sein, SSU2 zu verwenden.

- Aufrechterhaltung von Zeitstempeln für Rückspiel- und Abweichungsdetektion.

- Vermeidung von Problemen mit dem Jahr 2038 in Zeitstempeln, muss bis mindestens 2106 funktionieren.

- Erhöhung des minimalen MTU von 620 auf 1280 für Effizienz, Implementierungsfreundlichkeit und Erhöhung der maximalen I2NP-Nachrichtengröße. Fragmentierung und Wiederzusammenfügung sind ziemlich kostspielig. Durch Bereitstellung von Raum für 1028 Byte große Tunnel-Nachrichten wird die große Mehrheit der I2NP-Nachrichten keine Fragmentierung erfordern.

- Erhöhung des maximalen MTU von 1488 (1484 für IPv6) auf 1500 für Effizienz. Entfernen der Anforderung, dass das MTU ein Vielfaches von 16 ist.

- Erhöhung der maximalen I2NP-Nachrichtengröße von etwa 32K in SSU 1 auf etwa 64 KB wie in NTCP2.

- Entfernen der Signatur der IP- und Port-Felder aus dem Handshake, so dass Router, die ihre externe IP und ihren Port nicht kennen, sich verbinden können.

- Beibehaltung des IP/Port-Entdeckungsmechanismus aus SSU 1 im Handshake, so dass Router ihre externe IP und ihren Port lernen können.

- Einbeziehung von Vertretern der Java-, C++- und Go-Router-Entwickler in das Design.



### Nicht-Ziele

- Kugelsichere DPI-Resistenz... das wären pluggable Transports,
  [Prop109](/en/proposals/109-hashcash/).

- Ein TLS-basiertes (oder HTTPS-ähnliches) Transportprotokoll... das wäre [Prop104](/en/proposals/104-new-protocol/).

- Timing-basierte DPI-Resistenz (Inter-Message-Timing/Delays können implementierungsabhängig sein; Intra-Message-Delays können an jedem Punkt eingefügt werden, einschließlich vor dem Senden der zufälligen Polsterung, zum Beispiel). Künstliche Delays (was obfs4 als IAT oder Inter-Arrival Time bezeichnet) sind unabhängig vom Protokoll selbst.

- Bestreitbarkeit der Teilnahme an einer Sitzung (es gibt Signaturen darin).

Nicht-Ziele, die teilweise überdacht oder diskutiert werden können:

- Der Grad des Schutzes gegen Deep Packet Inspection (DPI)

- Post-Quantum (PQ) Sicherheit

- Bestreitbarkeit



## Sicherheitsziele

Wir betrachten drei Parteien:

- Alice, die eine neue Sitzung einrichten möchte.
- Bob, mit dem Alice eine Sitzung einrichten möchte.
- Mallory, der "Man in the Middle" zwischen Alice und Bob.

Es können höchstens zwei Teilnehmer aktive Angriffe durchführen.

Alice und Bob besitzen ein statisches Schlüsselpaar, das in ihrer [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) enthalten ist.

Das vorgeschlagene Protokoll versucht, dass Alice und Bob einen gemeinsamen geheimen Schlüssel (K) unter den folgenden Anforderungen vereinbaren können:

1) Sicherheit des privaten Schlüssels: Weder Bob noch Mallory erfahren etwas über Alice's privaten statischen Schlüssel. Symmetrisch erfährt Alice nichts über Bob's privaten statischen Schlüssel.

2) Der Sitzungsschlüssel K ist nur Alice und Bob bekannt.

3) Perfekte Vorwärtssicherheit: Der vereinbarte Sitzungsschlüssel bleibt auch dann geheim, wenn die statischen privaten Schlüssel von Alice und/oder Bob nach der Einigung auf den Schlüssel offengelegt werden.

4) Zwei-Wege-Authentifizierung: Alice ist sicher, dass sie eine Sitzung mit Bob eingerichtet hat, und umgekehrt.

5) Schutz vor Online DPI: Sicherstellen, dass es nicht trivial ist, nur mit einfachen Deep Packet Inspection (DPI)-Techniken zu erkennen, dass Alice und Bob sich am Protokoll beteiligen. Siehe unten.

6) Begrenzte Bestreitbarkeit: Weder Alice noch Bob können die Teilnahme am Protokoll leugnen, aber wenn einer den gemeinsamen Schlüssel leakt, kann die andere Partei die Echtheit der Inhalte der übertragenen Daten leugnen.

Der vorliegende Vorschlag versucht, alle fünf Anforderungen basierend auf dem Station-To-Station (STS)-Protokoll zu erfüllen [STS](https://en.wikipedia.org/wiki/Station-to-Station_protocol). Beachten Sie, dass dieses Protokoll auch die Basis für das SSU-Protokoll ist.


### Zusätzliche DPI-Diskussion

Wir gehen von zwei DPI-Komponenten aus:

Online DPI
`````````````

Online DPI inspiziert alle Flüsse in Echtzeit. Verbindungen können blockiert oder anderweitig manipuliert werden. Verbindungsdaten oder Metadaten können zur Offline-Analyse identifiziert und gespeichert werden. Die Online-DPI hat keinen Zugriff auf die I2P-Netzwerkdatenbank. Die Online-DPI hat nur begrenzte Echtzeit-Berechnungsfähigkeiten, einschließlich Längenberechnung, Feldinspektion und einfacher Berechnungen wie XOR. Die Online-DPI hat die Fähigkeit zu schnellen Echtzeit-Kryptografiefunktionen wie ChaCha20, AEAD und Hashing, aber diese wären zu teuer, um für die meisten oder alle Flüsse angewendet zu werden. Jede Anwendung dieser kryptografischen Operationen würde nur für Flüsse auf IP/Port-Kombinationen gelten, die zuvor durch Offline-Analyse identifiziert wurden. Die Online-DPI hat nicht die Fähigkeit zu kryptografischen Hochleistung-Funktionen wie DH oder elligator2. Die Online-DPI ist nicht speziell darauf ausgelegt, I2P zu erkennen, obwohl sie möglicherweise begrenzte Klassifikationsregeln zu diesem Zweck hat.

Es ist ein Ziel, die Protokollerkennung durch eine Online-DPI zu verhindern.

Der Begriff Online- oder "einfache" DPI wird hier als die Fähigkeit eines Angreifers aufgefasst:

1) Die Möglichkeit, alle Daten zu inspizieren, die vom Ziel gesendet oder empfangen werden.

2) Die Möglichkeit, Operationen an den beobachteten Daten durchzuführen, wie z.B. Blockchiffren oder Hash-Funktionen anzuwenden.

3) Die Fähigkeit, Daten zu speichern und mit zuvor gesendeten Nachrichten zu vergleichen.

4) Die Fähigkeit, Pakete zu verändern, zu verzögern oder zu fragmentieren.

Es wird jedoch angenommen, dass die Online-DPI die folgenden Einschränkungen hat:

5) Die Unfähigkeit, IP-Adressen Router-Hashes zuzuordnen. Während dies mit Echtzeitzugriff auf die Netzwerkdatenbank trivial ist,
   würde dies eine DPI-Anlage erfordern, die speziell auf I2P zielt.

6) Die Unfähigkeit, Zeitinformationen zur Protokollerkennung zu verwenden.

7) Im Allgemeinen enthält der Online-DPI-Toolbox keine eingebauten Tools, die speziell für die I2P-Erkennung entwickelt wurden. Dazu gehört das Erstellen von "Honeypots", die beispielsweise nicht-randomisierte Polsterungen in ihren Nachrichten enthalten würden. Beachten Sie, dass dies maschinelles Lernen oder hochkonfigurierbare DPI-Tools nicht ausschließt, solange sie die anderen Anforderungen erfüllen.

Zur Bekämpfung der Nutzlastanalyse wird der Nachrichteninhalt als ununterscheidbar von Zufallswerten gesichert. Dies erfordert auch, dass die Länge zufällig ist, was komplexer ist, als einfach zufällige Polsterung hinzuzufügen. Tatsächlich argumentieren die Autoren in Anhang A, dass ein naives (d.h. gleichmäßiges) Polsterungsschema das Problem nicht löst. Anhang A schlägt daher vor, entweder zufällige Verzögerungen einzuführen oder ein alternatives Polsterungsschema zu entwickeln, das einen angemessenen Schutz gegen den vorgeschlagenen Angriff bietet.

Um den oben genannten sechsten Eintrag zu schützen, sollten Implementierungen zufällige Verzögerungen im Protokoll einführen. Solche Techniken sind in diesem Vorschlag nicht vorgesehen, könnten jedoch auch die Probleme mit der Polsterungslänge lösen. Zusammenfassend bietet der Vorschlag einen guten Schutz gegen Nutzlastanalyse (wenn die Überlegungen in Anhang A berücksichtigt werden), jedoch nur einen begrenzten Schutz gegen Flussanalyse.


Offline DPI
``````````````

Offline-DPI inspiziert Daten, die von der Online-DPI zur späteren Analyse gespeichert wurden. Die Offline-DPI kann speziell darauf ausgelegt sein, I2P zu erkennen. Die Offline-DPI hat Echtzeitzugriff auf die I2P-Netzwerkdatenbank. Die Offline-DPI hat Zugriff auf diese und andere I2P-Spezifikationen. Die Offline-DPI hat unbegrenzte Rechenkapazitäten, einschließlich aller in dieser Spezifikation definierten kryptografischen Funktionen.

Die Offline-DPI hat nicht die Fähigkeit, bestehende Verbindungen zu blockieren. Die Offline-DPI hat die Möglichkeit, innerhalb von Minuten nach dem Setup Datensendungen an Host/Port von Parteien durch Paketinjektion durchzuführen. Die Offline-DPI hat die Möglichkeit, innerhalb weniger Minuten nach dem Setup alte Nachrichten (modifiziert oder nicht) zur "Erkundung" oder aus anderen Gründen erneut abzuspielen.

Es ist kein Ziel, die Protokollerkennung durch eine Offline-DPI zu verhindern. Die gesamte Entschlüsselung von verunklarten Daten in den ersten beiden Nachrichten, die von I2P-Routern implementiert wird, kann auch von der Offline-DPI implementiert werden.

Es ist ein Ziel, Verbindungsversuche mit Wiederholungsangriffen zu blockieren.




### Address Validation

Das folgende ist aus QUIC [RFC-9000](https://www.rfc-editor.org/rfc/rfc9000.html) kopiert.
Für jeden Abschnitt, überprüfen und bearbeiten.

Adressvalidierung stellt sicher, dass ein Endpunkt nicht für einen
Verstärkungsangriff verwendet werden kann. In einem solchen Angriff wird
ein Paket mit gefälschtem Quelladresseninformation an einen Server gesendet, der eine
fiktive Adresse des Opfers angibt. Wenn ein Server
in Reaktion auf dieses Paket mehr oder größere Pakete generiert,
kann der Angreifer den Server verwenden, um mehr Daten in Richtung des Opfers zu senden,
als er selbst senden könnte.

Die Hauptverteidigung gegen Verstärkungsangriffe ist die Überprüfung, dass ein
Peer Pakete an der angegebenen Transportadresse
empfangen kann. Daher muss ein Endpunkt nach Erhalt von Paketen von einer
nicht validierten Adresse die Größe der Daten, die er an die nicht validierte Adresse sendet,
auf dreimal die Menge der von dieser Adresse empfangenen Daten begrenzen. Diese Begrenzung der
Größe der Antworten ist als Anti-Verstärkungslimit bekannt.

Adressvalidierung wird sowohl während der Verbindungsherstellung
(siehe Abschnitt 8.1) als auch während der Verbindungsmigration (siehe Abschnitt 8.2)
durchgeführt.

Adressvalidierung während der Verbindungsherstellung
```````````````````````````````````````````````````````

Die Verbindungsherstellung stellt implizit eine Adressvalidierung für
beide Endpunkte bereit. Insbesondere der Erhalt eines Pakets, das mit
Handshake-Schlüsseln geschützt ist, bestätigt, dass der Peer erfolgreich ein
Initial-Paket verarbeiten konnte. Sobald ein Endpunkt ein Handshake-Paket
vom Peer erfolgreich verarbeitet hat, kann er die Peer-Adresse als validiert betrachten.

Darüber hinaus kann ein Endpunkt die Peer-Adresse als validiert betrachten, wenn
der Peer eine von ihm gewählte Verbindung ID verwendet und die
Verbindung ID mindestens 64 Bits Entropie enthält.

Für den Client ermöglicht der Wert des Destination Connection ID-Feldes in
seinem ersten Initial-Paket die Validierung der Server-Adresse als
Teil der erfolgreichen Verarbeitung eines beliebigen Pakets. Initial-Pakete
vom Server sind mit Schlüsseln geschützt, die aus diesem Wert
abgeleitet werden (siehe Abschnitt 5.2 in [QUIC-TLS]). Alternativ wird der Wert vom
Server in Version Negotiation-Paketen (Abschnitt 6) widergespiegelt oder
im Integrity Tag in Retry-Paketen (Abschnitt 5.8 von [QUIC-TLS])
enthalten.

Vor der Validierung der Client-Adresse dürfen Server nicht mehr
als dreimal so viele Bytes senden, wie sie empfangen haben. Dies begrenzt
das Ausmaß eines Verstärkungsangriffes, der durch gefälschte Quelladressen
eingeleitet werden kann. Für den Zweck, Verstärkungsangriffe vor einer
Adressvalidierung zu vermeiden, müssen Server alle Payload-Bytes,
die in Datagrammen enthalten sind, die eindeutig einer einzelnen Verbindung
zugeordnet sind, zählen. Dies umfasst Datagramme, die Pakete enthalten, die
erfolgreich verarbeitet werden, und Datagramme, die Pakete enthalten, die
alle verworfen werden.

Clients müssen sicherstellen, dass UDP-Datagramme, die Initial-Pakete
enthalten, UDP-Payloads von mindestens 1200 Bytes haben, wobei
PADDING-Frames nach Bedarf hinzugefügt werden. Ein Client, der gepolsterte
Datagramme sendet, ermöglicht es dem Server, mehr Daten zu senden,
bevor er die Adressvalidierung abschließt.

Der Verlust eines Initial- oder Handshake-Pakets vom Server kann eine
Sackgasse verursachen, wenn der Client keine zusätzlichen Initial- oder Handshake-
Pakete sendet. Eine Sackgasse könnte auftreten, wenn der Server sein
Anti-Verstärkungslimit erreicht und der Client Bestätigungen für
alle Daten erhalten hat, die er gesendet hat. In diesem Fall, wenn der Client keinen
Grund hat, zusätzliche Pakete zu senden, wird der Server keine
weiteren Daten senden können, da er die Client-Adresse nicht validiert hat. Um
dieser Sackgasse zu vermeiden, müssen Clients ein Paket auf Timeout senden
(Probe Timeout, PTO); siehe Abschnitt 6.2 von [QUIC-RECOVERY]. Insbesondere
muss der Client ein Initial-Paket in einem UDP-Datagram senden, das
mindestens 1200 Bytes enthält, wenn er keine Handshake-Schlüssel hat, und
andernfalls ein Handshake-Paket senden.

Ein Server möchte möglicherweise die Client-Adresse validieren, bevor er
den kryptografischen Handshake startet. QUIC verwendet ein Token im Initial-
Paket, um eine Adressvalidierung vor Abschluss des Handshakes
bereitzustellen. Dieses Token wird dem Client während der
Verbindungsherstellung mit einem Retry-Paket (siehe Abschnitt 8.1.2) oder in einer
vorherigen Verbindung unter Verwendung des NEW_TOKEN-Frames (siehe Abschnitt 8.1.3)
bereitgestellt.

Zusätzlich zu den Sendebegrenzungen, die vor der Adressvalidierung
auferlegt werden, sind Server auch durch die von der
Staukontrolle gesetzten Begrenzungen eingeschränkt. Clients sind nur durch die
Staukontrolle eingeschränkt.

Token-Konstruktion
```````````````````````````````````````````````````````

Ein im NEW_TOKEN-Frame oder in einem Retry-Paket gesendetes Token muss
so konstruiert sein, dass der Server identifizieren kann, wie es einem Client
posibiliterte. Diese Tokens werden im gleichen Feld übertragen, erfordern aber unterschiedliche
Verarbeitung von Servern.

Adressvalidierung mit Retry-Paketen
```````````````````````````````````````````````````````

Beim Empfang des Initial-Pakets des Clients kann der Server
eine Adressvalidierung anfordern, indem er ein Retry-Paket sendet (Abschnitt 17.2.5),
das ein Token enthält. Dieses Token MUSS vom Client in allen
Initial-Paketen, die es für diese Verbindung sendet, wiederholt werden,
nachdem es das Retry-Paket erhalten hat.

Als Antwort auf die Verarbeitung eines Initial-Pakets, das ein Token
enthält, das in einem Retry-Paket bereitgestellt wurde, kann ein Server kein weiteres
Retry-Paket senden; er kann nur die Verbindung ablehnen oder
sie fortsetzen lassen.

Solange es einem Angreifer nicht möglich ist, ein gültiges
Token für seine eigene Adresse zu generieren (siehe Abschnitt 8.1.4) und der
Client dieses Token zurückgeben kann, beweist es dem Server, dass es das
Token erhalten hat.

Ein Server kann auch ein Retry-Paket verwenden, um die
Verbindungsherstellungskosten zu verzögern. Der Server muss eine
andere Verbindungskennung zusammen mit dem
original_destination_connection_id-Transportparameter bereitstellen, wie in
Abschnitt 18.2 definiert, was den Server zwingt, zu demonstrieren, dass
er oder eine mit ihm kooperierende Entität das ursprüngliche Initial-Paket
vom Client empfangen hat. Die Bereitstellung einer
anderen Verbindungskennung ermöglicht es einem Server auch, die
nachfolgenden Pakete anders zu routen. Dies kann verwendet werden, um Verbindungen an
eine andere Serverinstanz zu overmitteln.

Wenn ein Server ein Initial-Paket vom Client empfängt, das ein ungültiges
Retry-Token enthält, aber ansonsten gültig ist, weiß er, dass der Client kein
weiteres Retry-Token akzeptieren wird. Der Server könnte ein
solches Paket verwerfen und das Timeout des Clients zulassen, um
ein Handshake-Fehlverhalten zu erkennen, aber das würde dem Client
eine bedeutende Latenz auferlegen. Stattdessen SOLLTE der Server die
Verbindung sofort mit einem INVALID_TOKEN-Fehler schließen
(Abschnitt 10.2). Beachten Sie, dass ein Server zu diesem Zeitpunkt keine
Seitenverbindungen für die Verbindung hat und daher nicht in den
Schließungszeitraum eintritt.

Ein Fluss, der die Verwendung eines Retry-Pakets zeigt, ist in
Abbildung 9 dargestellt.

```
Client                                                  Server

  Initial[0]: CRYPTO[CH] ->

                                                <- Retry+Token

  Initial+Token[1]: CRYPTO[CH] ->

                                 Initial[0]: CRYPTO[SH] ACK[1]
                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                 <- 1-RTT[0]: STREAM[1, "..."]

                Figure 9: Example Handshake with Retry
```



Adressvalidierung für zukünftige Verbindungen
```````````````````````````````````````````````````````

Ein Server kann Clients ein Adressvalidierungstoken
in einer Verbindung bereitstellen, das in einer zukünftigen Verbindung verwendet
werden kann. Adressvalidierung ist insbesondere bei 0-RTT
wichtig, da ein Server möglicherweise in einer Verbindung
aufgrund von 0-RTT-Daten viele Daten an einen Client sendet.

Der Server verwendet den NEW_TOKEN-Frame (Abschnitt 19.7), um dem
Client ein Adressvalidierungstoken bereitzustellen, das in
zukünftigen Verbindungen verwendet werden kann. In einer zukünftigen Verbindung
schließt der Client dieses Token in alle Initial-Pakete ein,
um die Adressvalidierung zu liefern. Der Client MUSS das Token in
alle Initial-Pakete aufnehmen, die er sendet, es sei denn, ein Retry
ersetzt das Token durch ein neueres. Der Client darf das
Token, das in einem Retry bereitgestellt wird, nicht für zukünftige Verbindungen verwenden. Server KÖNNEN jedes
Initial-Paket, das nicht das erwartete Token trägt, verwerfen.

Im Gegensatz zu dem Token, das für ein Retry-Paket erstellt wird und
unmittelbar verwendet wird, kann das im NEW_TOKEN-Frame gesendete
Token nach Ablauf einer bestimmten Zeitspanne verwendet werden. Daher SOLLTE ein Token eine
Ablaufzeit haben, die ein explizites Ablaufdatum sein könnte
oder ein ausgegebener Zeitstempel, der zur dynamischen Berechnung der
Ablaufzeit verwendet werden kann. Ein Server kann das Ablaufdatum speichern
oder es in einer verschlüsselten Form im Token hinterlegen.

Ein im NEW_TOKEN-Frame bereitgestelltes Token DARF keine Informationen enthalten, die
es einem Beobachter ermöglichen würden, die Werte der Verbindung, aus der es ausgesandt wurde,
zu verknüpfen. Zum Beispiel darf es keine vorherigen
Verbindungs-IDs oder Adressinformationen enthalten, es sei denn, die
Werte sind verschlüsselt. Ein Server MUSS sicherstellen, dass jeder NEW_TOKEN-Frame, den er
sendet, für alle Clients einzigartig ist, mit Ausnahme von
neuen Inhalten von TRY_TOKEN-Frame.
Informationen, die es dem Server ermöglichen, zwischen Token
aus Retry und NEW_TOKEN zu unterscheiden, KÖNNTEN anderen
Entitäten als dem Server zugänglich gemacht werden.

Es ist unwahrscheinlich, dass die Client-Portnummer auf zwei
verschiedenen Verbindungen dieselbe ist; daher ist die Validierung
des Ports unwahrscheinlich erfolgreich zu sein.

Ein im NEW_TOKEN-Frame erhaltenes Token gilt für
alle Serververbindungen, für die die Verbindung als autoritativ
betrachtet wird (z.B. Servernamen, die im Zertifikat
enthalten sind). Wenn eine Verbindung zu einem Server hergestellt wird, für
den der Client ein anwendbares und unbenutztes Token hat, SOLLTE
er dieses Token in das Token-Feld des Initial-Pakets einfügen.
Die Einfügung eines Tokens könnte es dem Server ermöglichen, die
Client-Adresse zu validieren, ohne eine zusätzliche Rundreise durchzuführen.
Der Client DARF kein Token verwenden, das nicht für den Server
angewendet wird, zu dem er eine Verbindung herstellt, es sei denn, er
hat das Wissen, dass der Server, der das Token ausgestellt hat, und der Server, zu dem der Client eine Verbindung herstellt,
gemeinsam die Tokens verwalten. Ein Client KÖNNTE ein Token von
einer vorherigen Verbindung zu diesem Server verwenden.

Ein Token ermöglicht es einem Server, Aktivitäten zwischen der Verbindung,
in dem das Token ausgestellt wurde, und jeder Verbindung, in der es
verwendet wird, zu korrelieren. Clients, die die
Kontinuität ihrer Identität mit einem Server brechen möchten,
können die im NEW_TOKEN-Frame bereitgestellten Tokens verwerfen. Im Vergleich dazu
muss ein Token, das in einem Retry-Paket erhalten wurde, sofort
während des Verbindungsversuchs verwendet werden und kann in
zukünftigen Verbindungsversuchen nicht verwendet werden.

Ein Client SOLLTE das im NEW_TOKEN-Frame erhaltene Token nicht
für verschiedene Verbindungsversuche erneut verwenden. Das erneute
Verwenden eines Tokens ermöglicht es Verbindungen, von
Entitäten auf dem Netzwerkpfad verknüpft zu werden; siehe Abschnitt 9.5.

Clients könnten mehrere Tokens in einer einzigen Verbindung
erhalten. Abgesehen davon, dass Verknüpfungen verhindert werden, kann
jedes Token in jedem Verbindungsversuch verwendet werden.
Server können zusätzliche Tokens senden, um die Adressvalidierung
für mehrere Verbindungsversuche zu ermöglichen oder ältere Tokens, die
ungültig werden könnten, zu ersetzen. Für einen Client bedeutet
diese Mehrdeutigkeit, dass das Senden des zuletzt unbenutzten Tokens
wahrscheinlich die erfolgreichste Methode ist, um die
Adressvalidierung für den Server durchzuführen.
Obwohl das Speichern und Verwenden älterer Tokens keine
nachteiligen Folgen hat, können Clients ältere Tokens
als unwahrscheinlicher ansehen, um für den Server zur Adressvalidierung von Bedeutung zu sein.

Wenn ein Server ein Initial-Paket mit einem Adressvalidierungs-
token erhält, muss er den Versuch, das Token
zu validieren, unternehmen, es sei denn, er hat die
Adressvalidierung bereits abgeschlossen. Wenn das Token ungültig ist, sollte
der Server vorgehen, als ob der Client keine
validierte Adresse hätte, einschließlich des möglichen Sendens eines
Retry-Pakets. Tokens, die im NEW_TOKEN-Frame und in
Retry-Paketen bereitgestellt werden, können von den Servern
unterschieden werden (siehe Abschnitt 8.1.1), und
letztere können strenger validiert werden. Wenn die Validierung
erfolgreich ist, sollte der Server dann den Handshake fortsetzen.

Hinweis: Der Grund dafür, den Client als
nicht validiert zu behandeln, anstatt das Paket zu
verwerfen, liegt darin, dass der Client das Token
möglicherweise in einer vorherigen Verbindung mit dem NEW_TOKEN-Frame erhalten
hat, und wenn der Server den Zustand verloren hat, könnte
er möglicherweise nicht in der Lage sein, das Token zu
validieren, was zu einem Verbindungsfehler führen könnte, wenn
das Paket verworfen wird.

In einem stateless Design kann ein Server verschlüsselte und
authentifizierte Tokens verwenden, um Informationen an Clients
zu übergeben, um diese später wiederherzustellen und zur
Validierung einer Client-Adresse zu verwenden. Tokens sind nicht in den
kryptografischen Handshake integriert, und daher
ist Iacknote sie nicht
authentifiziert. Beispielsweise könnte ein Client in der Lage sein, ein
Token erneut zu verwenden. Um Angriffe zu vermeiden, die sich
diese Eigenschaft zunutze machen, kann ein Server die Verwendung von
Tokens nur auf die Informationen beschränken, die zur
Validierung von Client-Adressen benötigt werden.

Clients KÖNNTEN Tokens, die in einer Verbindung erhalten wurden,
für jeden Verbindungsversuch mit derselben Version verwenden. Beim
Auswählen eines Tokens zur Verwendung müssen Clients keine
anderen Eigenschaften der zu versuchenden Verbindung
berücksichtigen, einschließlich der Auswahl möglicher
Anwendungsprotokolle, Sitzungstickets oder anderer
Verbindungseigenschaften.

Integrität von Address Validation Tokens
```````````````````````````````````````````````````````

Ein Adressvalidierungstoken muss schwer zu erraten
sein. Die Einbeziehung eines zufälligen
Wertes mit mindestens 128 Bits Entropie in das Token wäre
ausreichend, aber dies hängt davon ab, ob sich
der Server den gesandten Wert merkt.

Ein Token-basierendes Schema ermöglicht es dem Server,
jeden mit der Validierung in Verbindung stehenden Zustand
auf den Client zu verschieben. Für dieses Design
zu arbeiten, muss das Token durch
Integritätsschutz gegen
Änderung oder Fälschung durch den Client geschützt werden. Ohne Integritätsschutz
könnten böswillige Clients Werte für
Tokens generieren oder erraten, die vom Server akzeptiert
würden. Nur der Server benötigt Zugang zum Integritätsschutz-Schlüssel für Tokens.

Es gibt keine Notwendigkeit für ein einziges, gut definiertes Format
für das Token, da der Server, der das Token
generiert, es auch konsumieren
wird. Tokens, die in Retry-Paketen gesendet
werden, sollten Informationen enthalten,
die dem Server ermöglichen, zu überprüfen, ob die
Quell-IP-Adresse und der Port in
Client-Paketen konstant bleiben.

Tokens, die mit NEW_TOKEN-Frames gesendet
werden, müssen Informationen enthalten,
die dem Server ermöglichen,
zu überprüfen, ob sich die
Client-IP-Adresse nicht geändert hat,
seit das Token ausgestellt wurde. Server können auf
Tokens in NEW_TOKEN-Frames Zurückgreifen, wenn sie entscheiden,
kein Retry-Paket zu versenden.  Wenn die Client-IP-Adresse
sich geändert hat, muss der Server
das Anti-Verstärkungslimit einhalten;
siehe Abschnitt 8.  Beachten Sie, dass
in Anwesenheit von NAT diese Anforderung
möglicherweise nicht ausreicht, um andere
Hosts, die das NAT teilen,
vor Verstärkungsangriffen zu schützen.

Angreifer könnten Tokens erneut
abspielen, um Server als Verstärker in DDoS-
Angriffen zu verwenden. Um sich gegen solche Angriffe
zu schützen, müssen Server sicherstellen,
dass die Wiederholung von Tokens verhindert oder
eingeschränkt wird. Server sollten sicherstellen,
dass Tokens in Retry-Paketen nur akzeptiert
werden, wenn sie kurzfristig sind,
da sie vom Client sofort zurückgegeben werden.  Tokens,
die in NEW_TOKEN-Frames bereitgestellt
werden (Abschnitt 19.7), müssen für
länger gültig sein, sollten jedoch nicht
mehrfach akzeptiert werden. Server werden
dazu ermuntert, die Verwendung von
Tokens nur einmal zuzulassen, sofern möglich;
Tokens KÖNNEN zusätzliche Informationen
über Clients enthalten, um die
Anwendbarkeit oder Wiederverwendung
weiter einzuschränken.

Pfadvalidierung
```````````````````````````````````````````````````````

Die Pfadvalidierung wird von
beiden Partnern während der Verbindungsmigration
durchgeführt (siehe Abschnitt 9), um die Erreichbarkeit
nach einer Adressänderung zu bestätigen. In der
Pfadvalidierung testen Endpunkte
die Erreichbarkeit zwischen einer spezifischen
lokalen Adresse und einer spezifischen
Peer-Adresse, wobei eine Adresse
das 2-Tupel aus IP-Adresse und Port ist.

Die Pfadvalidierung überprüft, dass Pakete,
die über einen Pfad an einen Peer gesendet werden, von
diesem Peer empfangen werden.
Die Pfadvalidierung wird verwendet, um sicherzustellen,
dass Pakete, die von
einem migrierenden Peer empfangen werden,
keine gefälschte Quelladresse tragen.

Die Pfadvalidierung validiert nicht, dass ein Peer
in der Rückrichtung senden kann. Bestätigungen
können nicht für die Validierung des Rückpfads
verwendet werden, da sie unzureichende Entropie
enthalten und gefälscht werden können.
Endpunkte bestimmen unabhängig die
Erreichbarkeit in jeder Richtung eines
Pfades, und daher kann die
Rückwegerreichbarkeit nur durch den
Peer hergestellt werden.

Die Pfadvalidierung kann jederzeit von beiden
Endpunkten verwendet werden. Ein Endpunkt
könnte zum Beispiel überprüfen, ob ein Peer
immer noch im Besitz seiner Adresse ist
nach einer Zeit der Ruhe.

Die Pfadvalidierung ist nicht als NAT-Traversal-
Mechanismus konzipiert. Obwohl der hier beschriebene
Mechanismus möglicherweise wirksam für die
Erstellung von NAT-Bindings zur Unterstützung des NAT-
Traversals ist, wird erwartet, dass ein
Endpunkt ohne Sendung eines
Pakets auf dem Pfad in der Lage ist,
Pakete zu empfangen. Effektives NAT-
Traversal benötigt zusätzliche
Synchronisationsmechanismen, die hier
nicht zur Verfügung gestellt werden.

Ein Endpunkt KANN andere Frames mit
den PATH_CHALLENGE- und PATH_RESPONSE-
Frames verwenden, die für die
Pfadvalidierung verwendet werden.
Insbesondere kann ein Endpunkt
PADDING-Frames mit einem PATH_CHALLENGE-Frame
für die Pfad-MTU-Entdeckung (PMTUD) enthalten;
siehe Abschnitt 14.2.1. Ein Endpunkt
kann auch seinen eigenen
PATH_CHALLENGE-Frame senden,
wenn er einen PATH_RESPONSE-Frame sendet.

Wir verwenden auch eine neue
Verbindungs-ID für Tests, die von
einer neuen lokalen Adresse gesendet
werden, siehe Abschnitt 9.5. Wenn
wir einen neuen Pfad testen, kann der
Endpunkt sicherstellen, dass sein
Peer eine ungenutzte Verbindungs-ID
für Antworten hat. Durch das Senden von
NEW_CONNECTION_ID- und PATH_CHALLENGE-
Frames im gleichen Paket, falls
die active_connection_id_limit des Peers dies
erlaubt, wird sichergestellt, dass
eine ungenutzte Verbindungs-ID dem Peer
zur Verfügung steht, wenn er eine Antwort
senden möchte.

Ein Endpunkt kann wählen,
mehrere Pfade gleichzeitig zu testen.
Die Anzahl der gleichzeitig
verwendeten Pfade für Tests ist durch
die Anzahl der zusätzlichen
Verbindungs-IDs begrenzt, die sein Peer
früher bereitgestellt hat, da jede
neue lokale Adresse, die für einen
Test verwendet wird, eine zuvor
ungebrauchte Verbindungs-ID erfordert.

Start der Pfadvalidierung
```````````````````````````````````````````````````````

Zum Initiieren der Pfadvalidierung
sendet ein Endpunkt einen
PATH_CHALLENGE-Frame mit einem
unvorhersehbaren Payload auf dem
zu validierenden Pfad.

Ein Endpunkt kann mehrere
PATH_CHALLENGE-Frames senden, um
einem Paketverlust vorzubeugen.
Ein Endpunkt SOLLTE jedoch nicht mehrere
PATH_CHALLENGE-Frames in einem
einzigen Paket senden.

Ein Endpunkt SOLLTE einen neuen
Pfad mit Paketen nicht öfter testen,
die einen PATH_CHALLENGE-Frame
enthalten, es sei denn, es würde ein
Initial-Paket gesendet. Dies stellt
sicher, dass die Verbindungsmigration
keine höhere Belastung für einen
neuen Pfad darstellt als die Herstellung
einer neuen Verbindung.

Der Endpunkt MUSS unvorhersehbare
Daten in jedem PATH_CHALLENGE-
Frame verwenden, um sicherstellen
zu können, welche Antwort zu
welchem PATH_CHALLENGE gehört.

Ein Endpunkt SOLLTE die Datagramme,
die einen PATH_CHALLENGE-Frame
enthalten, an die Mindestgröße
des maximal zulässigen Datagramms
von 1200 Bytes erweitern, es sei denn,
das Anti-Verstärkungslimit für den Pfad
erlaubt das Senden eines Datagramms
dieser Größe nicht. Das Senden von UDP-
Datagrammen dieser Größe stellt sicher,
dass der Netzwerkpfad vom Endpunkt
zum Peer für QUIC verwendet werden
kann; siehe Abschnitt 14.

Wenn ein Endpunkt nicht in der Lage
ist, die Datagrammgröße aufgrund
des Anti-Verstärkungslimits auf
1200 Bytes zu erweitern,
wird die Pfad-MTU nicht validiert.
Um sicherzustellen, dass die Pfad-MTU
groß genug ist, muss der Endpunkt
eine zweite Pfadvalidierung durchführen,
indem er einen PATH_CHALLENGE-
Frame in einem Datagram von
mindestens 1200 Bytes sendet.
Diese zusätzliche Validierung kann
nach erfolgreichem Empfang eines
PATH_RESPONSE oder wenn genügend
Bytes empfangen wurden
(dieses Pakets) gesendet werden,
durchgeführt werden,
wenn das Senden des größeren
Datagramms das Anti-Verstärkungslimit
nicht überschreitet.

Im Gegensatz zu anderen Fällen, bei denen
Datagramme erweitert werden, erhalten
Endpunkte, die einen
PATH_CHALLENGE-Frame oder
PATH_RESPONSE enthalten,
nicht zu klein erscheinende Datagramme
bei zu kleinen Datagrammen:
das Paket wird nicht verworfen.

PATH_CHALLENGE-Rahmen
```````````````````````````````````````````````````````

Wenn ein Endpunkt einen PATH_CHALLENGE-Frame
empfängt, MUSS er antworten, indem
er die darin enthaltenen Daten
in einem PATH_RESPONSE-Frame wiedergibt.
Ein Endpunkt SOLLTE die Übertragung
eines Pakets mit einem PATH_RESPONSE-Frame nicht
verzögern, es sei denn,
auslastungsgesteuert.

Ein PATH_RESPONSE-Frame MUSS über den
Netzwerkpfad gesendet werden,
über den der PATH_CHALLENGE-Frame
empfangen wurde. Dies stellt sicher,
dass die Pfadvalidierung nur dann
erfolgreich ist, wenn der Pfad
in beiden Richtungen funktioniert.
Diese Anforderung DARF nicht von dem
Endpunkt durchgesetzt werden,
der die Pfadvalidierung initiiert,
da dies zu einem Angriff auf die
Migration führen könnte; siehe
Abschnitt 9.3.3.

Ein Endpunkt SOLLTE die Datagramme,
die einen PATH_RESPONSE-Frame
enthalten, an die Mindestgröße
des maximal zulässigen Datagramms
von 1200 Bytes erweitern.
Dies prüft, ob der Pfad in beiden
Richtungen Datagramme dieser Größe
führen kann. Ein Endpunkt SOLLTE jedoch
das Datagramm, das den PATH_RESPONSE
enthält, nicht erweitern, wenn die
resultierende Datenmenge das Anti-
Verstärkungslimit überschreiten
würden. Dies wird voraussichtlich nur
eintreten, wenn der empfangene
PATH_CHALLENGE nicht
in einem erweiterten Datagramm
gesendet wurde.

Ein Endpunkt darf nicht mehr als einen
PATH_RESPONSE-Frame als Antwort
auf einen PATH_CHALLENGE-Frame
senden; siehe Abschnitt 13.3.
Der Peer wird erwartet, wie erforderlich
mehr PATH_CHALLENGE-Frames zu
senden um zusätzliche
PATH_RESPONSE-Frames zu erhalten.

Erfolgreiche Pfadvalidierung
```````````````````````````````````````````````````````

Die Pfadvalidierung ist erfolgreich,
wenn ein PATH_RESPONSE-Frame
erhalten wird, der die in einem
vorherigen PATH_CHALLENGE-Frame gesendeten
Daten enthält. Ein PATH_RESPONSE-Frame
validiert den Pfad, auf dem der
PATH_CHALLENGE gesendet wurde.

Wenn ein Endpunkt ein
PATH_CHALLENGE-Frame in einem
Datagramm sendet, das nicht
auf mindestens 1200 Bytes erweitert
wurde, und wenn die Antwort
die Peer-Adresse validiert,
ist der Pfad validiert, aber nicht die
Pfad-MTU. Infolgedessen kann der
Endpunkt nun mehr als die dreifache
Menge an Daten senden, die
empfangen wurde. Der Endpunkt MUSS
jedoch eine weitere Pfadvalidierung
durchführen, indem er ein
PATH_CHALLENGE-Frame in einem Datagramm
von mindestens 1200 Bytes sendet,
um sicherzustellen, dass der Pfad
die geforderte MTU unterstützt.

Der Empfang einer Bestätigung für ein
Paket, das ein PATH_CHALLENGE-Frame
enthält, reicht nicht
aus, da die Bestätigung
von einem böswilligen Peer
gefälscht werden kann.

Fehlgeschlagene Pfadvalidierung
```````````````````````````````````````````````````````

Die Pfadvalidierung schlägt nur dann
fehl, wenn der Endpunkt, der die Validierung
des Pfades versucht, den Versuch abbricht.

Endpunkte SOLLTEN die Pfadvalidierung
aufgrund eines Timers abbrechen. Beim
Einstellen dieses Timers sollten
Implementierungen darauf achten,
dass der neue Pfad möglicherweise
eine längere Round-Trip-Zeit als
der ursprüngliche hat. Ein Wert,
der drei Mal so groß ist wie das
aktuelle PTO oder das PTO für den
neuen Pfad (unter Verwendung des kInitialRtt,
wie in [QUIC-RECOVERY] definiert),
wird EMPFOHLEN.

Dieses Timeout ermöglicht es mehreren
PTOs abzubrechen, bevor die
Pfadvalidierung fehlschlägt, sodass
der Verlust eines einzigen PATH_CHALLENGE
oder PATH_RESPONSE-Frames nicht
zum Scheitern der Pfadvalidierung führt.

Hinweis: der Endpunkt könnte
Pakete enthalten, die andere
Frames auf dem neuen Pfad enthalten,
aber ein PATH_RESPONSE-Frame
mit passenden Daten ist notwendig,
damit die Pfadvalidierung erfolgreich ist.

Wenn ein Endpunkt die
Pfadvalidierung abbricht, stellt er fest,
dass der Pfad unbrauchbar ist. Dies bedeutet
nicht zwangsläufig ein
Verbindungsfehler -- Endpunkte
können weiterhin Pakete über
andere Pfade senden, wie angemessen.
Wenn keine Pfade verfügbar sind, kann
der Endpunkt warten, bis ein neuer
Pfad verfügbar wird, oder die
Verbindung schließen. Ein Endpunkt,
der keinen gültigen Netzwerkpfad zu
seinem Peer hat, KANN dies mit einem
NO_VIABLE_PATH-Verbindungsfehler
signalisieren, wobei dies nur
möglich ist, wenn der Netzwerkpfad
existiert, jedoch nicht die
erforderliche MTU unterstützt
(Siehe Abschnitt 14).

Eine Pfadvalidierung könnte aus
anderen Gründen außer einem
Fehler abgebrochen werden.
Dies geschieht vor allem, wenn eine
Verbindungsmigration zu einem neuen
Pfad eingeleitet wird, während eine
Pfadvalidierung auf dem alten Pfad
noch im Gange ist.



### Verbindungsmigration

Das Folgende ist aus QUIC [RFC-9000] kopiert.
Für jeden Abschnitt, überprüfen und bearbeiten.

Die Verwendung einer Verbindungs-ID
ermöglicht es Verbindungen,
Änderungen von Adresse der Endpunkte
(IP und Port) zu überleben,
wie diejenigen, die durch einen
Endpunkt verursacht werden, der zu einem
neuen Netzwerk migriert.
Dieser Abschnitt beschreibt den
Prozess, durch den ein Endpunkt
zu einer neuen Adresse migriert.

Das Design von QUIC basiert darauf, dass
Endpoints für die Dauer des Handshakes
eine stabile Adresse beibehalten.
Ein Endpunkt DARF keine
Verbindungsmigration vornehmen, bevor
der Handshake bestätigt ist, wie in
Abschnitt 4.1.2 von [QUIC-TLS] definiert.

Wenn der Peer den
disable_active_migration-Transportparameter
gesendet hat,
darf ein Endpunkt keine Pakete
(einschließlich Probing-Paketen; siehe
Abschnitt 9.1) von einer anderen
lokalen Adresse an die durch den
Handshake verwendete Adresse des
Peers senden, es sei denn, der
Endpunkt hat auf einen
preferred_address-Transportparameter
vom Peer reagiert. Wenn der Peer
diese Anforderung verletzt, muss
der Endpunkt entweder die eingehenden
Pakete auf diesem Pfad ohne Generierung
eines Stateless Reset fallen lassen
oder die Pfadvalidierung fortsetzen
und den Peer die Migration
durchführen lassen. Ein Stateless
Reset oder die Schließung der
Verbindung zu generieren, würde
es Dritten im Netzwerk ermöglichen,
Verbindungen zu schließen, indem sie
beobachteten Verkehr fälschen oder
manipulieren.

Nicht alle Änderungen von Peer-Adressen
sind absichtlich oder aktiv,
Migrationen. Der Peer könnte
ein NAT-Rebinding erleben: eine
Adressänderung aufgrund eines
Mittelmanns, üblicherweise eines NAT,
ein neuer ausgehender Port oder
sogar eine neue ausgehende IP
Adresse für einen Fluss. Ein Endpunkt
MUSS die Pfadvalidierung durchführen
(Abschnitt 8.2), wenn er eine
Änderung der Adresse eines Peers
erkennt, es sei denn, er hat diese
Adresse zuvor validiert.

Wenn ein Endpunkt keinen validierten
Pfad hat, auf dem er Pakete senden
kann, kann er den Zustand der
Verbindung verwerfen. Ein Endpunkt,
der zur Verbindungsmigration fähig
ist, KÖNNte auf einem neuen Pfad
warten, bevor er den Zustand der
Verbindung verwirft.

Dieses Dokument beschränkt die Migration
von Verbindungen zu neuen
Client-Adressen, außer wie in
Abschnitt 9.6 beschrieben. Clients sind
verantwortlich für das Initiieren aller
Migrationen. Server senden keine
nicht-probing Pakete (siehe Abschnitt
9.1) an eine Client-Adresse, bis
sie ein nicht-probing Paket von
dieser Adresse gesehen haben. Wenn
ein Client Pakete von einer
unbekannten Server-Adresse
empfängt, muss der Client diese
Pakete verwerfen.

Einen neuen Pfad testen
```````````````````````````

Ein Endpunkt kann die Erreichbarkeit des
Intellipeer durch Protokollmäßig
Pfadvalidierung (Teil 8.2) des neuen
netieten. Ein Einpunkt
Noblichtende Ursache validate
negative achledlecht Vor
Ein Neural, Triggerkung erst Naht.
Negative British von Syn Penst,
Haltung. HauptwleddienShape von


Mitgehend Negative
```````````````````````````````````````````````

Ein Endpunkt kann einen neuen Pfad zu einem
Peer durch die Bereuung
nicht-prozediger Pakete von dieser Adresse
testen, bevor die Verbindung zu
dieser Adresse migriert wird.
Wenn die Pfadvalidierung fehlschlägt,
bedeutet dies einfach, dass der
neue Pfad für diese Verbindung
nicht verwendbar ist. Wenn
die Pfadvalidierung fehlschlägt,
führt dies nicht zum Ende
der Verbindung, es sei denn, es sind
keine gültigen alternativen Pfade
verfügbar.

PATH_CHALLENGE-, PATH_RESPONSE-, NEW_CONNECTION_ID- und PADDING-Frames
sind "Probing-Frames", und alle anderen Frames
sind "nicht-probing Frames".
Ein Paket, das nur Probing-Frames enthält, ist ein "Probing-Paket",
und ein Paket, das andere Frames enthält, ist ein "nicht-probing Paket".

Initiierung der Verbindungsmigration
```````````````````````````````````````````

Ein Endpunkt kann eine Verbindung zu einer neuen
lokalen Adresse migrieren, indem er
Pakete mit nicht-probe Frames von dieser Adresse sendet.

Jeder Endpunkt validiert die Adresse seines Peers
während der Verbindungsherstellung.
Daher kann ein migrierender Endpunkt zu seinem Peer
senden und wissen, dass der Peer bereit ist,
die Nachricht an die aktuelle Adresse
des Peers zu erhalten. So kann ein Endpunkt
ohne vorherige Validierung der
Peer-Adresse zu einer neuen lokalen
Adresse migrieren.

Um die Erreichbarkeit auf dem neuen Pfad sicherzustellen,
initiiert ein Endpunkt die Pfadvalidierung (Abschnitt 8.2)
auf dem neuen Pfad. Ein Endpunkt KANN
die Pfadvalidierung aufschieben, bis ein Peer
das nächste nicht-probing Paket
an seine neue Adresse sendet.

Während der Migration möglicherweise nicht im gleichen Maß
gesendet werden kann wie auf dem alten Pfad.
Daher setzt der Endpunkt seinen
Stau-Steuerungs-Algorithmus und
RTT-Schätzung zurück, wie in Abschnitt 9.4 beschrieben.

Der neue Pfad unterstützt möglicherweise nicht dieselbe
ECN-Fähigkeit. Daher validiert der Endpunkt
die ECN-Fähigkeit, wie in Abschnitt 13.4 beschrieben.

Reaktion auf die Verbindungsmigration
``````````````````````````````````````````````````

Wenn ein Paket von einer neuen Peer-Adresse empfangen wird,
das einen nicht-probing Frame enthält, bedeutet
dass der Peer zu dieser Adresse migriert ist.

Wenn der Empfänger die Migration erlaubt, MUSS er
folgende Pakete an die neue Peer-Adresse senden
und MUSS nach der Pfadvalidierung (Abschnitt 8.2)
initiiert, um die Eigentümerschaft des Peer an der Adresse zu bestätigen,
falls die Validierung nicht bereits im Gange ist.  Wenn der Empfänger
keine ungenutzte Verbindungs-ID vom Peer hat, wird er
in der Lage sein, etwas auf dem neuen Pfad zu senden,
bis der Peer eine bereitstellt; siehe Abschnitt 9.5.

Ein Endpunkt ändert die Adresse, zu der er Pakete
senden kann, nur als Antwort auf das Paket mit der
höchsten Nummer, das nicht-probe enthält. Dies
stellt dafür, dass ein Endpunkt keine Pakete an eine alte
Peer-Adresse sendet, wenn er durcheinander geratene
Pakete empfängt.

Ein Endpunkt KANN Daten an eine nicht validierte Peer-Adresse
senden, aber er MUSS sich gegen mögliche Angriffsabfassungen
schützen, wie in den Abschnitten 9.3.1 und 9.3.2 beschrieben.
Ein Endpunkt KANN die Validierung einer Peer-Adresse
überspringen, wenn die Adresse kürzlich gesehen wurde.
Insbesondere, wenn ein Endpunkt zu einem zuvor
validierten Pfad zurückkehrt, nachdem er eine Form von
falscher Migration erkannt hat, kann die vollständige
Validierung von der Adresse oder die vollständige Validierung
der Verlustdetektion und der Stauzustand reduzierte
den Leistungsseitigen Angriff auf das Gerät.

Nachdem ein Endpunkt die Adresse
zum Senden von nicht-probing Paketen
geändert hat, kann es jede
Pfadvalidierung für andere Adressen
heruntersetzen.

Ein Paket von einer neuen Peer-Adresse kann das
Ergebnis einer NAT-Neubindung des Peers sein.

Nach Verifizierung einer neuen Client-Adresse SOLLTE der Server
neue Adress-Validierungstoken (Abschnitt 8)
an den Client senden.

Peer-Adresse-Spoofing
`````````````````````````

Ein Peer könnte seine Quelladresse fälschen, um zu
versuchen, einen Endpunkt dazu zu bringen, erhebliche
Mengen an Daten an einen unwilligen Host zu senden.
Wenn der Endpunkt erheblich mehr Daten als der
fälschende Peer sendet, kann die Verbindungsmigration
verwendet werden, um das Volumen an Daten, das
ein Angreifer vom Opfer generieren kann, zu
verstärken.

Wie in Abschnitt 9.3 beschrieben, muss ein Endpunkt
die neue Adresse eines Peers validieren,
um das Eigentum des Peers an der neuen
Adresse zu bestätigen.
Bis eine Netzwerkadresse einer Peer-Adresse als gültig
anerkannt wird, muss ein Endpunkt die Menge an
Daten, die er an diese Adresse sendet, begrenzen;
siehe Abschnitt 8.  In der
Abwesenheit dieser Grenze riskiert ein Endpunkt,
von einem Angreifer im Netzwerk verwendet zu werden,
um eine Ablehnung des Dienstes gegen ein
nicht bewussten Opfer am möglicherweise
erlaubten Server zu erhalten.

Wenn ein Endpunkt die Validierung
einer Peer-Adresse wie oben beschrieben
überspringt, muss er seine Sendungsrate
nicht begrenzen.

On-Path Adress Spoofing
`````````````````````````
Ein On-Path-Angreifer kann eine unsachliche
Verbindungs-Migration erleichtern, indem er
Kopieren und Weiterleiten eines Pakets mit
einer gefälschten Adresse bewirkt, dass
es vor dem Origional ankommt.
Das Paket mit der gefälschten Adresse wird
als von einer migrierenden Verbindung kommend
gesehen und das ursprüngliche Paket als
Duplikat betrachtet und verworfen. Nach einer
unsachlichen Migration wird die Validierung der
Quelladresse fehlschlagen, da die Entität an
der Quelladresse nicht die notwendigen
kryptografischen Schlüssel besitzt, um den
geschickten PATH_CHALLENGE-Frame zu lesen
oder darauf zu antworten, selbst wenn sie
das wollte.

Um zu verhindern, dass die Verbindung durch
eine unsachliche Migration aufgrund eines
solchen Angriffes fehlschlägt, MUSS ein
Endpunkt zum letzten validierten Peer-Adresse
zurückkehren, wenn die Validierung eines neuen
Peer-Adresse fehlschlägt. Ebenso führt der
Empfang von Paketen mit höheren Paketnummern
von der legitimen Peer-Adresse zu einer
weiteren Verbindungs-Migration. Dies wird
die Validierung der Adresse der unsachlichen
Migration aufgeben und so das Ausmaß der durch
den Angreifer initiierten Migrationsbeschränkungen
dämpfen, indem er ein einziges
Paket injiziert.

Wenn ein Endpunkt keinen Zustand über die letzte
validierte Peer-Adresse hat, MUSS er die Verbindung
stillschweigend schließen, indem er den gesamten
Verbindungszustand verwirft. Dadurch werden
neue Pakete auf der Verbindung allgemein behandelt.
Zum Beispiel kann ein Endpunkt auf
ein pauschalisierten Reset als Reaktion
auf weitere eingehende Pakete senden.

Off-Path-Paket-Weiterleitung
```````````````````````````````````

Ein Off-Path-Angreifer, der Pakete beobachten kann,
könnte Kopien von echten Paketen an Endpunkte
weiterleiten. Wenn das kopierte Paket dem
echten Paket vorausgeht, wird dies als ein NAT-Rebinding
erscheinen. Jedes echte Paket wird als eine
duplizierte und verworfene angesehen.
Wenn der Angreifer in der Lage ist, weiterhin
Pakete weiterleiten zu lassen, könnte es in der Lage sein,
Migration zu einem Pfad über den Angreifer zu
verursachen. Dies bringt den Angreifer on-path,
was ihm die Möglichkeit gibt, alle nachfolgenden
Pakete zu beobachten oder zu verwerfen.

Dieser Stil von Angriff stützt sich darauf,
dass der Angreifer einen Pfad verwendet,
der ungefähr die gleichen
Eigenschaften wie der direkte Pfad
zwischen den Endpunkten hat. Der Angriff ist
zuverlässiger, wenn relativ wenige Pakete gesendet
werden oder wenn das Paketverlust mit dem
versuchten Angriff zusammenfällt.

Ein Paket, das im Originalpfad empfangen wird und die
höchste empfangene Paketnummer erhöht, wird dafür
sorgen, dass der Endpunkt auf diesen Pfad zurückkehrt.
Die Induzierung des Pakettauschs erhöht die
Wahrscheinlichkeit, dass der Angriff nicht
erfolgreich ist. Daher beruht die Minderung dieses
Angriffs darauf, den Austausch von Paketen
auszulösen.

Ein Endpunkt, der einen PATH_CHALLENGE auf einem
aktiven Pfad erhält, SOLLTE ein nicht-probing Paket
als Antwort senden. Wenn das nicht-probing Paket
vor einer vom Angreifer verursachten Kopie eintrifft,
führt dies dazu, dass die Verbindung auf den
ursprünglichen Pfad zurücknimmt. Jede
nachfolgende Migration zu einem anderen Pfad startet
diesen gesamten Prozess neu. 

Diese Verteidigung ist unvollkommen, aber dies wird
nicht als ernstes Problem angesehen. Wenn der
Pfad durch den Angriff zuverlässig schneller
ist als der ursprüngliche Pfad trotz mehrfachen
Versuchen, diesen ursprünglichen Pfad zu verwenden,
ist es nicht möglich, zwischen einem Angriff
und einer Verbesserung der Routing zu
unterscheiden. 

Ein Endpunkt könnte auch Heuristiken verwenden, um
die Erkennung dieses Stils von Angriff zu
verbessern. Zum Beispiel ist NAT-Rebinding
unwahrscheinlich, wenn kürzlich Pakete auf
dem alten Pfad empfangen wurden; ebenso sind
Rebindungen selten auf IPv6-Pfaden.
Endpoints können auch nach
duplizierten Paketen suchen. Umgekehrt deutet
eine Änderung der Verbindung ID eher
darauf hin, dass eine absichtliche Migration
erfolgt als eine böswillige. 

Verlustdetektion und Staukontrolle
`````````````````````````````````````````

Die Kapazität auf dem neuen Pfad
könnte nicht identisch mit der alten
Pfad sein. Pakete, die auf dem alten Pfad gesendet
werden, DÜRFEN NICHT zum Congestion-Control-
System oder zur RTT-Schätzung im neuen Pfad
beitragen. 

Auf die Bestätigung des Besitzes der neuen Adresse
durch einen Peer MUSS ein Endpunkt
sofort das Congestion-Control- und Round-
Trip-Time-Schätzsystem für den neuen Pfad auf
die Anfangswerte zurücksetzen (siehe Anhänge
A.3 und B.3 von [QUIC-RECOVERY]),
außer wenn der einzige Unterschied in der
Peer-Adresse die Port-Nummer ist.
Da Port-Änderungen häufig eine
Folge von NAT-Rebinding oder anderen
Mittelsmannaktivitäten sind, kann
der Endpunkt stattdessen seinen
Congestion-Steuerungsstatus und die Round-
Trip-Schätzung stattdessen beibehalten,
anstatt in den Anfangswert zurückzusetzen.
In Fällen, in denen Retained Congestion-
Control im alten Pfad auf einem neuen
Pfad mit erheblich unterschiedlichen
Merkmalen verwendet wird, könnte
ein Sender zu aggressiv senden, bis
der Congestion-Controller und der RTT-
Schätzer sich anpassen. Generell wird
implementiert, vorsichtig zu sein, wenn
frühere Werte auf einem neuen Pfad verwendet
werden. 

Es könnte zu scheinbarer Unordnung im
Empfänger kommen, wenn ein Endpunkt
Daten und Tests an/von mehreren Adressen
während der Migrationsperiode sendet,
da die beiden resultierenden Pfade
unterschiedliche Round-Trip-Zeiten
haben könnten. Ein Empfänger von
Paketen auf mehreren Pfaden wird
immer noch ACK-Frames senden, die alle
empfangenen Pakete enthalten.

Obwohl mehrere Pfade während der
Verbindungsmigration verwendet werden
könnten, könnte für eine ausreichende
kontextbasierte Congestion Control
und Verlusterkennung ein
einziger Kontext ausreichen.
Zum Beispiel könnte ein
Endpunkt die
Verbindungsmigration verzögern, bis es
bestätigt ist, dass ein alter Pfad nicht
länger benötigt wird (wie im Fall in
Abschnitt 9.3.3 beschrieben). 

Ein Sender kann Ausnahmen für Testpakete
machen, sodass deren Verlusterkennung
unabhängig ist und nicht unnötigerweise
den Congestion-Controller dazu veranlasst,
seine Sendungsrate zu reduzieren.
Ein Endpunkt kann ein separates Timer-Set
festlegen, wenn ein PATH_CHALLENGE gesendet
wird, das aufgehoben wird, wenn der
entsprechende PATH_RESPONSE-Frame
empfangen wird. Wenn der Timer
ausläuft, bevor der PATH_RESPONSE
empfangen wird, könnte der Endpunkt
einen neuen PATH_CHALLENGE
senden und den Timer für eine längere
Zeitraum neu starten. Dieser Timer SOLLTE
wie in Abschnitt 6.2.1 von
[QUIC-RECOVERY] beschrieben gesetzt werden und
DARF NICHT aggressiver sein. 

Datenschutzimplikationen der Verbindungsmigration
`````````````````````````````````````````````````````````

Die Verwendung einer stabilen Verbindung ID auf
mehreren Netzwerkpfaden würde es einem
neutralen Beobachter ermöglichen, Aktivität
zwischen diesen Pfaden zu korrelieren. Ein
Endpunkt, der zwischen Netzwerken wechselt,
möchte möglicherweise nicht, dass seine
Aktivität von anderen Entitäten als
seinem Peer korreliert wird, daher werden
verschiedene Verbindung IDs verwendet, wenn
von verschiedenen lokalen Adressen sendet.
Für dies effektiv zu sein, müssen Endpunkte
sicherstellen, dass von ihnen bereitgestellte
Verbindungs-IDs nicht von anderen Entitäten
verknüpft werden können.

Ein Endpunkt KANN jederzeit die
Destination Connection ID, die er mit
sendet, auf einen noch nicht
verwendeten Wert ändern. 

Ein Endpunkt DARF eine Verbindung-ID
nicht erneut verwenden, wenn
er von mehr als einer lokalen Adresse
sendet -- zum Beispiel,
wenn er eine Verbindungsmigration wie in
Abschnitt 9.2 beschrieben, initiiert,
oder nach einem neuen Netzwerkpfad sucht,
wie in Abschnitt 9.1 beschrieben wird. 

Ebenso DARF ein Endpunkt eine Verbindung ID nicht
erneut verwenden, indem er an mehr als eine
Zieladresse sendet.
Aufgrund von Netzwerkänderungen, die außerhalb der
Kontrolle seines Peers liegen, könnte ein Endpunkt
Pakete von einer neuen Quelladresse mit
dem gleichen Destination Connection ID-Feldwert
empfangen, in diesem Fall kann er
weiterhin dieselbe Verbindung ID mit
der neuen Remote-Adresse verwenden
und gleichzeitig von der
gleichen lokalen Adresse senden.

Diese Anforderungen bezüglich der
Beziehung der Verbindung ID gelten
nur für das Senden von Paketen,
da ungewollte Wege und Verbindungen
nicht ausgeschlossen werden.
Zum Beispiel könnte es nach einer
Phase der Inaktivität des Netzwerkes
zu einem NAT-Rebinding-Event kommen,
wenn der Client wieder zu senden beginnt.
Ein Endpunkt antwortet auf ein
solches Ereignis, wie in Abschnitt 9.3
beschrieben wird.

Die Verwendung verschiedener Verbindung IDs
für Pakete in beide Richtungen auf
jeden neuen Netzwerkpfad
ermöglicht die Verwendung der Verbindungs-ID
für das Verknüpfen von Paketen
aus der gleichen Verbindung über
verschiedene Netzwerkpfade hinweg. Die
Headerverdeckung stellt sicher,
dass Paketnummern nicht zur
Aktivitätskorrelation verwendet werden können.
Dies verhindert jedoch nicht, dass
andere Eigenschaften von Paketen,
wie z.B. Timing und Größe,
zur Aktivitätskorrelation verwendet
werden können. 

Ein Endpunkt SOLLTE keine Migration
bei einem Peer initialisieren,
der eine Verbindung ID mit
Länge Null angefordert hat,
da der gesamte neue Verkehr
auf dem neuen Pfad trivial
durch vertraute Entitäten
verlinkt werden könnte. Wenn der
Server in der Lage ist, Pakete
mit einer Verbindung ID von null
auf die richtige Verbindung ID zu
assoziieren, bedeutet das, dass
der Server andere aufkommende
Informationen verwenden, um
Pakete richtig einzurichten.  Zum
Beispiel, könnte ein Server
jedem Client eine eindeutige
Adresse bereitstellen -- zum Beispiel,
indem er HTTP-Alternative-Dienste [ALTSVC]
verwendet.
Informationen, die es erlauben,
eine Mobilverbindung grundsätzlich
umzustellen, dies erlaubt auch
die Mustacitipation von MigrationsbescheFigurenänderungen, unabhängig
von der Zugangskontrolle der
Konfiguration. 

Ein Client könnte
denkende Wahlarrangements verwenden,
um zu limitieren Aktivität durch das
Beginn einer natashn.
Der Zeitrahmen, z.B. das
Umtauschen Alternative Serenkotrends,
ist kaum durchführbar. 
Die Änderung einer verlinkten
Argozähler der Grenze und
einem zukünftigen Planalter wird
oft im Verhindernkonstr entstanden. 
Auch Änderungspraxis kann
einer Kontextbeginn vermeiden verhindern sein.
Zu style". Dies hat altruistische Mobilarten, id
durch Dienste Verhängnis. 

Ein Endpunkt, der keinen
Verbindungs-IDs augenblicklich
zur Verfügung hat, kann Gegner,
weil er einen neuen Weg des
Feindes oder sich, weil der
Peer versucht, eine Migration
durchzuführen. Um
Migration ermöglichen zu können
und damit es den Empfang
richten ermöglicht, sollten die
Endpunkte Verbindung IDs
bereitstellen, die gegebenen
Cf5 um einzugeben Peers drucklig
zur Migraktion loskommen To Shaden;
siehe Abschnitt 5.1.1.  Wenn ein
Peer identifizieren könnte, ist
geschäftigt bereitgestellter
Verbindungs-IDs, könnten
an der neuen Pfad allen
Peer Peer bei einbeziehung.
Verbindung IDs auswählen
noch besteht.

Server's bevorzugte Adresse
`````````````````````````````````

QUIC erlaubt Servern, Verbindungen
auf einer IP beherstellt für die
Bestimmung des Pfades den bevorzugten
Adresse zweifeln bestimmte Sp
zu dirigieren. Dies ist besonders
nützlich, wenn Clients eine
Verbindung zu einer Adresse herstellen,
die von mehreren Servern geteilt wird,
aber eine b einisch und einheitlich Adresse ist,
um die Verbindung zu gewährleisten sin great.
Diesen Streckung der essentielstdnutigkeit,
um Lieferung als Entwicklung e ngosukuaru halta.
Es soll in dieser Adresse um Mathematika werden.
Berücksichtigt wehtre, vorzuziehen
Dennoch keine ily multi-Verbindungen.

Die Server bevorzugte Adress zu
nimmt im Begründungstransportparameter
innerhalb des TLS-Handshake Signals Erwähnten IO NERE.

IGN-Orte eine cozeitlichen Adressen von
beide Adresse weiter wie sich
router. 

Wenn der Bogen der Serverarbeits
zapieren einkeimen und nach
Empfangstätigkeit prüfen Sendemittel so
sible nochtrib vorworting weik
inner somn feledig hookup bideme atemend mitder.ir Adressen.

Nach Überprüfung wieder mit der
zuverlässigen Server Überprüfung PHB.

Annahme  Sicherheit.""

Erledigung, weik der Aborn einem
verifikation Folgeist, dass dieser gefressen,
Server dem Wahrnehmen vorgäng äußert.
''' Validation Register sicher schien ungelöscht, während
Performance die Zuwachsen könntenden bleibt.

Deckenobserver portionierend fitiaherence
Verbindung eingeschränkt, das Urs Level 
mit Superpositionskontrolle
