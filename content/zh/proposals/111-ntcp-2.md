---
title: "NTCP 2"
number: "111"
author: "EinMByte, orignal, psi, str4d, zzz"
created: "2014-02-13"
lastupdated: "2019-08-13"
status: "Closed"
thread: "http://zzz.i2p/topics/1577"
supercedes: "106"
target: "0.9.36"
implementedin: "0.9.36"
editor: "manas, str4d, zzz"
---

## 注意
提案阶段已结束。
请参阅 [SPEC](/en/docs/spec/ntcp2/) 完整的官方规范。
本提案可能仍用于参考背景信息。

## 概述

本提案描述了一个认证密钥协议，以提高 [NTCP](/en/docs/transport/ntcp/) 对各种自动识别和攻击形式的抵抗力。

提案组织如下：首先介绍安全目标，然后讨论基本协议。接下来，给出所有协议消息的完整规格。最后，讨论路由器地址和版本识别。附录中还讨论了一种对常见填充方案的通用攻击，以及附录中包含了一些认证密码的候选者。

与其他 I2P 传输方式一样，NTCP2 仅定义用于点对点（路由器到路由器）的 I2NP 消息传输。
它不是一个通用的数据管道。

## 动机

[NTCP](/en/docs/transport/ntcp/) 数据在第一条消息之后开始加密（第一条消息看起来是随机数据），从而防止通过“负载分析”进行协议识别。它仍然容易受到通过“流量分析”进行的协议识别。这是因为前四条消息（即握手）是固定长度的（288, 304, 448 和 48 字节）。

通过向每条消息添加随机数量的随机数据，我们可以大大提高识别的难度。

作者承认标准安全实践建议使用现有协议如 TLS，但这是 [Prop104](/en/proposals/104/) 并有自己的问题。每当合适时，都添加了“未来工作”段落，以指示缺失的功能或讨论的主题。

## 设计目标

- 在单一端口上支持 NTCP 1 和 2，自动检测，并作为单一“传输”（即 [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)）在 [NetDB](/en/docs/how/network-database/) 中发布。
  
- 支持仅发布版本 1、仅版本 2 或 1+2 在 NetDB 中的一个单独字段中，并默认支持版本 1（在特定路由器版本中不要阻止版本支持）。
  
- 确保所有实现（Java/i2pd/Kovri/go）可以按自己的计划添加版本 2 支持（或不支持）。
  
- 为所有 NTCP 消息（包括握手和数据消息）添加随机填充（即长度混淆，以便所有消息的长度不全是 16 字节的倍数）提供选项机制供双方请求最小和最大填充和/或填充分布。填充分布的细节依赖于实现，可能不被指定在协议中。
  
- 混淆未加密消息的内容（1 和 2），足以使 DPI 设备和 AV 签名无法轻松分类。还要确保发送给单个对等方或一组对等方的消息没有类似的比特模式。
  
- 修复由于 Java 格式导致的 DH 丢失的比特 [Ticket1112](https://trac.i2p2.i2p/ticket/1112)，可能（可能？）通过切换到 X25519。
  
- 转向一个真正的密钥派生函数（KDF），而不是使用 DH 结果原样？

- 添加探测抵抗力（如 Tor 所称）；这包括重放抵抗力。
  
- 保持双向认证密钥交换（2W-AKE）。我们的应用程序不适合一向认证的密钥交换（1W-AKE）。
  
- 继续使用可变类型、可变长度的签名（来自发布的 [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) 签名密钥）作为认证的一部分。依赖于在 RouterInfo 中发布的一个静态公钥作为认证的另一部分。
  
- 在握手中添加选项/版本以便将来扩展。
  
- 如果可能，应对恶意的 MitM TCP 段进行抵抗。
  
- 不要明显增加连接设置所需的 CPU；如果可能，显著减少。
  
- 添加消息认证（MAC），可能的 HMAC-SHA256 和 Poly1305，去除 Adler 校验和。
  
- 缩短并简化 I2NP 头：
  将到期缩短为 4 字节，如在 SSU 中。
  移除一个字节的截断 SHA256 校验和。
  
- 如果可能，将四消息双往返握手减少为三消息单往返握手，如 [SSU](/en/docs/transport/ssu/) 中。这将需要将 Bob 在消息 4 中的签名移动到消息 2。研究在十年前的电子邮件/状态/会议档案中 4 条消息的原因。
  
- 在填充之前尽量减少协议开销。虽然会添加填充，可能是大量的填充，但填充前的开销仍然是开销。低带宽节点必须能够使用 NTCP2。
  
- 保留时间戳以进行重播和偏差检测。
  
- 必须避免时间戳中的任何 2038 年问题，至少要工作到 2106 年。
  
- 将最大消息大小从 16K 增加到 32K 或 64K。
  
- 任何新的密码学原语应在库中易于为 Java（1.7）、C++ 和 Go 路由器实现中使用。
  
- 将 Java、C++ 和 Go 路由器开发人员的代表纳入设计。
  
- 尽量减少更改（但会有很多）。
  
- 在一组公用代码中支持这两个版本（这可能不可行，依赖于任何情况下的实现）。


### 非目标

- 防弹 DPI 抵抗：那会是可插拔的传输，[Prop109](/en/proposals/109/)。

- 基于 TLS 的（或类似 HTTPS 的）传输：那会是 [Prop104](/en/proposals/104/)。

- 可以更改对称流加密。

- 基于定时的 DPI 抵抗（消息间的定时/延迟可依赖于实现；消息内的延迟可在任何点引入，例如在发送随机填充之前）。人造延迟（obfs4 所称的 IAT 或到达时间间隔）与协议本身无关。

- 否认参与会话（有签名在里面）。

可能会部分重新考虑或讨论的非目标：

- 对深度包检测（DPI）的防护程度

- 后量子（PQ）安全

- 否认参与



### 相关目标

- 实现 NTCP 1/2 测试设置


## 安全目标

我们考虑三个参与者：

- Alice，希望建立一个新会话。

- Bob，Alice 希望与其建立会话。

- Mallory，“中间人”在 Alice 和 Bob 之间。

最多两个参与者可以进行主动攻击。

Alice 和 Bob 都拥有包含在其 [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) 中的静态密钥对。

提议的协议试图使 Alice 和 Bob 在以下要求下达成共享的秘密密钥（K）：

1) 私钥安全：Bob 和 Mallory 均不能获得 Alice 的静态私钥的任何信息。对称地，Alice 也无法获知 Bob 的静态私钥任何信息。

2) 只有 Alice 和 Bob 知道会话密钥 K。

3) 完全前向保密性：即使在 Alice 和/或 Bob 的静态私钥在密钥达成一致后被披露，商定的会话密钥仍然保密。

4) 双向认证：Alice 可以确定她已经与 Bob 建立了会话，反之亦然。

5) 防止在线 DPI：确保仅使用简单的深度包检测（DPI）技术，无法轻易检测到 Alice 和 Bob 是否正在使用协议。见下文。

6) 限定否认性：Alice 和 Bob 都无法否认参与协议，但如果任意一方泄漏共享密钥，另一方可以否认传输数据内容的真实性。

目前的提案尝试基于站到站（Station-To-Station，STS）协议 [STS]_ 提供五项要求。注意，该协议也是 [SSU](/en/docs/transport/ssu/) 协议的基础。


### 其他 DPI 讨论

我们假设两种 DPI 组件：

1) 在线 DPI
```````````
实时检查所有流的数据。可以阻止或以其他方式篡改连接。可以识别并存储连接数据或元数据以供离线分析。在线 DPI 无法访问 I2P 网络数据库。在线 DPI 仅具有有限的实时计算能力，包括长度计算、字段检查和简单计算如 XOR。在线 DPI 拥有快速实时密码功能如 AES、AEAD 和哈希，但对于大多数或所有流应用这些加密操作太昂贵。任何加密操作的应用仅适用于先前被离线分析识别的 IP/端口组合流。在线 DPI 无法执行高负荷密码功能如 DH 或 elligator2。在线 DPI 并非专门为检测 I2P 而设计，但可能对该目的有有限的分类规则。

目标是防止在线 DPI 识别协议。

此处所述的在线或“普通” DPI 假设敌手具有以下能力：

1) 能检查目标发送或接收的所有数据。

2) 能在观察到的数据上执行操作，如应用块密码或哈希函数。

3) 能存储并与之前发送的消息进行比较。

4) 能够修改、延迟或分段数据包。

然而，在线 DPI 假定有如下限制：

5) 无法将 IP 地址映射到路由器哈希。尽管实时访问网络数据库很容易，但需要专门设计的 DPI 系统才能针对 I2P。

6) 无法使用定时信息检测协议。

7) 一般来说，在线 DPI 工具箱没有专为 I2P 检测而设计的内置工具。这包括创造“蜜罐”，比如在它们的消息中包含非随机填充。注意，这不包括机器学习系统或高级可配置的 DPI 工具，只要它们满足其他要求。

为了对抗负载分析，确保所有消息都难以与随机消息区分。要求它们的长度是随机的，这比仅仅添加随机填充更复杂。事实上，在附录 A 中，作者认为简单（即均匀）填充方案无法解决问题。因此，附录 A 建议包括随机延迟或开发备用填充方案，为提议的攻击提供合理的保护。

为了应对上面提到的第六点，实现应当在协议中增加随机延迟。这些技术不在本提案的范围内，但它们也可能解决填充长度问题。总之，如果考虑附录 A 中的内容，本提案提供了对负载分析的良好保护，但对流量分析仅提供了有限的保护。


2) 离线 DPI
```````````
检查在线 DPI 存储的数据以供后续分析。
离线 DPI 可能专门为检测 I2P 设计。
离线 DPI 确实具实时访问 I2P 网络数据库的权限。
离线 DPI 可以访问该规格书和其他 I2P 规格书。
离线 DPI 具有无限的计算能力，包括
在此规格书中定义的所有密码功能。

离线 DPI 无法阻止现有连接。
离线 DPI 能够进行近实时（在设置后几分钟内）
向某方的主机/端口发送，例如 TCP RST。
离线 DPI 能够进行近实时（在设置后几分钟内）
重放先前的消息（修订或不修订），以便
进行“探测”或其他目的。

目标不是防止离线 DPI 识别协议。
在第一条消息中所有被 I2P 路由器实现的
数据混淆解码，离线 DPI 也可以实现。

目标是拒绝使用之前消息重放的尝试连接。


未来工作
````````

- 观察协议在攻击者掉落或重新排列数据包时的行为。最近可以参考的有趣工作请见 [IACR-1150](https://eprint.iacr.org/2015/1150)。

- 提供 DPI 系统的更准确分类，考虑到与该主题相关的现有文学。

- 讨论提议协议的形式安全性，最好能够考虑到 DPI 攻击模型。


## 噪声协议框架

本提案基于噪声协议框架 [NOISE](http://noiseprotocol.org/)（修订版 33, 2017-10-04）提供的要求。
噪声具有类似于站到站协议（Station-To-Station） [STS]_ 的属性，SSU 协议的基础。
在噪声惯例中，Alice 是发起方，Bob 是响应方。

NTCP2 基于 Noise_XK_25519_ChaChaPoly_SHA256。
（实际的初始密钥派生函数标识符为
“Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256”表示 I2P 扩展 - 请参阅 KDF 1 部分。）
这个噪声协议使用以下原语：

- 握手模式：XK
  Alice 将她的密钥传输给 Bob（X）
  Alice 已知道 Bob 的静态密钥（K）

- DH 函数：X25519
  使用密钥长度为 32 字节的 X25519 DH，如 [RFC-7748](https://tools.ietf.org/html/rfc7748)中 所述

- 加密函数：ChaChaPoly
  AEAD_CHACHA20_POLY1305，如 [RFC-7539](https://tools.ietf.org/html/rfc7539) 第 2.8 节中所述。
  12 字节 nonce，前四字节始终为零。

- 哈希函数：SHA256
  标准 32 字节哈希，在 I2P 中广泛使用。


## 框架的补充

本提案定义了对 Noise_XK_25519_ChaChaPoly_SHA256 的以下增强。通常遵循 [NOISE](http://noiseprotocol.org/) 第 13 节的指导原则。

1) 使用 AES 加密和已知密钥和 IV 掩蔽明文临时密钥。 比 elligator2 更快。

2) 在消息 1 和 2 中添加随机明文填充。
   将明文填充包括在握手哈希（MixHash）计算中。
   请参阅以下消息 2 和消息 3 第 1 部分的 KDF。
   随机 AEAD 填充添加到消息 3 和数据阶段消息中。

3) 增加了一个两字节框架长度字段，这是为了在 TCP 上使用噪声所需的，与 obfs4 中一样。仅用于数据阶段消息。
   消息 1 和 2 AEAD 帧为固定长度。
   消息 3 第 1 部分 AEAD 帧为固定长度。
   消息 3 第 2 部分的 AEAD 帧长度在消息 1 中指定。

4) 两字节帧长度字段使用 SipHash-2-4 掩蔽，与 obfs4 中相同。

5) 定义消息 1、2、3 和数据阶段的有效负载格式。
   当然，这不是在噪声中定义的。

## I2P 的新密码学原语

现有的 I2P 路由器实现将需要实现以下标准密码学原语，它们不是当前 I2P 协议所需的：

1) X25519 密钥生成和 DH

2) AEAD_ChaCha20_Poly1305（以下简称 ChaChaPoly）

3) SipHash-2-4


## 处理开销估计

三条消息的消息大小：

1) 64 字节 + 填充（NTCP 是 288 字节）

2) 64 字节 + 填充（NTCP 是 304 字节）

3) 约 64 字节 + Alice 路由器信息 + 填充 平均路由器信息约为 750 字节 总平均为 814 字节，填充前（NTCP 是 448 字节）

4) NTCP2 中不需要（NTCP 是 48 字节）

总计填充前：
NTCP2: 942 字节
NTCP: 1088 字节
注意，如果 Alice 连接到 Bob 用于发送她的 RouterInfo 的 DatabaseStore 消息，则不需要该消息，节省了大约 800 字节。

每个参与者完成握手并进入数据阶段所需的以下加密操作：

- AES: 2
- SHA256: 7（Alice），6（Bob）（不包括所有连接的 1 Alice，2 Bob 预计算）（不包括 HMAC-SHA256）
- HMAC-SHA256: 19
- ChaChaPoly: 4
- X25519 密钥生成: 1
- X25519 DH: 3
- 签名验证: 1（Bob）（Alice 以前生成她的 RI 时签名） 推测 Ed25519（取决于 RI 签名类型）


每个数据阶段消息各方所需的以下加密操作：

- SipHash: 1
- ChaChaPoly: 1


## 消息

所有 NTCP2 消息的长度均小于等于 65537 字节。消息格式基于噪声消息，对框架和区别性进行了修改。使用标准噪声库的实现可能需要在接收数据和噪声消息格式之间进行预处理。所有加密字段均为 AEAD 密文。

建立顺序如下：

Alice                           Bob

  SessionRequest ------------------->
  <------------------- SessionCreated
  SessionConfirmed ----------------->
使用噪声术语，建立和数据顺序如下：
（负载安全属性）

XK(s, rs):           Authentication   Confidentiality
    <- s
    ...
    -> e, es                  0                2
    <- e, ee                  2                1
    -> s, se                  2                5
    <-                        2                5
一旦会话建立，Alice 和 Bob 就可以交换数据消息。

本节中指定所有消息类型（SessionRequest、SessionCreated、SessionConfirmed、Data 和 TimeSync）。

一些符号::

  - RH_A = Alice 的路由器哈希（32 字节）

  - RH_B = Bob 的路由器哈希（32 字节）


### 认证加密

在握手期间和两个方向的数据阶段中有三个独立的认证加密实例（CipherStates）。每个实例都有其自己的从 KDF 中生成的密钥。

加密/认证的数据将表示为

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   加密和认证的数据                    |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
ChaCha20/Poly1305
`````````````````

加密和认证的数据格式。

加密/解密函数的输入：

k :: 32 字节加密密钥，如从 KDF 生成

  nonce :: 基于计数器的随机数，12 字节。
           从 0 开始并为每条消息递增。
           前四字节始终为零。
           最后八字节是计数器，小端编码。
           最大值为 2**64 - 2。
           在达到该值后必须断开连接并重新启动。
           值 2**64 - 1 必须永远不发送。

  ad :: 在握手阶段：
        关联数据，32 字节。
        所有前数据的 SHA256 哈希。
        在数据阶段：
        零字节

  data :: 明文数据，0 或多个字节

加密函数的输出、解密函数的输入：

+----+----+----+----+----+----+----+----+
  |混淆长度 |                             |
  +----+----+                             +
  |       ChaCha20 加密数据              |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 消息认证码                 |
  +              (MAC)                    +
  |             16 字节                   |
  +----+----+----+----+----+----+----+----+

  混淆长度 :: 后面的（加密数据 + MAC）的长度，16 - 65535
              使用 SipHash 混淆（见下文）
              不用于消息 1 或 2，或消息 3 第 1 部分，其中长度是固定的
              不用于消息 3 第 1 部分，因为长度在消息 1 中指定

  加密数据 :: 与明文数据大小相同，0 - 65519 字节

  MAC :: Poly1305 消息认证码，16 字节

对于 ChaCha20，这里描述的对应于 [RFC-7539](https://tools.ietf.org/html/rfc7539)，这是在 TLS 中类似使用的 [RFC-7905](https://tools.ietf.org/html/rfc7905)。

说明
`````
- 由于 ChaCha20 是流密码，明文不需要填充。
  丢弃多余的密钥流字节。

- 密钥（256 位）通过 SHA256 KDF 协议商定。
  各消息的 KDF 详见下文的各个部分。

- ChaChaPoly 帧对于消息 1、2 和消息 3 第一部分，长度已知。 从第二部分消息 3 开始，帧为可变大小。如果 Alice 连接到 Bob 用于发送她的 RouterInfo 的 DatabaseStore 消息， 则不需要该消息，节省了大约 800 字节。

- 消息1和2的填充在认证数据帧之外。填充用于下一条消息的KDF，以便篡改会被检测到。 从消息3开始，填充在认证数据帧内部。

AEAD 错误处理
````````````````````
- 在消息 1, 2 和消息 3 的第 1 和第 2 部分中，AEAD 消息大小已知。
  在 AEAD 认证失败时，接收方必须停止进一步的消息处理，并关闭连接而无需响应。 这应该是异常关闭（TCP RST）。

- 为了探测抵抗，在消息1中，在AEAD失败后，Bob应
  设置一个随机超时（范围待定）然后读取一个随机字节数（范围待定）
  在关闭套接字之前。Bob 应保持一个IP黑名单以便记录重复的失败。

- 在数据阶段，AEAD 消息大小用 SipHash“加密”（混淆）。
  必须注意避免创建解密 oracle。
  在数据阶段 AEAD 认证失败时，接收方应该设置一个随机超时（范围待定）然后读取一个随机字节数（范围待定）。在读取完，或读取超时后，接收方应发送一个包含"AEAD失败"原因代码的终止块负载，并关闭连接。

- 在数据阶段对无效长度字段值采取相同的错误操作。
