---
title: "新的 netDB 条目"
number: "123"
author: "zzz, str4d, orignal"
created: "2016-01-16"
lastupdated: "2020-07-18"
status: "开放"
thread: "http://zzz.i2p/topics/2051"
supercedes: "110, 120, 121, 122"
---

## 状态

该提案的部分内容已经完成，并在 0.9.38 和 0.9.39 中实现。
通用结构、I2CP、I2NP 和其他规范
现在已更新，以反映目前支持的更改。

已完成的部分仍会根据需要进行小幅修订。
本提案的其他部分仍在开发中，
并可能会有重大修改。

服务查找（类型 9 和 11）优先级较低，
暂无计划，并可能会拆分为单独的提案。


## 概述

这是对以下 4 项提案的更新和汇总：

- 110 LS2
- 120 大规模多宿主的 Meta LS2
- 121 加密的 LS2
- 122 无验证服务查找（任播）

这些提案大多是独立的，但为了合理性，我们为其中的几个定义并使用了
一个通用格式。

以下提案与此提案稍有关系：

- 140 隐形多宿主（与此提案不兼容）
- 142 新的加密模板（用于新的对称加密）
- 144 ECIES-X25519-AEAD-Ratchet
- 145 ECIES-P256
- 146 Red25519
- 148 EdDSA-BLAKE2b-Ed25519
- 149 用于加密 LS2 的 B32
- 150 Garlic Farm 协议
- 151 ECDSA 盲化


## 提案

本提案定义了 5 种新的 DatabaseEntry 类型及其在网络数据库中的存储和检索过程，
以及用于签名和验证这些签名的方法。

### 目标

- 向后兼容
- 使用旧式多宿主时可用的 LS2
- 不需要任何新加密或支持的原语
- 保持加密和签名在结构上的解耦；支持所有当前和未来版本
- 启用可选的离线签名密钥
- 减少时间戳的准确性以减少指纹识别
- 启用用于目的地的新加密
- 启用大规模多宿主
- 修复现有加密 LS 的多个问题
- 可选的盲化减少 floodfills 对服务的可见性
- 加密支持单密钥和多可撤销密钥
- 服务查找便于查找 outproxies、应用程序 DHT 引导等用途
- 不破坏依赖于 32 字节二进制目的地哈希的任何东西，例如比特流
- 通过属性增加 leasesets 的灵活性，就像我们在 routerinfos 中一样。
- 将已发布的时间戳和可变过期时间放在标题中，因此即使内容被加密（不从最早的 lease 派生时间戳）也能正常工作
- 所有新类型都在同一 DHT 空间和现有 leasesets 的相同位置，因此用户可以从旧的 LS 迁移到 LS2，或者在 LS2、Meta 和 Encrypted 之间切换，而无需更改目的地或哈希。
- 可以将现有目的地转换为使用离线密钥，或重新转换为在线密钥，而不更改目的地或哈希。


### 非目标/超出范围

- 新的 DHT 旋转算法或共享随机生成
- 使用新加密类型和端到端加密方案的特定新加密类型将在单独的提案中说明。
  本文不指定或讨论任何新加密。
- RI 或隧道构建的新加密。
  这将在单独的提案中说明。
- I2NP DLM / DSM / DSRM 消息的加密、传输和接收方法。
  不更改。
- 如何生成和支持 Meta，包括后台路由器间通信、管理、故障转移和协调。
  支持可以添加到 I2CP，或 i2pcontrol，或新的协议。
  这可能会也可能不会标准化。
- 如何实际实现和管理长时间过期的隧道，或取消现有隧道。
  这非常困难，如果没有合理的优雅关闭，你就无法实现它。
- 威胁模型更改
- 离线存储格式，或数据的存储/检索/共享方法。
- 实施细节未在本文提及，交由各项目团队处理。



### 理由

LS2 增加了用于更改加密类型和未来协议更改的字段。

加密的 LS2 通过
对整个 leases 组使用非对称加密修复了现有加密 LS 的几个安全问题。

Meta LS2 提供了灵活、高效、有效和大规模的多宿主。

服务记录和服务列表提供了任播服务，如命名查找
和 DHT 自举。


### NetDB 数据类型

在 I2NP 数据库查找/存储消息中使用类型编号。

端到端列指的是查询/响应是否通过 Garlic 消息发送到某个目的地。


已有类型：

            NetDB 数据               查找类型     存储类型 
任何                                     0           任何     
LS                                      1            1      
RI                                      2            0      
探索                                     3           DSRM    

新类型：

            NetDB 数据               查找类型     存储类型   标准 LS2 头部？   端到端发送？
LS2                                     1            3             是                    是
加密的 LS2                              1            5             否                    否
Meta LS2                                1            7             是                    否
服务记录                               n/a           9             是                    否
服务列表                                4           11             否                    否



备注
`````
- 查找类型目前是数据库查找消息中的位 3-2。
  任何额外的类型都需要使用位 4。

- 所有存储类型都是奇数，因为上层位在数据库存储消息
  中的类型字段被旧路由器忽略。
  我们宁愿解析失败为 LS，而不是作为压缩的 RI。

- 类型应该在签名覆盖的数据中是显式、隐式，还是都不是？



### 查找/存储过程

类型 3、5 和 7 可以作为标准 leaseset 查找（类型 1）的响应返回。
类型 9 从不作为查找的响应返回。
类型 11 作为新的服务查找类型（类型 11）返回。

仅类型 3 可以在客户端对客户端的 Garlic 消息中发送。



### 格式

类型 3、7 和 9 都有一个通用格式：

  标准 LS2 头部
  - 如下所定义

  类型特定部分
  - 如在每一部分中定义

  标准 LS2 签名：
  - 签名密钥签名类型所暗示的长度

类型 5（加密的）不以目的地开始并有不同的格式。见下文。

类型 11（服务列表）是若干服务记录的聚集体，具有不同格式。见下文。


### 隐私/安全考虑

待定



## 标准 LS2 头部

类型 3、7 和 9 使用标准 LS2 头部，规格如下：


### 格式
::

  标准 LS2 头部：
  - 类型（1字节）
    实际上不在头部，但属于签名覆盖的数据。
    从数据库存储消息字段取。
  - 目的地（387+ 字节）
  - 已发布时间戳（4字节，大端方式，自纪元以来的秒数，2106年翻滚）
  - 过期（2字节，大端方式） （自发布时间戳起的秒数，最大 18.2 小时）
  - 标志（2字节）
    位顺序：15 14 ... 3 2 1 0
    位 0：如果为 0，则无离线密钥；如果为 1，则有离线密钥
    位 1：如果为 0，则为标准已发布 leaseset。
           如果为 1，则为未公开的 leaseset。 不应泛洪、发布或
           在查询响应中发送。如果此 leaseset 过期，则不要查询
           netdb 以获取新 leaseset，除非设置了位 2。
    位 2：如果为 0，则为标准已发布 leaseset。
           如果为 1，则在出版时此未加密的 leaseset 将被盲化和加密。
           如果此 leaseset 过期，则查询盲化位置的 netdb 获取新 leaseset。
           如果该位设为 1，则同时设位 1 为 1。
           自 0.9.42 发布以来。
    位 3-15：设置为 0 以便于未来使用
  - 如果标志指示离线密钥，则离线签名部分：
    过期时间戳（4字节，大端方式，自纪元以来的秒数，2106年翻滚）
    临时签名类型（2字节，大端方式）
    临时签名公钥（长度由签名类型暗示）
    由目的地公钥签名的过期时间戳，各临时签名类型和公钥，
    签名长度由目的地公钥签名类型暗示。
    此部分可以并且应由离线生成。


理由
`````````````

- 未公开/公开：用于在端到端发送数据库存储时，
  发送路由器可以希望表明此 leaseset 不应为
  向其他人发送。我们当前使用启发式方法来维护此状态。

- 已发布：替代了确定leaseset“版本”所需的复杂逻辑。
  目前，版本是最后到期leasess的到期时间，
  并且发布leasess的路由器在发布
  仅移除现有历元的leases时，必须将截止日期增加至少 1ms。

- 过期：允许 netdb 条目的过期时间早于其最后到期Leasess。
  对于期望的 LS2 11 分钟最大过期时间，这在 LS2 中可能没有用，
  但对于其他新类型，必要（见下文的 Meta LS 和 Serice Record）。

- 离线密钥是可选的，以减少最初/必要的实现复杂性。


### 问题

- 可以进一步减少时间戳的精度（10 分钟？），但需要添加
  版本号。这可能会破坏多宿主，除非我们具有顺序保护加密？
  可能不能完全没有时间戳。

- 替代方案：3 字节时间戳（纪元 / 10 分钟），1 字节版本，2 字节过期

- 类型显式还是隐式在数据/签名中？ 签名的“域”常量？


备注
`````

- 路由器不应发布一个 LS 超过一秒。
  如果它们确实需要，它们必须在先前发布的 LS 上将已发布的时间戳将人为地增加 1。

- 路由器实现可以缓存临时密钥和签名以
  避免每次验证。特别是， floodfills 和两端的路由器使用稳定连接，
  可以从中受益。

- 离线密钥和签名只适用于长期存在的目的地，
  如服务器，而不是客户端。



## 新的 DatabaseEntry 类型


### LeaseSet 2

与现有 LeaseSet 的变化：

- 添加发布时间戳、过期时间戳、标志和属性
- 添加加密类型
- 删除撤销密钥

查找使用
    标准 LS 标记（1）
存储使用
    标准 LS2 类型（3）
存储于
    目的地的哈希
    然后使用该哈希生成每日的“路由密钥”，如在 LS1 中
通常过期
    10 分钟，像在常规 LS 中一样。
已发布者
    目的地

格式
``````
::

  标准 LS2 头部，按上文说明

  标准 LS2 类型特定部分
  - 属性（如通用结构规范中所述的映射，无则为 2 个零字节）
  - 后续密钥部分的数量（1 字节，最大值 TBD）
  - 密钥部分：
    - 加密类型（2 字节，大端）
    - 加密密钥长度（2 字节，大端）
      这是显式的，因此 floodfills可以解析具有未知加密类型的 LS2。
    - 加密密钥（指定的字节数）
  - Lease2 的数量（1 字节）
  - Lease2s（每个 40 字节）
    这些是 leases，但有 4 字节而不是 8 字节的过期时间，
    自纪元以来的秒数（2106 年翻卷）

  标准 LS2 签名：
  - 签名
    如果标志指示离线密钥，则由临时公钥签名，
    否则，由目的地公钥签名
    签名长度由签名密钥的签名类型暗示的长度
    签名是上述所有内容的签名。




理由
`````````````

- 属性：未来的扩展和灵活性。
  如果解析其余数据所必需，则放置在首位。

- 多种加密类型/公钥对
  便于过渡到新的加密类型。另一种方法是
  发布多个 leasesets，可能使用相同的隧道，
  就像我们现在对 DSA 和 EdDSA 目标的做法一样。
  隧道上的传入加密类型可能通过现有的会话标签机制来识别，
  和/或试验解密使用每个密钥。传入消息的长度也可以提供线索。

讨论
``````````

该提案继续使用 leaseset 中的公钥作为
端到端加密密钥，并在目的地保留公钥字段未使用，正如现在一样。加密类型未在目标密钥证书中指定，将保持为0。

一种被拒绝的替代方案是将加密类型指定在目的地密钥证书中，
使用目的地中的公钥，并不使用leasess中的公钥。我们不打算这样做。

LS2 的好处：

- 实际公钥的位置不变。
- 加密类型或公钥可以更改，而无需更改目的地。
- 删除未使用的撤销字段
- 基本兼容此提案中的其他DatabaseEntry类型
- 允许多种加密类型

LS2 的缺点：

- 公钥和加密类型的位置不同于RouterInfo
- 在leasesset中维护未使用的公钥
- 需要跨网络实现；在替代方案中，如floodfills
  允许，可以使用实验性加密类型
  （但请参见相关提案 136 和 137 关于对实验性签名类型的支持）。
  替代提案可能更易于实现和测试实验性加密类型。


新加密问题
```````````````````````
其中一些超出了本提案的范围，
但现在在这里写一些笔记，因为我们尚无
 单独的加密提案。
看看 ECIES 提案 144 和 145。

- 加密类型表示
  曲线、密钥长度和端到端方案的组合，
  包括 KDF 和 MAC（如果有）。

- 我们已经包含一个密钥长度字段，因此 LS2 是
  可由floodfill解析和验证，即使对于未知加密类型。

- 第一个新加密类型将
  可能是 ECIES/X25519。它是如何在端到端使用的
  （要么使用略微修改的版本 ElGamal/AES+SessionTag
  或者完全新建，如 ChaCha/Poly）将在一个或多个单独的提案中说明。
  也请参见 ECIES 提案 144 和 145。


备注
`````
- 在leases里8字节的过期改为4字节。

- 如果我们要实现撤销，可以通过过期字段为零来实现，
  或者零leases，或者两者兼而有之。不需要单独的撤销键。

- 加密键按服务器优先顺序排列，最优先的在前。默认的
  客户行为是选择第一个支持的加密类型的密钥。
  客户可能会根据加密支持、相对性能和其他因素
  使用基于其他选择算法。


### 加密的 LS2

目标：

- 添加盲化功能
- 允许多种签名类型
- 不需要任何新的加密原语
- 可选择加密到每个接收者，可撤销
- 支持仅加密标准 LS2 和 Meta LS2

加密的 LS2 从未在端到端的 garlic 消息中发送。
使用标准 LS2 如上所述。


与现有加密 LeaseSet 的变化：

- 加密整个东西以确保安全
- 使用不只是 AES 进行安全加密。
- 加密到每个接收者

查找使用
    标准 LS 标记（1）
存储使用
    加密 LS2 类型（5）
存储于
    盲化签名类型和盲化公钥的哈希
    两字节签名类型（大端，如 0x000b）||盲化公钥
    然后使用该哈希生成每日的“路由密钥”，如在 LS1 中
通常过期
    10 分钟，像在常规 LS 中，或几个小时，像在meta LS 中。
已发布者
    目的地


定义
```````````
我们定义了用于加密 LS2 的密码学构建块对应的以下函数：

CSRNG(n)
    从密码学上安全的随机数生成器生成 n 字节输出。

    除了 CSRNG 必须是密码学上安全的（因此适用于生成密钥材料）的要求外，它还必须安全地使某个 n 字节输出用于密钥材料，即使字节序列前后立即
    在网络上暴露（如盐，或加密填充）。实现如果依赖于可能不可信的源，则应对要暴露在网络上的任何输出进行散列 [PRNG-REFS]_。

H(p,d)
    SHA-256 散列函数，需以显著种子 p 和数据 d 的输入，产出长度为 32 字节。

    如下使用 SHA-256 函数：

        H(p, d):= SHA-256 (p || d)

STREAM
    ChaCha20 流动加密算法，已在 [RFC-7539-S2.4]_ 中指定，初始化计数器设为1。 S_KEY_LEN = 32 并且 S_IV_LEN = 12。

    ENCRYPT(k, iv, plaintext)
        使用密钥 k 和 iv 对明文进行加密。 iv 在相同密钥 k 下须唯一。 返回密文，其大小与明文相同。
        
        在密钥秘密的情况下，整个密文必须与随机数据不可区分。

    DECRYPT(k, iv, ciphertext)
        使用密钥 k 和 iv 对密文进行解密。返回明文。

SIG
    RedDSA 签名方案（对应签名类型11）支持密钥盲化。
    它具有以下功能：

    DERIVE_PUBLIC(privkey)
        返回与给定私钥匹配的公钥。

    SIGN(privkey, m)
        返回由私钥privkey对给定消息m签名的结果。

    VERIFY(pubkey, m, sig)
        使用公钥 pubkey 和消息 m 验证签名 sig。 如果签名有效，则返回 true；否则返回 false。

    它还必须支持以下密钥盲化操作：

    GENERATE_ALPHA(data, secret)
        为拥有 data 和可选密钥的用户生成 alpha。
        结果必须与私钥分布相同。

    BLIND_PRIVKEY(privkey, alpha)
        使用私钥 alpha 盲化私钥。

    BLIND_PUBKEY(pubkey, alpha)
        使用私钥 alpha 盲化公钥。
        对于给定密钥对 (privkey, pubkey)，以下关系成立：

            BLIND_PUBKEY(pubkey, alpha) ==
            DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha))

DH
    X25519 公钥协议系统。私钥 32 字节，公钥 32字节，产生32字节输出。其具有以下功能：

    GENERATE_PRIVATE()
        生成新的私钥。

    DERIVE_PUBLIC(privkey)
        返回与给定私钥对应的公钥。

    DH(privkey, pubkey)
        根据给定的私钥和公钥生成共享密钥。

HKDF(salt, ikm, info, n)
    密钥导出函数（KDF）接受某些开发关键材料 ikm（应该有良好的熵，但不需要是均匀随机字符串），一个 32 字节盐，并且一个特定于上下文的'info'值，并生成n字节输出，适合作为密钥材料。

    如 [RFC-5869]_ 中所示，使用 HMAC 散列函数 SHA-256，
    如 [RFC-2104]_。 这意味着 SALT_LEN 最大为 32 字节。

格式
``````
加密的 LS2 格式由三层嵌套层组成：

- 包含存储和检索所需的明文信息的外层。
- 负责客户身份验证的中间层。
- 包含实际 LS2 数据的内层。

总体格式如下所示：

    Layer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature

注意加密的 LS2 是盲化的。目的地不在头文件中。
DHT 存储位置是 SHA-256（签名类型 || 盲化公钥），并且每天旋转。

不使用上面指定的标准 LS2 头部。

#### Layer 0（外层）
类型
    1字节

    实际上不在头部，但属于签名覆盖的数据。
    从数据库存储消息字段取。

盲化公钥签名类型
    2字节，大端输入
    这将总是类型11，标识 Red25519 盲化密钥。

盲化公钥
    长度由签名类型暗示

已发布的时间戳
    4字节，大端

    自纪元以来的秒数，2106年翻滚

过期
    2字节，大端

    自发布时间戳起的秒数，最大 18.2 小时

标志
    2字节

    位顺序：15 14 ... 3 2 1 0

    位 0：如果为 0，则无离线密钥；如果为 1，则有离线密钥

    其他位：为兼容性设置为 0

临时密钥数据
    在标志指示离线密钥时出现

    过期时间戳
        4字节，大端

        自纪元以来的秒数，2106年翻滚

    临时签名类型
        2字节，大端输入

    临时签名公钥
        长度由签名类型暗示

    签名
        长度由盲化公钥签名类型暗示

        超过到期时间戳，临时签名类型和临时公钥。

        使用盲化公钥验证。

lenOuterCiphertext
    2字节，大端

outerCiphertext
    lenOuterCiphertext bytes 

    加密层 1 数据。请参阅下面的密钥衍生和加密算法。

签名
    长度由使用的签名密钥的签名类型暗示

    签名是对上述所有内容的签名。

    如果该标志指示离线密钥，则使用该盲化公钥，签名是由该临时
    公钥验证。此外由盲化公钥进行验证生产。`


#### Layer 1（中层）
标志
    1字节
    
    位顺序：76543210

    位 0：0 为所有人，1 为每个客户端，后接认证节

    位 3-1： 认证方案，仅当位 0 设置为 1 时为每个客户端，否则为 000
              000：无需 per-client 认证的 DH 客户认证
              001：预共享密钥客户认证

    位 7-4：未使用，设为 0 以兼容未来

DH 客户认证数据
    在标志位 0 被设置为 1 并且标志位 3-1 被设置为 000 时出现。

    ephemeralPublicKey
        32 字节

    clients
        2 字节，大端

        后续 authClient 条目的数量，每个 40 字节

    authClient
        单个客户端的授权数据。
        请参见下面的每个客户端授权算法。

        clientID_i
            8 字节

        clientCookie_i
            32 字节

PSK 客户认证数据
    在标志位 0 被设置为 1 并且标志位 3-1 被设置为 001 时出现。

    authSalt
        32 字节

    clients
        2 字节，大端

        后续 authClient 条目的数量，每个 40 字节

    authClient
        单个客户端的授权数据。
        请参见下面的每个客户端授权算法。

        clientID_i
            8 字节

        clientCookie_i
            32 字节


innerCiphertext
    通过 lenOuterCiphertext 隐含的长度（剩余数据）

    加密的 Layer 2 数据。请参阅下面的密钥衍生和加密算法。


#### Layer 2（内层）
类型
    1字节

    3 （LS2）或 7 （Meta LS2）

数据
    LeaseSet2 数据为给定类型。

    包括头部和签名。

盲化密钥衍生
````````````````````````

我们在 Ed25519 和 ZCash RedDSA [ZCASH]_ 的基础上使用以下方案进行密钥盲化。
Re25519 签名用于 Ed25519 曲线，SHA-512 用于该哈希。

我们不使用 Tor 的 rend-spec-v3.txt 附录 A.2 [TOR-REND-SPEC-V3]_
尽管具有相似的设计目标，但该设计目标中盲化公钥
可能超出素数子组，安全隐患尚不明确。


#### 目标

- 在未盲化的目标中，签名公钥必须为
  Ed25519（签名类型 7）或 Red25519（签名类型 11）；
  不支持其他签名类型
- 如果签名公钥为离线，临时签名公钥也必须为 Ed25519
- 盲化计算必须简单
- 使用现有密码原语
- 盲化公钥无法解盲
- 盲化公钥必须位于 Ed25519 曲线并且在素数子组中
- 必须知道目标的签名公钥
  （不需要完整目标）来衍生盲化公钥
- 可选提供衍生盲化公钥所需的额外密钥


#### 安全

盲化方案的安全性要求
alpha 的分布与未盲化的私钥相同。
然而，当我们将 Ed25519 私钥（签名类型 7）
盲化为 Red25519 私钥（签名类型 11） 时，分布不同。
为了满足 zcash 章节 4.1.6.1 [ZCASH]_
的要求，Red25519（签名类型 11）也应该被用于非盲化密钥中，
以便"重新随机化公钥和在该密钥下的签名（们）的组合不泄露生成该密钥的密钥。"
我们允许类型 7 用于现有目的地，但建议
使用类型 11 用于新的加密目的地。


#### 定义

B
    Ed25519 基点（生成器）2^255 - 19 如 [ED25519-REFS]_

L
    Ed25519 订单 2^252 + 27742317777372353535851937790883648493
    如 [ED25519-REFS]_ 中所述

DERIVE_PUBLIC(a)
    将私钥转换为公钥，如在Ed25519中（乘以G）

alpha
    在知道目标数据的人所知的 32 字节随机数。

GENERATE_ALPHA(目标, date, secret)
    为当前日期生成alpha，对于知道目标和密钥的人。
    结果必须与 Ed25519 私钥一致分布。

a
    用于为目标签名的未盲化32字节EdDSA或RedDSA签名私钥

A
    目的地中的未盲化32字节EdDSA或RedDSA签名公钥，
    = DERIVE_PUBLIC（a），如Ed25519中

a'
    用于签名加密leaseset的盲化32字节EdDSA签名私钥。
    这是一个有效的 EdDSA 私钥。

A'
    目的地中的盲化32字节EdDSA签名公钥，
    可使用 DERIVE_PUBLIC（a'）或从 A 和 alpha 生成。
    这是一个有效的 EdDSA 公钥，在曲线上并在素数子组中。

LEOS2IP(x)
    将输入字节反转为little-endian

H*(x)
    32 字节 = (LEOS2IP(SHA512(x))) mod B，与Ed25519中哈希和削减相同


#### 盲化计算

必须每一天（UTC）生成新的密钥和盲化密钥。
密钥和盲化密钥的计算如下。

显著目的地(目标, 日期, secret)，适用于所有各方：
```text

// 生成alpha(目标, 日期, secret)

  // 秘密是可选，否则是零长度
  A = 目标的签名公钥
  stA = A 的签名类型，2 字节大端 (0x0007 或 0x000b)
  stA' = 盲化公钥 A' 的签名类型，2 字节大端 (0x000b)
  keydata = A || stA || stA'
  datestring = 从当前日期 UTC 的 8 字节 ASCII YYYYMMDD
  secret = UTF-8 编码字符串
  seed = HKDF(H("I2PGenerateAlpha", keydata), datestring || secret, "i2pblinding1", 64)
  //将种子视为64字节little-endian值
  alpha = seed mod L
```

BLIND_PRIVKEY()，适用于发布leaseset的所有者：

```text

// BLIND_PRIVKEY()

  alpha = GENERATE_ALPHA(destination, date, secret)
  // 若为 Ed25519 私钥（类型 7）
  seed = goal 的签名私钥
  a = SHA512(seed) 的左半部分，并根据 Ed25519 进行夹紧
  // 否则，为 Red25519 私钥（类型 11）
  a = 目标的签名私钥
  // 使用标量算术的加法
  盲化签名私钥 = a' = BLIND_PRIVKEY(a, alpha) = (a + alpha) mod L
  盲化签名公钥 = A' = DERIVE_PUBLIC(a')
```

BLIND_PUBKEY()，适用于检索leaseset的客户端：

```text

// BLIND_PUBKEY()

  alpha = GENERATE_ALPHA(destination, date, secret)
  A = 目标的签名公钥
  // 加法使用群元素（曲线上的点）
  盲化公钥 = A' = BLIND_PUBKEY(A, alpha) = A + DERIVE_PUBLIC(alpha)
```

两种方法计算 A' 均产出相同结果，这是必需的。



#### 签名

未盲化leaseset由未盲化Ed25519或Red25519签名私钥
签名并使用未盲化Ed25519或Red25519签名公钥（签名类型7或11）进行验证，
如常规所述。

如果签名公钥为离线，则
未盲化leaseset由未盲化临时Ed25519或Red25519签名私钥
签名，使用未盲化Ed25519或Red25519临时签名公钥（签名类型7或11）进行验证，
见下文关于加密leasesets的离线密钥额外注意事项。

对于加密leaseset的签名，我们使用基于RedDSA[ZCASH]_的Red25519签名
和使用盲化密钥进行验证。
Red25519签名用于Ed25519曲线，使用SHA-512进行哈希。

Red25519与标准Ed25519唯一不同之处如以下指定


#### 签名/验证计算

加密leaseset的外层使用Red25519密钥和签名。

Red25519与Ed25519几乎相同。 有两个区别：

Red25519 私钥由随机数生成，然后必须 MOD L 约简，其中 L 是上面定义的。
Ed25519 私钥由随机数生成，然后使用对字节 0 和 31 的逐位掩码进行“夹紧”。 这对 Red25519 不适用。
上面定义的函数“生成Alpha（）” 和“盲化私钥（）” 正确的Red25519 私钥通过 MOD L 生成。

在 Red25519 中，签名中 r 的计算采用了额外的随机数据，
它使用公钥值而不是私钥的哈希。
因为随机数据，每个 Red25519 签名都是不同的， 即使
当签署相同的数据并使用相同的密钥。

签名:

..

```text
T = 80随机字节
  r = H*(T || 公钥 || 消息)
  // 其余的和Ed25519一样
```

验证：

```text
// 与在Ed25519中相同
```

加密和处理
``````````````````````````

#### 子凭据的衍生

作为盲化过程的一部分，我们需要确保加密LS2只能由知晓相应目标的签名公钥的用户解密。
不需要完整目标。
为实现这一点，我们从签名公钥上衍生凭据：

.. 

```text
A = 目的地签名公钥
  stA = A 的签名类型, 2字节大端 (0x0007 或 0x000b)
  stA' = A' 的签名类型, 2字节大端 (0x000b)
  keydata = A || stA || stA'
  凭据 = H("credential", keydata)
```

个性化字符串可确保凭据不与任何散列用于DHT查找键如明文目标哈希混淆。

对于给定的盲化键，我们可以接着找到一个衍生出的凭据：

..

```text
subcredential = H("subcredential", credential || blindedPublicKey)
```

该衍生出凭据包含在下面的密钥衍生过程中，使这些
密钥绑定到目的地签名公钥的知识。

#### Layer 1 加密

首先，逐个准备密钥衍生过程：

..

```text
outerInput = subcredential || 发布的 时间戳
```

接着，生成一个随机盐：

..

```text
outerSalt = CSRNG(32)
```

然后使用衍生出内层1加密的密钥：

..

```text
keys = HKDF(outerSalt, outerInput, "ELS2_L1K", 44)
  outerKey = keys[0:31]
  outerIV = keys[32:43]
```

最后，加密内层1的明文并对其进行序列化：

..

```text
outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext)
```

#### Layer 1 解密
该盐在innerCiphertext 里将被解析：

..

```text
outerSalt = outerCiphertext[0:31]
```

猜测曾用的密钥来进行内层1加密：

..

```text
outerInput = subcredential || 发布的 时间戳
  keys = HKDF(outerSalt, outerInput, "ELS2_L1K", 44)
  outerKey = keys[0:31]
  outerIV = keys[32:43]
```

最后，解密innerCiphertext：

..

```text
outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end])
```

#### Layer 2 加密
当客户端授权启用时, ``authCookie`` 是通过如下描述的方式来进行计算。
当不启用客户端授权时，``authCookie`` 是零长度字节数组。

加密以某种方式类似内层1：

..

```text
innerInput = authCookie || subcredential || 发布的 时间戳
  innerSalt = CSRNG(32)
  keys = HKDF(innerSalt, innerInput, "ELS2_L2K", 44)
  innerKey = keys[0:31]
  innerIV = keys[32:43]
  innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext)
```

#### Layer 2 解密
当客户端授权启用时, ``authCookie`` 是通过如下描述的方式来进行计算。
当不启用客户端授权时，``authCookie`` 是零长度字节数组。

解密以某种方式类似内层1：

..
`
```text
innerInput = authCookie || subcredential || 发布的 时间戳
  innerSalt = innerCiphertext[0:31]
  keys = HKDF(innerSalt, innerInput, "ELS2_L2K", 44)
  innerKey = keys[0:31]
  innerIV = keys[32:43]
  innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end])
```

每个客户端授权
```````````````````````
当客户端授权启用于目的地时，服务器维护某些
认证的客户端列表，允许他们解密加密的 LS2 数据。 数据存储在客户端以取决于授权机制，并包括每个
客户生成并通过安全的外部机制发送给服务器某些键材料。

实现每个客户端授权有两个替代方案：

#### DH 客户端授权
每个客户生成一个 DH 密钥对 ``[csk_i, cpk_i]``，并将该公钥 ``cpk_i``
发送给服务器。

服务器处理
^^^^^^^^^^^^^^^^^
服务器生成一个新的 ``authCookie`` 和一个临时 DH 密钥对：

..

```text
authCookie = CSRNG(32)
  esk = 生成私钥()
  epk = DERIVE_PUBLIC(esk)
```

然后对于每个授权的客户端，服务器将`authCookie`加密给该公钥：

..

```text
sharedSecret = DH(esk, cpk_i)
  authInput = sharedSecret || cpk_i || subcredential || 发布的 时间戳
  okm = HKDF(epk, authInput, "ELS2_XCA", 52)
  clientKey_i = okm[0:31]
  clientIV_i = okm[32:43]
  clientID_i = okm[44:51]
  clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie)
```

在 layer 1 中服务器存储此``[clientID_i, clientCookie_i]`` 存放授权身份
加密的 LS2 和``epk``。

客户端加工
^^^^^^^^^^^^^^^^^
客户端使用其私钥推导期望的客户端标识符 clientID_i
加密密钥 clientKey_i 和加密IV clientIV_i：

..

```text
sharedSecret = DH(csk_i, epk)
  authInput = sharedSecret || cpk_i || subcredential || 发布的 时间戳
  okm = HKDF(epk, authInput, "ELS2_XCA", 52)
  clientKey_i = okm[0:31]
  clientIV_i = okm[32:43]
  clientID_i = okm[44:51]
```

然后客户在层1安装的数据中查找一个包含 clientID_i 的条目。
如果存在匹配条目，则客户端可以进行解密，获取 authCookie：

..

```text
authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie_i)
```

#### 预共享密钥客户端授权
每个客户生成一个秘密的32字节的密钥``psk_i``, 并发生给服务器。
或者，服务器可以生成一个匿名密钥，并将匿名密钥与一个以上客户共享。

服务器处理
^^^^^^^^^^^^^^^^^
服务器生成一个新的<<`authCookie``和盐：

..

```text
authCookie = CSRNG(32)
  authSalt = CSRNG(32)
```

每个授权的客户，服务器加密 authCookie 到它的预共享密钥：

..

```text
authInput = psk_i || subcredential || 发布的 时间戳
  okm = HKDF(authSalt, authInput, "ELS2PSKA", 52)
  clientKey_i = okm[0:31]
  clientIV_i = okm[32:43]
  clientID_i = okm[44:51]
  clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie)
```

在 layer 1 中服务器放置每个``[clientID_i, clientCookie_i]`` 的记录
加密的LS2连同authSalt储存

客户端加工
^^^^^^^^^^^^^^^^^
客户端生成自己的预共享密钥，转为期望的客户端标分 clientID_i
加密密钥clientKey_i 和IV clientIV_i：

..

```text
authInput = psk_i || subcredential || 发布的 时间戳
  okm = HKDF(authSalt, authInput, "ELS2PSKA", 52)
  clientKey_i = okm[0:31]
  clientIV_i = okm[32:43]
  clientID_i = okm[44:51]
```

然后客户在层1安装的数据中查找一个包含 clientID_i 的条目。
如果存在匹配条目，则客户会解密以获取 authCookie：

..

```text
authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie_i)
```

#### 安全考虑
上述两个客户端认证机制均可为成员提供隐私。
一个仅了解目标的实体可能会看到有多少客户端被订阅，
但无论如何无法得知哪个客户端已被添加或撤销。

服务器 应 该每次生成加密的 LS2 时都随机化客户端的顺序，以
防止客户端了解其在列表中的位置并推断出正在添加或撤销他人。

如果服务器想隐藏有多少客户端可通过向列表中插入随机条目。 

DH 客户端认证优势
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- 不是仅依赖于所有块密钥的外部交换，实现安全的方案。
  客户端的私钥从不需要离开其设备，因此一个
  那可能可以拦截外部交换的敌手不能以解开加密的 LS2，或确定多长时间给予客户的访问。

DH 客户端授权的缺点
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- 需要N+1个服务侧的DH操作
- 从客户端方面可能仅需一个DH操作。
- 客户端需要生成私钥。

PSK 客户端授权优势
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- 不需要任何DH操作
- 允许服务器生成私钥。
- 允许服务即可将相同密钥与多名客户共享。

PSK 客户端授权的缺点
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- 安全依赖于关键材料外部交换的方案。如果对于某一客户端而言，外部交换被敌手拦截
可以解密给客户进行认证的后续加密 LS2，和
确定什么时候客户确认撤销。

加密 LS 与 Base 32 地址
`````````````````````````````````````

请参见提案 149。

您不能对比特流使用加密的 LS2，因为其回复是
32 字节。32字节中仅包含哈希。
没有地方去指示
leaseset 是加密的，或签名类型。

加密的 LS 与 离线键
``````````````````````````````````
对于使用离线密钥的加密的 leasesets ，盲化私钥也必须离线生成，
每天一个。

由于可选的离线签名块位于加密 leaseset 的明文部分，
任何清理的 floodfills 都可用于跟踪 leaseset（但不能解密）、超过多个天。
为了防止此，我们的键所有者应生成新临时密钥
的每一天。临时和盲化密钥可以提前生成
，并在批处理中提供给路由器。

本提案中没有定义打包多个临时和
盲化密钥并提供给客户端或路由器的文件格式。
本提案未定义对有离线密钥的加密 leasesets的
支持 I2CP 协议增强

备注
`````

- 使用加密 leaseset的服务会将加密的版本发布到
floodfills。但为了效率，它将不加密的leasesets发送给
客户端以包装 garlic 消息，一旦认证（通过白名单，例如）。

- floodfills 可能会将最大大小限制在合理值内以防止滥用。

- 解密后，应进行几项检查，包括
内时间戳和过期时间与顶部级别匹配。

- 选择ChaCha20是为了选择AES。虽然在启用AES硬件支持的情况下速度相似，但ChaCha20在没有
AES硬件支持，例如在低端ARM设备上，至少要快2.5-3倍。

- 我们不太关心速度来使用密钥BLAKE2b。写出
一个输出大小足够大以容纳我们所要求的最大 n（或我们每
生成一个所需密钥都可调用一次它并附带一个计数器
参数）。BLAKE2b比SHA-256要快得多，
密钥BLAKE2b 减少了总的哈希函数调用数量。
但是，也请参见提案 148，通过提案提出我们转向 BLAKE2b 作为其他
原因。[UNSCIENTIFIC-KDF-SPEEDS]_

### Meta LS2

这用于取代多宿主。像任何 leaseset 一样，这由
创建者签名。这是一份参与服务的目标 hash 的认证列表。

Meta LS2 是树结构的顶部，可能是中间节点。
它包含若干条目，每个条目指向一个 LS、LS2 或另一个 Meta LS2
以支持大量多宿主。
Meta LS2 可能包含 LS、LS2 和 Meta LS2 条目的组合。
树的叶子永远是一个 LS 或 LS2。
树是一个有向无环图（DAG）；不允许形成环路；客户端
查询时必须检测并拒绝遵循这些环路。

Meta LS2 的过期时间可能比标准 LS 或 LS2 长得多。
顶级的可以发布日期几小时后的过期。
最大过期时间将由 floodfills 和客户端强制实施，TBD。

Meta LS2 的用例是大规模多宿主，但没有比
现有 LS 或 LS2 提供更多对启发性目录与
leaseset（在路由器重启时间）关联保护。
这种方法与“脸书”使用案例相当，不需要
相关保护。此方法可能需要离线密钥，
由树的每个节点上的标准头提供。

后台协议用于协调物理叶
路由器、附属和主 Meta LS签署人
不在此处指定。需求很简单——只是验证和
定期（数小时）发布新 LS。唯一复杂因素是
挑选新的发布者以应对顶级或中级 Meta LS 的故障。

混合宿主空穴
将多个路由器的leases合并、签名后发布
到单个leasesets 的文档在提案 140中
“看不见的多宿主”。
该提案如编写的情况下，不现实，因为流
连接并不会“粘性化”到单个路由器（见 http://zzz.i2p
/topics/2335 )

后台协议以及与路由器和客户端内部的交互，
对于看不见的多宿主尤为
复杂。

为了避免对顶级 Meta LS 的 floodfill 过载，过期时间应
至少几小时。客户端必须缓存顶级 Meta LS，并持久化
如果未过期，则重新启动。

我们需要定义一些算法用于客户端遍历
树，包括后退，因此使用可释溶散。如果某个节点同时拥有 LS 或 LS2 和 Meta LS，
我们需要知道何时允许
使用这些leasesets，何时继续遍历树。

查找使用
    标准 LS 标记（1）
存储使用
    Meta LS2 类型（7）
存储于
    目的地的哈希
    然后使用该哈希生成每日的“路由密钥”，如在 LS1 中
通常过期
    小时。最大 18.2 小时（65535 秒）
已发布者
    "master"目标或协调程序，或中间协调程序

格式
``````
::

  标准 LS2 头部，按上文说明

  Meta LS2 类型特定部分
  - 属性（如通用结构规范中所述的映射，无则为 2个零字节）
  - 条目数量（1字节） 最大 TBD
  - 条目。每个条目包含：（40字节）
    - Hash（32字节）
    - 标志（2字节）
      TBD。设为零，以支持未来使用。
    - 类型（1字节）它是引用的LS的类型；
      1 为 LS，3 为 LS2，5 为加密，7 为元，0 为未知。
    - 成本（优先级）（1字节）
    - 过期（4 字节）（大端，秒数，自纪元以来，2106年翻卷）
  - 撤销数量（1字节）最大 TBD
  - 撤销：每个撤销包含：（32字节）
    - 哈希（32字节）

  标准 LS2 签名：
  - 签名 (40+ bytes)
    签名是上述所有内容的签名。

标志和属性：供将来使用


备注
`````
- 具有此功能的分布式服务将有一个或多个具有
  服务目标私人钥匙的"主机"。它们将（Out of band）确定
  当前活动目标列表并且发布 Meta LS2 。为
  冗余，可以多宿主（即同时发布）Meta LS2 。

- 分布服务可以从单个目标或使用旧式多宿主开始，然后过渡到Meta LS2 。 标准LS查询可以返回
  LS、LS2或Meta LS2中的任何一个。

- 当诸如Meta LS2之类的方法被使用，服务则不具有隧道（leases）。


### 服务记录

这是表明目的地参与一项服务的单个记录。它从参与者发送到 floodfill。它从未被 floodfill
单独发送，但只作为服务列表的一部分。服务记录
还用于通过将到期设置为零来撤销服务参与。

这不是一个 LS2, 但它使用标准 LS2 头部和签名格式。

查找使用
    n/a, 见服务列表
存储使用
    服务记录类型（9）
存储于
    服务名称的哈希
    然后使用该哈希生成每日的“路由密钥”，如在 LS1 中
通常过期
    小时。最大18.2小时（65535秒）
已发布者
    目的地

格式
``````
::

  标准 LS2 头部，按上面说明

  服务记录类型特定部分
  - 端口 (2 字节，大端)（未指定时为0）
  - 服务名称 hash (32 bytes)

  标准 LS2 签名：
  - 签名 (40+ bytes)
    签名是对上述所有内容的签名。

备注
`````
- 如果到期为全0，填充器应撤销该记录并不再
  包括它在服务列表中。

- 存储：填充器可以严格控制这些记录的存储
  和限制每个hash存储的记录数及其过期时间。也可用于
  hash的白名单。

- 任何其他 netdb 类型在同一哈希下具有优先权，所以一个服务记录永不能
  覆盖 LS/RI，但一 LS/RI 将覆盖在该哈希的所有服务记录。



### 服务列表

这与LS2不同，并使用不同格式。

服务列表由 floodfill 创建并签名。它未经认证
因为任何人都可以通过向 floodfill
发布服务记录加入服务。

服务列表包含简要服务记录，而不是完整服务记录。 这些
包含签名，但仅包含哈希，不包含完整的目标，因此在没有完整目标的情况下无法验证。

服务列表的安全性（如果有）和可取性仍需决定。
填充器可以根据实现或操作员喜好对加入和查找的服务进行 whitelist限制，
但该白名单可能因实现而异。
在不同实现之间可能无法达成一致意见以支持一致的初始白名单。

如果服务名称包含在与服务记录中，
那么 floodfill 运营商可能会反对；如果仅包含 hash，
则没有验证，并且一个服务记录可以“优先于”
其他 netdb类型存储到 floodfill。

查找使用
    服务列表查找类型（11）
存储使用
    服务列表类型（11）
存储于
    服务名称的哈希
    然后使用该哈希生成每日的“路由密钥”，如在 LS1 中
通常过期
    小时，不在列表本身中指定，依据本地政策规定
已发布者
    无人，未发送到 floodfill, 未泛洪。

格式
``````
不使用上面指定的标准 LS2 头部。

::

  - 类型 (1 字节)
    实际上不在头部，但属于签名涵盖的数据。
    来自数据库存储消息字段。
  - 服务名称的哈希（隐含，在数据库存储消息）
  - 创建者哈希（填充器）（32字节）
  - 已发布的时间戳（8字节，Big-endian）

  - 简短服务记录数量（1字节）
  - 简短服务记录列表：
    每个简短服务记录包含（90+ 字节）
    - 目的地 hash（32字节）
    - 发布时间戳（8字节，Big-endian）
    - 过期（4字节，Big-endian）（从发布在 ms 中的偏移量）
    - 标志（2字节）
    - 端口（2字节，Big-endian）
    - 签名长度（2字节，Big-endian）
    - 意图签名（40+字节）

  - 撤销记录数量（1字节）
  - 撤销记录列表：
    每个撤销记录包含（86+ 字节）
    - 目的地 hash（32字节）
    - 发布时间戳（8字节，Big-endian）
    - 标志（2字节）
    - 端口（2字节，Big-endian）
    - 签名长度（2字节，Big-endian）
    - 意图签名（40+字节）

  - 填充器签名（40+字节）
    签名是对所有以上内容的签名。

验证服务列表的签名：

- 将服务名称的哈希添加到前面
- 去除创造者的哈希
- 检查签名的修改后的内容

验证每个简短服务记录的签名：

- 获取目的地
- 检查签名（发布时间戳 + 过期 + 标志 + 端口 + 服务名称的哈希）

验证每个撤销记录的签名：

- 获取目的地
- 检查签名（发布时间戳 + 4个零字节 + 标志 + 端口 + 服务名称的哈希）

备注
`````
- 使用签名长度而不是签名类型，以支持未知签名。
  
- 没有服务列表的过期，接收方可以根据策略或个别记录的有效期自行决定。

- 服务列表不会被泛洪传播，只有个别的服务记录可以。每个 floodfill 创建
  签名，缓存一个服务列表。floodfill 使用自身政策来储存
  和控制缓存时间及最大服务和撤销记录数。



## 必须更改的公共结构规范

### 密钥证书

不在本提案中。
添加到 ECIES 提案 144 和 145。

### 新中间结构

为 Lease2、MetaLease、LeaseSet2Header 和 OfflineSignature 添加新的结构。
如更改在0.9.38发布时有效。

### 新的 NetDB 类型

为每个新leaseest类型添加结构，自上而下。
对于 LeaseSet2、EncryptedLeaseSet 和 MetaLeaseSet，
如在0.9.38发布时有效。
对于服务记录和服务列表，
预备的，没有计划。

### 新的签名类型

增加RedDSA_SHA512_Ed25519类型11。
公钥 32 字节；私钥 32字节；哈希 64字节；签名 64字节。

## 必须更改的加密规范

不在本提案中。
请参见提案 144 和 145。

## I2NP 必须更改

添加注释：LS2 只能发布到具有最低版本的 floodfills。

### 数据库查找消息

添加服务列表查找类型。

更改
`````
::
2
  标志字节：查找类型字段（当前为位 3-2），扩展到位 4-2。
  设定查找类型0x04为服务列表查找。
  
  添加注释：服务列表查找只可以给最小版本的 floodfills发送。
  最小版本为 0.9.38。

### 数据库存储消息

添加所有新的存储类型。

更改
`````
::
4
  类型字节：类型字段，当前位为0，扩展至位3-0。
  类型3被定义为LS2存储。
  类型5被定义为加密的LS2存储。
  类型7被定义为Meta LS2存储。
  类型9被定义为服务记录存储。
  类型11被定义为服务列表存储。
  其他类型未定义且无效。

  添加注释：所有新类型只能发布到具有最低版本的 floodfills。
  最小版本为0.9.38。
## I2CP 必须更改

### I2CP 选项

新的由路由器解释的选项，发送时为SessionConfig 映射：

::

  i2cp.leaseSetType=nnn       将在创建 LeaseSet 消息中发送 leaseest 的类型
                              值与上表的 netdb 存储类型相同。
                              客户端侧解释，但也传递到路由器在
                              SessionConfig中，以声明意图并检查支持。

  i2cp.leaseSetEncType=nnn[,nnn]  将使用的加密类型。
                                  客户端侧解释，但也传递到路由器在
                                  SessionConfig中，以声明意图并检查支持。
                                  请参阅提案 144 和 145。

  i2cp.leaseSetOfflineExpiration=nnn  离线签名的到期，ASCII，
                                      自最大以来的秒数。

  i2cp.leaseSetTransientPublicKey=[type:]b64  临时私钥的base64，
                                              前缀为可选的sig类型数字
                                              或名称，默认DSA_SHA1。
                                              长度可从sig类型推断

  i2cp.leaseSetOfflineSignature=b64   离线签名的base64。
                                      长度可从目标
                                      私钥类型推断

  i2cp.leaseSetSecret=b64     用于盲化leaseset
                              地址的base64，默认""

  i2cp.leaseSetAuthType=nnn   加密的 LS2 的认证类型。
                              0 表示无 per-client 认证（默认）
                              1 表示DH per-client认证
                              2 表示PSK per-client认证

  i2cp.leaseSetPrivKey=b64    基于base64的私钥，供路由器使用
                              解密加密的 LS2，
                              仅在启用 per-client 认证时提供

由客户端解释的新选项：

::

  i2cp.leaseSetType=nnn     将在创建LeaseSet消息中发送leaseest的类型
                            值与上表的netdb存储类型相同。
                            客户端侧解释，参数将在SessionConfig中发送给路由器
                            以声明意图和检查支持。

  i2cp.leaseSetEncType=nnn[,nnn]  将使用的加密类型。
                                  客户端侧解释但也传递到路由器在
                                  SessionConfig中，以声明意图和检查支持。
                                  请参阅提案144 和145。

  i2cp.leaseSetSecret=b64     用于盲化leaseset的base64，
                              地址，默认“”

  i2cp.leaseSetAuthType=nnn       加密的 LS2 的认证类型。
                                  0 表示无 per-client 认证（默认）
                                  1 表示DH per-client认证
                                  2 表示PSK per-client认证

  i2cp.leaseSetBlindedType=nnn   用于加密的 LS2 的盲化密钥的签名类型。
                                 默认值取决于目的地签名类型。

  i2cp.leaseSetClient.dh.nnn=b64name:b64pubkey   为DH每个客户端的身份验证
                                                 使用的公钥的base64，b64pubkey，
                                                 前缀由可选的客户端名称，随后是":",
                                                 然后是 DH for  per-client auth的公钥base64。
                                                 nnn从 0 开始

  i2cp.leaseSetClient.psk.nnn=b64name:b64privkey   为PSK每个客户端的身份认证
                                                   使用的私钥的base64，b64key
                                                   前缀为可选的客户端名称名称（仅限UI）
 thatn，
                                                   随后是":", 然后是 PSK for per-client auth的
                                                   私钥的base64。nnn起始为0

### 会话配置

请注意，对于离线签名，选项
i2cp.leaseSetOfflineExpiration,
i2cp.leaseSetTransientPublicKey, 和
i2cp.leaseSetOfflineSignature 是必需的，
该签名是由临时签名私钥的签名。



### 请求 LeaseSet 消息

路由器至客户端。
无更改。
leases 以8字节时间戳发送，即使
返回的leaseset将是具有4字节时间戳的LS2。
请注意，响应可能是根据需要的`创建leaseest`或`创建leaseest2`消息中发出的。

### 请求可变Leaseset 消息

路由器至客户端。
无更改。
leases 以8字节时间戳发送，即使
所需类型的返回leaseest将是具有4字节时间戳的LS2。
请注意，响应可能是按需根据发送的创建leaseest或创建leaseest2消息发出的。

### 创建Leaseset2 消息

客户端到路由器。
新消息，以信息的格式用于取代原来的create leaseest消息中的`创建 leaseest`消息`消息`.

合理
```````````````

- 对于路由器解析存储类型，类型必须在消息中，
  除非它被事先传递给路由器签名配置。
  对于通用解析代码，更容易从消息内知解析出来。

- 对于路由器知道加密密钥的类型和长度,
  它必须放在leaseest之后，除非解析器由先前签名弄清。
  签名配置。
  对于通用解析代码，更容易从消息内知解析出来。

- 未盲化的leaseest中定义的签名私钥，KEY
  是为撤销准备的，并且未使用在LS2。

消息类型
````````````

`创建Leaseset2消息的消息类型为41。

格式
``````

::

  会话ID
  类型字节: 跟随leaseest的类型
             类型1 是 LS
             类型3 是LS2
             类型5 是加密的LS2
             类型7是metaLS2
  LeaseSet: 上述说明的类型
  私钥数量为后（1字节）
  加密私钥：每个公开的关键在 leaseset 中，
                           与相同顺序
                           (对于Meta LS2 不存在)
                           - 加密类型（2字节，大端）
                           - 加密键值长度（2字节，大端）
                           - 加密键（按指定字节数）

注意
`````

- 最小路由器版本为 0.9.39。
- 带有消息类型的临时版本40是在0.9.38中，但格式已更改。
  类型40已放弃并不受支持。

问题
``````

- 需要更多更改以支持加密和元LS。

### 盲信息消息

客户端到路由器。
新消息。

合理
`````````````

- 路由器需要知道目标是否盲目化。
  如果它是盲目的，并使用一个秘密或per-client认证，
  他需要这些信息作为进一步行动的确认

- 一个“b33”新格式`b32`
  提醒路由器知道地址是盲化的，但没有地方
  在 host lookup 消息中传递密钥或私钥
  同时还要传递那个信息。
  尽管我们可以扩展 host lookup 消息、以添加该信息，
  定义一个新的消息更干净。

- 我们需要一个程序方法由客户端告诉路由器它是盲化的。
  否则，用户需要为每个目标手动配置。

使用情况
``````

在客户端向盲目目标发送消息之前，必须
   在 host lookup 中查看“b33”，或发送盲目化信息msg
  有必要的或per-client认证要求，
  客户端必须发送盲目信息信

路由器对此消息不发送回复。

消息类型
````````````

盲目化信息消息类型为42。

格式
``````

::

  会话ID
  标志:       1字节
               位顺序：76543210
               位0：对所有人0，为每个客户1
               位3-1: 认证方案，如果位0设置为1 per-client，否则为000
                         000：DH 客户端认证（或没有每一个客户端认证）
                         001： PSK 客户端认证
               位4：如果需求为1，否则为0
               位置7-5：未使用，设置为0以兼容未来
  类型字节:   跟随的端点类型
               类型0 是哈希
               类型1 是主机名称字符串
               类型2 是目标
               类型3 是签名类型和签名公钥
  否字节:  2字节盲化签名类型（大端）
  过期:  4字节，大端，自纪元秒
  端点:   数据如上段所规定的
               类型0: 32字节的二进制哈希
               类型1: 主机名字符串
               类型2: 二进制地址
               类型3: 2字节sig类型（大端）
                           签名公钥（长度由签名类型暗示）
  私钥:      仅在标志位0时
               A 32字节 ECIES_X25519 私钥
  密钥:      仅在标志位4时
               程式字符串

注意
`````

- 最低路由器版本为0.9.43

问题
``````
### Host Reply Message (enc)

为支持“b33”主机名查找及返回指示
如果路由器没有必要信息，我们定义
来的Host Reply Message的附加结果代码如下：

::



   

2: 需要查找密码

   

3: 需要私钥

   

4: 需要查找密码和私钥

   

5: Leaseset解码失败

值1-255已经定义为错误,不过与
向后的兼容性没有问题。

### Meta Redirect Message

路由器到客户端。
新消息。

合理
````
