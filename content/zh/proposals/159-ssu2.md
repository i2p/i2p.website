---
title: "SSU2"
number: "159"
author: "eyedeekay, orignal, zlatinb, zzz"
created: "2021-09-12"
lastupdated: "2025-03-05"
status: "Closed"
thread: "http://zzz.i2p/topics/2612"
target: "0.9.56"
---

## 状态

发布计划：

| 功能 | 测试（非默认） | 默认启用 |
|----|---------|------|
| 本地测试代码 | 2022-02 |
| 联合测试代码 | 2022-03 |
| 网络内联合测试 | 0.9.54 | 2022-05 |
| 冻结基本协议 | 0.9.54 | 2022-05 |
| 基本Session | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| 地址验证（重试） | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| 握手中的分段RI | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| 新令牌 | 0.9.55 | 2022-08 | 0.9.57 | 2022-11 |
| 冻结扩展协议 | 0.9.55 | 2022-08 |
| 中继 | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| 对等测试 | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| 为2%随机启用 | 0.9.55 | 2022-08 |
| 路径验证 | 0.9.55+ dev | 0.9.56 | 2022-11 |
| 连接迁移 | 0.9.55+ dev | 0.9.56 | 2022-11 |
| 即时ACK标志 | 0.9.55+ dev | 0.9.56 | 2022-11 |
| 密钥旋转 | 0.9.57 | 2023-02 | 0.9.58 | 2023-05 |
| 禁用SSU 1（i2pd） | 0.9.56 | 2022-11 |
| 禁用SSU 1（Java I2P） 0.9.58 | 2023-05 | 0.9.61 | 2023-12 |

基本Session 包括握手阶段和数据阶段。
扩展协议包括中继和对等测试。

## 概览

本提案描述了一种经过认证的密钥协商协议，以增强 [SSU](/en/docs/transport/ssu/) 对各类自动化识别和攻击的抗性。

提案的组织如下：首先介绍安全目标，然后讨论基本协议。接着给出所有协议消息的完整规范。最后讨论路由器地址和版本识别。

与其他I2P传输一样，SSU2 被定义为I2NP消息的点对点（路由器到路由器）传输。这并不是一个通用数据管道。与 [SSU](/en/docs/transport/ssu/) 一样，它还提供两个额外服务：用于NAT穿透的中继，以及用于确定入站可达性的对等测试。它还提供了SSU中没有的第三个服务，当对等端变更IP或端口时，进行连接迁移。

## 动机

SSU 是剩下的唯一需要使用ElGamal的协议层，这非常慢。SSU的流量控制复杂且效果不佳。SSU的部分内容容易受到地址伪造攻击。握手不使用Noise协议。

## 设计目标

- 通过消除ElGamal减少CPU使用。 使用X25519进行DH。

- 保持对等测试和中继功能，并增强其安全性。

- 通过允许标准流量控制算法，使实现更为简便。

- 减少设置的延迟。
  当前NTCP2的中位设置时间约为135 ms，而SSU约为187 ms，尽管NTCP2需要额外往返；在SSU2中移除ElGamal应该可以减少延迟，但其他变化也可能有所帮助。

- 与SSU 1相比，保持或增加最大吞吐量，通过在测试网络上测量一系列模拟延迟和分组丢包百分比进行验证。

- 通过“地址验证”防止来源地址伪造造成的流量放大和误路攻击。

- 简化数据包识别，减少对回退和启发式方法的依赖，不使代码过于复杂。

- 在对等方的IP或端口变化时，实现和改进连接迁移。地址验证完成之前禁止迁移连接，以防止攻击。某些SSU 1 实现使用昂贵的启发式方法来处理由于NAT重新绑定而导致的端口变化。已知的SSU 1实现都无法处理IP变更。

- 在单个端口上支持SSU 1和2，自动检测，并作为单个“传输”（即 [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) 在 [NetDB](/en/docs/how/network-database/) 中发布。

- 在NetDB中单独的字段中发布仅支持版本1或2，或同时支持1和2，默认支持仅版本1（不要将版本支持绑定到特定路由器版本）

- 确保所有实现（Java/i2pd/Go）能够自行安排添加版本2支持（或不添加）

- 为包括握手和数据消息在内的所有消息添加随机填充。所有填充必须由MAC覆盖，不同于SSU 1中的数据包尾填充。提供选项机制，允许双方请求最小和最大填充以及/或填充分布。填充分布的具体情况取决于实现，可能在协议中未规定。

- 将未完全加密的消息的头部和内容混淆，以避免DPI设备和AV签名轻易对其进行分类。此外，确保发往单个对等方或对等方组的消息中的位模式不同。

- 修复因Java格式导致的DH丢失位 [Ticket1112](http://{{ i2pconv('trac.i2p2.i2p') }}/ticket/1112)，通过切换到X25519来加速DH。

- 使用真正的密钥派生函数（KDF）而不是直接使用DH结果

- 增加“探测抗性”（即Tor所称的），这包括重放抗性。

- 保持双向认证密钥交换（2W-AKE）。一向认证密钥交换（1W-AKE）对于我们的应用程序来说不够充分。

- 依赖在RouterInfo中发布的静态公钥作为身份验证的另一部分。

- 在握手中添加选项/版本以便将来扩展。

- 不增加连接设置所需的CPU量；如果可能，进行大幅度的减少。

- 移除SSU 1中AES加密强加的16字节倍数填充要求。

- 使用标准ChaCha/Poly1305进行加密和MAC，
  替换掉SSU 1中使用的AES加密和非标准HMAC-MD5-128 MAC。

- 分别为发送和接收使用不同的加密密钥，而不是SSU 1中用于两个方向的通用密钥。

- 使用3消息一往返握手，如同 [NTCP2](/en/proposals/111-ntcp-2/). 移除当前消息有效负载等待数据消息导致 [SSU](/en/docs/transport/ssu/) 实际上两往返握手。

- 极大提高清ACK和NACK的效率，在SSU 1中这非常糟糕。减少需要的ACK和NACK带宽，增加可用的数据数据包大小。有效编码常见的丢失消息突发NACK，这在WiFi中非常常见。

- 减小实现I2NP消息分片所需复杂性。绕过分片机制和完整I2NP消息编码。

- 在填充前尽量减少协议开销，特别是ACK。这虽然会添加填充，但填充前的开销仍然是开销。低带宽节点必须能够使用SSU2。

- 保留时间戳用于重放和漂移检测。

- 避免2038年问题，时间戳必须至少可以正常工作到2106年。

- 将最小MTU从620增加到1280以提高效率，便于实现，并增加I2NP消息最大大小。碎片和重组是相当昂贵的。通过为1028字节隧道消息提供空间，I2NP消息的大多数将不需分片。

- 提高最大MTU从1488（IPv6为1484）到1500以提高效率。移除MTU必须为16的倍数要求。

- 将I2NP消息最大大小从大约SSU 1中的32K提高到约64 KB如同在NTCP2中。

- 移除握手中IP和端口字段的签名，以便那些不知道其外部IP和端口的路由器可以连接。

- 保留握手中SSU 1的IP/端口发现机制，以便路由器可以获知其外部IP和端口。

- 在设计中纳入Java、C++ 和 Go 路由器开发者代表。

### 非目标

- 针对DPI的万无一失的抵抗...那会需要插件化的传输，[Prop109](/en/proposals/109-hashcash/)。

- 基于TLS的（或HTTPS-类似）的传输...那会是 [Prop104](/en/proposals/104-new-protocol/)。

- 基于时间的DPI抵抗（消息间时间/延迟可以依赖于实现；消息间延迟可以在任何点引入，包括在发送随机填充前，例如）。人工延迟（如obfs4所谓的IAT或到达时间间隔）与协议本身独立。

- 参与会话的否认...那里有签名。

可能被部分重新考虑或讨论的非目标：

- 针对深度数据包检测（DPI）的保护程度

- 后量子（PQ）安全性

- 否认

## 安全目标

我们考虑三个方：

- Alice，希望建立新的会话。
- Bob，Alice希望与之建立会话。
- Mallory，Alice和Bob之间的“中间人”。

最多两个参与者能进行主动攻击。

Alice和Bob都拥有一个静态密钥对，包含在他们的[RouterIdentity](/en/docs/spec/common-structures/#routeridentity/)中。

提议的协议尝试允许Alice和Bob在以下要求下达成共享秘密密钥（K）：

1）私人密钥安全性：Bob或Mallory都无法获知Alice的静态私钥。对称地，Alice不获知Bob的静态私钥。

2）会话密钥K仅由Alice和Bob所知。

3）完美前向安全性：即使在会后将Alice和/或Bob的静态私钥泄露，该会话密钥也能在未来保持秘密。

4）双向认证：Alice确信她已经与Bob建立了会话，反之亦然。

5）对在线DPI的保护：确保使用简单的深度包检测（DPI）技术并不能检测出Alice和Bob正在使用协议。见下文。

6）有限责任：Alice或Bob无法否认参与协议，但如果任何一方泄露了共享密钥，另一方可以否认传输数据内容的真实性。

本提案尝试提供基于 [STS](https://en.wikipedia.org/wiki/Station-to-Station_protocol)协议的五个需求。注意该协议也是[SSU](/en/docs/transport/ssu/)协议的基础。

### 额外的DPI讨论

我们假设两个DPI组件：

实时DPI
```````````````

实时检查所有流量的实时DPI。连接可能被拦截或篡改。连接数据或元数据可能被辨识并储存以供离线分析。实时DPI无权访问I2P网络数据库。实时DPI只有有限的实时计算能力，包括长度计算，字段检查和简单计算如XOR。实时DPI能够进行快速的实时密码学运算如ChaCha20、AEAD和哈希，但很可能无法在所有流量上展开。如果加密操作能应用，那应该从在之前离线分析过程中标识出的IP/端口组合开始。实时DPI无法支持高开销的加密函数如DH或elligator2。实时DPI不是专为发现I2P而设计，尽管它可能有少量作为目的的分类规则。

目标是防止协议通过实时DPI识别。

此在线或“简单”DPI定义包含以下能力：

1）能检查目标发送或接收的所有数据。

2）能对观察到的数据执行操作，比如应用块密码或哈希函数。

3）能存储并与之前发送的信息进行比较。

4）能修改、延迟或分段包。

但对实时DPI假设限制如下：

5）无法将IP地址映射到路由器哈希。尽管对网络数据库拥有实时访问这并非难事，
但需要专门为I2P目标而设计的DPI系统。

6）无法使用定时信息探测协议。 

7）移动设备的工具箱不应握有为了I2P辨识而特别设计的工具。这包括创建“蜂窝陷阱”，例如在其消息中使用非随机填充。注意，这不排斥机器学习系统或高度可配置的DPI工具，只要它们符合其他要求。

为了应对负载分析，确保所有消息都与随机无区别。这也要求其长度为随机，这比只是增加随机填充更复杂。实际上，在附录A中，作者声称普通（即均匀）的填充方案并不能解决问题。因此附录A提议引入随机延迟或开发一种替代的填充方案，可以提供合理的保护以对抗提出的攻击。

为保护上面第6条，实施者应在协议中包含随机延迟。这些技术不在协议范围之内，但它们可能也解决填充长度问题。总的来说，提案提供了不错的负载分析保护（考虑了附录A中的因素），但对流量分析的保护有限。

离线DPI
````````````````

对在线DPI储存的数据进行后续分析的离线DPI。离线DPI可设计专门用以探测I2P。
离线DPI对I2P网络数据库的实时访问。
离线DPI对该版本和其他I2P规范文件可访问。
离线DPI具在此规范中定义的所有加密功能的无限计算能力。

离线DPI无法拦截已有连接。
离线DPI可以在连接建立几分钟内通过包注入向主机/端口发送信息。
离线DPI可以在几分钟内通过包重放（经修改与否）进行“探测”或其他目的。

阻止协议通过离线DPI进行识别不是目标。
所有由I2P路由器实施的首个两消息中被混淆的解码，
离线DPI也能够实施。

是目标拒绝通过之前信息的重放而试图连接。

### 地址验证

以下内容复制自QUIC [RFC-9000](https://www.rfc-editor.org/rfc/rfc9000.html)。
对每个部分进行查看和编辑。

地址验证确保实体不能被用于流量放大攻击。在此攻击中，一个包被发送到服务器，其中伪造的源地址标识受害者。如果服务器在回应包时生成更多或更大的包，攻击者可以使用服务器向受害者发送比其自身能发送的数据量更大的包。

针对放大攻击的主要防御措施是验证对等方能够在其声称的传输地址接收包。因此，在从尚未验证的地址接收包后，实体MUST限制发送到未经验证地址的数据量为从该地址接收到的数据量的三倍。这种响应大小的限制被称为反放大限制。

地址验证在连接建立期间（见第8.1节）和连接迁移期间（见第8.2节）进行。

连接建立期间的地址验证
````````````````````````````

连接建立过程内隐提供了对双方地址的验证。特别地，收到通过握手密钥保护的包确认了对等方已经成功处理了Initial包。一旦一个实体已经成功处理了对等方的任何握手包，它可以认为对等方地址已被验证。

此外，如果对等方使用密钥试应用连接ID，并且连接ID包含至少64位熵，实体可以考虑对等方地址已验证。

对于客户端，其在其首个Initial包中的Destination Connection ID允许其在处理任何包时验证服务器地址。服务端使用此值（见[QUIC-TLS]的第5.2节）保护初始包的信息。或者，通过Server预协商包（第6节）可能会从服务端收到作为Integrity Tag附加到的Retry包中的响应。

在验证客户端地址前，服务器MUST NOT请求多于3倍其接收的数据量的包。这样可以限制由冒名来源地址通过扒行放大攻击的规模。对于在验证地址之前的放大限制，服务器必须计算归属到单个连接的IP/Port（见第17.2.4节和[QUIC-TRANSPORT]的第17.3节）。这包括处理成功的包和被全部丢弃的包。

客户端MUST确保包含Initial包的UDP数据报载有至少1200字节的UDP有效载荷，必要时增加填充帧。发送填充后的数据报允许服务端在验证地址前发送更多数据。

丢失服务端的Initial或Handshake包可能导致死锁，尤其是客户端未发送Initial或Handshake包时。这种情况，当服务端达到其反放大限制且客户端收到其发送的所有数据的ACK时发生。在这种情况下，当客户端没有理由发送额外的包时，服务端因为没有验证地址而无法发送更多数据。为防止此死锁，客户端MUST在探测超时（PTO）(见[QUIC-RECOVERY]中的第6.2节)时发送一个包。具体来说，如果客户端没有握手密钥，它必须发送大小至少1200字节的Initial包字节，或者发送Handshake包。

服务端可能希望在握手的加密之前验证客户端地址。QUIC使用Initial包中的令牌来在握手完成前验证地址。此令牌在连接建立期间使用Retry包（见第8.1.2节）或在之前的连接中通过NEW_TOKEN帧传送（见第8.1.3节）。

除在地址验证前的发送限制外，服务器还受拥塞控制器设定的限制。客户端仅会受到拥塞控制器的限制。

令牌构造
`````````````````````````````

在NEW_TOKEN帧或Retry包中发送的令牌必须构造使服务端能够识别是如何提供给客户端的。这些令牌保存在同一个字段中但需要服务器进行不同的处理。``````````````````

使用Retry包进行的地址验证
````````````````````````````

在接受到客户端的Initial包时，服务器可以发送Retry包（见第17.2.5节）要求进行地址验证，其中包含一个令牌。这个令牌必须由客户端在接收到Retry包后之后发送的所有Initial包中重复。

在处理包含一个Retry包提供的令牌的Initial包时，服务器不能发送其他Retry包，只能拒绝连接或允许其进行。

只要攻击者无法为自己的地址生成有效令牌（见第8.1.4节），且客户能够返还该令牌，它证明服务器收到了它。

服务器还可使用Retry包将连接设立的状态和处理成本推迟到以后的阶段。要求服务器提供不同的连接ID，和第18.2节中定义的original_destination_connection_id传输参数一起，迫使服务器展示自己是否（或与合作的实体）收到了客户端的原始Initial包。提供不同的连接ID也让服务端对后续包的路由有了一定的控制。这可以用于将连接引导到不同的服务器实例。

如果服务器接收到一个Initial包，其中的Retry令牌无效且其他均有效，可以放弃包让客户端超时来检测连接失败，但这可能会给客户端带来显著的延迟惩罚。取而代之，服务器应立即关闭连接，返回INVALID_TOKEN错误。注意，在这时服务器尚未为连接建立状态，并且没有进入closing阶段。

使用Retry包的开销如下图9显示：

```
客户端                                                    服务器

  初始包[0]: CRYPTO[CH] ->

                                                <- Retry+Token

  初始包+Token[1]: CRYPTO[CH] ->

                                     初始包[0]: CRYPTO[SH] ACK[1]
                               握手包[0]: CRYPTO[EE, CERT, CV, FIN]
                                     <- 1-RTT[0]: STREAM[1, "..."]

                图 9: 例子握手与重试
```



未来连接的地址验证
`````````````````````````````

在一次连接上，服务器可能向客户端提供后续连接可使用的地址验证令牌。在0-RTT情况下，地址验证尤为重要，因为客户在发送0-RTT数据时，服务器能回应发送大量的数据。

服务端在握手期间通过NEW_TOKEN帧传送地址验证令牌（见第19.7节），客户端在未来连接初始数据包中包含这个令牌来提供地址验证。客户端必须包括未来连接中所有发送Initial包的令牌，除非Retry替换为新的。客户端必须不在未来连接尝试中使用Retry提供的令牌。服务器可以丢弃缺少所需令牌的任何包。

类似于发送Retry包立即被使用的令牌，NEW_TOKEN帧提供的令牌在某段时间后方可使用。因此，令牌应设有到期时间，可以是显式到期时间或一个发行时间戳，用于动态计算到期时间。服务器可以存储到期时间，或将其以加密形式嵌入到令牌中。

通过NEW_TOKEN帧发送的令牌不应包含可能将值与发放连接关联起来的信息。例如，它不能包含之前的连接ID或地址信息，除非这些值被加密。服务端确定发出的每个NEW_TOKEN帧都是唯一的，除非用于修复之前发送的NEW_TOKEN丢失时。标识 Retry和NEW_TOKEN的区别的信息可以对服务端之外的实体可见。

客户端可能会在两个不同连接中使用先前连接中提供的令牌。因为在不同连接上，客户端端口号大致可能不同，因此验证端口成功更可能。

从一个连接中接收到的令牌适用于客户端认证的服务器（如证书中包括的服务器名）。连接到发布令牌的服务器时，客户端应在其初始包中的令牌字段中包括该令牌。这样可能允许服务器验证客户端地址无需额外往返。在不知道发布令牌和发起连接的服务器是否共同管理令牌的情况下，客户端不得在连接到另一服务器时使用该令牌。客户端可能在任何以前连接到该服务器的尝试中使用任何令牌。

令牌允许服务器在发放令牌的连接和使用令牌的任何连接之间关联活动。希望与服务器断开身份关联的客户端丢弃通过NEW_TOKEN帧提供的令牌。相比之下，在Retry包中获得的令牌必须在尝试连接中立即使用，不能用于后续的连接尝试。

对于不同连接尝试，客户端不应重复使用NEW_TOKEN帧中的令牌。因为不同连接路径的实体可能会通过重复使用令牌关联这些连接，见第9.5节。

客户端可能会在单个连接上接收多个令牌。除了去关联，任何令牌可以在任何连接尝试中使用。服务器可以发送额外的令牌使用以启用多个连接尝试或替换可能无效的旧令牌。由于这些不确定性，最可能有效地是发送最近的未使用令牌。尽管保存和使用旧令牌没有负面影响，但客户端可考虑旧令牌在服务器进行的地址验证的可能性较小。

注意，无法验证毒务地址时，客户端被看作未经验证的原因：在这个情况下，客户端可能在以前的连接中通过NEW_TOKEN帧接收到令牌，且服务端失去状态后可能无法验证令牌，这将导致连接失败，如果包被丢弃的话。

在无状态设计中，在客户端收到后，服务器可通过加密和认证的令牌将信息传递回服务器，用于以后验证客户端地址。由于令牌没有集成到加密握手，因而未认证。客户端可能能重用令牌。为了避免利用该属性进行攻击，服务器可以限制其应用使用这么少的信息，只限于验证客户端地址的信息。

同一个版本的平台可以使用在一个连接中获取的令牌到同版本的任何连接尝试。在选择要使用的令牌时，客户端不需要考虑连接尝试的其他特性，包括可能的应用协议、会话票据或其他连接属性。

地址验证令牌完整性
```````````````````
地址验证令牌必须难以猜测。令牌中包括的随机值至少需要128位熵足够。但这取决于服务器记住发送给客户端的值。

基于令牌的方案允许服务器来卸载与验证相关的任何状态到客户端。为使该设计正常工作，令牌必须由完整性保护，以防止客户端修改或伪造。没有完整性保护，恶意客户端可以生成或猜测服务器接受的令牌值。只有服务器需要访问令牌的完整性保护密钥。

不需要有单一格式标准的令牌，因为生成和消费令牌的是同一个服务端。传送在Retry包中的令牌应包括允许服务器验证客户端分组的源地址和端口在客户包中未更改的信息。

传送在NEW_TOKEN帧中的令牌必须包括允许服务器在发放时验证客户端IP地址未更改的信息。即便IP地址更改，服务端在发送前不能超过反放大限制，请参阅第8节。注意，在NAT存在的情况下，这一限制可能不足以保护分享该NAT的其他主机免于放大攻击。

攻击者可能重放令牌来利用服务器进行分布式拒绝服务攻击。为了保护此类攻击，服务端必须确保令牌的重放限制。服务端应确保在短时间内发放的Retry包仅被接受，因为对客户端立即发送返回NEW_TOKEN帧给予的令牌需有效更长时间并且不能被多次使用。随着时间推移，服务器建议让允许每个令牌最多使用一次；令牌可能包括其他信息，以便更精确化应用或重用。

路径验证
`````````````````
在连接迁移过程中用来验证更换IP地址后的可达性。路径验证中，端点测试发送到对等机路径上的包的接收能力。

路径验证测试发送到某特定本地地址和对等方特定地址间路径验证，其中地址是IP地址和端口的2元组。

路径验证仅验证一个对等方的包能否在一个特定的路径上送到目标。路径验证无法确认对等方能够从返回方向发起发包。由于ACK 缺少熵的有关信息，可被伪造，并不能用于验证返回路径。每一个路径的对等方独立地确定可达性，因此只有通过对端的确认，返回可达性才能确立。

路径验证可由任意时间各端点使用。例如，端点可用来检查一段时间的静止后对端仍然持有其地址。

路径验证设计不是作为NAT穿透机制。但此机制可能有效于生成支持NAT穿透的NAT绑定，期望一方在该路径下发送包之前能收到包。有效的NAT穿透需要额外同步机制不为文中提供。

任何时候，端点可选择探测多条路径。由对等方提供的额外连接ID数限制设备的同时探测路径数，因为每个用来探测的新本地地址需一个未使用的连接ID。

成功的路径验证
`````````````
路径验证成功时，包含发送的PATH_CHALLENGE帧的数据的PATH_RESPONSE帧被接收。如其所发送的PATH_CHALLENGE，在其上接收到PATH_RESPONSE帧将验证该路径。

...

## 设计概述

### 总结

设计参考几个现存的协议，包括I2P以及外部标准，意在从基础、指导以及代码复用获益：

* 威胁模型：来自NTCP2 [NTCP2](/en/proposals/111-ntcp-2/)，以及对UDP传输模式相关重要威胁的详细分析通过QUIC [RFC-9000](https://www.rfc-editor.org/rfc/rfc9000.html) [RFC-9001](https://www.rfc-editor.org/rfc/rfc9001.html)。

* 密码选择：参考自 [NTCP2](/en/proposals/111-ntcp-2/)。

* 握手：参考自 [NTCP2](/en/proposals/111-ntcp-2/) 和 [NOISE](https://noiseprotocol.org/noise.html) 的Noise XK。NTCP2在此基础上做了显著简化，这得益于UDP提供的封装（固有的消息边界）。

* 握手瞬态密钥模糊化：自 [NTCP2](/en/proposals/111-ntcp-2/) 改编，但使用 [ECIES](/en/docs/spec/ecies/) 中的ChaCha20代替AES。

* 数据包头：改编自WireGuard [WireGuard](https://www.wireguard.com/) 和 QUIC [RFC-9000](https://www.rfc-editor.org/rfc/rfc9000.html) [RFC-9001](https://www.rfc-editor.org/rfc/rfc9001.html)。

* 数据包头混淆：改编自 [NTCP2](/en/proposals/111-ntcp-2/)，但使用 [ECIES](/en/docs/spec/ecies/) 中的ChaCha20替换AES。

* 数据包头保护：改编自QUIC [RFC-9001](https://www.rfc-editor.org/rfc/rfc9001.html) 和 [Nonces](/en/docs/spec/ecies/)。

* Headers用作AEAD的关联数据，见 [ECIES](/en/docs/spec/ecies/)。

* 数据包编号：改编自WireGuard [WireGuard](https://www.wireguard.com/) 和 QUIC [RFC-9000](https://www.rfc-editor.org/rfc/rfc9000.html) [RFC-9001](https://www.rfc-editor.org/rfc/rfc9001.html)。

* 消息：改编自 [SSU](/en/docs/transport/ssu/)。

* I2NP分片：改编自 [SSU](/en/docs/transport/ssu/)。

* 中继和对等测试：改编自 [SSU](/en/docs/transport/ssu/)。

* 中继和对等测试数据的签名：来自 [Common](/en/docs/spec/common-structures/) 的常见结构规范。

* 块格式：来自 [NTCP2](/en/proposals/111-ntcp-2/) 和 [ECIES](/en/docs/spec/ecies/)。

* 填充和选项：来自 [NTCP2](/en/proposals/111-ntcp-2/) 和 [ECIES](/en/docs/spec/ecies/)。

* Acks, nacks：改编自QUIC [RFC-9000](https://www.rfc-editor.org/rfc/rfc9000.html)。

* 流量控制：TBD

没有新设计的密码原语在I2P中未曾使用过。

### 交付保证

与I2P其他传输NTCP、NTCP2和SSU 1一样，该协议不是用于传递有序字节流的一般性设施。设计用于I2NP消息的传输。未提供“流”抽象。

此外对于SSU，它包含为对等方促进的NAT穿越及连接的可达性检测（入站连接）的额外设施。

如同SSU 1，它不提供I2NP消息的顺序交付。
它也没有保证I2NP消息的交付。
为提高效率，或由于UDP数据报的无序损坏和丢失，这些数据报中I2NP消息可能无序到达或最终丢失。
I2NP消息可能被多次重传，如果没有最终发送成功也不意味着会导致整个连接中断。即使在重传（丢失恢复）发生时仍可以发送新的I2NP消息。

此协议不能完全防止I2NP消息的重复交付。路由器应强制执行I2NP过期和基于I2NP消息ID的Bloom过滤来避免。
详见下文中I2NP消息重复部分。

### Noise协议框架

本提案依据Noise协议框架[NOISE](https://noiseprotocol.org/noise.html)（第33修订版，2017-10-04），声明需求。
Noise匹配类似Station-To-Station [STS](https://en.wikipedia.org/wiki/Station-to-Station_protocol)，后者是 [SSU](/en/docs/transport/ssu/)协议的基础。在Noise例子中，Alice为发起方，Bob为响应方。

SSU2基于Noise_XK_25519_ChaChaPoly_SHA256。
（各个初始化密钥衍生函数的观察标识符“Noise_XKchaobfse+hs1+hs2+hs3_25519_ChaChaPoly_SHA256”
用于指示I2P扩展 - 见KDF1后的相关章节）

注意：因为所有三个握手消息使用header作为附加数据，此标识与
NTCP2使用的不同。

该Noise协议使用以下原语：

- 握手模式：XK
  Alice传送她的密钥给Bob (X)
  Alice已经知道Bob的静态密钥 (K)

- DH函数：X25519
  根据[RFC-7748](https://www.rfc-editor.org/rfc/rfc7748.html)，长度为32字节的X25519 DH。

- 加密函数：ChaChaPoly
  AEAD_CHACHA20_POLY1305根据 [RFC-7539](https://www.rfc-editor.org/rfc/rfc7539.html) 第2.8节。非长度12字节，前4字节置零。

- 哈希函数：SHA256
  标准32字节哈希，已经在I2P中广泛使用。

### 框架的补充

本提案定义了在Noise_XK_25519_ChaChaPoly_SHA256上的以下增强。这些普遍遵循[NOISE](https://noiseprotocol.org/noise.html)第13节中的指南。

1）握手消息（Session Request, Created, Confirmed）包含16或32字节头部。

2）握手消息（Session Request, Created, Confirmed）的头部事先被加密/解密以预防对消息的加/解密攻击。

3）头部是加密且受保护的。

4）明文瞬态密钥用已知密钥和IV的ChaCha20加密。比elligator2更快。

5）在message 1, 2和数据阶段定义payload格式。
当然，这在Noise中尚未定义。

数据阶段使用的加密类似但不兼容于Noise数据阶段。

### 处理开销估算

TBD

## 定义

我们定义下列将被使用的加密构造的对应的函数。

ZEROLEN
    零长度字节数组

H(p, d)
    SHA-256 哈希函数取个人化字符串 p 和数据 d，
    产生长度为32字节的输出。
    如[NOISE](https://noiseprotocol.org/noise.html)中定义。
    || 在下文中意味着附加。

    使用SHA-256如下：

        H(p, d) := SHA-256(p || d)

MixHash(d)
    SHA-256 哈希函数，取之前的哈希 h 和新数据 d，
    产生长度为32字节的输出。
    || 在下文中意味着附加。

    使用SHA-256如下：

        MixHash(d) := h = SHA-256(h || d)

STREAM
    ChaCha20/Poly1305 AEAD组合，见[RFC-7539](https://www.rfc-editor.org/rfc/rfc7539.html)。
    S_KEY_LEN = 32 和 S_IV_LEN = 12。

    ENCRYPT(k, n, plaintext, ad)
        使用密钥k和必须对于每个密钥k唯一的nonce n加密明文。
        附加数据ad可选。
        返回密钥大小相同的ciphertext加上16字节的HMAC。

        若密钥是机密的，整个ciphertext必须与随机无异。

    DECRYPT(k, n, ciphertext, ad)
        使用密钥k和nonce n解密ciphertext。
        附加数据ad可选。
        返回明文。

DH
    X25519 公钥密钥协议系统。32字节的私钥和32字节的公钥，产生32字节的输出。它具有下列几种功能：

    GENERATE_PRIVATE()
        生成新私钥。

    DERIVE_PUBLIC(privkey)
        返回与给定私钥对应的公钥。

    DH(privkey, pubkey)
        从给定的私钥和公钥生成一个共享密钥。

HKDF(salt, ikm, info, n)
    一个密码学密钥派生函数，取某些输入密钥材料ikm（应包含很好熵但不要求均匀随机序列），一个32字节长的salt和一个上下文相关的‘info’值，产生一个n字节的输出为密钥材料所用。

    符合 [RFC-5869](https://www.rfc-editor.org/rfc/rfc5869.html), 使用HMAC哈希函数SHA-256如同 [RFC-2104](https://www.rfc-editor.org/rfc/rfc2104.html)。SALT_LEN最长为32字节。

MixKey(d)
    使用HKDF()和先前的chainKey和新数据d，然后
    设置新chainKey和k。
    如同[NOISE](https://noiseprotocol.org/noise.html)中定义。

    使用HKDF如下：

        MixKey(d) := output = HKDF(chainKey, d, "", 64)
                     chainKey = output[0:31]
                     k = output[32:63]

## 消息

每个UDP数据报包含一个消息。
数据报的长度（在IP和UDP 头后）即消息长度。
若有填充，包含于消息内部。
在该文档中，我们使用“数据报”和“包”大致交替。
每个数据报（或包）都包含单独的消息（不像QUIC，QUIC数据报可以包含多个）。
“包头”即IP/UDP头部分。

例外：
Session Confirmed 消息的例外是可以在多个包中分片。
详见下文中Session Confirmed Fragmentation章节。

所有SSU2消息长度至少40字节。
若长度为1-39字节则为无效消息。
所有SSU2消息小于或等于1472（IPv4）或1452（IPv6）字节长。消息格式基于Noise消息，扩展了帧定义和不可辨识属性。
实现普通Noise库的必要先处理好接收消息到标准Noise格式。所有加密字段是AEAD密文。


以下消息已定义：

| 类型 | 消息 | 头部长度 | 受保护头部长度 |
|----|----|------|---------|
| 0 | SessionRequest | 32 | 64 |
| 1 | SessionCreated | 32 | 64 |
| 2 | SessionConfirmed | 16 | 16 |
| 6 | Data | 16 | 16 |
| 7 | PeerTest | 32 | 32 |
| 9 | Retry | 32 | 32 |
| 10 | Token Request | 32 | 32 |
| 11 | HolePunch | 32 | 32 |

### Session Establishment

当Alice已从Bob处获取有效Token时，标准握手序列如下所示：

.. raw:: HTML

  {% highlight %}
Alice                           Bob

  SessionRequest ------------------->
  <------------------- SessionCreated
  SessionConfirmed ----------------->
{% endhighlight %}


当Alice没有有效Token时，握手序列如下：

.. raw:: HTML

  {% highlight %}
Alice                           Bob

  TokenRequest --------------------->
  <---------------------------  Retry
  SessionRequest ------------------->
  <------------------- SessionCreated
  SessionConfirmed ----------------->
{% endhighlight %}


当Alice认为她有有效Token，
但Bob拒绝时（可能因为Bob重启了），
握手序列如下：

.. raw:: HTML

  {% highlight %}
Alice                           Bob

  SessionRequest ------------------->
  <---------------------------  Retry
  SessionRequest ------------------->
  <------------------- SessionCreated
  SessionConfirmed ----------------->
{% endhighlight %}


Bob 可以通过包含原因代码的Termination块的 Retry 消息拒绝 Session 或者 Token Request。
基于原因码，Alice 应该在一些时间段内不要尝试其他请求。

.. raw:: HTML

  {% highlight %}
Alice                           Bob

  SessionRequest ------------------->
  <---------------------------  Retry containing a Termination block

  or

  TokenRequest --------------------->
  <---------------------------  Retry containing a Termination block
{% endhighlight %}


使用Noise术语，建立和数据序列如下：
（Payload 安全性属性）

```
XK(s, rs):           认证    机密性
    <- s
    ...
    -> e, es                  0                2
    <- e, ee                  2                1
    -> s, se                  2                5
    <-                        2                5
```

一旦会话建立，Alice和Bob可以交换数据消息。

### Packet Header

所有包以一个被混淆（加密）的头部开始。有两种头格式，长头和短头。注意前13字节（Destination Connection ID、packet number和type）对所有头格式相同。

长头
`````````````
长头为32字节。用于session建立前，适于Token Request、SessionRequest、SessionCreated和Retry。也用于未在session中的Peer Test和Hole Punch消息。

headar加密之前：

```

+----+----+----+----+----+----+----+----+
  |     目标连接ID           |
  +----+----+----+----+----+----+----+----+
  |   数据包编号   |类型| 版本| id |标志位|
  +----+----+----+----+----+----+----+----+
  |       源连接ID           |
  +----+----+----+----+----+----+----+----+
  |        令牌              |
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: 8字节无符号大端整数

  Packet Number :: 4字节无符号大端整数

  type :: 消息类型 = 0, 1, 7, 9, 10, or 11

  ver :: 协议版本，等于2

  id :: 1字节，网络ID（当前为2，测试网络除外）

  flag :: 1字节，未使用，设为0以便将来兼容

  Source Connection ID :: 8字节无符号大端整数

  Token :: 8字节无符号大端整数

```

短头
`````````````
短头为16字节。在Session Created和数据消息中使用。
Session Request，Retry和Peer Test等未经认证的消息将一直使用长头。

需要16字节，因为接收者必须解密前16字节获取消息类型，然后如有必要解密额外16字节。

在Session Confirmed中，header加密之前：

```

+----+----+----+----+----+----+----+----+
  |     目标连接ID             |
  +----+----+----+----+----+----+----+----+
  |   数据包编号   |类型|分段|  flag  |
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: 8字节无符号大端整数

  Packet Number :: 4字节内全为0

  type :: 消息类型 = 2

  frag :: 1字节分段信息:
         bit顺序: 76543210 (bit 7为MSB)
         bits 7-4: 分段号码0-14，大端
         bits 3-0: 总分段数1-15，大端

  flags :: 2字节，未使用，设为0以便将来兼容

```

关于frag域的更多信息请参见Session Confirmed Fragmentation部分。


在数据消息中，headar加密之前：

```

+----+----+----+----+----+----+----+----+
  |     目标连接ID             |
  +----+----+----+----+----+----+----+----+
  |   数据包编号   |type|flag|moreflags|
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: 8字节无符号大端整数

  Packet Number :: 4字节无符号大端整数

  type :: 消息类型 = 6

  flag :: 1字节标志:
         bit顺序: 76543210 (bit 7为MSB)
         bits 7-1: 未使用，设为0以便将来兼容
         bits 0: 设为1时，表示立即ack已请求

  moreflags :: 2字节，未使用，设为0以便将来兼容

```


Connection ID Numbering
```````````````````````````

Connection IDs 必须随机生成。
源和目标ID必须不相同，
这样在路上监听的攻击者不能捕获和发送一个看起来有效的包回到原发方。
请勿使用计数器来生成connection IDs，这样在路上监听的攻击者不能生成有效的包。

不同于QUIC，我们在握手期间或之后没有更改connection IDs，
即便在重试消息之后也是如此。这些ID自消息起始（Token Request或Session Request）到最后消息（Data with Termination）一直保持不变。
此外，connection IDs在路径挑战或连接迁移期间不改变。

也区别于QUIC，header中的connection IDs总是受header加密保护的。详见下文。


Packet Numbering
`````````````````
如果没有First Packet Number 块在握手中发送，packet number 在单个Session内，为每个方向，始于0，最大为(2**32 -1).
Session必须在发送max number of packets前终止，并建立新的Session。

如果First Packet Number 块在握手中发送，packet number 在单个Session内，为该方向，始于该packet number。packet number可在Session期间回环。
当发送的包数量达到了2**32个时，起始packet number作为包处理环回，标志着该会话失效。
会话必须正是在发送最大数量的数据包之前结束。

TODO key rotation，减少max packet number？

通过标识丢失的数据包必须链温馨重传握手阶段的包。
握手消息 Session Request, Session Created, 和 Session Confirmed必须重发相同packet number和加密后的内容，
以便于加密响应使用相同的链式哈希。
除Retry消息外，握手消息必须以相同的packet number重发。

数据阶段的包内容如果被确认为丢失则从不整体重发（除非termination，见下文）。
新的数据包不包含被标识为过期内容。
重发的数据包总是用缓存内的最新的包信息，且可能与丢失的数据包内容不同。
一旦确认数据包内容命中，发放停止。存储新包内容可能没有实现价值。

例外：包含Termination块的数据阶段包可能，但不要求，整体重传，见下文Session Termination部分。

以下包 contains a random packet number that is ignored:

- Session Request
- Session Created
- Token Request
- Retry
- Peer Test
- Hole Punch

对于Alice，outbound packet numbering自0起，始于Session Confirmed。
对于Bob，outbound packet numbering自0起，始于首个包含ACK的Data包。
其他包标记将不会促使打包传递与零数据包重传情况这类比较，其不易于进行传输。
以此可能缩短重新传输顺序，并有助于加密等候反馈逻辑的过程。

即使在传输握手消息流中，元数据和传输消息数仍将保持透明。
根据包头声明，数据阶段的不同传输数据包编号将需要新的策略。

header加密header就是加密数据和不同传输消息头的所有伪数据。
这种方法提供了在线DPI保护，故它们不将其与消息数受smål口头保护的密钥绑定到数据包保护数据。
在线DPI保护的策略发布后的拼接的密钥会给提出保护进行反映。
释放和拦截会在此场景下声明。
这些都反映在风险标识和风险设定的自定义使用案例中。
这些都反映在最佳传输标识中。

变化header要求防重复和不当输出，XAttr提供的修复和调试都是影响包的包。
标识为了避免进行保护，包标准化数据中所有明标准KDF生成结果更为它所针对的输出，而非包号。

数据头绑定
`````````````
徐最后用同样的k_header_2密钥加密数据传输的HEAD后，
数据头的解密输出为解密DPI敌恶总部通过携带，密码不是梭托运输长大混淆，通过任何一位防止商杂将数据指向源发送或记录源为数据系。

对于多维动态引用不作为解密确认并绑定过程数据头，在校验值时应当立即最后智在数据段的数据头中。
头功能当更大数量时的段数据流mış头时了解包头。
此过程中，其中请返回请求的结果时应由建议如同上述，反复出现在各个场景中。

对于头加密
`````````````````

```

  // 收到的加密包
  packet = incoming encrypted packet
  len = packet.length

  // 取 next-to-last 12 字节的包
  iv = packet[len-24:len-13]
  k_header_1 = header encryption key 1
  data = {0, 0, 0, 0, 0, 0, 0, 0}
  mask = ChaCha20.encrypt(k_header_1, iv, data)

  // Xor with the mask encrypt first part of the header with
  packet[0:7]^= mask[0:7]

  // 取 包最后12字节
  iv = packet[len-12:len-1]
  k_header_2 = header encryption key 2
  data = {0, 0, 0, 0, 0, 0, 0, 0}
  mask = ChaCha20.encrypt(k_header_2, iv, data)

  // 将数据包第二部分用Xor进行合并加密
  packet[8:15]^= mask[0:7]


  // 仅在 Session Request 和 Session Created中
  iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

  // 加密头的第三部分和ephemeral key钥
  packet[16:63] = ChaCha20.encrypt(k_header_2, iv, packet[16:63])


  // 仅对于重试、令牌请求、对等测试和hole punch
  iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

  // 加密头的第三部分
  packet[16:31] = ChaCha20.encrypt(k_header_2, iv, packet[16:31])


```

此KDF使用包中的最后24个字节为IV进行两次不同格式的ChaCha20操作。由于所有包都会结尾16字节的MAC，因此这个要求包领取有效载荷需要最小值为8字节。这个以料必须存储在不同格式的struct中用于关注它在动态的结果不同的分片中逐步演变，尤其是在Bytes变量的结果动态。

头验证
``````````````
解密头的前8字节后，接收方即知为了恢复Destination Connection ID允许，然后了解所有产生出的不同头密钥阶段方案，以便以固定数量加密头。
此转换的最后32字节数offer掌握后内除RJ hash变换外额buff头为AD来以different forge/fail to bound to 3 确保包dr不同数据附近的尽量已被发现。
类型策略利用Mảng特性用于为AD的分配格在function aidful状态下可行部分或利用。

### 包完整性

所有消息包含或三或四部分：

- 消息头
- 仅对Session Request和Session Created，ephemeral key
- ChaCha20加密后的数据
- Poly1305 MAC

所以即当header (且某些ephemeral key在其当中是绑到消息)以下条敏链文本在before to ensure.

- 用握手消息 Session Request, Session Created, 和 Session Confirmed 部分绑定header在加密/解密phase
- 如陪任何实现的ephemeral key应该符合正常Noise架在解锁。
- 对任何不在Noise握手中所有未受保护的手field内部中，头内容即作为AD使用ChaCha20/Poly1305加密，进行加密和输入内容使用相同。

在inbound package处理程中，您必须总是解密所有数据框并验证传递的MAC，模板：为了泄露DoS因伪装的冒名而进行对Session Request进行处理。庚的应不必试图解密并验证完整信息（尽管对DH操作posing某同，）。发送Reply者抢先Retry消息使用Session Request中的某Head𿋣；包抱将此扩展到一种不因竞争清除状态.Reoccupc稳乂在随机输出实体头输入。推荐GIF使用扩展于其他关键特性高度操作IV或大fashion lock在选项镜中可能映万万象‘Robot’可能由对操作临测系统补充给Bean。

### 认证加密

其中三种不同的认证加密（CipherStates）包含了两者握手阶段，每一有专门的Key来自牛KDF。

用于Encryption/Decryption functions的定义：

```

k :: 32字节密码密钥，来源于KDF中生成

  nonce :: 基于计数的nonce，12字节。
           开始于0并递增用于每个消息。
           首四字节总为零。
           最后八字节为反向天数，小端字节编码。
           最大值为2**64 - 2。
           连接电源。含初值长包失败不需控。
           价值应不能超过2**64 - 1，但一乎。

  ad :: 在握手阶段：
        关联数据，32字节。
        所有preceding data的SHA256哈希。
        在数据阶段：
        该包头，16字节配线前期。

  data :: 定义的长短互补端数据，0或更多

```

加密后的数据使用，解密函数的输入：

```

+----+----+----+----+----+----+----+----+
  |                                         |
  +                                         +
  |       ChaCha20加密数据               |
  ~               .   .   .                 ~
  |                                         |
  +----+----+----+----+----+----+----+----+
  |   Poly1305 消息验证码                   |
  +              (MAC)                      +
  |             16字节                        |
  +----+----+----+----+----+----+----+----+

  encrypted data :: 与明文相同大小，0 - 65519字节

  MAC :: Poly1305消息认证码，16字节

```


对于ChaCha20，所描述内容同 [RFC-7539](https://www.rfc-editor.org/rfc/rfc7539.html)规定，并在TLS中相同 [RFC-7905](https://www.rfc-editor.org/rfc/rfc7905.html)。

注释
`````
- 由于ChaCha20是流密码，明文无需填充。
  剩余的keystream字节被抛弃。

- 密钥即（256位）密码协为SHA256 KDF授权。
  相关消息的KDF细节在特定消息章节内。

AEAD错误处理
```````````````
- 所有消息中的AEAD消息大小提前知道。
  若AEAD认证失败，接收者需停止消息处理并
  丢弃消息。

- Bob应维护所有包含反复失败的ip黑名单。

### 用于Session Request的KDF

KDF生成握手阶段round phase中cipher key k来源于DH结果校 HMAC-SHA256(key, data)定义在 [RFC-2104](https://www.rfc-editor.org/rfc/rfc2104.html)。
这些来自InitializeSymmetric()，MixHash()和MixKey()函数一如Noise版本全定义。

KDF for Initial ChainKey
``````````````````````

```

- 定义protocol_name。
    Set protocol_name = "Noise_XKchaobfse+hs1+hs2+hs3_25519_ChaChaPoly_SHA256"
     (52字节，US-ASCII编码，未终止NULL)。

    定义Hash h = 32 字节
    h = SHA256(protocol_name);

    将ChainKey定义为32字节串链性生成。拷贝旧值h数据。
    Set ck = h

    // MixHash(null prologue)
    h = SHA256(h);

    //到此Alice可以同接收者面向非互相(Direction)端为满足相对平稳性处理建议发出连接

    // Bob的X25519 static keys
    // bpk通过伊通过罗纳却发布
    bsk = GENERATE_PRIVATE()
    bpk = DERIVE_PUBLIC(bsk)

    // Bob static key
    // MixHash(bpk)
    // || 下文表示连接
    h = SHA256(h || bpk);

    // Bob introduction key
    // bik通过伊通过罗纳却发布
    bik = RANDOM(32)

    //在Alice在Bob发出提前处理计算部阿在起初发(Few)lidations
```


Session Request 的 KDF
```````````````````````

```

  // MixHash(header)
    h = SHA256(h || header)

  这就是“e”消息模式：

  // Alice的X25519临时密钥
  aesk = GENERATE_PRIVATE()
  aepk = DERIVE_PUBLIC(aesk)

  // Alice临时密钥X
  // MixHash(aepk)
  h = SHA256(h || aepk);

  // h 被用作
  AEAD in Session Request中 的关联数据
  // 为Session Established 来保存Hash h


  End of “e” 消息模式。

  这里是“es”消息模式：

  // DH(e, rs) == DH(s, re)
  sharedSecret = DH(aesk, bpk) = DH(bsk, aepk)

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  // ChaChaPoly参数to加密/解密
  keydata = HKDF(chainKey, sharedSecret, "", 64)
  chainKey = keydata[0:31]

  // AEAD 参数
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, payload, ad)

  // 保持chainKey 为Session Created KDF

  End of “es” 消息模式。

  // 该消息的头部加密密钥
  // bik = Bob's intro key
  k_header_1 = bik
  k_header_2 = bik

  // 下一条消息(Session Created)的头部加密密钥
  k_header_1 = bik
  k_header_2 = HKDF(chainKey, ZEROLEN, "SessCreateHeader", 32)

  // 下一条消息(Retry)的头部加密密钥
  k_header_1 = bik
  k_header_2 = bik

```

### SessionRequest (类型0)

Alice发送到Bob，或作为握手中的第一条消息，
或响应一条Retry消息。
Bob用Session Created消息回应。
大小为: 80 + payload size。
Minimum Size：88

如果Alice没有一个有效令牌，Alice应发送Token Request消息
而不是Session Request，来避免在产生Session Request时进行非对称加密开销。

长head。
Noise内容: Alice的临时密钥X
Noise payload: DateTime和其他块
max payload size：MTU - 108 (IPv4) 或 MTU - 128 (IPv6)。
对于1280 MTU: max payload 是1172 (IPv4) 或 1152 (IPv6)。
对于1500 MTU: max payload 是1392 (IPv4) 或 1372 (IPv6)。

Payload安全属性：

```
XK(s, rs):           认证    机密性
    -> e, es                  0                2

    认证：无（0）。
    该payload可能由任何一方发送，包括主动攻击者。

    机密性：2。
    加密至已知收信方，对于发信者妥协前向保密仍有效。
    此载荷仅参与收信方的静态密钥对中的DH。
    如果收信方的静态私钥被攻破，甚至稍后，该payload就可以解密此消息。 
    此消息可能也被重放，因为收信方没有新的瞬态参与。

    “e”: Alice产生的一个新empheral key pair并将其存储在e变量中，将其öffentlichkey 作为明文写入消息缓冲区，并与旧h一起哈希，得到一个新的哈希值 h。

    “es”: Alice的临时密钥对和Bob的静态密钥对之间进行了DH。结果与旧的ck一起哈希以派生出新的ck和k，并将n设置为零。

```

X值被加密以确保payload不能辨识以及其他DPI对其无效。
使用ChaCha20加密以实现此目的，
而非更复杂和较慢的选项例如elligator2。
非对称加密至Bob的router公钥将过于缓慢。
ChaCha20加密使用Bob在网络数据库上发布的intro key。

ChaCha20加密是为了DPI抵制而用。
任何知道Bob引入密钥的实体，且该密钥已发布在网络数据库中
可以解密该消息中的header和X值。

原始内容：

```
+----+----+----+----+----+----+----+----+
  |  长hd 字节0-15个字节，ChaCha20加密      |
  +  使用Bob intro key                     +
  |    看见Header Encryption KDF          |
  +----+----+----+----+----+----+----+----+
  |  长head字节16-31个字节，使用ChaCha20   |
  +  用 Bob intro key n=0         +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       X, 加密用               +
  |       with Bob intro key n=0          |
  +              (32 bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaCha20加密真钱发送             |
  +          (长度不同)                  +
  |  在 Session Request 的 KDF 中定义的 k|
  +  n = 0
  |  see KDF for associated data          |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+

  X :: 32字节, X25519临时密钥以ChaCha20加密, 小端，
          key: Bob's intro key
          n: 1
          data: 48字节（header的字节16-31，以及加密的X）

```

未加密数据（不显示Poly1305 auth tag）：

```
+----+----+----+----+----+----+----+----+
  |     目标连接ID           |
  +----+----+----+----+----+----+----+----+
  |   数据包编号   |类型|版本| id |标志位|
  +----+----+----+----+----+----+----+----+
  |       源连接ID           |
  +----+----+----+----+----+----+----+----+
  |        令牌              |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                   X                   |
  +              (32 bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     Noise payload (块数据)          |
  +          (长度不同)                  +
  |     看见下方封装块                 |
  +----+----+----+----+----+----+----+----+


  Destination Connection ID :: 随机生成by Alice

  id :: 1字节，网络ID（当前为2，测试网络除外）

  ver :: 2

  type :: 0

  flag :: 1字节，not spacing，使为future机动内能性。

  Packet Number :: random 4字节数字为Alice生成，ignore

  Source Connection ID :: 通过Alice 随机生成的值
                          不得和Destination Connection ID相等

  Token :: 如果之前未从Bob处接收，为0

  X :: 32字节, X25519小端的临时公钥

```


Payload
```````

- DateTime block
- Options block (可选)
- Relay Tag 请求块 (可选)
- Padding block (可选)

最小payload大小为8字节。由于DateTime块
仅7字节，所以需要至少1个其他块。

注意
`````
- 为了探测抗性，Bob应不以Reply消息
  回应Session Request消息，除非
  该Session Request消息中的a格型号、协议阶段、网络ID字段正常。

- 通过Bob需要中止有太过偏田时间戳的
  时间戳时间值定义为“D”。Bob应维持
  一项本地历史环将已使用的握手标值，并拒绝后来就变为标值，以预防此后更大的重。存储值适应，如果一些实现了使用的
   存储表以下链值（或其变量）可能stration。
      通过终止或sergeor完全寄目值即预计对话中最好由sessioncookie恢复除非为专节chacking较理想。

- Diffie-Hellman 网的临时密钥剧情在场演示小侯都得到了
Evidence指定

- Orion策略策略足以进行AR模拟策略应以定义
  Valạn继策略使Bob能够处理exorbitant超过的项目
  进行计算条件和协议请求请求验哈O几种条junk方向：将以
  求出趋势将以DD排量，确保以量平行以算行为的 daráahke
  费用计算代偿记录。
  Buffer参数加相应ql23faction，应些
  不阻有相应的力产政策应怎为。
  奖最终方案，PT链动的尴尬应为された或审核、铲总资金重算
  写在试言及施高。

- 同属NPfixBack的信息定义CS上黑量的未来性
  同样应为了同给他的另外要求即使在数据以行为内虽乘法继续安全程度内容分析有相

- "ver" field: 表示库结合，对部spirit line的现法设定规范该数材
  Me remax发关到未来实现以下划定后的任何调整。

- 凡烈父都对规哒锁使用不以附款的结
  Bob如不通信监测器化除非跨界扩的，隔李理（
translate）创造于前她，受保包装、由包by从到隔连
  任何上篇标写在librson extens才要接口和种乎方法截行验证这样还基本。

- Bob是st罗的收包所揭示的信息是ayer逻辑，访问较为技术数据存储子

- Bob必须在Source连接ID等于
  Destination Connection ID的情况下掷弃消息。

### KDF用于Session Created和Session Confirmed part 1

```

- 取h存于Session Request KDF中
  // MixHash(ciphertext)
  h = SHA256(h || 从 Session Request 加密的 Noise payload)

  // MixHash(header)
  h = SHA256(h || header)

  This is “e” 消息模式：

  // Bob的X25519临时密钥
  besk = GENERATE_PRIVATE()
  bepk = DERIVE_PUBLIC(besk)

  // h 是来源与 KDF 为 Session Request
  // Bob临时密钥Y
  // MixHash(bepk)
  h = SHA256(h || bepk);

  // h 是用于AESD在Session Created中关联数据所用
  // 为Session Confirmed储存的Hash h

  End of “e” 消息模式。

  This is “ee” 消息模式：

  经验:: 包含两Block附上的
  header加密的内容标为应当。
  
  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  sharedSecret = DH(aesk, bepk) = DH(besk, aepk)
  keydata = HKDF(chainKey, sharedSecret, "", 64)
  chainKey = keydata[0:31]

  // AEAD 参数
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, payload, ad)

  // 为确认步骤链为 Session Confirmed 来保留链码块

  End of "ee" 消息模式。

  // 该消息的头部加密密钥
  // bik = Bob's intro key
  k_header_1 = bik
  k_header_2: 参见上方Session Request KDF

  // 数据阶段的头加密密钥
  k_header_1 = bik
  k_header_2 = HKDF(chainKey, ZEROLEN, "SessionConfirmed", 32)

```


### SessionCreated (类型1)

Bob向Alice发送，以回应Session Request消息。
Alice以Session Confirmed消息回应。
大小为: 80 + payload size。
最小Size：88

Noise内容：Bob的临时密钥Y
Noise payload：DateTime，Address和其他块
最大payload大小：MTU - 108 (IPv4) 或 MTU - 128 (IPv6)。
对于1280 MTU: max payload 是1172 (IPv4) 或 1152 (IPv6)。
对于1500 MTU: max payload 是1392 (IPv4) 或 1372 (
