```markdown
---
title: "NTCP 2"
number: "111"
author: "EinMByte, orignal, psi, str4d, zzz"
created: "2014-02-13"
lastupdated: "2019-08-13"
status: "Closed"
thread: "http://zzz.i2p/topics/1577"
supercedes: "106"
target: "0.9.36"
implementedin: "0.9.36"
editor: "manas, str4d, zzz"
---

## Note
La phase de proposition est close.
Voir [SPEC](/en/docs/spec/ntcp2/) pour la spécification officielle.
Cette proposition peut encore être référencée pour des informations préliminaires.


## Vue d'ensemble

Cette proposition décrit un protocole de partage de clés authentifié pour améliorer la
résistance de [NTCP](/en/docs/transport/ntcp/) à diverses formes d'identification automatique et d'attaques.

La proposition est organisée comme suit : les objectifs de sécurité sont présentés,
suivis d'une discussion sur le protocole de base. Ensuite, une spécification complète
de tous les messages du protocole est donnée. Enfin, les adresses du routeur et
l'identification de version sont discutés. Une annexe discutant d'une attaque générique sur les
schémas de remplissage courants est également incluse, ainsi qu'une annexe contenant un certain nombre de
candidats pour le chiffrement authentifié.

Comme pour les autres transports I2P, NTCP2 est défini uniquement
pour le transport point à point (routeur à routeur) des messages I2NP.
Ce n'est pas un tuyau de données à usage général.


## Motivation

Les données [NTCP](/en/docs/transport/ntcp/) sont chiffrées après le premier message (et le premier message
ressemble à des données aléatoires), prévenant ainsi l'identification du protocole via
l'"analyse des charges utiles". Il reste toujours vulnérable à l'identification de protocole par
"analyse de flux". Cela est dû au fait que les 4 premiers messages (c'est-à-dire la poignée de main)
ont une longueur fixe (288, 304, 448 et 48 octets).

En ajoutant des quantités aléatoires de données aléatoires à chacun des messages, nous pouvons rendre
cela beaucoup plus difficile.

Les auteurs reconnaissent que les pratiques de sécurité standard suggéreraient d'utiliser
un protocole existant tel que TLS, mais c'est [Prop104](/en/proposals/104/) qui a ses
propres problèmes. Là où cela est approprié, des paragraphes "travail futur"
ont été ajoutés pour indiquer les fonctionnalités manquantes ou les sujets de discussion.


## Objectifs de Conception

- Supporter NTCP 1 et 2 sur un seul port, autodétecter, et publier comme un seul
  "transport" (c’est-à-dire [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) dans le [NetDB](/en/docs/how/network-database/).

- Publier le support de la version 1 uniquement, 2 uniquement, ou 1+2 dans le NetDB dans un champ
  séparé, et par défaut à la version 1 uniquement (ne pas lier le support de version à une
  version de routeur particulière)

- Assurer que toutes les implémentations (Java/i2pd/Kovri/go) peuvent ajouter un support de
  version 2 (ou non) selon leur propre calendrier

- Ajouter du remplissage aléatoire à tous les messages NTCP incluant les messages de poignée de main et
  les messages de données (c'est-à-dire obfuscation de longueur pour que tous les messages ne soient pas un multiple de 16 octets)
  Fournir un mécanisme d'options pour que les deux côtés puissent demander un remplissage min et max
  et/ou une distribution de remplissage. Les spécificités de la distribution de remplissage dépendent
  de l'implémentation et peuvent ou non être spécifiées dans le protocole lui-même.

- Obscurcir le contenu des messages qui ne sont pas chiffrés (1 et 2),
  suffisamment pour que les boîtes DPI et les signatures AV ne puissent pas les classifier facilement.
  Assurez-vous également que les messages allant à un seul pair ou ensemble de pairs n'ont pas
  un modèle similaire de bits.

- Corriger la perte de bits dans DH due à la format Java [Ticket1112](https://trac.i2p2.i2p/ticket/1112), éventuellement (probablement?)
  en passant à X25519.

- Passer à une véritable fonction de dérivation de clé (KDF) plutôt que d'utiliser le
  résultat DH tel quel?

- Ajouter une "résistance à la sonde" (comme l'appelle Tor); cela inclut la résistance aux
  rejouements.

- Maintenir l'échange de clés authentifié bidirectionnel (2W-AKE). 1W-AKE n'est pas suffisant
  pour notre application.

- Continuer à utiliser les signatures de type variable, de longueur variable (de la
  clé de signature [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) publiée) comme une partie de l'authentification. Compter
  sur une clé publique statique publiée dans le RouterInfo comme une autre partie de
  l'authentification.

- Ajouter des options/version dans la poignée de main pour la future extensibilité.

- Ajouter une résistance à la segmentation TCP MitM malveillante si possible.

- Ne pas augmenter de façon significative le CPU requis pour l'établissement de connexion;
  si possible, réduisez-le de manière significative.

- Ajouter une authentification des messages (MAC), possiblement HMAC-SHA256 et Poly1305, et
  enlever la somme de contrôle Adler.

- Raccourcir et simplifier l'en-tête I2NP :
  Raccourcir l'expiration à 4 octets, comme dans SSU.
  Enlever une somme de contrôle SHA256 tronquée d'un octet.

- Si possible, réduire la poignée de main à 4 messages et deux allers-retours à une poignée de main
  à 3 messages et un aller-retour, comme dans [SSU](/en/docs/transport/ssu/). Cela nécessiterait de déplacer la
  signature de Bob dans le message 2 au message 4. Recherche de la raison de 4 messages dans
  les archives d'e-mails/états/réunions vieux de dix ans.

- Minimiser la surch...

(modération : réduction de la longueur pour conserver la qualité)


- ...tection dans les en-têtes de messages NTCP2 non-handshake, comme dans obfs4.
```

Vous pouvez continuer à traiter le reste paragraphe par paragraphe en traduisant uniquement le texte de l'instruction en anglais en français, tout en conservant le formatage, le code source, et les balises hypertextes (HTML, données, URL, etc.) inchangés.
