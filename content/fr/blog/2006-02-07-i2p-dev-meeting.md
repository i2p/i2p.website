---
title: "Réunion des développeurs I2P - 7 février 2006"
date: 2006-02-07
author: "jrandom"
description: "Compte rendu de la réunion de développement d'I2P du 07 février 2006."
categories: ["meeting"]
---

## Résumé rapide

<p class="attendees-inline"><strong>Présents:</strong> bar, cervantes, Complication, jrandom, KBlup, modulus, tethra, tmp</p>

## Journal de réunion

<div class="irc-log"> 15:36 &lt;jrandom&gt; 0) salut 15:36 &lt;jrandom&gt; 1) État du réseau 15:36 &lt;jrandom&gt; 2) Avancées du réseau _PRE 15:36 &lt;jrandom&gt; 3) I2Phex 0.1.1.37 15:36 &lt;jrandom&gt; 4) ??? 15:36 &lt;jrandom&gt; 0) salut 15:37  * jrandom fait signe de la main 15:37 &lt;jrandom&gt; notes d'état hebdomadaires publiées @ http://dev.i2p.net/pipermail/i2p/2006-February/001258.html 15:37 &lt;bar&gt; bonjour 15:38 &lt;jrandom&gt; pendant que vous fouillez ce matériau oh combien passionnant, passons directement à 1) État du réseau 15:38 &lt;jrandom&gt; il n’y a pas eu beaucoup de changements sur le réseau en production la semaine dernière, du point de vue i2p, donc je n’ai pas grand-chose à ajouter ici 15:39 &lt;jrandom&gt; quelqu’un a quelque chose à soulever concernant l’état actuel du réseau ? 15:39 &lt;KBlup&gt; J’ai vu d’horribles pics de clients en échec quand i2p tourne longtemps… je ne sais pas si ça rentre dans 1) 15:39 &lt;jrandom&gt; KBlup: ça correspond à une forte charge CPU ou à une consommation de bande passante ? 15:40 &lt;KBlup&gt; ça se traduit par msg-delay&gt; 10000ms :-/ 15:40 &lt;jrandom&gt; ah, c’est très probablement l’une des raisons pour lesquelles le réseau _PRE est développé :) 15:40 &lt;KBlup&gt; Je pense qu’il essaie alors d’établir de nouveaux tunnels et échoue constamment, ce qui aboutit parfois à 300+ jobs… 15:41 &lt;KBlup&gt; ma machine est assez puissante mais est surchargée avec ça… 15:41 &lt;jrandom&gt; oui, tout cela a été revu au passage pour la 0.6.1.10, tenez bon jusqu’à ce que ce soit prêt 15:43 &lt;jrandom&gt; ok, autre chose sur 1) ou on se dirige tranquillement vers 2) Avancées du réseau _PRE 15:43 &lt;+Complication&gt; 0.6.1.10 semble effectivement contenir des changements substantiels 15:45 &lt;jrandom&gt; oui, il y a du lourd là-dessous. À ce stade, le nouveau code de création est en place et semble fonctionner correctement, mais j’en profite maintenant pour déboguer davantage certains problèmes sous-jacents 15:46 &lt;+Complication&gt; Tu as mentionné qu’il fallait consacrer pas mal de temps CPU à l’avance 15:47 &lt;+Complication&gt; Ce coût serait-il désormais associé à la construction de n’importe quel type de tunnel ? 15:48 &lt;+Complication&gt; (autrement dit, avant la construction, pendant un court moment, il faudrait effectuer une série d’opérations crypto lourdes) 15:48 &lt;jrandom&gt; oui, toutes les demandes de construction de tunnel devront effectuer k opérations cryptographiques lourdes (où k = le nombre de sauts dans le tunnel en cours de construction) 15:49 &lt;+Complication&gt; Ce que je voulais demander… l’intervalle est-il simplement plus serré qu’avant, ou la quantité est-elle aussi plus grande ? 15:50 &lt;jrandom&gt; la quantité est à la fois plus grande, plus petite et plus serrée. Plus serrée, parce qu’elles sont toutes faites en amont. Plus grande, parce qu’on ne peut pas court-circuiter et éviter le chiffrement pour un saut si un saut antérieur le rejette, et plus petite parce que les sauts antérieurs échouent beaucoup moins 15:51 &lt;jrandom&gt; de plus, toutefois, contrairement aux versions précédentes, nous n’utilisons plus ElGamal/AES+SessionTag pour les requêtes de tunnel — nous utilisons un ElGamal (assez) direct 15:52 &lt;+Complication&gt; …et cela ne pourrait pas être pré-calculé, à moins de connaître l’ensemble final qui va réussir ? 15:52 &lt;jrandom&gt; cela signifie que, même si nous pouvions auparavant tricher sans opération asymétrique, nous n’essayons plus de tricher (car la tricherie elle-même exposait une classe d’attaques) 15:53 &lt;+Complication&gt; (ensemble de pairs) 15:53 &lt;jrandom&gt; hmm, cela pourrait certainement être pré-calculé, en supposant que tu connaisses les pairs du tunnel qui vont être sollicités 15:54 &lt;jrandom&gt; le nouveau processus de création de tunnel est effectué dans un thread séparé, afin de ne pas engorger la file de jobs principale sous charge, et pour pouvoir mieux se réguler 15:54 &lt;+Complication&gt; Pourrait-on aussi supposer que, sauf changement dans les connaissances disponibles, on sait à l’avance quelques-uns de ceux qu’on va solliciter si les tentatives échouent ? 15:54 &lt;jrandom&gt; hmm, je ne suis pas sûr de suivre entièrement 15:55 &lt;+Complication&gt; Ou bien les connaître à l’avance est-il inutile, puisque la structure doit être refaite depuis zéro ? 15:56 &lt;+Complication&gt; (c’est-à-dire : les ElGamal refaits depuis zéro, au moins) 15:56 &lt;jrandom&gt; ah, la structure est http://dev.i2p.net/cgi-bin/cvsweb.cgi/i2p/router/doc/tunnel-alt-creation.html?rev=HEAD#tunnelCreate.requestRecord 15:56 &lt;jrandom&gt; donc oui, si le prochain saut change, l’ElGamal doit être refait 15:56 &lt;jrandom&gt; (si tu pré-calcules) 15:56 &lt;+Complication&gt; D’accord, je n’en étais pas assez sûr sur le coup 15:57 &lt;+Complication&gt; Maintenant je le réalise, toutefois 15:57 &lt;jrandom&gt; d’un autre côté, nous essayons vraiment d’augmenter notre taux de réussite de construction, et le nouveau processus de construction devrait pouvoir s’adapter pour minimiser les créations inutiles 15:58 &lt;+Complication&gt; Comment cela semble-t-il se comporter en pratique ? 15:58 &lt;jrandom&gt; (oh, cette structure a été légèrement modifiée sur la branche _PRE : http://dev.i2p.net/cgi-bin/cvsweb.cgi/~checkout~/i2p/router/doc/tunnel-alt-creation.html?rev=1.1.2.1;content-type=text%2Fhtml#tunnelCreate.requestRecord ) 15:59 &lt;+Complication&gt; J’ai remarqué le détail selon lequel les chiffrages ElGamal font un bond en rapidité… 15:59 &lt;jrandom&gt; eh bien, le taux de réussite de construction est bien, bien plus élevé que sur le réseau en production, mais cela peut simplement être dû à la petite taille du réseau _PRE 16:00 &lt;jrandom&gt; oui, créer une structure à 2 sauts, par exemple, prend en moyenne 44ms sur 1120 exécutions, contre 542ms pour le temps de chiffrement ElGamal sur le réseau en production (sur 1344 exécutions) 16:02 &lt;jrandom&gt; (sur la même machine) 16:02 &lt;+Complication&gt; Ces 542 incluent-ils aussi les réessais en cas d’échec, ou seulement la construction pure ? 16:02 &lt;+Complication&gt; Si c’est la construction pure, il faut que je retrouve ma mâchoire inférieure… elle est quelque part par terre. :P 16:02 &lt;KBlup&gt; à propos de ce changement d’exposant : à quelle échelle cela affecte-t-il l’anonymat ? 16:02 &lt;jrandom&gt; non, c’est la statistique d’ElGamal pure, puisque le réseau en production ne construit pas la nouvelle structure du réseau _PRE 16:04 &lt;jrandom&gt; KBlup : anonymat ? aucun. sécurité ? d’après ce que j’ai lu, 228 bits suffisent largement pour correspondre à un ElGamal 2048 bits 16:04  * Complication ne connaît pas grand-chose aux x et y d’ElGamal 16:04 &lt;+Complication&gt; Pas assez pour commenter de manière significative 16:06 &lt;+Complication&gt; Si des chercheurs sérieux considèrent que le x plus court est suffisamment difficile, et que ces gourous de la crypto ne se sont pas enfuis en hurlant… 16:06 &lt;@cervantes&gt; eh bien pas seulement ça, mais aussi les implications de passer à 1024/160 16:07 &lt;KBlup&gt; je suppose que je dois lire l’article plus tard ;) 16:07 &lt;+Complication&gt; cervantes : oui, c’est mieux que ça, c’est sûr 16:08 &lt;+Complication&gt; D’ailleurs, quelle est l’attaque principale que ce chiffre doit repousser, et combien de temps cette attaque est-elle viable ? 16:09 &lt;+Complication&gt; Est-ce quelque chose qui ne te profite que si tu le casses rapidement, ou cela apporte-t-il aussi un bénéfice si tu le casses plus tard ? 16:11 &lt;+Complication&gt; Si je comprends bien, le secret immédiat qu’il protège est le prochain participant du tunnel, n’est-ce pas ? 16:11 &lt;+Complication&gt; (ou plus précisément, le suivant du suivant) 16:11 &lt;@modulus&gt; réunion en cours ? 16:11 &lt;+Complication&gt; (que seul le suivant peut connaître) 16:11 &lt;@cervantes&gt; modulus: ayre 16:11 &lt;@cervantes&gt; -r 16:11 &lt;jrandom&gt; pour un adversaire pratique (mais incroyablement puissant), il serait nécessaire de le casser durant la durée de vie du tunnel. Le casser après cette durée de vie n’aiderait que si tu avais journalisé tout le trafic réseau et cassé tous les tunnels (c’est-à-dire, après avoir cassé le chiffrement éphémère de la couche de transport et en travaillant sur le chiffrement de la couche de tunnel) 16:11 &lt;jrandom&gt; donc, on parle ici d’un ordre de grandeur de minutes, pas de décennies 16:12 &lt;jrandom&gt; (donc 1024 bits est probablement même excessif) 16:12 &lt;@cervantes&gt; y a-t-il un moyen de mesurer le risque de manière significative ? 16:13 &lt;+Complication&gt; De plus, pour un tunnel avec plus de sauts, l’adversaire devrait en casser plusieurs, non ? 16:13 &lt;+Complication&gt; (bien que le constructeur doive lui aussi en construire plusieurs) 16:13 &lt;@cervantes&gt; si nous n’avons pas besoin de plus de 1024 bits, est-il vraiment nécessaire d’en utiliser plus ?  16:14 &lt;@cervantes&gt; nous pouvons toujours utiliser un algo plus fort dans 3 ans quand nous aurons des ordinateurs quantiques bien plus puissants 16:14 &lt;@modulus&gt; jrandom : si l’adversaire savait qu’à l’heure hh:mm quelque chose d’important va être acheminé via un tunnel, est-il probable qu’il puisse le casser d’une manière ou d’une autre en journalisant ? 16:14 &lt;jrandom&gt; Complication : oui, ils devraient en casser plusieurs (ainsi que les clés DH protégeant la couche de transport) 16:14 &lt;@modulus&gt; à ma connaissance, 1024 bits est break()able avec beaucoup de puissance 16:15 &lt;jrandom&gt; beaucoup de puissance et une décennie 16:15 &lt;jrandom&gt; (ou trois) 16:15 &lt;@cervantes&gt; jrandom : est-ce difficile d’essayer le chiffre plus faible ? 16:15 &lt;@modulus&gt; j’avais l’impression que des composites 1024 bits étaient factorisables de nos jours en quelques mois. 16:15 &lt;@cervantes&gt; pourrions-nous déployer sur le réseau _PRE  16:15 &lt;@cervantes&gt; et voir si cela offre vraiment beaucoup d’avantages 16:16 &lt;@cervantes&gt; modulus : oui mais ils devraient en casser plusieurs 16:16 &lt;@modulus&gt; si c’est basé sur le domaine du logarithme discret et tout ce bazar alors je n’y connais rien 16:16 &lt;@modulus&gt; cervantes : aha 16:16 &lt;jrandom&gt; cervantes : cela nécessite des changements à beaucoup de structures, puisque nous utilisons actuellement des créneaux de 512 octets. quoique, peut-être pourrions-nous simplement remplir les 256 premiers octets avec 0x00 pour tester 16:17 &lt;jrandom&gt; modulus : ElGamal est basé sur le logarithme discret 16:17 &lt;@cervantes&gt; jrandom : ça vaut la peine de tester ? 16:17 &lt;@modulus&gt; oui oui, j’imaginais RSA 16:17 &lt;@cervantes&gt; ou mieux vaut se concentrer sur d’autres choses et y revenir si nécessaire 16:18 &lt;jrandom&gt; ça vaut clairement le coup d’être testé, même si pour le moment je bidouille des évaluations de la couche de transport 16:18 &lt;+Complication&gt; J’imagine que ça dépend de la façon dont leur calcul peut être géré dans la vraie vie. 16:18 &lt;jrandom&gt; (et les 44ms de temps de chiffrement sont suffisantes pour le moment, même si 4ms seraient encore mieux :) 16:19 &lt;+Complication&gt; Si ça tient avec les ordinateurs actuels, ça s’améliorera avec les nouvelles machines. 16:19 &lt;@modulus&gt; surtout s’il arrive du matériel crypto, comme on commence à en voir dans certains 16:19 &lt;jrandom&gt; mais bien sûr, changer ce paramètre ne se fera ni à la légère ni immédiatement. mais si quelqu’un a une bonne raison de l’éviter, merci de me contacter 16:21 &lt;jrandom&gt; modulus : j’ai entendu parler de puces dédiées AES et RSA, mais rien sur DH/ElGamal. d’un autre côté, si l’on considère la NSA/etc comme adversaire, qui peut construire les siennes, c’est possible 16:22 &lt;@cervantes&gt; ils ont des machines de crypto basées sur une technologie de donuts saupoudrés en anneau 16:23  * Complication est prêt à passer du Celeron 300 à l’Athlon 600, si cela retient la marée de donuts saupoudrés en anneau :D 16:23 &lt;tethra&gt; héhé 16:24 &lt;jrandom&gt; mmMMmm donuts 16:25 &lt;jrandom&gt; ok, quelqu’un a autre chose sur 2) Avancées du réseau _PRE ? 16:25 &lt;jrandom&gt; sinon, passons à 3) I2Phex 0.1.1.37 16:26 &lt;jrandom&gt; Complication : tu veux nous donner les grandes lignes ? 16:26 &lt;+Complication&gt; Eh bien, ça semble fonctionner. :) 16:26 &lt;+Complication&gt; Il y a l’espoir d’obtenir plus de webcaches pour une redondance supplémentaire bientôt. 16:27 &lt;jrandom&gt; cool 16:27 &lt;jrandom&gt; hmm, penses-tu qu’il nous faut plus de webcaches ? il ne nous en faut pas juste un en ligne ? pas que plus fasse du mal, bien sûr 16:27 &lt;+Complication&gt; (si legion parvient à résoudre les mystères qui ont hanté sa tentative initiale) 16:27 &lt;+Complication&gt; Il y a aussi un bug mystérieux là-dedans, mais il ne mord pas fort, et j’essaie de le trouver. 16:28 &lt;+Complication&gt; Un seul en ligne suffit 16:28 &lt;+Complication&gt; En avoir plus augmente juste les chances qu’il y en ait un en ligne 16:28 &lt;jrandom&gt; cool 16:28 &lt;+Complication&gt; Parce qu’à ce stade, il ne marquera jamais les webcaches comme mauvais. Ils sont trop peu nombreux au total. 16:29 &lt;+Complication&gt; (cette routine s’activera s’il en existe plus de 10) 16:29 &lt;+Complication&gt; (si je me souviens bien) 16:29 &lt;+Complication&gt; Quant au bug : après un long fonctionnement, le sous-système webcache se fige parfois 16:30 &lt;+Complication&gt; Probablement parce qu’une requête GET d’un httpclient ne peut pas être interrompue avec succès 16:31 &lt;@modulus&gt; donc il doit mourir de temps en temps ? 16:31 &lt;+Complication&gt; C’est sans risque, et ça ne semble jamais mordre les machines qui viennent de rejoindre 16:31 &lt;jrandom&gt; hmm, qu’est-ce que cela signifie, fonctionnellement ? après un moment, il cessera de s’enregistrer auprès du webcache, donc les nouveaux n’obtiendront pas de références vers eux ? 16:31 &lt;+Complication&gt; Si ça mord une machine déjà bien intégrée, cette machine peut obtenir suffisamment de pairs à partir des pairs auxquels elle est déjà connectée 16:31 &lt;+Complication&gt; Donc pour l’instant l’impact semble proche de 0 16:31 &lt;@modulus&gt; cool 16:32 &lt;+Complication&gt; C’est juste curieux 16:32 &lt;@modulus&gt; aucune règle sur le moment où cela va échouer ou quoi que ce soit ? 16:32 &lt;+Complication&gt; modulus : généralement pas avant 20 heures 16:33 &lt;+Complication&gt; Et comme je n’ai aucun moyen de le provoquer, le débogage est un peu lent 16:33 &lt;@modulus&gt; :_) 16:34 &lt;+Complication&gt; Quoi qu’il en soit, si je le trouve, je le corrigerai, et si je ne le trouve pas, je trouverai d’autres trucs à bidouiller :) 16:34 &lt;jrandom&gt; :) 16:34 &lt;jrandom&gt; on dirait que ce n’est qu’un symptôme de quelques bugs que nous avons vus dans la bibliothèque de streaming / eepproxy, donc corriger ceux-là devrait corriger celui-ci 16:35 &lt;+Complication&gt; Possible 16:38 &lt;jrandom&gt; ok génial, beau travail Complication 16:38 &lt;jrandom&gt; quelqu’un a autre chose sur 3) I2Phex 0.1.1.37, ou passons-nous au fourre-tout, 4) ??? 16:41 &lt;jrandom&gt; (considérez que nous avons sauté) 16:41 &lt;jrandom&gt; ok, quelqu’un a autre chose pour la réunion ? 16:42 &lt;tmp&gt; Ou retenez votre souffle pour toujours ? 16:43 &lt;jrandom&gt; et à jamais et à jamais 16:43  * jrandom se prépare 16:43  * jrandom *baf* clôt la réunion </div>
