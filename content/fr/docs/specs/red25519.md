---
title: "Schéma de signature Red25519"
description: "Schéma de signature ré-randomisable pour créer des Destinations aveuglées"
slug: "red25519-signature-scheme"
lastUpdated: "2025-10"
accurateFor: "2.10.0"
---

## Vue d'ensemble

Ce document spécifie un schéma de signature re-randomisable, adapté à la création de Destinations (adresses I2P) pouvant être aveuglées. Il peut en outre être utilisé pour aveugler des Destinations Ed25519 existantes, avec une légère réduction d’efficacité.

Red25519 est pleinement opérationnel dans les routers I2P depuis la version 0.9.39 (publiée le 21 mars 2019). Cette spécification a été finalisée dans la version 0.9.47 (août 2020) après 17 mois de déploiement en production. Le schéma de signature fonctionne en tant que type de signature 11 (RedDSA_SHA512_Ed25519) sur le réseau I2P.

## Motivation

La Proposition 123 (New netDB Entries) définit un format de LeaseSet2 chiffré qui incarne le principe de moindre autorité : chaque participant du réseau ne reçoit que les informations nécessaires à son rôle. En particulier, un LeaseSet2 chiffré publié sur un floodfill ne révèle pas la Destination (identité publique I2P) à laquelle il est destiné, et les Leases ne peuvent être consultés que par une personne ayant une connaissance préalable de la Destination. Toutefois, les floodfills doivent toujours pouvoir authentifier les LeaseSet2 chiffrés au moment de leur publication, et les clients doivent en outre s’assurer que cette authentification a bien été assurée par la Destination elle-même.

La proposition 123 y parvient en aveuglant les clés de signature des Destinations (identités de service I2P). Les clés aveuglées peuvent être utilisées pour créer des signatures vérifiables par les floodfills, et les clients peuvent être certains que seule la Destination peut les avoir créées. Il est donc nécessaire de spécifier un schéma de signature pouvant être utilisé pour l’aveuglement.

**Note sur l'état de la Proposition 123**: Des parties de la Proposition 123 ont été implémentées et déployées progressivement depuis la version 0.9.38, avec la prise en charge de Red25519 ajoutée dans la version 0.9.39. La fonctionnalité LeaseSet2 chiffrée est prête pour la production et est utilisée activement sur le réseau I2P pour des services cachés à confidentialité renforcée.

## Conception

### Schéma de signature principal

Le schéma de signature spécifié ici, Red25519, est une instanciation de RedDSA telle que définie à la section 5.4.6 de la Spécification du protocole Zcash (Sapling et ultérieures). RedDSA est un schéma de signature basé sur Schnorr qui prend en charge la ré-randomisation des clés. Il fournit les fonctions suivantes :

**GENERATE_PRIVATE()** : Renvoie une clé privée tirée uniformément au hasard.

**DERIVE_PUBLIC(sk)** : Renvoie la clé publique correspondant à la clé privée donnée.

**GENERATE_RANDOM()** : Renvoie un scalaire aléatoire approprié pour rerandomiser une paire de clés.

**RANDOMIZE_PRIVATE(sk, alpha)** : Ré-randomise une clé privée, en utilisant un scalaire secret alpha.

**RANDOMIZE_PUBLIC(vk, alpha)** : Re-randomise une clé publique à l'aide d'un scalaire secret alpha.

**SIGN(sk, m)** : Renvoie une signature générée par la clé privée sk sur le message m donné.

**VERIFY(vk, m, sig)** : Vérifie la signature sig par rapport à la clé publique vk et au message m. Renvoie vrai si la signature est valide, faux sinon.

Pour une paire de clés donnée (sk, vk), la relation suivante est vérifiée :

```
RANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha))
```
### Conversion des clés Ed25519 en Red25519

Les clés Ed25519 PEUVENT faire l’objet d’une conversion unidirectionnelle temporaire en clés Red25519, afin de permettre la ré-aléatorisation de Destinations Ed25519 existantes. Les autres types de signature ne sont pas compatibles.

Nous définissons les fonctions de conversion suivantes :

**CONVERT_ED25519_PRIVATE(privkey)** : Renvoie la clé privée Red25519 correspondante à la clé privée Ed25519 fournie.

**CONVERT_ED25519_PUBLIC(pubkey)** : Renvoie la clé publique Red25519 correspondant à la clé publique Ed25519 fournie.

Pour une paire de clés Ed25519 donnée (privkey, pubkey), la relation suivante est vérifiée :

```
CONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey))
```
## Spécification

### Définitions

**B** : Le point de base Ed25519 comme dans [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html).

**L** : L'ordre d'Ed25519 2^252 + 27742317777372353535851937790883648493 tel que défini dans [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html).

**[s] B** : Multiplication scalaire à base fixe du point de base par s.

**[s] A** : Multiplication scalaire à base variable de A par s.

**x || y** : Concatène deux tableaux d'octets x et y.

### Red25519

Le schéma Red25519 est une spécialisation de RedDSA avec :

- G := le groupe des points sur la forme Edwards de Curve25519. En particulier, cela signifie que Red25519 utilise le sous-groupe d'ordre premier L, et le cofacteur h_G vaut 8.
- P_G := le point de base Ed25519 B.
- l_H := 512
- H(x) := SHA-512("I2P_Red25519H(x)" || x)

**Remarque sur le choix de la fonction de hachage**: Red25519 utilise SHA-512 plutôt que BLAKE2b-512 (comme dans RedDSA de Zcash). Ce choix de conception est compensé par la protection par préfixage de longueur décrite ci-dessous. La proposition I2P 148 suggère une migration future vers BLAKE2b-512 pour une protection renforcée contre Duplicate Message Identification (DMI, identification des messages dupliqués) et Length Extension Attacks (LEA, attaques par extension de longueur), ainsi qu’une amélioration des performances.

RedDSA suppose que H(x) est instanciée avec une fonction de hachage cryptographique résistante aux attaques par extension de longueur. SHA-512 ne satisfait pas à cette exigence à elle seule. Pour y remédier, nous exigeons que les messages soient précédés d’un encodage à préfixe libre de leur longueur:

```
len_u16(M) || M
```
où `len_u16(M)` est la représentation sur 2 octets de la longueur de M, en little-endian (afin d'être cohérent avec l'encodage little-endian des scalaires et des points).

Les messages ne doivent pas dépasser 65534 octets. Une longueur de 65535 est réservée pour d'éventuelles extensions futures.

**Note de sécurité**: L'inclusion de la clé publique (vk) dans la fonction de hachage, combinée à 80 octets aléatoires lors de la signature, garantit une protection contre les vulnérabilités SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack — non-forgeabilité forte avec clés re-randomisées sous attaque par message choisi) découvertes dans les premières conceptions de RedDSA. Cette implémentation intègre les correctifs de sécurité issus de l'audit Zcash de NCC Group (Finding NCC-Zcash2018-009).

### Encodage et décodage

Les clés privées Red25519 sont des scalaires modulo L, encodés en représentation little-endian (octet de poids faible en premier). Nous définissons les fonctions `DECODE_SCALAR` et `ENCODE_SCALAR` pour convertir entre la représentation en tableau d’octets et la représentation entière d’un scalaire.

Les clés publiques Red25519 sont des points sur la forme Edwards de Curve25519. Elles sont encodées comme la représentation little-endian sur 255 bits de la coordonnée y (ordre des octets du moins significatif au plus significatif), suivie d’un seul bit indiquant le signe de la coordonnée x. Il s’agit du même encodage que pour Ed25519. Nous définissons les fonctions `DECODE_POINT` et `ENCODE_POINT` pour passer entre la représentation en tableau d’octets et la représentation par coordonnées d’un point.

### Fonctions RedDSA

Pour faciliter l'implémentation, nous détaillons explicitement ci-dessous les fonctions RedDSA (ainsi que plusieurs fonctions utilitaires) déjà spécialisées pour Red25519. Les implémenteurs devraient se référer à la section 5.4.6 de la spécification du protocole Zcash pour la spécification générale des fonctions RedDSA.

```
HStar(prefix1, prefix2, m) :=
    h = SHA-512()
    h.input("I2P_Red25519H(x)")
    h.input(prefix1)
    h.input(prefix2)

    h.input(len(m) & 0xff)
    h.input((len(m) >> 8) & 0xff)
    h.input(m)

    s = h.digest()
    return s mod L

GENERATE_PRIVATE :=
    s = 64 random bytes
    return s mod L

DERIVE_PUBLIC(sk) := [sk] B

GENERATE_RANDOM :=
    s = 64 random bytes
    return s mod L

RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L

RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B

SIGN(sk, m) :=
    T = 80 random bytes
    vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk))
    r = HStar(T, vkBytes, m)

    R = [r] B
    Rbytes = ENCODE_POINT(R)

    c = HStar(Rbytes, vkBytes, m)
    S = (r + (c * sk)) mod L

    return Rbytes || ENCODE_SCALAR(S)

VERIFY(vk, m, sig) :=
    Rbytes = sig[0..32]
    Sbytes = sig[32..64]

    R = DECODE_POINT(Rbytes)
    if R is invalid:
        return false

    S = DECODE_SCALAR(Sbytes)
    if S >= L:
        return false

    vkBytes = ENCODE_POINT(vk)
    c = HStar(Rbytes, vkBytes, m)
    return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity()
```
### Fonctions de conversion

```
CONVERT_ED25519_PRIVATE(privkey) :=
    s = SHA-512(privkey)[0..32]
    s[0] = s[0] & 248
    s[31] = (s[31] & 63) | 64
    return s

CONVERT_ED25519_PUBLIC(pubkey) := pubkey
```
Notez que l’implémentation de `CONVERT_ED25519_PRIVATE` est équivalente au calcul du scalaire secret s lors de la dérivation d’une clé publique Ed25519 à partir d’une clé privée Ed25519, comme spécifié aux étapes 1 à 3 de la section 5.1.5 de [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html).

## Implications en matière de sécurité

Rerandomiser une Destination Red25519 et ensuite créer des signatures avec celle‑ci ne divulgue aucune information sur la Destination, car la distribution des clés privées Red25519 générées via `RANDOMIZE_PRIVATE` est identique à la distribution des clés privées générées via `GENERATE_PRIVATE`, et `DERIVE_PUBLIC` est déterministe.

La conversion des clés privées Ed25519 en Red25519 via `CONVERT_ED25519_PRIVATE` ne produit pas la même distribution. Cependant, nous jugeons la diminution du niveau de sécurité acceptable pour les raisons suivantes :

- L’espace des scalaires Ed25519 représente environ la moitié de la taille de l’espace des scalaires Red25519 (il existe 2^251 scalaires Ed25519 possibles, et L ~= 2^252 scalaires Red25519 possibles). Par conséquent, la perte de sécurité est au plus d’un facteur d’environ 2, soit environ 1 bit (car nous aurions pu, par coïncidence, choisir un scalaire Red25519 qui est aussi un scalaire Ed25519 valide).
- Les Destinations Ed25519 existantes ont déjà été exposées par le passé sur le réseau, et il faut partir du principe que des floodfills malveillants les ont déjà recensées.

**Important**: Les utilisateurs préoccupés par cette réduction de sécurité devraient utiliser Red25519 (type de signature 11) comme sigtype (type de signature) pour leurs Destinations plutôt que Ed25519 (type de signature 7).

Notez que l’argument ci-dessus ne s’applique pas au scalaire alpha de ré-randomisation ; des informations sur la clé sont divulguées chaque fois qu’un alpha biaisé est choisi, car la ré-randomisation additive se comporte comme un masque jetable.

### Statut de l'audit de sécurité

**Divulgation importante**: I2P, y compris Red25519 (instanciation de RedDSA spécifique à I2P), n'a jamais fait l'objet d'un audit de sécurité formel par une tierce partie. La conception sous-jacente RedDSA (algorithme de signature numérique de type Schnorr utilisé notamment par Zcash) a fait l'objet d'un examen de sécurité par NCC Group dans le cadre de l'audit du protocole Sapling de Zcash en 2018, au cours duquel des problèmes de sécurité ont été identifiés et corrigés. Cependant, l'instanciation spécifique d'I2P avec SHA-512 (au lieu de BLAKE2b-512) et la séparation de domaines propre à I2P n'ont pas fait l'objet d'une analyse indépendante.

L’implémentation de référence ed25519-java par str4d a fait l’objet d’un audit par un tiers indépendant, mais celui-ci a précédé l’implémentation de Red25519 et ne couvrait que les fonctionnalités d’Ed25519, pas les extensions Red25519.

Les utilisateurs qui déploient Red25519 (algorithme de signature) devraient comprendre cette limitation et évaluer les compromis de sécurité en fonction de leur modèle de menace.

## Compatibilité

Les versions d'I2P qui prennent en charge Red25519 (algorithme de signature EdDSA sur Curve25519 utilisé par I2P) (version 0.9.39 et ultérieures) pourront vérifier les structures de données du réseau qui sont signées avec Red25519. Les versions d'I2P qui ne prennent pas en charge Red25519 le traiteront comme une signature inconnue et PEUVENT rejeter les structures de données.

**Chronologie du déploiement**: - **0.9.39** (mars 2019): Première implémentation avec prise en charge du LS2 chiffré dans les floodfills - **0.9.40** (mai 2019): Autorisation par client pour le LS2 chiffré - **0.9.41** (août 2019): Meta LS2 et LS2 chiffré avec des clés hors ligne - **0.9.43** (février 2020): Prise en charge du b32 pour le LS2 chiffré - **0.9.47** (août 2020): Finalisation de la spécification - **2.10.0** (octobre 2025): Version actuelle du réseau (équivalente à 0.9.67+)

Les utilisateurs devraient s’attendre à ce que la fiabilité des structures de données signées Red25519 soit bonne pour les cas d’utilisation d’Encrypted LeaseSet2 (LeaseSet2 chiffré), car le réseau a eu plus de six ans pour se mettre à niveau depuis la mise en œuvre initiale. Cependant, les indicateurs d’adoption concernant l’usage général des destinations ne sont pas disponibles publiquement.

**Cas d’utilisation principal**: Red25519 est principalement utilisé pour la fonctionnalité LeaseSet2 chiffrée où l’aveuglement de clé est requis. Pour les destinations standard sans exigences de leaseset chiffré, Ed25519 (signature type 7) reste le choix recommandé en raison d’une compatibilité plus large et d’un historique éprouvé plus long.

## Notes d'implémentation

Red25519 est implémenté dans le router Java d’I2P à `net.i2p.crypto.eddsa.RedDSAEngine` et utilise la bibliothèque ed25519-java de str4d (Jack Grigg) en tant que dépendance Maven `net.i2p.crypto:eddsa` (versions 0.1.0 à 0.3.0).

L’implémentation C++ d’i2pd prend également en charge Red25519 (signaturetype=11) pour la publication de LeaseSet chiffrés.

Exemple de configuration pour i2pd :

```
signaturetype=11
i2cp.leaseSetType=5
```
**Compatibilité du LeaseSet2 chiffré**: La spécification du LeaseSet chiffré exige que la clé publique de signature dans l'unblinded destination (destination désaveuglée) soit Ed25519 (type de signature 7) ou Red25519 (type de signature 11). Aucun autre type de signature n'est pris en charge pour la fonctionnalité de LeaseSet chiffré.

## Vecteurs de test

Les vecteurs de test suivants sont fournis pour la validation de l'implémentation. Chaque vecteur comprend :

- `edsk`: Clé privée Ed25519 (aléatoire)
- `edpk`: Clé publique Ed25519 correspondante à edsk
- `sk`: CONVERT_ED25519_PRIVATE(edsk)
- `vk`: CONVERT_ED25519_PUBLIC(edpk)
- `msg`: Message à signer
- `sig`: SIGN(sk, msg)
- `alpha`: GENERATE_RANDOM()
- `rsk`: RANDOMIZE_PRIVATE(sk, alpha)
- `rvk`: RANDOMIZE_PUBLIC(vk, alpha)
- `rsig`: SIGN(rsk, msg)

**Note d'implémentation**: Ces vecteurs de test devraient être intégrés dans des suites de tests unitaires automatisées pour une validation continue. Les implémenteurs devraient vérifier que toutes les conversions, signatures et opérations de ré-randomisation correspondent à ces valeurs attendues.

### Vecteur de test 1

```
edsk:  0101010101010101010101010101010101010101010101010101010101010101
edpk:  8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c
sk:    58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e
vk:    8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c
msg:   0202020202020202020202020202020202020202020202020202020202020202
sig:   61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a
       6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f
alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08
rsk:   8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107
rvk:   6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3
rsig:  533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5
       b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001
```
### Vecteur de test 2

```
edsk:  0202020202020202020202020202020202020202020202020202020202020202
edpk:  8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394
sk:    a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e
vk:    8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394
msg:   0303030303030303030303030303030303030303030303030303030303030303
sig:   0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d
       5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a
alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203
rsk:   9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402
rvk:   527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177
rsig:  9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51
       3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f
```
**Remarque**: Les vecteurs de test supplémentaires 3 à 10 suivent le même format et se trouvent dans l’implémentation de référence.

## Références

- [Proposition 123 : Nouvelles entrées netDB](/proposals/123-new-netdb-entries/) - Parties mises en œuvre et déployées dans les versions 0.9.38, 0.9.39 et ultérieures
- [Spécification du protocole Zcash, section 5.4.6 : RedDSA, RedJubjub et RedPallas](https://zips.z.cash/protocol/protocol.pdf) - RedDSA est défini dans la spécification du protocole Zcash ; audit de sécurité par NCC Group (janvier 2019)
- [RFC 8032 : Algorithme de signature numérique à courbe d'Edwards (EdDSA)](https://www.rfc-editor.org/rfc/rfc8032.html)
- [Proposition 148 : RedDSA-BLAKE2b-Ed25519](/proposals/148-eddsa-blake2b-ed25519/) - Proposé mais pas encore implémenté ; suggère une migration future vers BLAKE2b-512
- [Spécification du LeaseSet chiffré](/docs/specs/encryptedleaseset/)
- [Spécification de la cryptographie de bas niveau](/docs/specs/cryptography/)
