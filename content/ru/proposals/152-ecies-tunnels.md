```markdown
---
title: "ECIES Туннели"
number: "152"
author: "chisana, zzz, orignal"
created: "2019-07-04"
lastupdated: "2025-03-05"
status: "Closed"
thread: "http://zzz.i2p/topics/2737"
target: "0.9.48"
implementedin: "0.9.48"
---

## Примечание
Проводится развертывание и тестирование сети.
Возможны незначительные изменения.
См. [SPEC](/en/docs/spec/) для официальной спецификации.


## Обзор

Этот документ предлагает изменения в шифровании сообщений построения туннеля с использованием криптопримитивов, введенных в [ECIES-X25519](/en/docs/spec/ecies/).
Это часть общей предложения
[Prop156](/en/proposals/156-ecies-routers/) по переводу маршрутизаторов с ElGamal на ECIES-X25519 ключи.

Для перехода сети с ElGamal + AES256 на ECIES + ChaCha20 необходимы туннели с комбинацией маршрутизаторов ElGamal и ECIES.
Предоставляются спецификации для обработки смешанных хопов туннеля.
Изменения формата, обработки или шифрования ElGamal хопов не планируется.

Создатели туннелей ElGamal должны будут создавать эфемерные ключевые пары X25519 для каждого хопа и следовать этой спецификации для создания туннелей, содержащих ECIES хопы.

Это предложение уточняет изменения, необходимые для построения туннелей ECIES-X25519.
Для обзора всех изменений, необходимых для маршрутизаторов ECIES, см. предложение 156 [Prop156](/en/proposals/156-ecies-routers/).

Это предложение сохраняет тот же размер записей построения туннелей, как требуется для совместимости. Меньшие записи и сообщения будут реализованы позже - см. [Prop157](/en/proposals/157-new-tbm/).


### Криптографические примитивы

Никакие новые криптографические примитивы не введены. Примитивы, необходимые для реализации этого предложения:

- AES-256-CBC как в [Cryptography](/en/docs/spec/cryptography/)
- Функции STREAM ChaCha20/Poly1305:
  ENCRYPT(k, n, plaintext, ad) и DECRYPT(k, n, ciphertext, ad) - как в [NTCP2](/en/docs/spec/ntcp2/) [ECIES-X25519](/en/docs/spec/ecies/) и [RFC-7539](https://tools.ietf.org/html/rfc7539)
- Функции X25519 DH - как в [NTCP2](/en/docs/spec/ntcp2/) и [ECIES-X25519](/en/docs/spec/ecies/)
- HKDF(salt, ikm, info, n) - как в [NTCP2](/en/docs/spec/ntcp2/) и [ECIES-X25519](/en/docs/spec/ecies/)

Другие функции Noise, определенные в других местах:

- MixHash(d) - как в [NTCP2](/en/docs/spec/ntcp2/) и [ECIES-X25519](/en/docs/spec/ecies/)
- MixKey(d) - как в [NTCP2](/en/docs/spec/ntcp2/) и [ECIES-X25519](/en/docs/spec/ecies/)


### Цели

- Увеличение скорости криптовычислений
- Замена ElGamal + AES256/CBC примитивами ECIES для Tunnel BuildRequestRecords и BuildReplyRecords.
- Без изменения размера зашифрованных BuildRequestRecords и BuildReplyRecords (528 байт) для обеспечения совместимости
- Отсутствие новых I2NP сообщений
- Поддержание размера зашифрованной записи построения для совместимости
- Добавление прямой секретности для сообщений построения туннелей.
- Добавление аутентифицированного шифрования
- Обнаружение изменения порядка расположения BuildRequestRecords
- Увеличение разрешения временной метки, что позволит уменьшить размер фильтра Блума
- Добавление поля для истечения срока действия туннеля, чтобы обеспечить возможность изменения времени жизни туннеля (только для туннелей с ECIES)
- Добавление расширяемого поля опций для будущих функций
- Повторное использование существующих криптографических примитивов
- Улучшение безопасности сообщения построения туннеля, где это возможно, сохраняя при этом совместимость
- Поддержка туннелей с комбинацией ElGamal/ECIES узлов
- Улучшение защиты от атак "тагания" на сообщения о построении
- Узлы не обязаны знать тип шифрования следующего узла перед обработкой сообщения о построении,
  так как у них может не быть при этом следующего узла RI
- Максимальная совместимость с текущей сетью
- Без изменений в соответствии туннелей AES для запроса/ответа для маршрутизаторов ElGamal
- Без изменений в соответствии туннелей AES "слоя", для этого см. [Prop153](/en/proposals/153-chacha20-layer-encryption/)
- Продолжение поддержки как 8-записей TBM/TBRM, так и переменного размера VTBM/VTBRM
- Нет необходимости в "дне введения" апгрейда для всей сети


### Не цели

- Полное переработка сообщений о построении туннелей, требующих "день введения".
- Уменьшение сообщений о построении туннелей (требует всех-хопов ECIES и нового предложения)
- Использование опций построения туннелей, как определено в [Prop143](/en/proposals/143-build-message-options/), только необходимо для небольших сообщений
- Двусторонние туннели - для этого см. [Prop119](/en/proposals/119-bidirectional-tunnels/)
- Меньшие сообщения о построении туннелей - для этого см. [Prop157](/en/proposals/157-new-tbm/)


## Модель угроз

### Цели разработки

- Ни один из хопов не может определить инициатора туннеля.

- Хопы в середине не должны уметь определять направление туннеля
  или своё местоположение в туннеле.

- Ни один из хопов не может прочитать какой-либо содержимое других записей запросов или ответов, кроме
  усеченного хеша маршрутизатора и эфемерного ключа для следующего хопа

- Ни один из участников туннеля ответа для исходящего построения не может прочитать какие-либо записи ответа.

- Ни один из участников исходящего туннеля для входящего построения не может прочитать какие-либо записи запросов,
  за исключением того, что OBEP может видеть усеченный хеш маршрутизатора и эфемерный ключ для IBGW


### Атаки "таганием"

Главной целью дизайна построения туннеля является усложнение понимания для взаимодействующих маршрутизаторов X и Y о том, что они находятся в одном туннеле.
Если маршрутизатор X находится на хопе m, а маршрутизатор Y находится на хопе m+1, то они очевидно будут знать.
Но если маршрутизатор X находится на хопе m, а маршрутизатор Y находится на хопе m+n при n>1, это должно быть намного сложнее.

Атаки "таганием" — это когда маршрутизатор в середине хопа X изменяет сообщение о построении туннеля таким образом, что
маршрутизатор Y может обнаружить изменение, когда сообщение о построении туда доходит.
Цель состоит в том, чтобы любое измененное сообщение было отброшено каким-либо маршрутизатором между X и Y до того, как оно достигнет маршрутизатора Y.
Для изменений, которые не были отброшены до маршрутизатора Y, создатель туннеля должен обнаружить повреждение в ответе
и отклонить туннель.

Возможные атаки:

- Изменение записи построения
- Замена записи построения
- Добавление или удаление записи построения
- Изменение порядка записей построения

TODO: Предотвращает ли текущий дизайн все эти атаки?

## Дизайн

### Noise Protocol Framework

Это предложение предоставляет требования на основе Noise Protocol Framework
[NOISE](https://noiseprotocol.org/noise.html) (Revision 34, 2018-07-11).
В терминах Noise, Alice является инициатором, а Bob — ответчиком.

Настоящее предложение основано на Noise протоколе Noise_N_25519_ChaChaPoly_SHA256.
Этот Noise протокол использует следующие примитивы:

- Шаблон рукопожатия: N
  Alice не передает свой статический ключ Bob'у (N)

- DH функция: X25519
  X25519 DH с длиной ключа 32 байта, как определено в [RFC-7748](https://tools.ietf.org/html/rfc7748).

- Функция шифрования: ChaChaPoly
  AEAD_CHACHA20_POLY1305, как определено в [RFC-7539](https://tools.ietf.org/html/rfc7539) раздел 2.8.
  12 байт nonce, с первыми 4 байтами ноль.
  Идентично тому, что в [NTCP2](/en/docs/spec/ntcp2/).

- Хэш-функция: SHA256
  Стандартный 32-байтный хэш, широко использующийся в I2P.


Добавления к Фреймворку
````````````````````````

Нет.


### Шаблоны рукопожатия

Рукопожатия используют шаблоны рукопожатия [Noise](https://noiseprotocol.org/noise.html).

Следующее соответствие букв используется:

- e = одноразовый эфемерный ключ
- s = статический ключ
- p = полезная нагрузка сообщения

Запрос построения идентичен шаблону Noise N.
Это также идентично первому (Сообщение запроса сеанса) в шаблону XK, используемому в [NTCP2](/en/docs/spec/ntcp2/).


  ```dataspec

<- s
  ...
  e es p ->





  ```


### Шифрование запроса

Записи запроса на построение создаются создателем туннеля и асимметрично шифруются для индивидуального хопа.
Это асимметричное шифрование записей запросов в настоящее время использует ElGamal как определено в [Cryptography](/en/docs/spec/cryptography/)
и содержит SHA-256 контрольную сумму. Этот дизайн не обладает прямой секретностью.

Новый дизайн будет использовать одноразовый шаблон Noise "N" с ECIES-X25519 эфемерно-статическим DH, с HKDF и
ChaCha20/Poly1305 AEAD для прямой секретности, целостности и аутентификации.
Alice является запрашивающим туннель построения. Каждый хоп в туннеле — Bob.


(Свойства безопасности полезной нагрузки)

  ```text

N:                      Аутентификация   Конфиденциальность
    -> e, es                  0                2

    Аутентификация: Нет (0).
    Эта полезная нагрузка могла была отправлена любой стороной, включая активного злоумышленника.

    Конфиденциальность: 2.
    Шифрование для известного получателя, прямая секретность только для компрометации отправителя,
    уязвимо для повторной атаки. Эта полезная нагрузка зашифрована только на основе DH,
    включающих статическую ключевую пару получателя. Если статический закрытый ключ получателя
    скомпрометирован, даже через некоторое время, эта полезная нагрузка может быть расшифрована.
    Это сообщение также может быть повторено, поскольку нет эфемерного вклада от получателя.

    "e": Alice генерирует новую эфемерную ключевую пару и сохраняет её в переменной e,
         записывает публичный ключ как открытый текст в буфер сообщения, и хеширует публичный ключ
         вместе с предыдущим h для вычисления нового значения h.

    "es": Выполняется DH между эфемерной ключевой парой Alice и
          статической ключевой парой Bob. Результат хешируется с предыдущим ck для
          вычисления нового ck и k, и n устанавливается в ноль.





  ```



### Шифрование ответа

Записи ответа на построение создаются создателем хопа и симметрично шифруются создателю.
Это симметричное шифрование записей ответа в настоящее время использует AES с добавленной SHA-256 контрольной суммой.
и содержит SHA-256 контрольную сумму. Этот дизайн не обладает прямой секретностью.

Новый дизайн будет использовать ChaCha20/Poly1305 AEAD для целостности и аутентификации.


### Обоснование

Эфемерный публичный ключ в запросе не нужно обфусцировать AES
или Elligator2. Предыдущий хоп — единственный, кто может его увидеть, и этот хоп
знает, что следующий хоп — ECIES.

Записи ответов не требуют полного асимметричного шифрования с другим DH.



## Спецификация



### Записи запросов на построение

Зашифрованные BuildRequestRecords имеют размер 528 байт как для ElGamal, так и для ECIES, для совместимости.


Не зашифрованная запись запроса (ElGamal)
`````````````````````````````````````````

Для справки, это текущая спецификация туннельного BuildRequestRecord для маршрутизаторов ElGamal, взятая из [I2NP](/en/docs/spec/i2np/).
Данные без шифрования добавляются с ненулевым байтом и SHA-256 хешем данных до шифрования,
как определено в [Cryptography](/en/docs/spec/cryptography/).

Все поля в формате big-endian.

Не зашифрованный размер: 222 байта

  ```dataspec


байты     0-3: туннельный ID для получения сообщений, ненулевой
  байты    4-35: локальный хэш идентификаций маршрутизатора
  байты   36-39: следующий туннельный ID, ненулевой
  байты   40-71: следующий хэш идентификаций маршрутизатора
  байты  72-103: AES-256 ключ туннеля
  байты 104-135: AES-256 IV туннеля
  байты 136-167: AES-256 ключ ответа
  байты 168-183: AES-256 IV ответа
  байт      184: флаги
  байты 185-188: время запроса (в часах с эпохи, округлено вниз)
  байты 189-192: следующий ID сообщения
  байты 193-221: не интерпретируемые / случайные добавки




  ```


Зашифрованная запись запроса (ElGamal)
```````````````````````````````````````

Для справки, это текущая спецификация туннельного BuildRequestRecord для маршрутизаторов ElGamal, взятая из [I2NP](/en/docs/spec/i2np/).

Зашифрованный размер: 528 байт

  ```dataspec


байты    0-15: усеченный хэш идентификаций хопа
  байты  16-528: ElGamal зашифрованная BuildRequestRecord




  ```




Не зашифрованная запись запроса (ECIES)
```````````````````````````````````````

Это предлагаемая спецификация туннельного BuildRequestRecord для маршрутизаторов ECIES-X25519.
Сводка изменений:

- Удаление неиспользуемого 32-байтного хэша маршрутизатора
- Изменение времени запроса с часов на минуты
- Добавление поля истечения срока для возможного изменения времени туннеля в будущем
- Добавление большего пространства для флагов
- Добавление сопоставления для дополнительных опций построения
- AES-256 ключ и IV ответа не используются для собственного ответного записи хопа
- Не зашифрованная запись длиннее из-за меньших накладных расходов на шифрование


Запись запроса не содержит никаких ChaCha ключей ответов.
Эти ключи выводятся из KDF. См. ниже.

Все поля в формате big-endian.

Не зашифрованный размер: 464 байта

  ```dataspec


байты     0-3: туннельный ID для получения сообщений, ненулевой
  байты     4-7: следующий туннельный ID, ненулевой
  байты    8-39: следующий хэш идентификаций маршрутизатора
  байты   40-71: AES-256 ключ туннеля
  байты  72-103: AES-256 IV туннеля
  байты 104-135: AES-256 ключ ответа
  байты 136-151: AES-256 IV ответа
  байт      152: флаги
  байты 153-155: еще флаги, не используются, установлены в 0 для совместимости
  байты 156-159: время запроса (в минутах с эпохи, округлено вниз)
  байты 160-163: истечение срока запроса (в секундах с момента создания)
  байты 164-167: следующий ID сообщения
  байты   168-x: опции построения туннеля (Сопоставление)
  байты     x-x: другие данные, как предполагается флагами или опциями
  байты   x-463: случайные добавки




  ```

Поле флагов такое же, как определено в [Tunnel-Creation_] и содержит следующее::

 Порядок битов: 76543210 (бит 7 является MSB)
 бит 7: если установлен, разрешить сообщения от всех
 бит 6: если установлен, разрешить сообщения всем и отправить ответ на
        указанному следующему хопу в сообщении о построении туннеля
 биты 5-0: Неопределено, необходимо установить в 0 для совместимости с будущими опциями

Бит 7 указывает, что хоп будет входящим шлюзом (IBGW). Бит 6
указывает, что хоп будет конечной точкой с исходящим (OBEP). Если ни один из битов
не установлен, хоп будет участником в середине. Оба не могут быть установлены одновременно.

Истечение срока запроса для будущей переменной длительности туннеля.
На данный момент единственное поддерживаемое значение — 600 (10 минут).

Опции построения туннеля является структурой сопоставления, как определено в [Common](/en/docs/spec/common-structures/).
Это для будущего использования. В настоящее время никаких опций не определено.
Если структура Сопоставления пуста, это два байта 0x00 0x00.
Максимальный размер Сопоставления (включая поле длины) составляет 296 байт,
и максимальное значение поля длины Сопоставления — 294.



Зашифрованная запись запроса (ECIES)
`````````````````````````````````````

Все поля в формате big-endian, кроме эфемерного публичного ключа, который является little-endian.

Зашифрованный размер: 528 байт

  ```dataspec


байты    0-15: усеченный хэш идентификаций хопа
  байты   16-47: Эфемерный X25519 открытый ключ отправителя
  байты  48-511: ChaCha20 зашифрованная BuildRequestRecord
  байты 512-527: Poly1305 MAC




  ```



### Записи ответов на построение

Зашифрованные BuildReplyRecords имеют размер 528 байт как для ElGamal, так и для ECIES, для совместимости.


Не зашифрованная запись ответа (ElGamal)
```````````````````````````````````````
ElGamal ответы шифруются с помощью AES.

Все поля в формате big-endian.

Не зашифрованный размер: 528 байт

  ```dataspec


байты   0-31: SHA-256 Хеш байтов 32-527
  байты 32-526: случайные данные
  байт     527: ответ

  общая длина: 528




  ```


Не зашифрованная запись ответа (ECIES)
`````````````````````````````````````
Это предлагаемая спецификация туннельного BuildReplyRecord для маршрутизаторов ECIES-X25519.
Сводка изменений:

- Добавление Сопоставления для опций ответа
- Не зашифрованная запись длиннее из-за меньших накладных расходов на шифрование

ECIES ответы шифруются с помощью ChaCha20/Poly1305.

Все поля в формате big-endian.

Не зашифрованный размер: 512 байт

  ```dataspec


байты    0-x: Опции ответа построения туннеля (Сопоставление)
  байты    x-x: другие данные, как предполагается опциями
  байты  x-510: Случайные добавки
  байт     511: Байты ответа




  ```

Опции ответа построения туннеля является структурой Сопоставления, как определено в [Common](/en/docs/spec/common-structures/).
Это для будущего использования. В настоящее время никаких опций не определено.
Если структура Сопоставления пуста, это два байта 0x00 0x00.
Максимальный размер Сопоставления (включая поле длины) составляет 511 байт,
и максимальное значение поля длины Сопоставления — 509.

Байт ответа является одним из следующих значений
как определено в [Tunnel-Creation](/en/docs/spec/tunnel-creation/) для избежания отпечатков пальцев:

- 0x00 (принять)
- 30 (TUNNEL_REJECT_BANDWIDTH)


Зашифрованная запись ответа (ECIES)
```````````````````````````````````

Зашифрованный размер: 528 байт

  ```dataspec


байты   0-511: ChaCha20 зашифрованная BuildReplyRecord
  байты 512-527: Poly1305 MAC




  ```

После полного перехода на ECIES записи правила диапазона добавок такие же, как и для записей запроса.


### Симметричное шифрование записей

Смешанные туннели будут допустимы и необходимы для перехода от ElGamal к ECIES.
Во время переходного периода количество маршрутизаторов с ключами ECIES будет увеличиваться.

Предварительная обработка симметричной криптографии будет осуществляться тем же образом:

- "шифрование":

  - шифр работает в режиме расшифровки
  - записи запроса предварительно расшифровываются при предварительной обработке (скрытие зашифрованных записей запросов)

- "расшифровка":

  - шифр работает в режиме шифрования
  - записи запросов шифруются (раскрытие следующей записи запроса в открытом виде) промежуточными хопами

- ChaCha20 не имеет "режимов", поэтому он просто выполняется три раза:

  - один раз при предварительной обработке
  - один раз хопом
  - один раз при окончательной обработке ответа

Когда используются смешанные туннели, создатели туннелей будут основывать симметричное шифрование
BuildRequestRecord на типе шифрования текущего и предыдущего хопов.

Каждый хоп использует свой собственный тип шифрования для шифрования BuildReplyRecords и других
записей в VariableTunnelBuildMessage (VTBM).

На пути ответа конечная точка (отправитель) должна будет отменить [Multiple-Encryption](https://en.wikipedia.org/wiki/Multiple_encryption), используя каждый ответный ключ маршрутизатора.

Как проясняющий пример, давайте рассмотрим исходящий туннель с ECIES, окруженный ElGamal:

- Отправитель (OBGW) -> ElGamal (H1) -> ECIES (H2) -> ElGamal (H3)

Все BuildRequestRecords находятся в зашифрованном состоянии (с использованием ElGamal или ECIES).

Шифр AES256/CBC, когда используется, все еще используется для каждой записи, без цепочки через несколько записей.

Аналогично, ChaCha20 будет использоваться для шифрования каждой записи, не потоком через весь VTBM.

Записи запросов предварительно обрабатываются Отправителем (OBGW):

- Запись H3 "зашифрована" с использованием:

  - ответный ключ H2 (ChaCha20)
  - ответный ключ H1 (AES256/CBC)

- Запись H2 "зашифрована" с использованием:

  - ответный ключ H1 (AES256/CBC)

- Запись H1 выходит без симметричного шифрования

Только H2 проверяет флаг шифрования ответа и видит, что за ним следует AES256/CBC.

После обработки каждым хопом записи находятся в "расшифрованном" состоянии:

- Запись H3 "расшифрована" с использованием:

  - ответный ключ H3 (AES256/CBC)

- Запись H2 "расшифрована" с использованием:

  - ответный ключ H3 (AES256/CBC)
  - ответный ключ H2 (ChaCha20-Poly1305)

- Запись H1 "расшифрована" с использованием:

  - ответный ключ H3 (AES256/CBC)
  - ответный ключ H2 (ChaCha20)
  - ответный ключ H1 (AES256/CBC)

Создатель туннеля, также известный как конечная точка (IBEP), постобрабатывает ответ:

- Запись H3 "зашифрована" с использованием:

  - ответный ключ H3 (AES256/CBC)

- Запись H2 "зашифрована" с использованием:

  - ответный ключ H3 (AES256/CBC)
  - ответный ключ H2 (ChaCha20-Poly1305)

- Запись H1 "зашифрована" с использованием:

  - ответный ключ H3 (AES256/CBC)
  - ответный ключ H2 (ChaCha20)
  - ответный ключ H1 (AES256/CBC)


### Ключи записи запроса (ECIES)

Эти ключи явно включены в ElGamal BuildRequestRecords.
Для ECIES BuildRequestRecords туннельные ключи и AES ключи ответов включены,
но ChaCha ключи ответов выводятся из DH обмена.
См. [Prop156](/en/proposals/156-ecies-routers/) для деталей статических ECIES ключей маршрутизаторов.

Ниже приводится описание того, как вывести ключи, ранее переданные в записях запроса.


KDF для начальных ck и h
````````````````````````

Это стандарт [NOISE](https://noiseprotocol.org/noise.html) для шаблона "N" со стандартным именем протокола.

  ```text

Это шаблон сообщения "e":

  // Задать protocol_name.
  Установите protocol_name = "Noise_N_25519_ChaChaPoly_SHA256"
  (31 байт, в кодировке US-ASCII, без NULL окончания).

  // Задать Hash h = 32 байта
  // Дополните до 32 байт. НЕ хешируйте, так как оно не более 32 байт.
  h = protocol_name || 0

  Определите ck = 32 байтовый цепной ключ. Скопируйте данные h в ck.
  Установите chainKey = h

  // MixHash(null prologue)
  h = SHA256(h);

  // до этого момента всё может быть предвычислено всеми маршрутизаторами.




  ```


KDF для записи запроса
````````````````````````

Создатели туннелей ElGamal генерируют эфемерную ключевую пару X25519 для каждого
ECIES хопа в туннеле, и используют схему выше для шифрования своей записи запроса на построение.
Создатели туннелей ElGamal будут использовать схему перед этой спецификацией для шифрования хопов ElGamal.

Создатели туннелей ECIES будут должны шифровать к каждому открытому ключу ElGamal хопа с использованием
схемы, определенной в [Tunnel-Creation](/en/docs/spec/tunnel-creation/). Создатели туннелей ECIES будут использовать вышеуказанную схему для шифрования
к ECIES хопам.

Это означает, что хопы туннеля будут видеть только зашифрованные записи от их собственного типа шифрования.

Для создателей туннелей ElGamal и ECIES они будут генерировать уникальные эффемерные ключевые пары X25519
для каждого ECIES хопа для шифрования.

**ВАЖНО**:
Эфемерные ключи должны быть уникальны для каждого ECIES хопа и для каждой записи построения.
Несоблюдение уникальности ключей открывает атаку для взаимодействующих хопов, чтобы подтвердить, что они находятся в одном туннеле.


  ```dataspec


// X25519 статическая ключевая пара каждого хопа (hesk, hepk) из идентификации маршрутизатора
  hesk = GENERATE_PRIVATE()
  hepk = DERIVE_PUBLIC(hesk)

  // MixHash(hepk)
  // || ниже обозначает добавление
  h = SHA256(h || hepk);

  // до этого момента всё может быть предвычислено каждым маршрутизатором
  // для всех входящих запросов на построение

  // Отправитель генерирует эфемерную ключевую пару X25519 для каждого ECIES хопа в VTBM (sesk, sepk)
  sesk = GENERATE_PRIVATE()
  sepk = DERIVE_PUBLIC(sesk)

  // MixHash(sepk)
  h = SHA256(h || sepk);

  Завершение шаблона сообщения "e".

  Это шаблон сообщения "es":

  // Noise es
  // Отправитель выполняет X25519 DH со статическим публичным ключом хопа.
  // Каждый хоп находит запись с их усеченным хешом идентификации,
  // и извлекает эфемерный ключ отправителя, предшествующий зашифрованной записи.
  sharedSecret = DH(sesk, hepk) = DH(hesk, sepk)

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  // ChaChaPoly параметры для шифрования/дешифрования
  keydata = HKDF(chainKey, sharedSecret, "", 64)
  // Сохранить для KDF записи ответа
  chainKey = keydata[0:31]

  // AEAD параметры
  k = keydata[32:63]
  n = 0
  текст = 464 байт записи запроса на построение
  ad = h
  зашифрованный текст = ENCRYPT(k, n, текст, ad)

  Завершение шаблона сообщения "es".

  // MixHash(зашифрованный текст)
  // Сохранить для KDF записи ответа
  h = SHA256(h || зашифрованный текст)





  ```

``replyKey``, ``layerKey`` и ``layerIV`` все еще должны быть включены внутри записей ElGamal,
и могут быть сгенерированы случайным образом.


### Шифрование записи запроса (ElGamal)

Как определено в [Tunnel-Creation](/en/docs/spec/tunnel-creation/).
Изменений в шифровании для хопов ElGamal не предусмотрено.



### Шифрование записи ответа (ECIES)

Запись ответа ChaCha20/Poly1305 зашифрована.

  ```dataspec


// AEAD параметры
  k = chainkey из записи запроса
  n = 0
  текст = 512 байт записи ответа
  ad = h из записи запроса

  зашифрованный текст = ENCRYPT(k, n, текст, ad)




  ```



### Шифрование записи ответа (ElGamal)

Как определено в [Tunnel-Creation](/en/docs/spec/tunnel-creation/).
Изменений в шифровании для хопов ElGamal не предусмотрено.



### Анализ безопасности

ElGamal не предоставляет прямую секретность для туннельных сообщений построения.

AES256/CBC находится в немного лучшем положении, являясь уязвимым только к теоретическому ослаблению из-за
известной атаки на открытый текст `biclique`.

Единственная известная практическая атака на AES256/CBC — это атака оракула заполнения, когда IV известен нападающему.

Нападающему потребуется взломать шифрование ElGamal следующего хопа, чтобы получить информацию о ключе AES256/CBC (ключ ответа и IV).

ElGamal значительно более CPU-интенсивен чем ECIES, что приводит к потенциальному истощению ресурсов.

ECIES, используемый с новыми эфемерными ключами per-BuildRequestRecord или VariableTunnelBuildMessage, предоставляет прямую секретность.

ChaCha20Poly1305 предоставляет AEAD шифрование, позволяя получателю проверить целостность сообщения перед попыткой расшифровки.


## Обоснование

Этот дизайн максимально использует существующие криптографические примитивы, протоколы и код.
Этот дизайн минимизирует риск.




## Примечания к реализации

* Старые маршрутизаторы не проверяют тип шифрования хопа и отправят записи, зашифрованные ElGamal.
Некоторые недавние маршрутизаторы неисправны и отправляют различные типы некорректных записей.
Реализаторы должны обнаруживать и отклонять эти записи до выполнения операции DH
если возможно, чтобы уменьшить использование CPU.


## Вопросы



## Миграция

См. [Prop156](/en/proposals/156-ecies-routers/).



