---
title: "NTCP 2"
number: "111"
author: "EinMByte, orignal, psi, str4d, zzz"
created: "2014-02-13"
lastupdated: "2019-08-13"
status: "Closed"
thread: "http://zzz.i2p/topics/1577"
supercedes: "106"
target: "0.9.36"
implementedin: "0.9.36"
editor: "manas, str4d, zzz"
---

## Note
Фаза предложения закрыта.
См. [SPEC](/en/docs/spec/ntcp2/) для официальной спецификации.
Этому предложению все еще можно ссылаться для получения фоновой информации.


## Overview

Это предложение описывает протокол проверенной передачи ключа для улучшения защиты [NTCP](/en/docs/transport/ntcp/) от различных форм автоматической идентификации и атак.

Предложение организовано следующим образом: сначала представлены цели безопасности, затем следует обсуждение основного протокола. Далее приводится полная спецификация всех сообщений протокола. В завершение обсуждаются адреса маршрутизаторов и идентификация версий. Также включен приложение с обсуждением общей атаки на общие схемы выравнивания, а также приложение, содержащее несколько кандидатов на роль аутентифицированного шифра.

Как и другие передачи данных I2P, NTCP2 определяется исключительно для транспорта точка-точка (маршрутизатор-к-маршрутизатор) сообщений I2NP. Это не универсальная трубопроводная передача данных.


## Motivation

Данные [NTCP](/en/docs/transport/ntcp/) шифруются после первого сообщения (и первое сообщение выглядит как случайные данные), тем самым предотвращая идентификацию протокола через "анализ загрузки". Он все еще уязвим к идентификации протокола через "анализ потока". Это связано с тем, что первые 4 сообщения (т.е. рукопожатие) имеют фиксированную длину (288, 304, 448 и 48 байт).

Добавляя случайные количества случайных данных к каждому из сообщений, мы можем значительно осложнить задачу.

Авторы признают, что стандартные практики безопасности рекомендуют использовать существующий протокол, такой как TLS, но это [Prop104](/en/proposals/104/), и у него есть свои проблемы. Везде, где это уместно, добавлены абзацы "будущая работа", указывающие на недостающие функции или темы для обсуждения.


## Design Goals

- Поддержка NTCP 1 и 2 на одном порту, автоматическое обнаружение и опубликование как один "транспорт" (т.е. [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) в [NetDB](/en/docs/how/network-database/).

- Публикация поддержки только версии 1, только версии 2 или 1+2 в NetDB в отдельном поле и установка по умолчанию поддержки только версии 1 (не связывать поддержку версии с определенной версией маршрутизатора).

- Обеспечение того, чтобы все реализации (Java/i2pd/Kovri/go) могли добавлять поддержку версии 2 (или нет) по собственным графикам.

- Добавление случайного выравнивания ко всем сообщениям NTCP, включая рукопожатие и сообщения с данными (т.е. обфускация длины, чтобы все сообщения не были кратными 16 байтам). Обеспечение механизма опций для обеих сторон с просьбой о минимальном и максимальном выравнивании и/или распределении выравнивания. Подробности распределения выравнивания зависят от реализации и могут быть не указаны в самом протоколе.

- Обфускация содержимого сообщений, которые не зашифрованы (1 и 2), в достаточной степени, чтобы DPI и антивирусные сигнатуры не могли легко классифицировать их. Также убедитесь, что сообщения, отправляемые одному пиру или набору пиров, не следуют одинаковой схеме битов.

- Исправление потери бит в DH из-за формата Java [Ticket1112](https://trac.i2p2.i2p/ticket/1112), возможно (вероятно?) путем переключения на X25519.

- Переключение на настоящую функцию производной ключа (KDF) вместо использования результата DH как есть?

- Добавление "устойчивости к зондированию" (как это называет Tor), включая устойчивость к воспроизведению.

- Поддержка двухстороннего защищенного обмена ключами (2W-AKE). 1W-AKE недостаточен для нашего приложения.

- Продолжение использования переменно-типа, переменно-длины подписей (из опубликованного ключа подписи [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/)) как части аутентификации. Полагаться на статический открытый ключ, опубликованный в RouterInfo, как другую часть аутентификации.

- Добавление опций/версий в рукопожатие для будущего расширения.

- Добавление устойчивости к вредоносным сегментациям TCP MitM, если это возможно.

- Не увеличивать существенно требуемую производительность ЦП для установки соединения; если это возможно, значительно уменьшить его.

- Добавление аутентификации сообщений (MAC), возможно HMAC-SHA256 и Poly1305, и удаление контрольной суммы Адлера.

- Сокращение и упрощение заголовка I2NP:
  Сокращение истечения до 4 байт, как в SSU.
  Удаление одно-байтовой урезанной контрольной суммы SHA256.

- Если это возможно, уменьшение 4-сообщения, двух-турового рукопожатия до 3-сообщения, одного турового рукопожатия, как в [SSU](/en/docs/transport/ssu/). Это потребовало бы переноса подписи Боба из сообщения 4 в сообщение 2. Исследовать причину для 4 сообщений в десяти-летних архивах электронной почты/статусов/встреч.

- Минимизирование накладных расходов протокола перед выравниванием. В то время как выравнивание будет добавлено, и, возможно, много его, накладные расходы перед выравниванием все еще остаются накладными расходами. Узлы с низкой пропускной способностью должны иметь возможность использования NTCP2.

- Поддержание временных меток для обнаружения воспроизведения и смещения.

- Избегать любых проблем 2038 года в временных метках, должен работать как минимум до 2106 года.

- Увеличение максимального размера сообщения с 16К до 32К или 64К.

- Любые новые криптографические примитивы должны быть легко доступны в библиотеках для использования в реализации маршрутизаторов Java (1.7), C++ и Go.

- Включение представителей разработчиков маршрутизаторов Java, C++ и Go в проектирование.

- Минимизирование изменений (но их все равно будет много).

- Поддержка обеих версий в общем наборе кода (это может быть невозможно и в любом случае зависит от реализации).


### Non-Goals

- Защита от DPI на высшем уровне... Это были бы подключаемые транспорты, [Prop109](/en/proposals/109/).

- Транспорт на основе TLS (или наподобие HTTPS)... Это было бы [Prop104](/en/proposals/104/).

- Допустимо изменить симметричное потоковое шифрование.

- Устойчивость к DPI на основе тайминга (межсообщения тайминг / задержки могут зависеть от реализации; внутрисообщения задержки могут быть введены в любое время, включая перед отправкой случайного выравнивания, например). Искусственные задержки (то, что obfs4 называет IAT или межприближенное время) независимы от самого протокола.

- Отказ участия в сессии (там есть подписи).

Не-цели, которые могут быть частично пересмотрены или обсуждены:

- Степень защиты от глубокого анализа пакетов (DPI)

- Пост-Квантовая (PQ) безопасность

- Отрицание


### Related Goals

- Реализация тестовой установки NTCP 1/2


## Security Goals

Мы рассматриваем три стороны:

- Алиса, которая хочет установить новую сессию.
- Боб, с кем Алиса хочет установить сессию.
- Мэллори, "человек в середине" между Алисой и Бобом.

Противники могут принимать участие в активных атаках не более чем двумя из них.

Алиса и Боб оба везти статическую пару ключей, которая размещается в их [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/).

Предложенный протокол пытается позволить Алисе и Бобу согласовать общий секретный ключ (K) при следующих требованиях:

1) Безопасность частного ключа: ни Боб, ни Мэллори не узнают ничего о статическом частном ключе Алисы. Аналогично, Алиса не узнает ничего о статическом частном ключе Боба.

2) Сессионный ключ K известен только Алисе и Бобу.

3) Абсолютный секрет вперед: согласованный сессионный ключ остается секретным в будущем, даже если статические частные ключи Алисы и/или Боба будут раскрыты после согласования ключа.

4) Двусторонняя аутентификация: Алиса уверена, что она установила сессию с Бобом, и наоборот.

5) Защита от онлайн DPI: убедитесь, что нелегко определить, что Алиса и Боб участвуют в протоколе, используя только прямые техники анализа пакетов (DPI). См. ниже.

6) Ограниченное отрицание: ни Алиса, ни Боб не могут отрицать участие в протоколе, но если одна из сторон утечет общий ключ, другая сторона может отрицать подлинность переданных данных.

Настоящее предложение пытается предоставить все пять требований на основе протокола Station-To-Station (STS) [STS]_. Обратите внимание, что этот протокол также является основой для протокола [SSU](/en/docs/transport/ssu/).

### Additional DPI Discussion

Мы предполагаем два компонента DPI:

1) Онлайновый DPI
`````````````
Онлайновый DPI, инспектирующий все потоки в режиме реального времени. Соединения могут быть заблокированы или иным образом изменены. Данные или метаданные соединения могут быть идентифицированы и сохранены для оффлайнового анализа. Онлайновый DPI не имеет доступа к базе данных сети I2P. Онлайновый DPI имеет только ограниченные вычислительные возможности в реальном времени, включая расчет длины, инспекцию полей и простые вычисления, такие как XOR. Онлайновый DPI обладает возможностью быстрого выполнения криптографических функций в реальном времени, таких как AES, AEAD и хэширование, но применение их ко всем потокам будет слишком дорогостоящим. Любое применение этих криптографических операций будет применяться только к потокам на IP/Port комбинациях, ранее выявленных оффлайновым анализом. Онлайновый DPI не обладает способностью выполнять криптографические функции с высокой нагрузкой, такие как DH или elligator2. Онлайновый DPI не предназначен специально для обнаружения I2P, хотя может иметь ограниченные правила классификации для этой цели.

Цель - предотвратить идентификацию протокола онлайновым DPI.

Понятие онлайнового или "прямого" DPI здесь принимается как включающее следующие возможности противника:

1) Способность наблюдать все данные, отправленные или полученные целью.

2) Способность выполнять операции с наблюдаемыми данными, такие как применение блочных шифров или хэш-функций.

3) Способность сохранять и сравнивать с ранее отправленными сообщениями.

4) Способность модифицировать, задерживать или фрагментировать пакеты.

Однако предполагается, что у онлайнового DPI есть следующие ограничения:

5) Невозможность сопоставления IP-адресов с хэшами маршрутизаторов. В то время как это тривиально с доступом в реальном времени к базе данных сети,
это потребует DPI системы, специально разработанной для таргетирования I2P.

6) Невозможность использовать информацию о времени для обнаружения протокола.

7) В общем, набор инструментов онлайнового DPI не содержит встроенных инструментов, специально разработанных для обнаружения I2P. Это включает создание "медовых ловушек", которые, например, включали бы несубъектное выравнивание в своих сообщениях. Обратите внимание, что это не исключает систем машинного обучения или высоко конфигурируемых инструментов DPI, если они соответствуют остальным требованиям.

Чтобы противостоять анализу полезной нагрузки, обеспечивается, что все сообщения неотличимы от случайных. Это также требует, чтобы их длина была случайной, что сложнее, чем просто добавление случайного выравнивания. Фактически, в Приложении A авторы утверждают, что наивная (т.е. равномерная) схема выравнивания не решает проблему. Приложение A, следовательно, предлагает ввести либо случайные задержки, либо разработать альтернативную схему выравнивания, которая может обеспечить разумную защиту от предлагаемой атаки.

Чтобы защищаться от шестого пункта выше, реализации должны включать случайные задержки в протоколе. Такие методы не охватываются этим предложением, но они также могут решить проблемы с длиной выравнивания. В общем, у предложения хорошая защита от анализа полезной нагрузки (при учете Приложения A), но только ограниченная защита от анализа потока.

2) Оффлайн DPI
``````````````
Оффлайн DPI, инспектирующий данные, хранящиеся онлайновым DPI для последующего анализа. Оффлайн DPI может быть специально разработан для обнаружения I2P. Оффлайн DPI имеет доступ в реальном времени к базе данных сети I2P. Оффлайн DPI имеет доступ к этой и другим спецификациям I2P. Оффлайн DPI обладает неограниченными вычислительными возможностями, включая все криптографические функции, определенные в этой спецификации.

Оффлайн DPI не имеет возможности блокировать существующие соединения. Оффлайн DPI обладает возможностью выполнения почти в реальном времени (в течение минут после установки) отправки на хост/порт участников, например, TCP RST. Оффлайн DPI обладает возможностью выполнения почти в реальном времени (в течение минут после установки) воспроизведения предыдущих сообщений (измененных или нет) для "зондирования" или других целей.

Это не является целью - предотвратить идентификацию протокола оффлайн DPI. Все декодирование обфусцированных данных в первых двух сообщениях, которое реализовано маршрутизаторами I2P, может быть также реализовано оффлайн DPI.

Цель - отвергнуть попытки подключения с использованием воспроизведенных предыдущих сообщений.

Будущая работа
`````````````
- Рассмотреть поведение протокола, когда пакеты упускаются или переупорядочены аттакующим. Недавние интересные работы в этой области можно найти в
[IACR-1150](https://eprint.iacr.org/2015/1150).

- Обеспечить более точную классификацию систем DPI, с учетом существующей литературы, связанной с данной темой.

- Обсудить формальную безопасность предложенного протокола, желательно с учетом модели атаки DPI.


## Noise Protocol Framework

Это предложение предоставляет требования, основанные на Noise Protocol Framework [NOISE](http://noiseprotocol.org/) (редакция 33, 2017-10-04).
Noise обладает схожими свойствами с протоколом Station-To-Station
[STS]_, который является основой для протокола [SSU](/en/docs/transport/ssu/). В терминологии Noise, Алиса
является инициатором, а Боб - ресивером.

NTCP2 основан на протоколе Noise Noise_XK_25519_ChaChaPoly_SHA256.
(Фактический идентификатор для функции начальной выработки ключа
это "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256",
чтобы указать расширения I2P - см. раздел KDF 1 ниже)
Этот протокол Noise использует следующие примитивы:

- Шаблон рукопожатия: XK
  Алиса передает свой ключ Бобу (X)
  Алиса уже знает статический ключ Боба (K)

- Функция DH: X25519
  X25519 DH длиной ключа 32 байта, как указано в [RFC-7748](https://tools.ietf.org/html/rfc7748).

- Функция шифра: ChaChaPoly
  AEAD_CHACHA20_POLY1305, как указано в [RFC-7539](https://tools.ietf.org/html/rfc7539) раздел 2.8.
  12-байтовый nonce, первые 4 байта всегда равны нулю.

- Функция хэширования: SHA256
  Стандартный 32-байтовый хэш, уже широко используемый в I2P.


## Additions to the Framework

Это предложение определяет следующие улучшения
Noise_XK_25519_ChaChaPoly_SHA256. Эти улучшения в основном следуют рекомендациям в
[NOISE](http://noiseprotocol.org/) раздел 13.

1) Эфемерные ключи в открытом тексте обфусцируются при помощи шифрования AES с использованием известного ключа и IV. Это быстрее, чем elligator2.

2) Случайное открытое выравнивание добавляется к сообщениям 1 и 2.
   Открытое выравнивание включается в расчет хэша рукопожатия (MixHash).
   См. разделы KDF ниже для сообщений 2 и 3 часть 1.
   Случайное выравнивание AEAD добавляется к сообщению 3 и сообщениям фазы данных.

3) Добавлено двухбайтовое поле длины фрейма, как это требуется для Noise по TCP,
   и как в obfs4. Это используется только в сообщениях фазы данных.
   Сообщения 1 и 2 AEAD фреймы имеют фиксированную длину.
   Размер части 1 сообщения 3 AEAD фрейма фиксирован.
   Длина части 2 сообщения 3 AEAD фрейма указана в сообщении 1.

4) Двухбайтовое поле длины фрейма обфусцируется с помощью SipHash-2-4,
   как в obfs4.

5) Формат полезной нагрузки определен для сообщений 1, 2, 3 и для фазы данных.
   Конечно, это не определено в Noise.

## New Cryptographic Primitives for I2P

Существующие реализации маршрутизаторов I2P потребуют реализации
следующих стандартных криптографических примитивов,
которые не необходимы для текущих протоколов I2P:

1) Генерация ключей и DH для X25519

2) AEAD_ChaCha20_Poly1305 (сокращенно ChaChaPoly ниже)

3) SipHash-2-4


## Processing overhead estimate

Размеры сообщений для 3 сообщений:

1) 64 байта + выравнивание   (NTCP был 288 байт)
2) 64 байта + выравнивание   (NTCP был 304 байт)
3) примерно 64 байта + Router Info Алисы + выравнивание   Средний размер Router Info составляет около 750
   байт   Общий средний размер 814 байт перед выравниванием (NTCP был 448 байт)
4) не требуется в NTCP2   (NTCP был 48 байт)

Всего перед выравниванием:
NTCP2: 942 байта
NTCP: 1088 байт
Обратите внимание, что если Алиса подключилась к Бобу с целью отправки
сообщения DatabaseStore Message о ее RouterInfo, это сообщение не требуется,
экономя примерно 800 байт.

Следующие криптографические операции требуются каждой стороне, чтобы завершить
рукопожатие и начать фазу данных:

- AES: 2
- SHA256: 7 (Алиса), 6 (Боб) (не включая 1 Алиса, 2 Боб предвычисленных для
  всех соединений) (не включая HMAC-SHA256)
- HMAC-SHA256: 19
- ChaChaPoly: 4
- Генерация ключей X25519: 1
- X25519 DH: 3
- Проверка подписи: 1 (Боб) (Алиса ранее подписала при генерации ее
  RI) Предполагается Ed25519 (зависит от типа подписи RI)

Следующие криптографические операции требуются каждое участнику для каждого сообщения фазы данных:

- SipHash: 1
- ChaChaPoly: 1



## Messages

Все сообщения NTCP2 имеют длину менее или равную 65537 байтам. Формат сообщения основан на сообщениях Noise, с модификациями для фрейминга и неразличимости. Реализации, использующие стандартные библиотеки Noise, возможно, потребуется предварительно обработать полученные сообщения в/из формата сообщений Noise. Все зашифрованные поля представляют собой зашифрованные AEAD
сообщения.

Последовательность установки следующая:

Алиса                           Боб

  Запрос сессии ------------------->
  <------------------- Создано сессия
  Подтверждено сессия ----------------->
Используя терминологию Noise, последовательность установки и данных следующая:
(Свойства безопасности полезной нагрузки)

XK(s, rs):           Аутентификация   Конфиденциальность
    <- s
    ...
    -> e, es                  0                2
    <- e, ee                  2                1
    -> s, se                  2                5
    <-                        2                5
Как только сессия была установлена, Алиса и Боб могут обмениваться данными.

Все типы сообщений (Запрос сессии, Сделано сессия, Подтверждено сессия, Дата и
TimeSync) указаны в этом разделе.

Некоторые обозначения::

  - RH_A = Хэш маршрутизатора для Алисы (32 байта)
  - RH_B = Хэш маршрутизатора для Боба (32 байта)


### Authenticated Encryption

Существует три отдельных проверенных шифрования (CipherStates).
Одно во время фазы рукопожатия, и два (передача и прием) для фазы данных.
У каждого есть свой ключ из KDF.

Зашифрованные/аутентифицированные данные будут представлены как

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   Зашифрованные и аутентифицированные данные    |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
ChaCha20/Poly1305
`````````````````

Формат зашифрованных и аутентифицированных данных.

Входные данные для шифрования/расшифрования:

k :: 32-байтовый ключ шифра, как сгенерированно из KDF

  nonce :: Нонсе на основе счетчика, 12 байт.
           Начинается с 0 и увеличивается для каждого сообщения.
           Первые четыре байта всегда равны нулю.
           Последние восемь байт - это счетчик, закодированный в Little-endian.
           Максимальное значение 2**64 - 2.
           Соединение должно быть прервано и перезапущено после
           достижения этого значения.
           Значение 2**64 - 1 не должно отправляться.

  ad :: В фазе рукопожатия:
        Связанные данные, 32 байта.
        Хэш SHA256 всех предшествующих данных.
        В фазе данных:
        Ноль байт

  data :: Открытый текст, 0 или более байт

Выход функции шифрования, вход функции расшифрования:

+----+----+----+----+----+----+----+----+
  |Obfs Len |                             |
  +----+----+                             +
  |       Зашифрованные данные ChaCha20        |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Контрольная сумма сообщения |
  +              (MAC)                    +
  |             16 байт                   |
  +----+----+----+----+----+----+----+----+

  Obfs Len :: Длина (зашифрованные данные + MAC) для последующих, 16 - 65535
              Обфускация с помощью SipHash (см. ниже)
              Не используется в сообщениях 1 или 2, или в сообщении 3 часть 1, где длина фиксирована
              Не используется в сообщении 3 часть 1, так как длина указана в сообщении 1

  зашифрованные данные :: Такая же длина, как у открытого текста, 0 - 65519 байт

  MAC :: Контрольная сумма сообщения Poly1305, 16 байт

Для ChaCha20 здесь описано [RFC-7539](https://tools.ietf.org/html/rfc7539), который также используется аналогично в TLS [RFC-7905](https://tools.ietf.org/html/rfc7905).

Notes
`````
- Поскольку ChaCha20 - это потоковый шифр, открытые тексты не требуют выравнивания.
  Дополнительные байты ключевой потока отбрасываются.

- Ключ шифра (256 бит) согласовывается с помощью KDF SHA256.
  Подробности KDF для каждого сообщения находятся в отдельных разделах ниже.

- Фреймы ChaChaPoly для сообщений 1, 2 и первой части сообщения 3 имеют известный размер. Начиная с второй части сообщения 3, фреймы имеют переменный размер. Размер части 1 сообщения 3 указывается в сообщении 1. Начиная с фазы данных, фреймы имеют препенденную двухбайтовую длину, обфусцированную SipHash как в obfs4.

- Выравнивание находится за пределами аутентифицированных данных для сообщений 1 и 2. Выравнивание используется в KDF для следующего сообщения, чтобы вмешательство было обнаружено. Начиная с сообщения 3, выравнивание находится внутри аутентифицированного дата фрейма.

AEAD Error Handling
```````````````````
- В сообщениях 1, 2 и части 1 и 2 сообщения 3 размер сообщения AEAD известен заранее.
  В случае сбоя аутентификации AEAD получатель должен прекратить дальнейшую обработку сообщения и закрыть соединение без ответа. Это должно быть аномальным закрытием (TCP RST).

- Для сопротивления зондированию, в сообщении 1, после сбоя AEAD, Боб должен установить случайный таймаут (диапазон TBD), а затем прочитать случайное количество байт (диапазон TBD) перед закрытием сокета. Боб должен вести черный список IP-адресов с повторными сбоями.

- В фазе данных размер сообщения AEAD "зашифрован" (обфусцирован) с использованием SipHash. Необходимо проявлять осторожность, чтобы избежать создания оракула дешифрования. При сбое аутентификации AEAD в фазе данных получатель должен установить случайный таймаут (диапазон TBD), а затем прочитать случайное количество байт (диапазон TBD). После чтения или по таймауту чтения, получатель должен отправить полезную нагрузку с блоком завершение, содержащим код причины "сбоя AEAD", и закрыть соединение.

- Принять те же меры на ошибку для недействительного значения поля длины в фазе данных.


### Key Derivation Function (KDF) (для сообщения рукопожатия 1)

KDF генерирует ключ шифрования фазы рукопожатия k из результата DH,
используя HMAC-SHA256(key, data), как определено в [RFC-2104](https://tools.ietf.org/html/rfc2104).
Это функции InitializeSymmetric(), MixHash() и MixKey(),
точно так же, как определено в спецификации Noise.

Это схема на основе "e" сообщения:

  // Определите protocol_name.
  Установите protocol_name = "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256"
   (48 байт, US-ASCII кодировка, без завершения NULL).

  // Определите Hash h = 32 байта
  h = SHA256(protocol_name);

  Определите ck = 32 байта цепного ключа. Скопируйте данные h в ck.
  Установите ck = h

  Определите rs = 32-байтовый статический ключ Боба, как опубликованный в RouterInfo

  // MixHash(null пролог)
  h = SHA256(h);

  // До этого момента все это может быть предварительно вычислено Алисой для всех исходящих соединений

  // Алиса должна проверить, что статический ключ Боба является допустимой точкой на кривой здесь.

  // Статический ключ Боба
  // MixHash(rs)
  // || означает объединение
  h = SHA256(h || rs);

  // До этого момента все это может быть предварительно вычислено Бобом для всех входящих соединений

  Это схема на основе "e" сообщения:

  Алиса генерирует свою эфемерную пару DH ключей e.

  // Эфемерный ключ X Алисы
  // MixHash(e.pubkey)
  // || означает объединение
  h = SHA256(h || e.pubkey);

  // h используется в качестве связанных данных для AEAD в сообщении 1
  // Сохраните хэш h для KDF сообщения 2


  Конец "e" сообщения.

  Это схема на основе "es" сообщения:

  // DH(e, rs) == DH(s, re)
  Определите input_key_material = 32-байтовый результат DH эфемерного ключа Алисы и статического ключа Боба
  Установите input_key_material = результат DH X25519

  // MixKey(DH())

  Определите temp_key = 32 байта
  Определите HMAC-SHA256(key, data), как в [RFC-2104](https://tools.ietf.org/html/rfc2104)
  // Генерация временного ключа из цепного ключа и результата DH
  // ck - это цепной ключ, определенный выше
  temp_key = HMAC-SHA256(ck, input_key_material)
  // перезаписывание результата DH в памяти, более не требуется
  input_key_material = (все нули)

  // Выход 1
  // Установление нового цепного ключа из временного ключа
  // byte() означает одиночный байт
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // Выход 2
  // Генерация ключа шифра k
  Определите k = 32 байта
  // || означает объединение
  // byte() означает одиночный байт
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
  // перезаписывание temp_key в памяти, более не требуется
  temp_key = (все нули)

  // сохранить цепной ключ ck для сообщения 2 KDF


  Конец "es" сообщения.

### 1) SessionRequest

Алиса отправляет Бобу.

Содержание Noise: эфемерный ключ Алисы X
Полезная нагрузка Noise: 16-байтовый блок опций
Не шумовая полезная нагрузка: случайное выравнивание

(Свойства безопасности полезной нагрузки)

XK(s, rs):           Аутентификация   Конфиденциальность
    -> e, es                  0                2

    Аутентификация: Отсутствует (0).
    Эта полезная нагрузка могла быть отправлена любой стороной, включая активного атакующего.

    Конфиденциальность: 2.
    Шифрование для известного получателя, с явным секретом для раскрытия отправителя,
    уязвимое для воспроизведения. Эта полезная нагрузка зашифрована только на основе DHs
    с использованием статической пары ключей получателя. Если статический
    частный ключ получателя скомпрометирован, даже в срок, это сообщение может быть
    расшифровано. Это сообщение также может быть воспроизведено, поскольку отсутствует эфемерный
    вклад от получателя.

    "e": Алиса генерирует новую пару эфемерных ключей и сохраняет ее в переменной e,
         записывает эфемерный открытый ключ в виде открытого текста в буфер сообщения,
         и хэширует открытый ключ вместе со старым h, чтобы получить новый h.

    "es": DH выполняется между эфемерной парой ключей Алисы и
          статической парой ключей Боба. Результат хэшируется вместе со старым ck,
          чтобы получить новый ck и k, и n установлен в ноль.


X значение зашифровано, чтобы обеспечить неразличимость полезной нагрузки
и уникальность, которые необходимы для противодействия DPI.
Мы используем шифрование AES, чтобы достичь этого,
вместо более сложных и медленных альтернатив, таких как elligator2.
Асимметричное шифрование с использованием открытого ключа маршрутизатора Боба было бы слишком медленным.
Шифрование AES использует хэш маршрутизатора Боба в качестве ключа и IV Боба, как это опубликовано в базе данных сети.

Шифрование AES предназначено только для защиты от DPI.
Любая сторона, знающая хэш маршрутизатора Боба и IV, который опубликован в базе данных сети,
может расшифровать X значение в этом сообщении.

Выравнивание не шифруется Алисой.
Бобу может понадобиться расшифровать выравнивание, чтобы противодействовать атакам на тайминг.


Сырой контент:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        обфусцируется с RH_B           +
  |       AES-CBC-256 зашифрованное X         |
  +             (32 байта)                +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaChaPoly фрейм                    |
  +             (32 байта)                +
  |   k определено в KDF для сообщения 1      |
  +   n = 0                               +
  |   см. KDF для связанных данных             |
  +----+----+----+----+----+----+----+----+
  |     нешифрованное аутентифицированное         |
  ~         выравнивание (опционально)            ~
  |     длина определена в блоке опций     |
  +----+----+----+----+----+----+----+----+

  X :: 32 байта, AES-256-CBC зашифрованный эфемерный ключ X25519, little-endian
          ключ: RH_B
          iv: Как опубликовано в записи сети Боба

  выравнивание :: Случайные данные, 0 или более байт.
             Общая длина сообщения должна быть 65535 байт или меньше.
             Общая длина сообщения должна быть 287 байт или меньше, если
             Боб публикует свой адрес как NTCP
             (см. раздел Определение версии ниже).
             Алиса и Боб будут использовать данные выравнивания в KDF для сообщения 2.
             Оно аутентифицированно, так что любое вмешательство вызовет
             сбой следующего сообщения.

Нешифрованные данные (бакалды POLY1305 не показаны):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                   X                   |
  +              (32 байта)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               опции                 |
  +              (16 байт)               +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     нешифрованное аутентифицированное         |
  +         выравнивание (опционально)            +
  |     длина определена в блоке опций     |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  X :: 32 байта, эфемерный ключ X25519, little-endian

  опции :: блок опций, 16 байт, см. ниже

  выравнивание :: Случайные данные, 0 или более байт.
             Общая длина сообщения должна быть 65535 байт или меньше.
             Общая длина сообщения должна быть 287 байт или меньше, если
             Боб публикует свой адрес как "NTCP"
             (см. раздел Определение версии ниже)
             Алиса и Боб будут использовать данные выравнивания в KDF для сообщения 2.
             Оно аутентифицированно, так что любое вмешательство вызовет
             сбой следующего сообщения.

Блок опций:
Примечание: Все поля большие - endian.

+----+----+----+----+----+----+----+----+
  | id | вер|  padLen | m3p2len | Rsvd(0) |
  +----+----+----+----+----+----+----+----+
  |        tsA        |   Резерв (0)    |
  +----+----+----+----+----+----+----+----+

  id :: 1 байт, идентификатор сети (в настоящее время 2, кроме тестовых сетей)
        По состоянию на 0.9.42. См. предложение 147.

  вер :: 1 байт, версия протокола (в настоящее время 2)

  padLen :: 2 байта, длина выравнивания, 0 или более
            Мин/макс рекомендации TBD. Случайный размер от 0 до 31 байт минимально?
            (Распределение для определения, см. Приложение A.)

  m3p2Len :: 2 байта, длина второго фрейма AEAD в "SessionConfirmed"
             (сообщение 3 часть 2) См. примечания ниже

  Rsvd :: 2 байта, установите 0 для совместимости с будущими опциями

  tsA :: 4 байта, Unix временная метка, беззнаковое целое количество секунд.
         Перекрывается в 2106 году

  Резерв :: 4 байта, установите 0 для совместимости с будущими опциями

Примечания
`````
- Когда опубликованный адрес - "NTCP", Боб поддерживает как NTCP, так и NTCP2 на
  одном порту. Для совместимости, при установлении соединения с адресом
  опубликованным как "NTCP", Алиса должна ограничить максимальный размер этого сообщения,
  включая выравнивание, до 287 байт или меньше. Это облегчает автоматическое определение протокола Бобом. Когда опубликован как "NTCP2", нет ограничений по размеру. См. опубликованные адреса и раздел определения версий ниже.

- Уникальное значение X в начальном блоке AES обеспечивает, что шифрованный текст
  отличается для каждой сессии.

- Боб должен отвергать соединения, где значение временной метки слишком сильно отличается от
  текущего времени. Назовите максимальное отклонение времени "D". Боб должен вести локальный
  кэш значений рукопожатия, используемых ранее, и отвергать дубликаты, чтобы предотвратить атаки воспроизведения. Значения в кэше должны иметь срок жизни как минимум 2*D. Значения кэша зависят от реализации, однако может использоваться 32-байтовое значение X (или его зашифрованный эквивалент).

- Диффи-Хеллман эфемерные ключи никогда не могут быть использованы повторно, чтобы предотвратить криптографические атаки,
  и повторное использование будет отвергаться как атака воспроизведения.

- Опции "KE" и "auth" должны быть совместимы, т.е. общий секретный ключ K должен
  быть соответствующего размера. Если будут добавлены другие опции "auth", это может
  неявно изменить значение флага "KE", чтобы использовать другой KDF или
  другой размер обрезки.

- Здесь Боб должен проверить, что эфемерный ключ Алисы - это допустимая точка на
  кривой.

- Выравнивание должно быть ограничено разумным количеством. Боб может отвергнуть соединения
  с чрезмерным выравниванием. Боб укажет свои опции выравнивания в сообщении 2.
  Мин/макс рекомендации TBD. Случайный размер от 0 до 31 байт минимально?
  (Распределение для определения, см. Приложение A.)

- При любой ошибке, включая AEAD, DH, отметку времени, очевидное повторное использование или
  сбой проверки ключа, Боб должен прекратить дальнейшую обработку сообщения и закрыть
  соединение без ответа. Это должно быть аномальным закрытием (TCP RST).
  Для сопротивления зондированию после сбоя AEAD Боб должен
  установить случайный таймаут (диапазон TBD), а затем прочитать случайное количество байт (диапазон TBD),
  до закрытия сокета.

- Смягчение DoS: DH - это относительно дорогостоящая операция. Как и в предыдущем протоколе NTCP,
  маршрутизаторы должны принимать все необходимые меры, чтобы предотвратить истощение ЦП или соединений.
  Установите ограничения на максимальное количество активных соединений и максимальное количество начатых соединений.
  Применяйте тайм-ауты для чтения (как для одного чтения, так и для общего времени для "медленного Loris").
  Ограничивайте повторные или одновременные соединения из одного источника.
  Поддерживайте черные списки для источников, которые систематически терпят неудачу.
  Не отвечайте на сбой AEAD.

- Для облегчения быстрого определения версии и рукопожатия реализации должны
  обеспечить, что Алиса буферизует и затем выталкивает всю содержимое первого
  сообщения сразу, включая выравнивание. Это увеличивает вероятность, что
  данные будут содержаться в одном TCP-пакете (если они не сегментированы ОС или
  средними боксами), и получены все сразу Бобом. Кроме того,
  реализации должны обеспечить, что Боб буферизует и затем выталкивает всю содержимое
  второго сообщения сразу, включая выравнивание. и что Боб
  буферизует и затем выталкивает всю содержимое третьего сообщения сразу.
  Это также для эффективности и для обеспечения эффективности случайного
  выравнивания.

- "вер." поле: Общий протокол Noise, расширения, а также NTCP протокол
  включая спецификации полезной нагрузки, указывающий NTCP2.
  Это поле может быть использовано для указания поддержки будущих изменений.

- Длина части сообщения 3 часть 2: Это размер второго фрейма AEAD (включая 16-байтный MAC)
  содержащий Router Info Алисы и дополнительное
  выравнивание, которое будет отправлено в сообщении "SessionConfirmed". Поскольку маршрутизаторы периодически регенерируют и перепубликуют
  свой Router Info, размер текущего Router Info может измениться до
  отправки сообщения 3. Реализации должны выбирать одну из двух стратегий:
  a) сохранить текущий Router Info для отправки в сообщение 3, чтобы размер был известен,
  и при необходимости добавить место для выравнивания;
  b) увеличить указанный размер достаточно, чтобы обеспечить возможное увеличение
  размера Router Info, и всегда добавлять выравнивание, когда сообщение 3 фактически отправлено.
  В любом случае, "m3p2len" длина, включенная в сообщение 1, должна быть точно равной
  размеру этого фрейма при отправке в сообщении 3.

- Боб должен завершать соединение, если любое входящее сообщение останется после валидации
  сообщения 1 и чтения выравнивания. От Алисы не должно быть дополнительных данных,
  так как Боб еще не ответил с сообщением 2.

- Поле идентификатора сети используется для быстрого обнаружения перекрестных сетевых соединений.
  Если это поле ненулевое и не совпадает с сетевым идентификатором Боба,
  Боб должен разорвать соединение и заблокировать дальнейшие подключения.
  По состоянию на 0.9.42. См. предложение 147 для дополнительной информации.


### Key Derivation Function (KDF) (для сообщения рукопожатия 2 и сообщения 3 часть 1)

```
// взять h, сохраненное из KDF сообщения 1
// MixHash(зашифрованное сообщение)
h = SHA256(h || 32-байтовая зашифрованная полезна нагрузка из сообщения 1)

// MixHash(выравнивание)
// Только если длина выравнивания не равна нулю
h = SHA256(h || случайное выравнивание из сообщения 1)

Это схема на основе "e" сообщения:

Боб генерирует свою эфемерную пару DH ключей e.

// h из KDF для сообщения рукопожатия 1
// Эфемерный ключ Y Боба
// MixHash(e.pubkey)
// || означает объединение
h = SHA256(h || e.pubkey);

// h используется в качестве связанных данных для AEAD в сообщении 2
// Сохраните Хэш h для сообщения 3 KDF

Конец "e" сообщения.

Это схема на основе "ee" сообщения:

// DH(e, re)
Определите input_key_material = 32-байтовый результат DH эфемерного ключа Алисы и эфемерного ключа Боба
Установите input_key_material = результат DH X25519
// перезапишите эфемерный ключ Алисы в памяти, более не требуется
// Алиса:
e(открытый и закрытый) = (все нули)
// Боб:
re = (все нули)

// MixKey(DH())

Определите temp_key = 32 байта
Определите HMAC-SHA256(key, data), как в [RFC-2104](https://tools.ietf.org/html/rfc2104)
// Генерация временного ключа из цепного ключа и результата DH
// ck - это цепной ключ, из KDF для сообщения рукопожатия 1
temp_key = HMAC-SHA256(ck, input_key_material)
// перезаписывание результата DH в памяти, более не требуется
input_key_material = (все нули)

// Выход 1
// Установление нового цепного ключа из временного ключа
// byte() означает одиночный байт
ck =       HMAC-SHA256(temp_key, byte(0x01)).

// Выход 2
// Генерация ключа шифра k
Определите k = 32 байта
// || ниже означает объединение
// byte() ниже означает одиночный байт
k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
// перезаписывание temp_key в памяти, более не требуется
temp_key = (все нули)

// сохранить цепной ключ ck для сообщения 3 KDF

Конец "ee" сообщения.
```

### 2) SessionCreated

Боб отправляет Алисе.

Содержание Noise: эфемерный ключ Y Боба
Полезная нагрузка Noise: 16-байтовый блок опций
Не шумовая полезная нагрузка: случайное выравнивание

(Свойства безопасности полезной нагрузки)

XK(s, rs):           Аутентификация   Конфиденциальность
    <- e, ee                  2                1

    Аутентификация: 2.
    Аутентификация отправителя устойчива к подделке при компрометации ключа (KCI).
    Аутентификация отправителя основана на эфемерно-статическом DH ("es" или "se")
    между статической парой ключей отправителя и эфемерной парой ключей получателя.
    При условии, что соответствующие закрытые ключи защищены, аутентификацию не удастся подделать.

    Конфиденциальность: 1.
    Шифрование на эфемерный получатель.
    Эта полезная нагрузка обладает явным секретом, так как шифрование включает эфемерно-эфемерный DH ("ee").
    Однако отправитель не аутентифицировал получателя,
    поэтому эта полезная нагрузка может быть отправлена любой стороне, включая активного атакующего.


    "e": Боб генерирует новую пару эфемерных ключей и сохраняет ее в переменной e,
    записывает эфемерный открытый ключ в виде открытого текста в буфер сообщения,
    и хэширует открытый ключ вместе со старым h, чтобы получить новый h.

    "ee": DH выполняется между эфемерной парой ключей Боба и эфемерной парой ключей Алисы.
    Результат хэшируется вместе со старым ck, чтобы получить новый ck и k, и n установлен в ноль.

Значение Y зашифровано, чтобы обеспечить неразличимость полезной нагрузки и уникальность, которые необходимы для противодействия DPI. Мы используем шифрование AES, чтобы достичь
этого, вместо более сложных и медленных альтернатив, таких как elligator2.
Асимметричное шифрование с использованием открытого ключа маршрутизатора Алисы было бы слишком медленным. Шифрование AES
использует хэш маршрутизатора Боба в качестве ключа и состояние AES из сообщения 1
(которое было инициализировано IV Боба, как опубликовано в базе данных сети).

Шифрование AES предназначено только для защиты от DPI. Любая сторона, знающая хэш маршрутизатора Боба
и IV, который опубликован в базе данных сети, и захватила первые 32 байта сообщения 1, может расшифровать значение Y в этом сообщении.

Сырой контент:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        обфусцировано с RH_B           +
  |       зашифрованное AES-CBC-256 Y         |
  +              (32 байта)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |   ChaChaPoly фрейм                    |
  +   Зашифрованные и аутентифицированные данные    +
  |   32 байта                            |
  +   k определено в KDF для сообщения 2      +
  |   n = 0; см. KDF для связанных данных  |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     нешифрованное аутентифицированное         |
  +         выравнивание (опционально)            +
  |     длина определена в блоке опций     |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 байта, зашифрованный AES-256-CBC эфемерный ключ X25519, little-endian
          ключ: RH_B
          iv: Используя состояние AES из сообщения 1

Нешифрованные данные (бакалды POLY1305 не показаны):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                  Y                    |
  +              (32 байта)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               опции                 |
  +              (16 байт)               +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     нешифрованное аутентифицированное         |
  +         выравнивание (опционально)            +
  |     длина определена в блоке опций     |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 байта, эфемерный ключ X25519, little-endian

  опции :: блок опций, 16 байт, см. ниже

  выравнивание :: Случайные данные, 0 или более байт.
             Общая длина сообщения должна быть 65535 байт или меньше.
             Алиса и Боб будут использовать данные выравнивания в KDF для сообщения 3 часть 1.
             Оно аутентифицированно, так что любое вмешательство вызовет
             сбой следующего сообщения.

Примечания
`````

- Здесь Алиса должна проверить, что эфемерный ключ Боба - это допустимая точка на
  кривой.

- Выравнивание должно быть ограничено разумным количеством.
  Алиса может отклонить соединения с чрезмерным выравнивание.
  Алиса укажет свои опции выравнивания в сообщении 3.
  Мин/макс рекомендации TBD. Случайный размер от 0 до 31 байт минимально?
  (Распределение для определения, см. Приложение A.)

- При любой ошибке, включая AEAD, DH, отметку времени, очевидное повторное использование или
  сбой проверки ключа, Алиса должна прекратить дальнейшую обработку сообщения и закрыть
  соединение без ответа. Это должно быть аномальным закрытием (TCP RST).

- Для облегчения быстрого рукопожатия реализации должны обеспечить, что Боб буферизует и затем выталкивает все содержимое первого сообщения сразу, включая выравнивание. Это увеличивает вероятность, что данные будут содержаться в одном TCP-пакете (если они не сегментированы ОС или средними боксами) и получены все сразу Алисой. Это также для эффективности и для обеспечения эффективности случайного выравнивания.

- Алиса должна завершить соединение, если любые входящие данные останутся после проверки
  сообщения 2 и чтения выравнивания. От Боба не должно быть дополнительных данных,
  поскольку Алиса еще не ответила с сообщением 3.

Блок опций:
Примечание: Все поля в big-endian.

+----+----+----+----+----+----+----+----+
  | Rsvd(0) | padLen  |   Резерв (0)    |
  +----+----+----+----+----+----+----+----+
  |        tsB        |   Резерв (0)    |
  +----+----+----+----+----+----+----+----+

  Резерв :: 10 байт всего, установите 0 для совместимости с будущими опциями

  padLen :: 2 байта, big-endian, длина выравнивания, 0 или более
            Мин/макс рекомендации TBD. Случайный размер от 0 до 31 байт минимально?
            (Распределение чтобы определить, см. Приложение A.)

  tsB :: 4 байта, big-endian, Unix временная метка, беззнаковое целое количество секунд.
         Перекрывается в 2106 году

Примечания
`````
- Алиса должна отклонять соединения, при которых значение временной метки слишком отклоняется от
  текущего времени. Назовите максимальное отклонение времени "D". Алиса должна поддерживать
  локальный кэш использованных ранее значений рукопожатия и отклонить дубликаты, чтобы
  предотвратить атаки воспроизведения. Значения в кэше должны иметь срок жизни, по крайней мере,
  2*D. Значения кэша зависят от реализации, однако может использоваться 32-байтовое значение Y
  (или его зашифрованный эквивалент).



### Шифрование для сообщения 3 часть 1, с использованием сообщения 2 KDF)

```
// взять h, сохраненное из KDF сообщения 2
// MixHash(зашифрованное сообщение)
h = SHA256(h || 24-байтовая зашифрованная полезная нагрузка из сообщения 2)

// MixHash(выравнивание)
// Только если длина выравнивания не равна нулю
h = SHA256(h || случайное выравнивание из сообщения 2)
// h используется в качестве связанных данных для AEAD в сообщении 3 часть 1, ниже

Это схема на основе "s" сообщения:

Определите s = статический открытый ключ Алисы, 32 байта

// EncryptAndHash(s.publickey)
// EncryptWithAd(h, s.publickey)
// AEAD_ChaCha20_Poly1305(key, nonce, associatedData, data)
// k из сообщения 1 рукопожатия
// n равно 1
зашифрованный текст = AEAD_ChaCha20_Poly1305(k, n++, h, s.publickey)
// MixHash(зашифрованный текст)
// || ниже означает объединение
h = SHA256(h || зашифрованный текст);

// h используется в качестве связанных данных для AEAD в сообщении 3 часть 2

Конец "s" сообщения.
```

### Key Derivation Function (KDF) (для сообщения 3 часть 2)

Это схема на основе "se" сообщения:

  // DH(s, re) == DH(e, rs)
  Определите input_key_material = 32-байтовый результат DH статического ключа Алисы и эфемерного ключа Боба
  Установите input_key_material = результат DH X25519
  // перезапишите эфемерный ключ Боба в памяти, более не требуется
  // Алиса:
  re = (все нули)
  // Боб:
  e(открытый и закрытый) = (все нули)

  // MixKey(DH())

  Определите temp_key = 32 байта
  Определите HMAC-SHA256(key, data), как в [RFC-2104](https://tools.ietf.org/html/rfc2104)
  // Генерация временного ключа из цепного ключа и результата DH
  // ck - это цепной ключ, из KDF для сообщения рукопожатия 1
  temp_key = HMAC-SHA256(ck, input_key_material)
  // перезаписывание результата DH в памяти, более не требуется
  input_key_material = (все нули)

  // Выход 1
  // Установление нового цепного ключа из временного ключа
  // byte() означает одиночный байт
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // Выход 2
  // Генерация ключа шифра k
  Определите k = 32 байта
  // || ниже означает объединение
  // byte() ниже означает одиночный байт
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).

  // h из сообщения 3 часть 1 используется в качестве связанных данных для AEAD в сообщении 3 часть 2

  // EncryptAndHash(payload)
  // EncryptWithAd(h, payload)
  // AEAD_ChaCha20_Poly1305(key, nonce, associatedData, data)
  // n равно 0
  зашифрованный текст = AEAD_ChaCha20_Poly1305(k, n++, h, payload)
  // MixHash(зашифрованный текст)
  // || ниже означает объединение
  h = SHA256(h || зашифрованный текст);

  // сохранить цепной ключ ck для KDF фазы данных
  // сохранить хэш h для KDF дополнительного симметричного ключа (SipHash) фазы данных

  Конец "se" сообщения.

  // перезаписывание temp_key в памяти, более не требуется
  temp_key = (все нули)

### 3) SessionConfirmed

Алиса отправляет Бобу.

Содержание Noise: статический ключ Алисы
Полезная нагрузка Noise: RouterInfo Алисы и случайное выравнивание
Не шумовая полезная нагрузка: отсутствует

(Свойства безопасности полезной нагрузки)


XK(s, rs):           Аутентификация   Конфиденциальность
    -> s, se                  2                5

    Аутентификация: 2.
    Аутентификация отправителя устойчива к подделке при компрометации ключа (KCI).  Аутентификация
    отправителя основана на эфемерно-статическом DH ("es" или "se")
    между статической парой ключей отправителя и эфемерной парой ключей получателя.
    При условии, что соответствующие закрытые ключи защищены, аутентификацию нельзя подделать.

    Конфиденциальность: 5.
    Шифрование для известного получателя, сильный за секрет вперед.  Эта полезная нагрузка
    зашифрована на основе эфемерно-эфемерного DH, а также эфемерно-статического DH
    с использованием статической пары ключей получателя.  При условии, что эфемерные закрытые
    ключи защищены, а получатель не подвергается активной подделке
    атакующего, который украл его статический закрытый ключ, эта полезная нагрузка не может быть
    расшифрована.

    "s": Алиса пишет свой статический открытый ключ из переменной s в
    буфер сообщения, зашифровывая его, и хэширует выход вместе со старым h,
    чтобы получить новый h.

    "se": DH выполняется между статической парой ключей Алисы и
    эфемерной парой ключей Боба.  Результат хэшируется вместе со старым ck,
    чтобы получить новый ck и k, и n установлен в ноль.

Это содержит два ChaChaPoly фрейма.
Первый - это зашифрованный статический открытый ключ Алисы.
Второй - это шумовая загрузка: зашифрованный RouterInfo Алисы, дополнительные
опции и дополнительное выравнивание. Они используют различные ключи, потому что функция MixKey()
вызывается между ними.

Сырой контент:

+----+----+----+----+----+----+----+----+
  |                                       |
  +   ChaChaPoly фрейм (48 байт)         +
  |   Зашифрованные и аутентифицированные         |
  +   статический ключ Алисы S                  +
  |      (32 байта)                       |
  +                                       +
  |     k определен в KDF для сообщения 2    |
  +     n = 1                             +
  |     см. KDF для связанных данных       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +     Длина указана в сообщении 1     +
  |                                       |
  +   ChaChaPoly фрейм                    +
  |   Зашифрованные и аутентифицированные         |
  +                                       +
  |       RouterInfo Алисы                |
  +       используя формат блока 2            +
  |       Опции Алисы (опционально)        |
  +       используя формат блока 1        +
  |       Произвольное выравнивание               |
  +       используя формат блока 254          +
  |                                       |
  +                                       +
  | k определен в KDF для сообщения 3 часть 2 |
  +     n = 0                             +
  |     см. KDF для связанных данных       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  S :: 32 байта, ChaChaPoly зашифрованный статический ключ X25519 Алисы, little-endian
       внутри 48-байтового фрейма ChaChaPoly

Нешифрированные данные (бакалды POLY1305 не показаны):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |              S                        |
  +       статический ключ Алисы                +
  |          (32 байта)                   |
  +                                       +
  |                                       |
  +                                       +
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                                       |
  +                                       +
  |       Блок RouterInfo Алисы          |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       Дополнительный блок опций          +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       Дополнительный блок выравнивания          +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  S :: 32 байта, статический ключ X25519 Алисы, little-endian

Notes
`````
- Боб должен выполнить обычную проверку Router Info.
  Убедитесь, что тип подписи поддерживается, проверьте подлинность подписи,
  проверьте попадание временной метки в диапазон и все другие необходимые проверки.

- Боб должен проверить, соответствует ли статический ключ Алисы, полученный в первом фрейме, статическому ключу в Router Info. Боб сначала должен искать Router Info для
  NTCP или NTCP2 Router Address с соответствующей версией (v) опции.
  См. опубликованные Router Info и неопубликованные Router Info разделы ниже.

- Если у Боба есть более старая версия RouterInfo Алисы в его netdb, проверьте
  что статический ключ в router info одинаков в обоих случаях, если он присутствует,
  и если более старая версия младше XXX дневной давности (см. ниже время поворота ключа).

- Здесь Боб должен проверить, что статический ключ Алисы - это допустимая точка на
  кривой.

- Опции должны быть включены, чтобы указать параметры выравнивания.

- При любой ошибке, включая AEAD, RI, DH, временную метку или сбой проверки ключа,
  Боб должен прекратить дальнейшую обработку сообщения и закрыть соединение без
  ответа. Это должно быть аномальным закрытием (TCP RST).

- Для облегчения быстрого рукопожатия реализации должны обеспечить, что Алиса
  буферизует и затем выталкивает всю содержимое третьего сообщения сразу,
  включая оба фрейма AEAD.
  Это увеличивает вероятность, что данные будут содержаться в одном TCP
  пакете (если они не сегментированы ОС или средними боксами), и
  получены все сразу Бобом. Это также для эффективности и для обеспечения эффективности
  случайного выравнивания.

- Длина части 2 сообщения 3 AEAD: Длина этого фрейма (включая MAC) отправляется Алисой в сообщении 1. См. это сообщение для важных примечаний о дополнении
  достаточно места для выравнивания.

- Длина части 2 сообщения 3 фрейма: Этот фрейм имеет такой же формат, как и
  фреймы фазы данных, за исключением того, что длина фрейма отправляется
  Алисой в сообщении 1. См. ниже форматы фреймов фазы данных.
  Фрейм должен содержать от 1 до 3 блоков в следующем порядке:
  1) Router Info Алисы блок (обязательный)
  2) Блок опций (опционально)
  3) Блок выравнивания (опционально)
  Этот фрейм никогда не должен содержать какого-либо другого типа блока.

- Выравнивание части 2 сообщения 3 не требуется, если Алиса добавляет фрейм фазы данных
  (опционально содержащий выравнивание), в конец сообщения 3 и отправляет оба сразу,
  так как это будет одним большим потоком байтов для наблюдателя.
  Поскольку Алиса обычно, но не всегда, имеет I2NP сообщение для отправки Бобу
  (поэтому она подключилась к нему), это рекомендуемая реализация,
  для эффективности и для обеспечения эффективности случайного выравнивания.

- Общая длина обоих фреймов сообщения 3 AEAD (части 1 и 2) составляет 65535 байт;
  часть 1 составляет 48 байт, поэтому максимальная длина фрейма части
