```markdown
---
title: "SSU2"
number: "159"
author: "eyedeekay, orignal, zlatinb, zzz"
created: "2021-09-12"
lastupdated: "2025-03-05"
status: "Closed"
thread: "http://zzz.i2p/topics/2612"
target: "0.9.56"
---

## Статус

План развёртывания:


| Функциональность | Тестирование (не по-умолчанию) | Включена по умолчанию |
|------------------|--------------------------------|-----------------------|
| Локальный тест кода | 2022-02 |
| Совместный тест кода | 2022-03 |
| Совместный тест в сети | 0.9.54 | 2022-05 |
| Заморозка базового протокола | 0.9.54 | 2022-05 |
| Базовая сессия | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Валидация адресов (повторный) 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Фрагментированный RI в рукопожатии 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Новый токен | 0.9.55 | 2022-08 | 0.9.57 | 2022-11 |
| Заморозка расширенного протокола 0.9.55 | 2022-08 |
| Релей | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Тест пиров | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Включение для случайных 2% | 0.9.55 | 2022-08 |
| Валидация пути | 0.9.55+ dev | 0.9.56 | 2022-11 |
| Миграция соединений | 0.9.55+ dev | 0.9.56 | 2022-11 |
| Флаг немедленного ACK | 0.9.55+ dev | 0.9.56 | 2022-11 |
| Вращение ключей | 0.9.57 | 2023-02 | 0.9.58 | 2023-05 |
| Отключение SSU 1 (i2pd) | 0.9.56 | 2022-11 |
| Отключение SSU 1 (Java I2P) | 0.9.58 | 2023-05 | 0.9.61 | 2023-12 |

Базовая сессия включает фазу рукопожатия и передачи данных.
Расширенный протокол включает в себя релей и тест пиров.



## Обзор

Данное предложение описывает протокол аутентифицированного согласования ключей для улучшения
стойкости [SSU] к различным формам автоматической идентификации и атак.

Структура предложения такова: представляются цели безопасности,
затем обсуждаются базовый протокол. Далее даётся полная спецификация
всех сообщений протокола. В заключение обсуждаются адреса роутеров и идентификация версий.

Как и другие транспорты I2P, SSU2 определяется
для точка-точка (роутер-к-роутеру) транспортировки I2NP сообщений.
Это не универсальный канал передачи данных.
Как и [SSU](/en/docs/transport/ssu/), он также предоставляет две дополнительные услуги:
Релей для обхода NAT и Тест Пиров для определения входной доступности.
Также он предоставляет третью услугу, отсутствующую в SSU, для миграции соединений
когда пир меняет IP или порт.


## Мотивация

SSU остаётся единственным уровнем протокола, требующим ElGamal, который весьма медленный.
Контроль потока для SSU комплексный и не работает должным образом.
Части SSU уязвимы для атак с подменой адресов.
Рукопожатие не использует Noise.



## Цели для Дизайна

- Уменьшение использования процессора за счёт устранения ElGamal. Использование X25519 для Диффи-Хеллмана.

- Сохранение функций теста пиров и релей и увеличение их безопасности.

- Упрощение реализации за счёт разрешения стандартных алгоритмов управления потоками.

- Уменьшение задержки установки соединения.
  Среднее время установки в текущий момент составляет около 135 мс для NTCP2 и 187 мс для SSU,
  даже несмотря на то, что NTCP2 требует дополнительного обхода; замена ElGamal в
  SSU2 должна его уменьшить, но и другие изменения могут помочь.

- Сохранение или увеличение максимальной пропускной способности по сравнению с SSU 1,
  измеряемое по диапазону смоделированных задержек и процентам потерь пакетов в тестовой сети.

- Предотвращение усиления трафика и атак с изменением маршрута с поддельных адресов источника
  через "валидацию адресов".

- Упрощение идентификации пакетов для уменьшения зависимости от запасных механизмов и
  эвристиков, которые чрезмерно усложняют код.

- Формализовать и улучшить миграцию соединений, когда IP или порт пира меняется.
  Не переносить соединения, пока валидация адреса не будет завершена, чтобы предотвратить атаки.
  Некоторые реализации SSU 1 используют дорогие эвристики для обработки изменений портов
  из-за привязки NAT. Известные реализации SSU 1 не могут полностью справиться с изменениями IP.

- Поддержка SSU 1 и 2 на одном порту, автоматическое определение и публикация как единое
  "транспортное средство" ([RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) в [NetDB](/en/docs/how/network-database/).

- Публикация поддержки только версии 1, 2 или 1+2 в NetDB в отдельном
  поле, и по умолчанию для только версии 1 (не связывайте поддержку версий с конкретной версией роутера)

- Убедитесь, что все реализации (Java/i2pd/Go) смогут добавить поддержку версии 2
  (или нет) по собственному графику

- Добавление случайного наращивания к каждому сообщению, включая сообщения рукопожатия и передачи данных.
  Всё наращивание должно быть покрыто MAC, в отличие от добавления в конце пакета в SSU 1.
  Обеспечьте механизм для обоих сторон запроса мин и макс наращивания
  и/или распределения наращивания. Специфика распределения наращивания зависит от реализации и может или
  не способствовать спецификации протокола.

- Скрытие заголовков и содержимого сообщений, которые не полностью зашифрованные
  достаточным образом, чтобы боксы DPI и сигнатуры AV не могли легко их классифицировать.
  Также убедитесь, что сообщения, отправляемые одному пиру или набору пиров, не
  имеют аналогичной битовой картины.

- Исправление потери бит в DH из-за формата Java [Ticket1112](http://{{ i2pconv('trac.i2p2.i2p') }}/ticket/1112), и ускорение DH
  посредством переключения на X25519.

- Переключение на настоящую функцию извлечения ключа (KDF), а не использование DH
  результата "как есть"

- Добавление "стойкости к зондированию" (как называемся в Tor); это включает стойкость к повторным атакам.

- Сохранение обмена аутентифицированными ключами в обе стороны (2W-AKE). 1W-AKE недостаточно
  для нашего применения.

- Полагаться на статический открытый ключ, опубликованный в RouterInfo, как часть
  аутентификации.

- Добавление опций/версии в рукопожатии для будущей расширяемости.

- Не увеличивать значительно нагрузку на CPU для установки соединений; если возможно,
  значительно её сократить.

- Удаление требования для добавления до кратности 16 байт
  при использовании шифрования AES в SSU 1.

- Использование стандартных ChaCha/Poly1305 для шифрования и MAC,
  замена шифрования AES и нестандартного MAC HMAC-MD5-128, использующемся в SSU 1.

- Использование отдельных шифровальных ключей для отправки и приема, вместо
  использования общих ключей в обоих направлениях, как это сделано в SSU 1.

- Использование 3-х сообщений, одного обхода для рукопожатия, как в [NTCP2](/en/proposals/111-ntcp-2/).
  Удаление задержки ожидания сообщений пакета, что делает
  [SSU](/en/docs/transport/ssu/) фактически рукопожатием с двумя обходами.

- Значительное улучшение эффективности ACK и NACK,
  что ужасно в SSU 1. Уменьшение необходимой полосы
  пропускания для ACK и NACK, и увеличение размера
  пакета, доступного для данных. Эффективное кодирование NACK-а для пропуска потерянного сообщений,
  что распространено по Wi-Fi.

- Снижение сложности, необходимой для реализации фрагментации I2NP сообщений.
  Обход механизмов фрагментации и кодирования для полных I2NP сообщений.

- Минимизация накладных расходов до добавления, особенно для ACK.
  Тогда как добавление будет добавлено,
  накладные расходы до добавления все равно будут накладными.
  Узлы с низкой полосой пропускания должны иметь возможность использовать SSU2.

- Поддержка меток времени для обнаружения повторных искажения и лицевой разницы.

- Предотвращение любых проблем с годом 2038 в метках времени, должно работать по крайней мере до 2106.

- Увеличение минимальной МТU с 620 до 1280 для производительности, облегчения реализации,
  и увеличения максимального размера I2NP сообщения.
  Фрагментация и повторная сборка очень дорогие.
  Обеспечение места для 1028-байтовых туннельных сообщений, большинство сообщений I2NP
  не будут требовать фрагментации.

- Увеличение максимальной МТU с 1488 (1484 для IPv6) до 1500 для эффективности.
  Удаление требования, что MTU должен быть кратен 16-ти.

- Увеличение максимального размера I2NP сообщения с приблизительно 32K в SSU 1
  до примерно 64 KB, как в NTCP2.

- Удаление подписи для полей IP и порта из рукопожатия,
  так что роутеры, которые не знают свою
  внешнюю IP и порт, смогут соединиться.

- Поддержка механизма обнаружения IP/порта из SSU 1 в рукопожатии,
 так что роутеры могут узнать свои внешние IP и порт.

- Включение представителей разработчиков роутеров для Java, C++ и Go в дизайн.



### Нецели

- Протестированные на пуленепробиваемости защиты от DPI... это будут подключаемые транспорты,
  [Prop109](/en/proposals/109-hashcash/).

- Транспорт, основанный на TLS (или аналогчный по виду HTTPS)... это будет [Prop104](/en/proposals/104-new-protocol/).

- Защита от DPI на основе времени (задержки в сообщениях/времени могут быть
  зависимыми от реализации; внутрисообщительные задержки могут быть введены в любой
  момент, включая перед отправкой случайного добавления, например). Искусственные
  задержки (что obfs4 называет IAT или интервал времени между прибытиями) независимы от
  самого протокола.

- Определенность участия в сессии (внутри есть подписи).

Обдуманные или дискутивные не-цели (возможно дополнительное обсуждение):

- Степень защиты от глубокого пакетного анализа (DPI)

- Пост-квантовая (PQ) безопасность

- Определенность участия



## Цели Безопасности

Мы рассматриваем три стороны:

- Алиса, которая желает установить новую сессию.
- Боб, с которым Алиса хочет установить сессию.
- Мэллори, "человек в середине", между Алисой и Бобом.

Не более двух участников могут быть вовлечены в активные атаки.

И Алиса, и Боб обладают парой статических ключей, которые содержатся
в их [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/).

Предлагаемый протокол пытается позволить Алисе и Бобу согласовать общий
секретный ключ (K) при следующих требованиях:

1) Безопасность частного ключа: ни Боб, ни Мэллори не узнают ничего о статическом
   частном ключе Алисы. Симметрично, Алиса ничего не узнает о статическом
   частном ключе Боба.

2) Сеансовый ключ K известен только Алисе и Бобу.

3) Идеальная прямая секретность: согласованный сеансовый ключ остаётся
   секретным в будущем, даже если статические частные ключи Алисы и/или Боба
   будут раскрыты после согласования ключа.

4) Двусторонняя аутентификация: Алиса убеждена, что она установила сессию
   с Бобом и наоборот.

5) Защита от онлайн DPI: обеспечьте, чтобы было не тривиально определить, что
   Алиса и Боб участвуют в протоколе, используя только простые техники
   глубокого пакетного анализа (DPI). См. ниже.

6) Ограниченная неопределённость: ни Алиса, ни Боб не могут отрицать участие в
   протоколе, но если один из них утечёт общий ключ, другая сторона может
   отрицать подлинность содержимого переданных данных.

Данное предложение пытается предоставить все пять требований на основе
протокола Station-To-Station (STS) [STS](https://en.wikipedia.org/wiki/Station-to-Station_protocol). Обратите внимание, что этот протокол
также является основой для протокола [SSU](/en/docs/transport/ssu/).


### Дополнительное обсуждение DPI

Мы предполагаем два компонента DPI:

Онлайн DPI
`````````````

Онлайн DPI инспектирует все потоки в реальном времени. Соединения могут быть заблокированы или
иным образом изменены. Данные соединения или его метаданные могут быть идентифицированы и
сохранены для оффлайнового анализа. Онлайн DPI не имеет доступа к сетевой базе данных I2P. Онлайн DPI
имеет только ограниченные возможности в реальном времени, включая расчёт длины,
осмотр полей и простые вычисления, такие как XOR. Онлайн DPI может выполнять
быстрые криптографические функции в реальном времени, такие как ChaCha20, AEAD и хеширование,
однако такие функции слишком дороги, чтобы применять их ко всем потокам. Любые применения
этих криптографических операций будут применены только для потоков на IP/портах,
ранее идентифицированных в результате оффлайнового анализа. Онлайн DPI не способен выполнять
высокоёмкие криптографические функции, такие как DH или elligator2.
Онлайн DPI не предназначен специально для обнаружения I2P, хотя может обладать
ограниченными правилами классификации для этих целей.

Цель заключается в предотвращении идентификации протокола онлайновым DPI.

Понятие онлайн DPI здесь учитывает следующие возможности противника:

1) Способность инспектировать все данные, отправленные или полученные целью.

2) Способность производить операции над наблюдаемыми данными, такие как
   применение блочного шифра или хеш-функции.

3) Способность сохранять и сравнивать с ранее отправленными сообщениями.

4) Способность изменять, задерживать или фрагментировать пакеты.

Однако, считается, что онлайн DPI имеет следующие ограничения:

5) Неспособность сопоставлять IP адреса с хэшами роутеров. Это тривиально
   с доступом к сетевой базе данных в реальном времени,
   однако требует, чтобы система DPI была специально спроектирована для
   обнаружения I2P.

6) Неспособность использовать временную информацию для обнаружения протокола.

7) Как правило, инструментарий онлайн DPI не предусматривает встроенные
   инструменты, специально разработанные для обнаружения I2P. Это включает
   создание "медовых банок", которые, например, включают в свои сообщения
   несоответствующую пэдингу случайность. Обратите внимание, что это не исключает
   систем машинного обучения или DPI-инструментов высокого уровня, если они отвечают
   остальным требованиям.

Для противодействия анализу полезной нагрузки обеспечивается,
что все сообщения неотличимы от случайных. Это также требует, чтобы их длина была
случайной, что сложнее, чем просто добавление случайного добавления. На самом
деле, в Приложении A аргументируется, что наивная (т.е. равномерная) схема добавления
не решает проблему. Приложение A, следовательно, предлагает включать либо
случайные задержки, либо разработать альтернативную схему добавления, которая может
обеспечить разумную защиту от предлагаемой атаки.

Для защиты от вышеописанного пункта 6, реализации должны включать случайные задержки
в протоколе. Такие методы не описаны в данном предложении, однако они могут
решить проблемы длины добавления. В резюме, предложение обеспечивает хорошую
защиту от анализа полезной нагрузки (при учёте соображений из приложения
A), однако только ограниченную защиту от поточного анализа.


Оффлайн DPI
``````````````

Оффлайн DPI, инспектирующий данные, сохранившиеся для последующего анализа
онлайн DPI. Оффлайн DPI может быть разработан специально для обнаружения I2P.
Оффлайн DPI имеет доступ к сетевой базе данных I2P в реальном времени.
Оффлайн DPI имеет доступ к этой и другим спецификациям I2P.
Оффлайн DPI обладает неограниченными вычислительными возможностями, включая
все криптографические функции, определённые в этой спецификации.

Оффлайн DPI не обладает возможностью блокировать существующие соединения.
Оффлайн DPI обладает возможностью отправки на хост/порт пакетов посредством
впрыскивания, в течение минут после установки соединения.
Оффлайн DPI имеет возможность выполнения репетиций предыдущих сообщений (модифицированных или нет) в течение
минут после установки соединения с целью "тестирования" или по другим причинам.

Не является целью предотвращение идентификации протокола оффлайн DPI.
Любая расшифровка запутанных данных в первых двух сообщениях,
реализуемая роутерами I2P, может быть также реализована оффлайн DPI.

Цель заключается в отбраковке попыток соединений при использовании повторного воспроизведения предыдущих сообщений.




### Валидация Адресов

Ниже процитировано из QUIC [RFC-9000](https://www.rfc-editor.org/rfc/rfc9000.html).
Каждый раздел следует пересмотреть и отредактировать.

Валидация адреса обеспечивает, что конечная точка не может быть использована для
атак с усилением трафика. В такой атаке пакет отправляется на
сервер с поддельной информацией источника, идентифицирующей
жертву. Если сервер генерирует больше или более объёмные пакеты
в ответ на этот пакет, нападающий может использовать сервер для отправки
большего объёма данных в направлении жертвы, чем он смог бы
отправить самостоятельно.

Основной защитой от атак усиления является проверка адреса, с которого
отправляет пакеты пир, чтобы гарантировать, что он может их получать.
Следовательно, после получения пакетов с адреса, который ещё не подтверждён,
точка должна ограничить объём данных, который она отправляет на
неподтверждённый адрес, тремя кратными объёму данных, полученных с этого
адреса. Это ограничение на объём ответов называется
лимитирования усиления.

Валидация адресов выполняется как во время установки соединений
(см. Раздел 8.1), так и во время миграции соединений (см. Раздел 8.2).

Валидация адресов во время установления соединения
`````````````````````````````````````````````````````

Установка соединения предполагает валидацию адресов
обеими конечными точками. В частности, получение пакета,
защищённого ключами Handshake, подтверждает, что пир успешно обработал
первоначальный пакет. После того, как точка успешно обработала пакет
Handshake от пира, она может считать адрес пира проверенным.

Дополнительно, точка МОЖЕТ считать адрес пира проверенным, если
он использует выбранный конечной точкой идентификатор соединения, и
это соединение содержит не менее 64 бит энтропии.

Для клиента, значение поля Destination Connection ID в
начальном пакете Initial позволяет ему подтвердить адрес сервера
как часть успешной обработки любого пакета. Начальные пакеты
отправляются с использованием ключей, выведенных из значения
(см. Раздел 5.2 [QUIC-TLS]). Или, альтернативно, значение
отображается сервером в пакете с помощью: Version Negotiation
(см. Раздел 6) или в Integrity Tag в пакете Retry (см.
Раздел 5.8 [QUIC-TLS]).

До завершения проверки адреса клиента, сервера НЕ ДОЛЖНЫ
отправлять больше данных, чем в три раза больше объёма данных,
полученных с него. Это ограничивает степень любой атаки усиления,
которая может быть инициирована с поддельными исходными адресами. Для
потребностей предотвращения усиления до проверки адреса, сервера
ДОЛЖНЫ учитывать все байты полезной нагрузки, полученные в уникально
принадлежащих этому соединению датаграммах. Это включает датаграммы,
содержащие пакеты, которые успешно обработаны, и датаграммы,
содержащие пакеты, которые все отброшены.

Клиенты ДОЛЖНЫ обеспечивать, чтобы полезные нагрузки UDP-датаграмм с
начальными пакетами Initial были не менее 1200 байт, добавляя
кадры PADDING по мере необходимости. Клиент, который отправляет
дополненные датаграммы, позволяет серверу отправлять больше данных до завершения
проверки адреса.

Потеря начального или Handshake-пакета от сервера может вызвать
застой, если клиент не отправляет дополнительные начальные или Handshake-пакеты.
Застой может возникнуть, когда сервер достигает лимита усиления, а клиент
получил подтверждения для всех отправленных данных. В этом случае клиент,
не имеющий причин для отправки дополнительных пакетов, не позволит серверу отправлять
больше данных, так как он не подтвердил адрес клиента. Чтобы предотвратить
застой, клиенты ДОЛЖНЫ отправлять пакет на время
Probe Timeout (PTO); см. Раздел 6.2 [QUIC-RECOVERY]. В частности, клиент ДОЛЖЕН
отправить начальный пакет Initial в UDP-дейтаграмме, содержащей как минимум 1200 байтов, если
он не имеет ключей Handshake, или отправить Handshake-пакет в противном случае.

Сервер может пожелать проверить адрес клиента до начала
криптографического рукопожатия. QUIC использует токен в начальном пакете
Initial, чтобы предоставить валидацию адреса до завершения рукопожатия.
Этот токен доставляется клиенту во время установления соединения
посредством пакета Retry (см. Раздел 8.1.2) или в предыдущем
соединении с помощью NEW_TOKEN-фрейма (см. Раздел 8.1.3).

Помимо ограничений, налагаемых на передачу данных до проверки адреса,
серверы также ограничиваются пределами, установленными контролером
перегрузки. Клиенты ограничиваются только контролером перегрузки.

Конструкция токена
```````````````````````````````````````````````````````

Токен, отправленный в NEW_TOKEN-фрейме или в Retry-пакете,
ДОЛЖЕН быть сконструирован таким образом, чтобы сервер смог определить, как
он был предоставлен клиенту. Эти токены передаются в одном и том же поле, но требуют
разного обращения от серверов.

Проверка адреса с использованием Retry-пакетов
```````````````````````````````````````````````````````

Получив начальный пакет Initial от клиента, сервер может запросить
проверку адреса посредством отправки Retry-пакета (см. Раздел 17.2.5),
содержащего токен. Этот токен ДОЛЖЕН повторять клиентом во всех
начальных пакетах Initial, отправленных им для этого соединения после
получения Retry-пакета.

В ответ на обработку начального пакета Initial, содержащего
токен, предоставленный в Retry-пакете, сервер не может отправить еще
один Retry-пакет; он может только отказать в соединении или позволить ему продолжиться.

Пока для атакующего невозможно сгенерировать допустимый токен для
его собственного адреса (см. Раздел 8.1.4) и клиент получает этот
токен, это доказывает серверу, что он его получил.

Сервер также может использовать Retry-пакет для отсрочки затрат на
состояние и обработку при установлении соединения.
Требование сервером предоставления иного идентификатора соединения вместе
с параметром transport original_destination_connection_id,
определённым в Разделе 18.2, заставляет сервер продемонстрировать, что он,
или субьект, с которым сервер сотрудничает, получил
начальный пакет Initial от клиента. Предоставление другого идентификатора подключения
также позволяет серверу некоторое управление маршрутизацией последующих пакетов.
Это может быть использовано для направления соединений на другой серверный экземпляр.

Если сервер получает начальный пакет Initial клиента, который содержит
недопустимый Retry-токен, но в остальном допустимый, он знает, что
клиент не примет другого Retry-токена. Сервер может отбросить
такой пакет и позволить клиенту истечь до обнаружения сбоя рукопожатия,
но это может налагать значительное временное наказание на клиента.
Вместо этого сервер ДОЛЖЕН немедленно закрыть (см. Раздел 10.2)
соединение с ошибкой INVALID_TOKEN. Обратите внимание, что у сервера
ещё не создано никакое состояние для соединения,
поэтому он не вступает в закрывающий период.

Пример использования Retry-пакета показан на рисунке 9.

```
Клиент                                                  Сервер

  Initial[0]: CRYPTO[CH] ->

                                                <- Retry+Token

  Initial+Token[1]: CRYPTO[CH] ->

                                 Initial[0]: CRYPTO[SH] ACK[1]
                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                 <- 1-RTT[0]: STREAM[1, "..."]

                Рисунок 9: Пример рукопожатия с Retry
```



Validation for Future Connections
```````````````````````````````````````````````````````

Сервер МОЖЕТ предоставить клиентам токен проверки адреса во время
одного соединения, который может быть использован при последующем
соединении. Проверка адреса особенно важна с 0-RTT, поскольку сервер
может отправить значительное количество данных клиенту в
ответ на 0-RTT-данные.

Сервер использует NEW_TOKEN-фрейм (см. Раздел 19.7) для предоставления
клиенту токена проверки адреса, который может быть использован для
подтверждения будущих соединений. В последующем соединении клиент включает
этот токен в начальные пакеты Initial для предоставления валидации
адреса. Клиент ДОЛЖЕН включить токен во все начальные пакеты Initial,
отправляемые им, если Retry не заменит его более новым.
Клиент НЕ ДОЛЖЕН использовать токен, предоставленный в Retry, для будущих соединений.
Сервера МОГУТ отбросить любой начальный пакет Initial, который не несёт
ожидаемый токен.

В отличие от токена, выдаваемого для Retry-пакета, который используется
сразу, токен, отправленный в NEW_TOKEN-фрейме, может быть использован
после некоторого времени. Таким образом, срок действия токена ДОЛЖЕН быть,
который может быть либо явным сроком истечения, либо временной меткой
выпуска, которая может быть использована для динамического вычисления
времени истечения. Сервер может сохранить время истечения или включить
его в зашифрованной форме в токен.

Токен, выданный с NEW_TOKEN, НЕ ДОЛЖЕН включать информацию, которая
может позволить наблюдателю связать значения с соединением, в котором
он был выдан. Например, он не может включать предыдущий
идентификатор соединения или информацию о адресах, если значения не
зашифрованы. Сервер ДОЛЖЕН гарантировать, что каждый NEW_TOKEN-фрейм,
который он отправляет, уникален для всех клиентов, за исключением
тех, которые отправляются в целях возврата потерь ранее отправленных
NEW_TOKEN-фреймов. Информация, позволяющая серверу различать токены от Retry
и NEW_TOKEN, МОЖЕТ быть доступна другим существам, кроме сервера.

Маловероятно, что номер клиентского порта останется прежним на двух
разных соединениях; следовательно, проверка валидности порта, скорее всего,
будет неуспешной.

Токен, полученный в NEW_TOKEN-фрейме, применим к любому серверу, с
которого клиент считает, что он имеет право доступа (например, серверы,
включённые в сертификат). Когда соединяется с сервером, для
которого клиент сохраняет применимый и неиспользованный токен, он ДОЛЖЕН
включать этот токен в поле Token своего начального пакета Initial.
Включение токена может позволить серверу подтвердить
адрес клиента без дополнительного обхода. Клиент НЕ ДОЛЖЕН включать
токен, который не применим к серверу, к которому он подключается,
если только клиент не имеет знаний о том, что сервер, выдавший токен, и
сервер, к которому клиент подключается, совместно управляют токенами.
Клиент МОЖЕТ использовать токен из любого предыдущего
соединения с этим сервером.

Токен позволяет серверу соотносить активность между соединением,
где токен был выпущен, и любым соединением, где
он использован. Клиенты, которые хотят разорвать
идентификационную преемственность с сервером, могут удалить
токены, предоставленные с использованием NEW_TOKEN-фрейма. В
сравнении токен, полученный в Retry-пакете, ДОЛЖЕН быть использован
немедленно во время попытки подключения и не может быть использован в
последующих попытках подключения.

Клиент НЕ ДОЛЖЕН повторно использовать токен из NEW_TOKEN-фрейма для
различных попыток соединения. Повторное использование токена позволяет
связывать соединения по сущностям на пути сети; см. Раздел 9.5.

Клиенты могут получать несколько токенов на одном соединении. За
исключением предотвращения связывания, любой токен может быть использован
в любой попытке соединения. Серверы могут отправлять дополнительные токены,
либо для разрешения проверки адреса для нескольких попыток соединения, либо для
замены старых токенов, которые могут стать недействительными. Для клиента это
двусмысленность означает, что отправка наиболее недавно неиспользованного токена
наиболее вероятно будет эффективной. Хотя сохранение и использование
старых токенов не имеет отрицательных последствий, клиенты могут
считать старые токены менее полезными для сервера для
подтверждения адреса.

Когда сервер получает начальный пакет Initial с токеном проверки
адреса, он ДОЛЖЕН пытаться подтвердить токен, если только он не
закончит подтверждение адреса. Если токен недействителен, сервер ДОЛЖЕН
действовать так, как если бы у клиента не был проверенный адрес,
включая потенциально отправку пакета Retry. Токены
предоставленные с NEW_TOKEN-фреймами и Retry-пакетами могут быть
отличены серверами (см. Раздел 8.1.1), и последние могут быть подтверждены
более строго. Если проверка прошла успешно, сервер ДОЛЖЕН
разрешить продолжение рукопожатия.

Примечание: Рациональным поведением будет считать клиента непроверенным,
вместо того чтобы отбросить пакет, так как клиент мог получить
токен в предыдущем соединении, используя NEW_token-фрейм, и если сервер
потерял состояние, он мог бы быть неспособен
подтвердить токен вообще, что приведёт к сбою соединения,
если пакет будет отброшен.

В бесстатическом дизайне сервер может использовать зашифрованные и
аутентифицированные токены, чтобы передать информацию клиентам, которую
сервер может восстановить и использовать для проверки адресов
клиентов. Токены не интегрированы в криптографическое
рукопожатие, и поэтому они не аутентифицированные. Например, клиент
может быть способным повторно использовать токен. Чтобы избежать атак, которые
эксплуатируют это свойство, сервер может ограничивать использование
токенов только информацией, необходимой для проверки
адресов клиентов.

Клиенты МОГУТ использовать токены, полученные в одном соединении, для
любых других попыток соединения, использующих ту же версию. Когда
выбирают токен для использования, клиенты не обязаны учитывать
другие свойства соединений, которые будут
раздвигаться, включая выбор возможных протоколов приложений,
билетов сессии или других свойств соединения.

Обеспечение целостности токена ID
```````````````````````````````````````````````````````

Токен проверки адресов ДОЛЖЕН быть трудным для угадывания. Включение
случайного значения с не менее 128 битами энтропии в токен будет
достаточно, но это зависит от того, что сервер запоминает значение,
которое он отправляет клиентам.

Схема на основе токена позволяет серверу выгрузить любое состояние,
связанное с проверкой, к клиенту. Для того, чтобы этот дизайн
работал, токен ДОЛЖЕН быть защищён от модификации или
фальсификации клиентами. Без такой защиты,
злонамеренные клиенты могут генерировать или угадать значения для
токенов, которые будут приняты сервером. Доступ только к серверу
требуется для использования ключа защиты целостности токенов.

Не существует необходимости в едином хорошо определённом формате для
токена, так как сервер, который генерирует токен, также его потребляет.
Токены, отправленные в Retry-пакетах, ДОЛЖНЫ включать информацию,
позволяющую серверу проверять, что IP-адрес и порт источника в
пакетах клиентов остаются неизменными.

Токены, отправленные в NEW_TOKEN-фреймах, ДОЛЖНЫ включать информацию,
позволяющую серверу проверять, что IP-адрес клиента не изменился с
момента выдачи токена. Сервера могут использовать токены из
NEW_TOKEN-фреймов при принятии решения не отправлять Retry-пакет,
даже если адрес клиента изменился. Если адрес клиента
изменился, сервер ДОЛЖЕН соблюдать лимит усиления;
см. Раздел 8. Обратите внимание, что в присутствии NAT это требование
может быть недостаточно, чтобы защитить другие хосты, которые
связаны с NAT от атак усиления.

Атакующие могут повторно воспроизводить токены, чтобы использовать серверы
как усилители в DDoS-атаках. Чтобы защититься от
таких атак, серверы ДОЛЖНЫ обеспечить, чтобы повторный
воспроизведение токенов было запрещено или ограничено. Сервера ДОЛЖНЫ
обеспечить, чтобы токены, отправленные в Retry-пакетах,
принимаются только в течение короткого времени, так как они немедленно
возвращаются клиентами. Токены, которые предоставлены в
NEW_TOKEN-фреймах (см. Раздел 19.7), должны быть действительными в течение
больше времени, но НЕ ДОЛЖНЫ приниматься несколько раз.
Серверы поощряются разрешать токены использоваться только один раз,
если возможно; токены МОГУТ включать дополнительную информацию о клиентах,
чтобы ещё более сузить применимость или повторное использование.

Проверка пути
```````````````````````````````````````````````````````

Проверка пути используется обеими сторонами во время миграции соединения
(см. Раздел 9) для проверки доступности после изменения адреса. В
проверке пути конечные точки проверяют достижимость
между конкретным локальным адресом и конкретным адресом пира, где
адрес представляет собой 2-кортеж IP-адреса и порта.

Проверка пути проверяет, что пакеты, отправленные на путь к пиру,
приняты пировым. Проверка пути используется для обеспечения того, что
пакет, принятый от мигрирующего соединения пира, не имеет подделанного
адреса источника.

Проверка пути не подтверждает, что пир может отправлять в обратном
направлении. Пакеты ACK не могут использоваться для проверки обратного
пути, так как они содержат недостаточную энтропию и могут быть
подделаны. Конечные точки независимо определяют достижимость на каждом
направлении пути, поэтому проверка обратной достигаемости может
быть выполнена пировым.

Проверка пути может быть выполнена в любое время любой конечной точкой.
Например, конечная точка может проверить, что пир всё ещё имеет
доступ к своему адресу после длительного периода затишья.

Проверка пути не предназначена в качестве механизма прохождения NAT.
Хотя механизм, описанный здесь, может быть эффективным для создания
NAT-соединений, поддерживающих прохождение NAT, предположения заключаются
в том, что одна конечная точка может принимать пакеты без
предварительной отправки пакетов на этот путь. Эффективное прохождение
NAT требует дополнительных механизмов синхронизации, которые здесь не
предоставляются.

Конечная точка МОЖЕТ включать другие фреймы с фреймами PATH_CHALLENGE и
PATH_RESPONSE, используемыми для проверки пути. Особенно, нуждам
I2NP. Конечная точка может включать кадры PADDING вместе с фреймом
PATH_CHALLENGE для Path Maximum Transmission Unit Discovery
(PMTUD); см. Раздел 14.2.1. Конечная точка может также включать
свои собственные фреймы PATH_CHALLENGE при отправке фрейма
PATH_RESPONSE.

Конечная точка использует новый идентификатор соединения для проб, отправленных с нового
локального адреса; см. Раздел 9.5. При проверке нового пути конечная
точка может гарантировать, что у её пира есть неиспользованный
идентификатор соединения для ответов. Отправка NEW_CONNECTION_ID и
PATH_CHALLENGE-фреймы в одном пакете, если позволяет
active_connection_id_limit пира, гарантирует, что у пира будет
доступен неиспользованный идентификатор соединения при отправке ответа.

Конечная точка может выбора одновременно проверять несколько путей.
Количество одновременных путей, используемых для проб, ограничено
количеством дополнительных идентификаторов соединения, которые она ранее
предоставила, так как каждый новый локальный адрес, используемый для
проверки, требует ранее неиспользованного идентификатора соединения.

Инициация проверки пути
```````````````````````````````````````````````````````

Для инициализации проверки пути конечная точка отправляет фрейм
PATH_CHALLENGE, содержащий непредсказуемую полезную нагрузку, на
путь, который будет проверяться.

Конечная точка МОЖЕТ отправлять несколько фреймов PATH_CHALLENGE для защиты от потерь
пакетов. Однако конечная точка НЕ ДОЛЖНА отправлять несколько фреймов
PATH_CHALLENGE в одном пакете.

Конечная точка НЕ ДОЛЖНА проверять новый путь с пакетами,
содержащими фрейм PATH_CHALLENGE, чаще, чем она отправляет
первоначальный пакет. Это гарантирует, что миграция соединения не
нагружает новый путь больше, чем установление нового соединения.

Конечная точка ДОЛЖНА использовать в каждом фрейме PATH_CHALLENGE
непредсказуемые данные, чтобы она могла ассоциировать ответ пира с
сопоставимым фреймом PATH_CHALLENGE.

Конечная точка ДОЛЖНА расширять дейтаграммы, содержащие фрейм
PATH_CHALLENGE, как минимум до минимального размероможефакаутом
наибольшей разрешённой дейтаграмме размера 1200 байт, если
лимит усиления на пути не позволяет отправить дейтаграмму
такого размера. Отправка UDP-дейтаграмм такого размера
гарантирует, что сетевой путь от конечной точки до пира может
быть использован для работы с QUIC; см. Раздел 14.

Когда конечная точка не может расширить дейтаграмму до 1200 байт
из-за лимита усиления, PMTUD не будет подтверждён. Для
гарантии, что PMTUD достаточно велик, конечная точка ДОЛЖНА
выполнить вторую проверку пути, отправив фрейм
PATH_CHALLENGE в дейтаграмме размером не менее 1200 байт.
Дополнительная проверка может быть выполнена после того, как
фрейм PATH_RESPONSE успешно принят, или когда достаточно
байтов принято на пути, чтобы отправка большей дейтаграммы
не привела к превышению лимита усиления.

В отличие от других случаев, когда дейтаграммы расширяются,
конечные точки НЕ ДОЛЖНЫ отбрасывать дейтаграммы, которые
кажутся слишком маленькими, когда они содержат фреймы
PATH_CHALLENGE или PATH_RESPONSE.

Ответы проверки пути
```````````````````````````````````````````````````````

При получении фрейма PATH_CHALLENGE конечная точка ДОЛЖНА
ответить, повторив данные, содержащиеся в фрейме
PATH_CHALLENGE, в виде фрейма PATH_RESPONSE. Конечная
точка НЕ ДОЛЖНА задерживать отправку пакета, содержащего фрейм
PATH_RESPONSE, если это не контролируется установлением
конгестии.

Фрейм PATH_RESPONSE ДОЛЖЕН быть отправлен на сетевой
путь, на который был получен фрейм PATH_CHALLENGE.
Это гарантирует, что проверка пути пира
успешна, только если путь функционален в обоих направлениях.
Это требование НЕ ДОЛЖНО выполняться
конечной точкой, которая инициирует проверку пути, так как
это позволяет атаке на миграцию; см. Раздел 9.3.3.

Конечная точка ДОЛЖНА расширять дейтаграммы, содержащие фрейм
PATH_RESPONSE, как минимум до минимального размероможефакаутом
наибольшей разрешённой дейтаграмме размера 1200 байт.
Это проверяет, что путь может передавать дейтаграммы такого
размера в обоих направлениях. Однако конечная точка НЕ ДОЛЖНА
расширять дейтаграмму, содержащую PATH_RESPONSE, если в результате
получаются данные, превышающие лимит усиления. Это ожидается
происходить только в случае, если принятый фрейм PATH_CHALLENGE
не был отправлен в расширенной дейтаграмме.

Конечная точка НЕ ДОЛЖНА отправлять более одного фрейма PATH_RESPONSE
в ответ на один фрейм PATH_CHALLENGE; см. Раздел 13.3. Ожидается, что
пир отправляет больше PATH_CHALLENGE-фреймов, если это
необходимо для вызова дополнительных PATH_RESPONSE-фреймов.

Успешная проверка пути
```````````````````````````````````````````````````````

Проверка пути успешна, когда фрейм PATH_RESPONSE
принимается с данными, полученными в предыдущем
фрейме PATH_CHALLENGE. Фрейм PATH_RESPONSE,
принятый на любом сетевом пути, подтверждает путь,
на который был отправлен фрейм PATH_CHALLENGE.

Если конечная точка отправляет фрейм PATH_CHALLENGE в дейтаграмме,
которая не расширена до как минимум 1200 байт, и если ответ на
него подтверждает адрес пира, путь считается
проверенным, но MTU не проверен. В результате
конечная точка может отправлять больше данных, чем в три раза
объём, полученного ранее. Однако конечная точка ДОЛЖНА
инициировать другую проверку пути с расширенной
дейтаграммой для проверки, что путь поддерживает требуемый MTU.

Приём ACK-пакета для пакета, содержащего фрейм PATH_CHALLENGE, не
достаточен для проверки, так как ACK может быть
подделан злонамеренным пировым.

Сбой проверки пути
```````````````````````````````````````````````````````

Проверка пути завершается неудачей, только если конечная точка,
пытающаяся проверить путь, отказывается от своей попытки
проверить путь.

Конечные точки ДОЛЖНЫ отказаться от проверки пути в зависимости от
таймера. При установке таймера реализации предостерегаются, что новый
путь может иметь более длительный круговой маршрут, чем
исходный. Рекомендуется значение в три
раза большее, чем большее из текущей PTO или PTO для
нового пути (используя kInitialRtt, как
определено в [QUIC-RECOVERY]).

Этот таймаут позволяет истечь нескольким PTO до
завершения проверки пути, так что потеря
единственного фрейма PATH_CHALLENGE или PATH_RESPONSE не
приведёт к сбою в проверке пути.

Обратите внимание, что конечная точка может принимать
пакеты, содержащие другие фреймы на новом пути, но для
проверки пути необходимо, чтобы принятый фрейм
PATH_RESPONSE включал соответствующие данные.

Когда конечная точка отклоняется от проверки пути, она
определяет, что путь непригоден. Это не обязательно
означает отказ соединения — конечные точки могут
продолжать отправлять пакеты через другие доступные пути.
Если условия соединения отсутствуют, конечная точка может ждать
нового пути или закрыть соединение. Конечная точка,
у которой нет допустимого сетевого пути к своему пировому,
МОЖЕТ сигнализировать это, используя ошибку соединения NO_VIABLE_PATH,
отметив, что это возможно только в случае, если сетевой путь
существует, но не поддерживает требуемый MTU (см.
Раздел 14).

Проверка пути может быть приостановлена по другим причинам,
кроме неудачи. Прежде всего, это может произойти, если
инициирована миграция соединения на новый путь, пока
проверка пути на старом пути ещё выполняется.

### Миграция соединения

Следующее скопировано из QUIC [RFC-9000](https://www.rfc-editor.org/rfc/rfc9000.html).
Каждый раздел следует пересмотреть и отредактировать.


Использование идентификатора соединения позволяет
соединениям выживать при изменениях адресов конечных точек
(IP-адрес и порт), таких как те, которые вызваны переходом
конечной точки на новую сеть. Этот раздел описывает
процесс, при котором конечная точка мигрирует на новый адрес.

Дизайн QUIC предполагает, что конечные точки сохраняют стабильный
адрес в течение всего времени выполнения рукопожатия. Конечная
точка НЕ ДОЛЖНА инициировать миграцию соединения до подтверждения
рукопожатия, как определено в Разделе 4.1.2 [QUIC-TLS].

Если пир отправил транспортный параметр disable_active_migration,
конечная точка также НЕ ДОЛЖНА отправлять пакеты (включая
пробные пакеты; см. Раздел 9.1) с другого локального адреса
на адрес, который использовал пир во время рукопожатия, если
только конечная точка не действовала в соответствии с транспортным
параметром preferred_address от пира. Если
пир нарушает это требование, конечная точка ДОЛЖНА либо
отбрасывать входящие пакеты на этом пути, не
генерируя Stateless Reset, либо продолжить проверку
пути и разрешить пирам мигрировать. Генерация Stateless Reset
или закрытие соединения позволили бы третьим
сторонам в сети вызвать закрытие соединений
путём подмены или иного манипулирования
наблюдаемым трафиком.

Не все изменения адреса пира являются намеренными или
активными миграциями. Пир мог испытать новый NAT
перепривязку: изменение адреса из-за промежуточного
устройства, обычно NAT, назначающего новый
исходящий порт или даже новый исходящий IP-адрес для потока.
Конечная точка ДОЛЖНА выполнять проверку пути (см. Раздел 8.2),
если она обнаруживает любое изменение адреса пира, если
только он ранее подтверждён.

Когда у конечной точки нет проверенного пути, на который
отправлять пакеты, она МОЖЕТ отказаться от состояния
сессии. Конечная точка, способная на миграцию соединения,
МОЖЕТ ждать нового пути, прежде чем отказаться от состояния
сессии.

Этот документ ограничивает миграцию соединений на новые клиентские
адреса, за исключением описанного в Разделе 9.6. Клиенты
несут ответственность за начало всех миграций.
Сервера не отправляют непроверенные пакеты (см. Раздел 9.1)
по адресу клиента, пока не увидят непроверенный пакет
из этого адреса. Если клиент получает пакеты с неизвестного
адреса сервера, клиент ДОЛЖЕН отбросить эти пакеты.

Проверка нового пути
`````````````````````````

Конечная точка МОЖЕТ проверять доступность пира с нового
локального адреса, используя проверку пути (см. Раздел 8.2) до
миграции соединения на новый локальный адрес. Сбой проверки пути
просто означает, что новый путь недоступен для этого соединения.
Сбой проверки не приводит к завершению соединения, если
доступны альтернативные допустимые пути.

Фреймы PATH_CHALLENGE, PATH_RESPONSE, NEW_CONNECTION_ID и PADDING
являются "проверочными фреймами", а все другие фреймы
являются "непроверочными фреймами". Пакет, содержащий только
проверочные фреймы, является "проверочным пакетом", а пакет,
содержащий любой другой фрейм, является "непроверочным пакетом".

Инициация миграции соединения
`````````````````````````````````````

Конечная точка может мигрировать соединение на новый локальный адрес
путём отправки пакетов, содержащих непроверочные фреймы, с этого адреса.

Каждая конечная точка проверяет адресы своих пиров во время
установления соединения. Таким образом, мигрирующая конечная точка может отправить
своему пиру, зная, что пир готов получить на
текущем адресе пира. Таким образом, конечная
точка может мигрировать на новый локальный адрес
без предварительной проверки адреса пира.

Для установления доступности на новом пути конечная точка
инициирует проверку пути (см. Раздел 8.2) на новом пути.
Конечная точка МОЖЕТ отложить проверку пути до того, как пир
отправит следующий непроверочный фрейм на новый адрес.

В ходе миграции новый путь может не поддерживать текущее
значение отправки. Следовательно, конечная точка сбрасывает
контроллер перегрузки и оценку времени
кругового маршрута, как описано в Разделе 9.4.

Новый путь может не обладать той же способностью ECN. Поэтому
конечная точка валидирует возможность ECN, как описано в Разделе 13.4.

Ответ на миграцию соединения
`````````````````````````````````````````````

Прием пакета с нового адреса пира, содержащего непроверочные
фреймы, указывает на то, что пир мигрировал на этот адрес.

Приемник, разрешивший миграцию, ДОЛЖЕН отправить последующие
пакеты на новый адрес пира и ДОЛЖЕН инициировать
проверку пути (см. Раздел 8.2) для проверки обладания пира адресом, если
валидация еще не выполняется. Если у получателя нет
неиспользованных идентификаторов соединения от пира, он не сможет
отправить что-либо на новом пути, пока пир его не обеспечит;
см. Раздел 9.5.

Конечная точка меняет адрес, на который отправляет пакеты, только в
ответ на непроверочные пакеты с наибольшим номером.
Это гарантирует, что конечная точка не отправляет пакеты на старый
адрес пира в случае, если пакеты были приняты вне
очереди.

Конечная точка МОЖЕТ отправлять данные на недостоверный адрес пира,
но она ДОЛЖНА защищать себя от возможных атак, как описано в
Разделах 9.3.1 и 9.3.2. Конечная точка МОЖЕТ пропускать проверку адреса
пира, если этот адрес был недавно использован. В частности, если
конечная точка возвращается к ранее проверенному пути после обнаружения
какой-либо ложной миграции, пропуская проверку адреса и
восстанавливая состояние потери и перегрузки, можно
уменьшить влияние атаки на производительность.

После изменения адреса, на который отправляются пакеты
непроверочные пакеты, конечная точка может отказаться от
проверки пути для других адресов.

Получение пакета с нового адреса пира может быть результатом
изменения порта NAT у пира.

После проверки нового адреса клиента сервер ДОЛЖЕН отправить
новые токены валидации адреса (см. Раздел 8) клиенту.

Подделка адресов пиров
`````````````````````````

Возможно, что пир подделывается, чтобы
вызвать значительные объёмы данных к
нежелательному хосту. Если
конечная точка отправляет значительно больше данных, чем
подделывающий пир, миграция соединения может быть
использована для увеличения объёма данных, которые
нападающий может генерировать против жертвы.

Как описано в Разделе 9.3, конечная точка обязана проверять
новый адрес пира для подтверждения обладания пира новым
адресом. До признания нового адреса пира недействительным,
конечная точка ограничивает объём данных, который она отправляет
на этот адрес; см. Раздел 8. В отсутствие этого
ограничения конечная точка рискует быть использованной для
атаки отказа в обслуживании против неожиданной жертвы.

Если без валидации адреса пира конечная точка не обязана
ограничивать скорость отправки.

Подмены на пути
`````````````````

Атакующий на пути может вызвать спонтанную миграцию
соединения, копируя и пересылая пакет с поддельным
адресом, чтобы он прибыл раньше оригинального пакета.
Пакет с обманутым адресом будет показан как часть
мигрирующего соединения, и оригинальный пакет будет приемным
как дубликат и отклонен. После спонтанной миграции
валидация адреса источника не будет успешной, так как
существующая на адресе отправки сущность не обладает
необходимыми криптографическими ключами для расшифровки или
ответа на фрейм PATH_CHALLENGE, отправленный к нему даже
при желании.

Чтобы предотвратить провал соединения из-за такой
спонтанной миграции, конечная точка ДОЛЖНА возвратиться
к последнему подтвержденному адресу пира, когда валидация нового
адреса пира не удалась. Кроме того, приём пакетов с
большими номерами пакетов с легитимного
адреса пира вызовет новую миграцию соединения. Это
спровоцирует отказ от валидации адреса ложной миграции, тем
самым ограничивая миграции, инициированные атакой при
вкалывании одного пакета.

Если конечной точке нет состояния о последнем
подтвержденном адресе пира, она ДОЛЖНА закрыть соединение
беззвучным удалением всех состояний соединения. Это приведет к
общей обработке новых пакетов на соединении. Например,
конечная точка МОЖЕТ отправить Stateless Reset в ответ на любые
последующие входящие пакеты.

Пересылка пакетов
``````````````````````````````````

Заблуждающий атакующий, который может наблюдать пакеты,
может пересылать копии подлинных пакетов конечным точкам.
Если скопированный пакет прибывает раньше оригинального
пакета, это будет представлено как переброска NAT.
Любой оригинал пакета будет отмечен, как дубликат,
и отклонен. Если атакующий умеет продолжать пересылку пакетов,
он может быть способен вызвать миграцию адреса
в противоположном направлении через атакующего. Это
размещает атакующего на пути, давая ему возможность
наблюдать или блокировать все последующие пакеты.

Этот стиль атаки полагается на атакующего на пути, который
имеет приблизительно те же характеристики, что и оригинальный
путь между конечными точками. Атака более надёжна, если
отправлено относительно немного пакетов или если потеря
пакетов совпадает с попыткой атаки.

Непроверивший пакет, принятый на оригинальном пути, который
увеличивает наибольший полученный номер пакета, приведёт к
перемещению конечной точки назад на этот путь.
Инициирование пакетов на этом пути увеличивает вероятность
того, что атака будет неудачной. Поэтому защита от этой
атаки полагается на инициацию обмена пакетами.

В ответ на явную миграцию конечные точки ДОЛЖНЫ
проверить ранее активный путь, используя фрейм PATH_CHALLENGE.
Это инициирует отправку новых пакетов на этот путь.
Если путь больше не действует, попытка проверки
сомнится нашла результат; если путь жизнеспособен, но
больше не желателен, проверка будет успешной, но только
приведет к отправке пробных пакетов на этот путь.

Конечная точка, получившая фрейм PATH_CHALLENGE на
активном пути, ДОЛЖНА отправить непроверяемый
пакет в ответ. Если непроверяемый пакет прибывает
до любой копии, сделанной атакующим, это приведет к
перемещению соединения назад на оригинальный путь. Любая
последующая миграция на другую дорогу возобновляет
весь этот процесс.

Эта защита несовершенна, но это не рассматривается как серьёзная
проблема. Если путь через атаку стабильно быстрее, чем
оригинальный путь, несмотря на многочисленные попытки использовать
этот оригинальный путь, невозможно отличить атаку от улучшения
маршрутизации.

Конечная точка также может использовать эвристику для улучшения обнаружения
этого стиля атаки. Например, перебрасывание NAT
маловероятно, если пакеты недавно были получены на старом пути;
аналогично, перебрасывание редко происходит на IPv6-путях.
Конечные точки могут также искать дублируемые пакеты.
И наоборот, изменение идентификатора соединения больше вероятно
указывает на намеренную миграцию, чем на атаку.

Обнаружение и управление перегрузкой
``````````````````````````````````````

Возможности, доступные на новом пути, могут отличаться от прежних
на пути. Пакеты, отправленные по старому пути, НЕ ДОЛЖНЫ
учитываться в управлении перегрузкой или оценке времени
кругового маршрута для нового пути.

После подтверждения обладания пиром своим новым адресом, конечная точка
ДОЛЖНА немедленно сбросить контроллер перегрузки и оценку
времени кругового маршрута для нового пути до начальных значений
(см. Приложения A.3 и B.3 [QUIC-RECOVERY]), если изменён только номер
порта. Поскольку изменения только портов обычно являются результатом
перепривязки NAT или другой активности промежуточного устройства,
конечная точка МОЖЕТ вместо этого сохранить свои состояния контроллера
перегрузки и оценки времени в противном случае вместо возврата
к начальным значениям. В случае, когда информация о перегрузке,
сохраненная от старого пути, используется на новом пути с
существенно различными характеристиками, отправитель может
отправлять слишком агрессивно, пока контроллер перегрузки
и оценка времени не адаптируются. Как правило, реализации
советуются быть осторожными при использовании предыдущих
значений на новом пути.

На стороне приёма может произойти заметная
перестановка пакетов, когда конечные точки отправляют данные и
исследуют с/на нескольких адресов во время миграции, так как два
получающихся пути могут иметь различные задержки. Получатель
пакетов на нескольких путях всё равно будет отправлять ACK-фреймы, охватывающие
все принятые пакеты.

Несмотря на то, что во время миграции соединения могут использовать несколько путей,
один контекст контроллера перегрузки и один контекст восстановления
потерь (как описано в [QUIC-RECOVERY]) могут быть
достаточными. Например, конечная точка может задержать переключение
на новый контекст управления перегрузкой до тех пор, пока не будет подтверждено,
что старый путь больше не нужен (как случай, описанный в
Разделе 9.3.3).

Отправитель может сделать исключения для пакетных пакетов, чтобы их
обнаружение потерь было независимым и не приводило к
неоправданному уменьшению скорости передачи контроллером
перегрузки. Конечная точка может установить отдельный таймер,
когда отправляется фрейм PATH_CHALLENGE, который завершится,
если будет получен соответствующий фрейм PATH_RESPONSE.
Если таймер истечёт, прежде чем будет получен фрейм PATH_RESPONSE,
конечная точка может отправить новый фрейм PATH_CHALLENGE и
перезапустить таймер на более длительный период. Этот таймер
ДОЛЖЕН быть установлен, как описано в Разделе 6.2.1 [QUIC-RECOVERY],
и НЕ ДОЛЖЕН быть более агрессивным.

Приватные последствия миграции соединения
`````````````````````````````````````````````````

Использование стабильного идентификатора соединения на нескольких сетевых
путях позволило бы пассивному наблюдателю соотнести
активность между этими путями. Конечная точка, которая перемещается
между сетями, может не захотеть, чтобы её активность была
соотнесена любым существом, за исключением её пира, поэтому, когда
отправляется с разных локальных адресов, используются
различные идентификаторы соединения, как обсуждается в Разделе 5.1.
Чтобы это было эффективно, конечные точки должны гарантировать,
что идентификаторы соединения, которые они предоставляют, не могут быть
связаны никаким другим существом.

В любом времени конечные точки МОГУТ изменить передаваемый
идентификатор соединения на значение, которое не использовалось на другом пути.

Конечная точка НЕ ДОЛЖНА использовать идентификатор соединения повторно при отправке из более
чем одного локального адреса – например, когда инициируется
миграция соединения, как описано в Разделе 9.2, или когда
проверяется новый сетевой путь, как описано в Разделе 9.1.

Аналогично, конечная точка НЕ ДОЛЖНА использовать идентификатор соединения повторно,
когда отправляется на более чем один адрес назначения. Из-за
изменений сети вне контроля её пира, конечная
точка может принимать пакеты с нового адреса источника
с тем же значением поля Destination Connection ID, в
этом случае она МОЖЕТ продолжать использовать текущий идентификатор соединения
с новым удалённым адресом, продолжая отправление с того же
локального адреса.

Эти требования по использованию идентификаторов соединения касаются
только отправки пакетов, поскольку непреднамеренные изменения пути без изменения
идентификатора соединения возможны. Например, после
периода сетевой неактивности переброска NAT может
привести к отправке пакетов новым путем, когда клиент
возобновляет отправку. Конечная точка реагирует на такое
событие, как описано в Разделе 9.3.

Использование различных идентификаторов соединения для пакетов, отправляемых в обоих направлениях на каждом новом
сетевом пути, исключает использование идентификатора соединения для
связи пакетов от одного соединения через различные сетевые пути.
Защита заголовков гарантирует, что номера пакетов не могут быть
использованы для соотношения активности. Это не предотвращает,
однако, использование других свойств пакетов, таких как
время или размер, для соотношения активности.

Конечная точка НЕ ДОЛЖНА инициировать миграцию с пира, который
запросил идентификатор соединения нулевой длины, потому что
трафик пути может быть тривиально соотнесён с трафиком по
старому пути. Если сервер способен сопоставить пакеты, содержащие
короткий идентификатор соединения с корректным соединением, это означает, что сервер
использует другую информацию для демультиплексирования
пакетов. Например, сервер может предоставить уникальный
адрес каждому клиенту – например, используя HTTP альтернативные
службы [ALTSVC]. Информация, которая может позволить
правильную маршрутизацию пакетов на нескольких сетевых путях,
также позволит соединить активность на данных путях
существами, кроме пира.

Клиент может захотеть уменьшить связываемость, переключаясь на новый
идентификатор соединения, источник UDP-порта или IP-адрес
(см. [RFC8981]) при отправке трафика после периода неактивности. Изменение
адреса, с которого отправляются пакеты одновременно, может привести
к обнаружению сервером миграции соединения. Это
гарантирует, что механизмы, поддерживающие миграцию, реализуются
даже для клиентов, которые не подверглись перекоммутации NAT или
настоящим миграциям. Изменение адреса может привести к
перезагрузке состояния контроллера перегрузки (см. Раздел 9.4),
поэтому адреса ДОЛЖНЫ изменяться нечасто.

Конечная точка, которая исчерпала доступные идентификаторы соединения,
не может проверять новые пути или инициировать миграцию, и не может отвечать
на пробы или усилия пира для миграции. Чтобы обеспечить возможность
миграции и чтобы пакеты, отправляемые на разные пути, не могли быть
соотнесены, конечные точки ДОЛЖНЫ предоставлять новые идентификаторы соединения
до того, как пирам мигрируют; см. Раздел 5.1.1. Если
пир мог исчерпать доступные идентификаторы соединения, мигрировавшая
конечная точка могла бы включить фрейм NEW_CONNECTION_ID во все пакеты,
отправляемые на новый сетевой путь.

Предпочтительный адрес сервера
`````````````````````````````````

QUIC позволяет серверам принимать соединения на одном IP-адресе
