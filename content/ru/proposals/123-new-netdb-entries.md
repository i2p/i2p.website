---
title: "Новые записи netDB"
number: "123"
author: "zzz, str4d, orignal"
created: "2016-01-16"
lastupdated: "2020-07-18"
status: "Open"
thread: "http://zzz.i2p/topics/2051"
supercedes: "110, 120, 121, 122"
---

## Статус

Части этого предложения уже завершены и реализованы в версиях 0.9.38 и 0.9.39.
Общие структуры, I2CP, I2NP и другие спецификации
теперь обновлены, чтобы отразить изменения, которые поддерживаются сейчас.

Завершенные части все еще могут быть подвергнуты небольшим изменениям.
Остальные части этого предложения все еще в разработке
и могут быть изменены значительно.

Поиск сервисов (типы 9 и 11) низкого приоритета и
не запланированы, и могут быть вынесены в отдельное предложение.


## Обзор

Это обновление и агрегирование следующих 4 предложений:

- 110 LS2
- 120 Meta LS2 для массового мультихоминга
- 121 Зашифрованный LS2
- 122 Неаутентифицированный поиск сервиса (anycasting)

Эти предложения в основном независимы, но для удобства мы определяем и используем
общий формат для нескольких из них.

Следующие предложения несколько связаны:

- 140 Невидимый мультихоминг (несовместим с этим предложением)
- 142 Новый криптошаблон (для новой симметричной криптографии)
- 144 ECIES-X25519-AEAD-Ratchet
- 145 ECIES-P256
- 146 Red25519
- 148 EdDSA-BLAKE2b-Ed25519
- 149 B32 для зашифрованного LS2
- 150 Garlic Farm Protocol
- 151 ЭЦП с ослеплением


## Предложение

Эта пропозиция определяет 5 новых типов DatabaseEntry и процесс для
их сохранения и извлечения из сетевой базы данных,
а также метод их подписания и проверки этих подписей.

### Цели

- Обратная совместимость
- LS2 используем с старой схемой мультихоминга
- Не требуется новая криптография или примитивы для поддержки
- Сохранять разделение криптографии и подписания; поддерживать все текущие и будущие версии
- Позволяет опциональные офлайн ключи для подписания
- Уменьшить точность временных меток, чтобы уменьшить возможность отслеживания
- Включить новую криптографию для целей
- Включить массовый мультихоминг
- Исправить несколько проблем с существующими зашифрованными LS
- Опциональное ослепление, чтобы уменьшить видимость для фладфиллов
- Зашифрованная поддерживает как одиночные, так и множественные отзываемые ключи
- Поиск сервисов для упрощения поиска аутпрокси, загрузки DHT приложений,
  и других применений
- Не ломать ничего, что полагается на 32-байтовые хэш-коды пунктов назначения, например, bittorrent
- Добавить гибкость к сетам с арендами через свойства, как у нас это есть в routerinfos.
- Поместить временную метку публикации и переменную экспирацию в заголовок, чтобы это работало даже
  если содержимое зашифровано (не выводить временную метку из ранней аренды)
- Все новые типы находятся в том же пространстве DHT и в тех же местах, что и существующие сеты с арендами,
  чтобы пользователи могли мигрировать из старого LS в LS2,
  или переключаться между LS2, Meta и Encrypted,
  без изменения точки назначения или хэша.
- Существующее назначение может быть преобразовано для использования офлайн ключей,
  или обратно в онлайн ключи, без изменения точки назначения или хэша.


### Несущиеся цели / Вне сферы

- Новый алгоритм ротации DHT или генерация общего случайного числа
- Конкретный новый тип шифрования и схема шифрования от конца до конца
  для использования этого нового типа будет в отдельном предложении.
  Здесь новая криптография не указана и не обсуждается.
- Новое шифрование для RIs или создания туннелей.
  Это будет в отдельном предложении.
- Методы шифрования, передачи и приёма сообщений I2NP DLM / DSM / DSRM.
  Не изменяется.
- Как генерировать и поддерживать Meta, включая внутреннюю коммуникацию между роутерами, управление, отказоустойчивость и координацию.
  Поддержка может быть добавлена в I2CP, или i2pcontrol, или новый протокол.
  Это может быть, а может и не быть стандартизировано.
- Как на самом деле реализовывать и управлять более длительными туннелями с истечением срока действия, или отменять существующие туннели.
  Это чрезвычайно сложно, и без этого не удастся сделать разумное выполнение плавного завершения работы.
- Изменения модели угроз
- Формат офлайн хранения или методы хранения/извлечения/обмена данными.
- Детали реализации здесь не обсуждаются и оставлены на усмотрение каждого проекта.



### Обоснование

LS2 добавляет поля для изменения типа шифрования и для будущих изменений протоколов.

Зашифрованный LS2 исправляет несколько проблем безопасности существующего зашифрованного LS,
используя асимметричное шифрование всего набора аренды.

Meta LS2 предоставляет гибкий, эффективный, действенный и масштабный мультихоминг.

Запись сервиса и список сервисов предоставляют услуги anycast, такие как просмотр имен
и загрузка DHT.


### Типы данных NetDB

Числа типов используются в I2NP Database Lookup/Store Messages.

Колонка с прямая отправкой к концу относится к тому, отправляются ли запросы/ответы на пункт назначения в Garlic Message.


Существующие типы:

            Данные NetDB            Тип запроса  Тип записи  
any                                       0           any     
LS                                        1            1      
RI                                        2            0      
exploratory                               3           DSRM    

Новые типы:

            Данные NetDB            Тип запроса  Тип записи   Станд. заголовок LS2?   Отправлено до конца?
LS2                                       1            3             да                  да
Зашифрованный LS2                         1            5             нет                 нет
Meta LS2                                  1            7             да                  нет
Запись сервиса                            нет           9             да                  нет
Список сервисов                           4           11             нет                 нет



Примечания
`````
- Типы поиска в настоящее время находятся в битах 3-2 в сообщении Database Lookup Message.
  Любые дополнительные типы потребуют использования бита 4.

- Все типы хранения нечетные, так как верхние биты в поле типа Database Store Message
  игнорируются старыми маршрутизаторами.
  Мы бы предпочли, чтобы разбор не удался как LS, а не как сжатый RI.

- Должен ли тип быть явным или неявным, или ни тем, ни другим в данных, охваченных подписью?



### Процесс поиска/записи

Типы 3, 5 и 7 могут возвращаться в ответ на стандартный поиск сетов с арендами (тип 1).
Тип 9 никогда не возвращается в ответ на запрос.
Тип 11 возвращается в ответ на новый тип поиска сервиса (тип 11).

Только тип 3 может быть отправлен в сообщении Garlic клиент-клиент.



### Формат

Типы 3, 7 и 9 имеют общий формат::

  Стандартный заголовок LS2
  - как определено ниже

  Часть, специфическая для типа
  - как определено ниже в каждой части

  Стандартная подпись LS2:
  - Длина как предполагается по типу подписи ключа подписания

Тип 5 (Зашифрованный) не начинается с пункта назначения и имеет
другой формат. См. ниже.

Тип 11 (Список сервисов) - это агрегирование нескольких записей сервиса и имеет
другой формат. См. ниже.


### Вопросы конфиденциальности/безопасности

TBD



## Стандартный заголовок LS2

Типы 3, 7 и 9 используют стандартный заголовок LS2, указанный ниже:


### Формат
::

  Стандартный заголовок LS2:
  - Тип (1 байт)
    На самом деле не в заголовке, но часть данных, охваченных подписью.
    Взять из поля Database Store Message.
  - Пункт назначения (387+ байтов)
  - Временная метка публикации (4 байта, big endian, секунды с эпохи, перегружается в 2106)
  - Истекает (2 байта, big endian) (смещение от временной метки публикации в секундах, макс. 18.2 часа)
  - Флаги (2 байта)
    Порядок битов: 15 14 ... 3 2 1 0
    Бит 0: Если 0, нет офлайн ключей; если 1, офлайн ключи
    Бит 1: Если 0, стандартный опубликованный сет аренд.
           Если 1, неопубликованный сет аренд. Не должен быть фладирован, опубликован или
           отправлен в ответ на запрос. Если этот сет аренд истекает, не запрашивайте
           в netdb новую, если не установлен бит 2.
    Бит 2: Если 0, стандартный опубликованный сет аренд.
           Если 1, этот незашифрованный сет аренд будет заслеплен и зашифрован при публикации.
           Если этот сет аренд истекает, запросите заслепленное местоположение в netdb для нового.
           Если этот бит установлен в 1, также установите бит 1 в 1.
           Начиная с версии 0.9.42.
    Биты 3-15: установлены в 0 для совместимости с будущими использованиями
  - Если флаг указывает на офлайн ключи, тест офлайн подписи:
    Временная метка истечения (4 байта, big endian, секунды с эпохи, перегружается в 2106)
    Тип транзитной подписи (2 байта, big endian)
    Публичный ключ транзитной подписи (длина как подразумевается по типу подписи)
    Подпись временной метки истечения, типа транзитной подписи и публичного ключа,
    по публичному ключу пункта назначения,
    длина как подразумевается по типу подписи публичного ключа пункта назначения.
    Этот тест может и должен быть создан офлайн.


Обоснование
``````````

- Неопубликованное/опубликованное: Для использования при отправке записи базы данных от конца до конца,
  отправляющий маршрутизатор может захотеть указать, что этот сет аренд не следует
  отправлять другим. В настоящее время мы используем эвристику для поддержания этого состояния.

- Опубликованный: Заменяет сложную логику, необходимую для определения 'версии' сет аренд. В настоящее время версия
  это время истечения срока последней аренды, и педантичный маршрутизатор должен увеличить это истечение по крайней мере на 1мс при
  публикации сета аренд, который просто удаляет старую аренду.

- Истекает: Позволяет истечению срока действия записи netdb быть раньше, чем истечение срока
  последнего сет аренд. Может быть не полезен для LS2, где сеты аренд
  ожидаются с максимальным истечением в 11 минут, но
  для других новых типов это необходимо (см. Meta LS и запись сервиса ниже).

- Офлайн ключи опциональны, чтобы уменьшить начальную/необходимую сложность реализации.


### Проблемы

- Можно еще больше уменьшить точность временной метки (10 минут?), но нужно будет добавить
  номер версии. Это может прервать мультихоминг, если только у нас нет
  шифрования с сохранением порядка?
  Вероятно, нельзя обойтись без временных меток вообще.

- Альтернатива: 3-байтная временная метка (эпоха / 10 минут), 1-байтовая версия, 2-байтовый истечение

- Является ли тип явным или неявным в данных / подписи? "Доменные" константы для подписи?


Примечания
`````

- Маршрутизаторы не должны публиковать LS чаще одного раза в секунду.
  Если они это делают, они должны искусственно увеличить временную метку публикации на 1
  по ранее опубликованному LS.

- Имплементации маршрутизаторов могут кэшировать временные ключи и подпись для
  избежания проверки каждый раз. В частности, фладфиллы и маршрутизаторы на
  обоих концах долгосрочных соединений, могут извлечь выгоду из этого.

- Офлайн ключи и подпись подходят только для долгосрочных пунктов назначения,
  т.е. серверов, а не клиентов.


## Новые типы DatabaseEntry


### LeaseSet 2

Изменения по сравнению с существующим LeaseSet:

- Добавление временной метки публикации, временной метки истечения, флагов и свойств
- Добавление типа шифрования
- Удаление ключа отзыва

Поиск с помощью
    Флаг Standard LS (1)
Запись с помощью
    Тип стандартного LS2 (3)
Запись в
    Хэш пункта назначения
    Этот хэш затем используется для генерации "ключа маршрутизации", как в LS1
Типичное истечение
    10 минут, как в обычном LS.
Опубликовано
    Пункт назначения

Формат
``````
::

  Стандартный заголовок LS2, указанный выше

  Стандартная часть, специфическая для типа LS2
  - Свойства (маппинг как указано в спецификации общих структур, 2 нулевых байта, если нет)
  - Число ключевых секций для последующего (1 байт, макс TBD)
  - Ключевые секции:
    - Тип шифрования (2 байта, big endian)
    - Длина ключа шифрования (2 байта, big endian)
      Это явно, чтобы фладфиллы могли парсить LS2 с неизвестными типами шифрования.
    - Ключ шифрования (указанное количество байтов)
  - Число lease2 (1 байт)
  - Lease2 (40 байтов каждый)
    Это аренды, но с 4-байтовым вместо 8-байтового истечения,
    секунды с эпохи (перегружается в 2106)

  Стандартная подпись LS2:
  - Подпись
    Если флаг указывает на офлайн ключи, это подписано временным публичным ключом,
    в противном случае, с помощью публичного ключа назначения
    Длина как подразумевается по типу подписи ключа подписания
    Подпись всего вышеизложенного.




Обоснование
```````````

- Свойства: Будущая расширяемость и гибкость.
  Размещены первыми на случай, если они необходимы для парсинга оставшихся данных.

- Множественные типы шифрования/пары открытого ключа
  для упрощения перехода на новые типы шифрования. Другой способ сделать это
  публиковать несколько сетов аренд, возможно, используя те же туннели,
  как мы делаем сейчас для добавление поддержки перехода от DSA к EdDSA назначениям.
  Идентификация входящего типа шифрования на туннеле
  может быть выполнена с помощью существующего механизма сессионных тегов, 
  и/или пробного дешифрования с использованием каждого ключа. Длины входящих
  сообщений также могут предоставить подсказку.

Обсуждение
``````````

Это предложение продолжает использовать публичный ключ в сет аренд в качестве
ключа для шифрования от-конца-до-конца, и оставляет поле публичного ключа в
 назначении неиспользуемым, как и сейчас. Тип шифрования не указан
 в ключевом сертификате цели, он останется 0.

 Отклоненная альтернатива - указать тип шифрования в ключевом сертификате назначения,
использовать публичный ключ в назначении и не использовать публичный ключ
в сет аренды. Мы не планируем это делать.

Преимущества LS2:

- Расположение фактического публичного ключа не изменяется.
- Тип шифрования или публичный ключ могут изменяться без изменения назначения.
- Убирается неиспользуемое поле отзыва
- Базовая совместимость с другими типами DatabaseEntry в этом предложении
- Позволяет множество типов шифрования

Недостатки LS2:

- Местоположение публичного ключа и типа шифрования отличается от RouterInfo
- Сохраняется неиспользуемый публичный ключ в сет аренд
- Требует реализации во всей сети; в альтернативе, экспериментальные
  типы шифрования могут использоваться, если разрешены фладфиллами
  (но см. связанные предложения 136 и 137 о поддержке экспериментальных
  типов подписей). Альтернативное предложение может
  быть легче реализовать и тестировать для экспериментальных типов шифрования.


Проблемы нового шифрования
```````````````````````````
Некоторые из этого выходят за рамки данного предложения,
но записываем заметки здесь, так как у нас нет
отдельного предложения по шифрованию.
См. также предложения по ECIES 144 и 145.

- Тип шифрования представляет комбинацию
  кривой, длины ключа и схемы от-конца-до-конца,
  включая KDF и MAC, если есть.

- Мы включили поле длины ключа, чтобы LS2 был
  разбираемым и проверяемым фладфиллом, даже для неизвестных типов шифрования.

- Первым новым типом шифрования, который будет предложен,
  вероятно, будет ECIES/X25519. То, как он будет использоваться от-конца-до-конца
  (либо слегка измененная версия ElGamal/AES+SessionTag
  или что-то совершенно новое, например ChaCha/Poly) будет указано
  в одном или нескольких отдельных предложениях.
  См. также предложения по ECIES 144 и 145.


Примечания
`````
- 8-байтное истечение в арендах изменено на 4 байта.

- Если мы когда-либо реализуем отзыв, мы можем сделать это с помощью поля истечения с нулями,
  или нулем аренд, или обоими. Нет необходимости в отдельном ключе отзыва.

- Ключи шифрования представлены в порядке предпочтения сервера, наиболее предпочтительные первыми.
  Поведение клиента по умолчанию основано на выборе первого подходящего ключа с
  поддерживаемым типом шифрования. Клиенты могут использовать другие алгоритмы выбора
  на основе поддержки шифрования, относительной производительности и других факторов.


### Зашифрованный LS2

Цели:

- Добавить ослепление
- Позволяет множество типов подписей
- Не требовать новых криптографических примитивов
- Опционально шифровать для каждого получателя, отзываемый
- Поддержка шифрования как стандартного LS2, так и Meta LS2

Зашифрованный LS2 никогда не отправляется в end-to-end garlic сообщении.
Используйте стандартный LS2, как указано выше.


Изменения относительно существующего зашифрованного LeaseSet:

- Шифровать все для безопасности
- Шифровать безопасно, не только с помощью AES.
- Шифровать для каждого получателя

Поиск с помощью
    Флаг standard LS (1)
Запись с помощью
    Зашифрованный тип LS2 (5)
Запись в
    Хэш ослепленного типа подписи и ослепленного публичного ключа
    Два байта типа подписи (big endian, например, 0x000b) || ослепленный публичный ключ
    Этот хэш затем используется для генерации "ключа маршрутизации", как в LS1
Типичное истечение
    10 минут, как в обычном LS, или часы, как в meta LS.
Опубликовано
    Пункт назначения


Определения
```````````
Мы определяем следующие функции, соответствующие криптографическим строительным блокам, используемым
для зашифрованного LS2:

CSRNG(n)
    n-байтный вывод из криптографически безопасного генератора случайных чисел.

    В дополнение к требованию, чтобы CSRNG был криптографически защищенным (и таким образом
    подходящим для генерации ключевого материала), он ДОЛЖЕН быть безопасным
    для использования некоторого n-байтного вывода в качестве ключевого материала, когда предыдущие и последующие
    за ним байтовые последовательности выставлены в сети (как например в соли, или зашифрованном
    дополнении). Реализации, полагающиеся на источник, которому можно не доверять, должны хешировать
    любой вывод, который будет экспонирован в сети [PRNG-REFS]_.

H(p, d)
    Хеш-функция SHA-256 принимает строку персонализации p и данные d и
    создает вывод длиной 32 байта.

    Использовать SHA-256 следующим образом::

        H(p, d) := SHA-256(p || d)

STREAM
    Потоковый шифр ChaCha20, как указано в [RFC-7539-S2.4]_, с начальным счетчиком,
    установленным в 1. S_KEY_LEN = 32 и S_IV_LEN = 12.

    ENCRYPT(k, iv, plaintext)
        Шифрует текст групповой клавишей k и nonce iv, который ДОЛЖЕН быть уникальным для ключа k.
        Возвращает шифр, который той же длины, что и текст.

        Весь шифр должен быть неотличим от случайного, если ключ секретен.

    DECRYPT(k, iv, ciphertext)
        Дешифрует текст с помощью ключа шифрования k и nonce iv. Возвращает текст.


SIG
    Схема подписи RedDSA (соответствует типу подписи 11) с ослеплением ключа.
    Он имеет следующие функции:

    DERIVE_PUBLIC(privkey)
        Возвращает открытый ключ, соответствующий заданному закрытому ключу.

    SIGN(privkey, m)
        Возвращает подпись закрытым ключом privkey для данного сообщения m.

    VERIFY(pubkey, m, sig)
        Проверяет подпись sig с использованием открытого ключа pubkey и сообщения m. Возвращает
        true, если подпись действительна, иначе false.

    Он также должен поддерживать следующие операции ослепления ключа:

    GENERATE_ALPHA(data, secret)
        Генерирует альфа для тех, кто знает данные и необязательный секретный.
        Результат должен быть идентично распределен как приватные ключи.

    BLIND_PRIVKEY(privkey, alpha)
        Ослепляет приватный ключ с использованием секретной альфы.

    BLIND_PUBKEY(pubkey, alpha)
        Ослепляет публичный ключ с использованием секретной альфы.
        Для заданной пары ключей (privkey, pubkey) действует следующая зависимость::

            BLIND_PUBKEY(pubkey, alpha) ==
            ВЫВЕСТИ_PUBLIC(BLIND_PRIVKEY(privkey, alpha))

DH
    Система генерации ключей Диффи-Хеллмана X25519. Приватные ключи имеют размер 32 байта, публичные ключи – 32
    байта, смещия давет ответы размером 32 байта. Поддерживает следующие
    функции:

    GENERATE_PRIVATE()
        Генерирует новый приватный ключ.

    DERIVE_PUBLIC(privkey)
        Возвращает публичный ключ, соответствующий данному закрытому ключу.

    DH(privkey, pubkey)
        Генерирует общий секрет от данных закрытого и публичного ключей.

HKDF(salt, ikm, info, n)
    Криптографическая функция производного ключа, принимающая некоторый входной ключевой материал ikm (который
    должен иметь хорошую энтропию, но может не быть равномерной случайной строкой), соль
    длиной 32 байта и контекстуально-специфическое значение "info", и генерирующая вывод
    размером n байт, подходящий для использования в качестве ключевого материала.

    Используйте HKDF как описано в [RFC-5869]_, используя хеш-функцию HMAC SHA-256
    как в [RFC-2104]_. Это означает, что SALT_LEN – максимум 32 байта.


Формат
``````
Формат зашифрованного LS2 состоит из трех вложенных слоев:

- Внешний слой содержит необходимую информацию в плейнтексте для хранения и поиска.
- Средний слой обрабатывает аутентификацию клиентов.
- Внутренний слой содержит фактические данные LS2.

Общий формат выглядит следующим образом::

    Layer 0 data + Enc(данные layer 1 + Enc(данные layer 2)) + Подпись

Обратите внимание, что зашифрованный LS2 заслеплен. Пункт назначения не находится в заголовке.
Местоположение хранения DHT - SHA-256(тип подписи || заслепленный публичный ключ), и вращается ежедневно.

Не использует стандартный заголовок LS2, указанный выше.

#### Слой 0 (внешний)
Тип
    1 байт

    На самом деле не в заголовке, но часть данных, охваченных подписью.
    Взять из поля Database Store Message.

Тип подписи заслепленного публичного ключа
    2 байта, big endian
    Это всегда будет тип 11, идентифицирующий демонический ключ Red25519.

Заслепленный публичный ключ
    Длина как подразумевается по типу подписи

Временная метка публикации
    4 байта, big endian

    Секунды с эпохи, перегружается в 2106

Истечет
    2 байта, big endian

    Смещение от временной метки публикации в секундах, максимум 18.2 часа

Флаги
    2 байта

    Порядок битов: 15 14 ... 3 2 1 0

    Бит 0: Если 0, нет офлайн ключей; если 1, офлайн ключи

    Остальные биты: установлены в 0 для совместимости с будущими использованиями

Транзитные данные ключа
    В случае, если флаг указывает на офлайн ключи

    Временная метка истечения
        4 байта, big endian

        Секунды с эпохи, перегружается в 2106

    Тип транзитной подписи
        2 байта, big endian

    Публичный ключ транзитной подписи
        Длина как подразумевается по типу подписи

    Подпись
        Длина как подразумевается по типу подписи заслепленного публичного ключа

        По временной метке истечения, типу транзитной подписи и публичному ключу.

        Проверено с помощью заслепленного публичного ключа.

lenOuterCiphertext
    2 байта, big endian

outerCiphertext
    lenOuterCiphertext байтов

    Зашифрованные данные layer 1. См. ниже для алгоритмов выведения ключей и шифрования.

Подпись
    Длина как подразумевается по типу подписи использованного ключа

    Подпись всего вышеизложенного.

    Если флаг указывает на офлайн ключи, подпись проверяется с помощью транзитного
    публичного ключа. В противном случае, подпись проверяется заслепленным публичным ключом.


#### Layer 1 (средний)
Флаги
    1 байт
    
    Порядок битов: 76543210

    Бит 0: 0 для всех, 1 для индивидуальной аутентификации клиента, если имеется

    Биты 3-1: Схема аутентификации, только если бит 0 установлен в 1 для индивидуальной аутентификации клиента, в противном случае 000
              000: DH аутентификация клиента (или нет индивидуальной аутентификации клиента)
              001: PSK аутентификация клиента

    Биты 7-4: Не используется, установлено в 0 для будущей совместимости

Данные проверки DH клиента
    Присутствуют только если бит 0 установлен в 1 и биты 3-1 установлены в 000.

    ephemeralPublicKey
        32 байта

    клиенты
        2 байта, big endian

        Число записей authClient следовать, 40 байтов каждая

    authClient
        Данные аутентификации для задания клиента.
        См. ниже для алгоритма аутентификации отдельного клиента.

        clientID_i
            8 байт

        clientCookie_i
            32 байта

Данные проверки PSK клиента
    Присутствуют только если бит 0 установлен в 1 и биты 3-1 установлены в 001.

    authSalt
        32 байта

    клиенты
        2 байта, big endian

        Число записей authClient следовать, 40 байтов каждая

    authClient
        Данные аутентификации для задания клиента.
        См. ниже для алгоритма аутентификации отдельного клиента.

        clientID_i
            8 байт

        clientCookie_i
            32 байта


innerCiphertext
    Длина подразумевается по lenOuterCiphertext (остальные данные)

    Зашифрованные данные layer 2. См. ниже для алгоритмов выведения ключей и шифрования.


#### Layer 2 (внутренний)
Тип
    1 байт

    Либо 3 (LS2), либо 7 (Meta LS2)

Данные
    Данные LeaseSet2 для указанных типов.

    Включает заголовок и подпись.


Выведение ключа слепленности
```````````````````````````

Мы используем следующую схему для ослепления ключа,
основанную на Ed25519 и ZCash RedDSA [ZCASH]_.
Подписи Re25519 основаны на кривой Ed25519, используя SHA-512 для хеша.

Мы не используем приложение Tor rend-spec-v3.txt A.2 [TOR-REND-SPEC-V3]_,
которое имеет аналогичные цели дизайна, так как его ослепленные публичные ключи
могут быть не в подгруппе основного порядка, с неизвестными последствиями для безопасности.


#### Цели

- Публичный ключ подписи в нескрытом пункте назначения должен быть
  Ed25519 (тип подписания 7) или Red25519 (тип подписания 11);
  никаких других типов подписей не поддерживается
- Если публичный ключ подписи находится в режиме офлайн, временный публичный ключ подписания также должен быть Ed25519
- Ослепление должно быть вычислительно простым
- Использовать существующие криптографические примитивы
- Ослепленные публичные ключи не могут быть скрыты обратно
- Ослепленные публичные ключи должны находиться на кривой Ed25519 и в подгруппе основного порядка
- Нужно знать публичный ключ подписи пункта назначения
  (полный пункт назначения не требуется) для выведения ослепленного публичного ключа
- Опционально предоставить дополнительный секрет, необходимый для выведения ослепленного публичного ключа


#### Безопасность

Безопасность схемы ослепления требует, чтобы
распределение альфа было таким же, как у нескрытых приватных ключей.
Однако, когда мы скрываем Ed25519 приватный ключ (тип подписания 7)
до Red25519 приватного ключа (тип подписания 11), распределение различное.
Чтобы удовлетворить требованиям секции 4.1.6.1 zcash [ZCASH]_,
Red25519 (тип подписания 11) также должен быть использован для нескрытых ключей, чтобы
"комбинация повторно случайного публичного ключа и подписи(ей)
под этим ключом не раскрывают ключ, из которого был повторно случайно обоснован."
Мы разрешаем тип 7 для существующих пунктов назначения, но рекомендуем
тип 11 для новых пунктов назначения, которые будут зашифрованы.



#### Определения

B
    Точка базы Ed25519 (генератор) 2^255 - 19 как в [ED25519-REFS]_

L
    Порядок Ed25519 2^252 + 27742317777372353535851937790883648493
    как в [ED25519-REFS]_

DERIVE_PUBLIC(a)
    Преобразование приватного ключа в публичный, как в Ed25519 (умножить на G)

alpha
    32-байтное случайное число, известное тем, кто знает пункт назначения.

GENERATE_ALPHA(destination, date, secret)
    Генерирует альфа для текущей даты для тех, кто знает пункт назначения и секрет.
    Результат должен быть идентично распределен, как приватные ключи Ed25519.

a
    Нескрытый 32-байтный EdDSA или RedDSA подписывающий приватный ключ, используемый для подписи пункта назначения

A
    Нескрытый 32-байтный EdDSA или RedDSA публичный ключ подписания в пункте назначения,
    = DERIVE_PUBLIC(a), как в Ed25519

a'
    Ослепленный 32-байтный EdDSA подписывающий приватный ключ, используемый для подписи зашифрованного сета аренд
    Это действительный EdDSA приватный ключ.

A'
    Ослепленный 32-байтный EdDSA публичный ключ подписания в пункте назначения,
    может быть выведен с помощью DERIVE_PUBLIC(a'), или из A и альфа.
    Это действительный EdDSA публичный ключ, на кривой и на подгруппе основного порядка.

LEOS2IP(x)
    Переверните порядок входных байтов на little-endian

H*(x)
    32 байта = (LEOS2IP(SHA512(x))) mod B, как в Ed25519 hash-and-reduce


#### Вычисления ослепления

Ежедневно (UTC) необходимо генерировать новый секрет alpha и ослепленные ключи.
Секретный alpha и ослепленные ключи вычисляются следующим образом.

GENERATE_ALPHA(destination, date, secret), для всех участвующих:

  ```text
// GENERATE_ALPHA(destination, date, secret)

  // secret является необязательным, иначе нулевой длины
  A = публичный ключ подписи пункта назначения
  stA = тип подписи A, 2 байта big endian (0x0007 или 0x000b)
  stA' = тип подписи ослепленного публичного ключа A', 2 байта big endian (0x000b)
  keydata = A || stA || stA'
  datestring = 8 байтов ASCII YYYYMMDD от текущей даты UTC
  secret = кодированная UTF-8 строка
  seed = HKDF(H("I2PGenerateAlpha", keydata), datestring || secret, "i2pblinding1", 64)
  // обработайте seed как 64-байтное little-endian значение
  alpha = seed mod L
```

BLIND_PRIVKEY(), для владельца, публикующего сет аренды:

  ```text
// BLIND_PRIVKEY()

  alpha = GENERATE_ALPHA(destination, date, secret)
  // Если для Ed25519 приватного ключа (тип 7)
  seed = приватный ключ подписания пункта назначения
  a = левая половина SHA512(seed) и обрезано как обычно для Ed25519
  // иначе, для Red25519 приватного ключа (тип 11)
  a = приватный ключ подписания пункта назначения
  // Сложение с использованием скалярной арифметики
  ослепленный подписывающий закрытый ключ = a' = BLIND_PRIVKEY(a, alpha) = (a + alpha) mod L
  ослепленный подписывающий публичный ключ = A' = DERIVE_PUBLIC(a')
```

BLIND_PUBKEY(), для клиентов, извлекающих сет аренды:

  ```text
// BLIND_PUBKEY()

  alpha = GENERATE_ALPHA(destination, date, secret)
  A = публичный ключ подписания пункта назначения
  // Сложение с использованием элементов группы (точек на кривой)
  ослепленный публичный ключ = A' = BLIND_PUBKEY(A, alpha) = A + DERIVE_PUBLIC(alpha)
```

Оба метода вычисления A' дают одинаковый результат, как и должно быть.



#### Подписание

Нескрытый сет аренды подписан несекрытым Ed25519 или Red25519 подписывающим приватным ключом
и проверен с использованием несекрытого Ed25519 или Red25519 подписывающего публичного ключа (типы подписания 7 или 11), как обычно.

Если публичный ключ подписи находится в режиме offline,
нескрытый сет аренды подписан несекрытым временным Ed25519 или Red25519 подписывающим приватным ключом
и проверяется несекрытым транзитным Ed25519 или Red25519 подписывающим публичным ключом (типы подписания 7 или 11), как обычно.
См. ниже для дополнительных примечаний о офлайновых ключах для зашифрованных сетов аренды.

Для подписания зашифрованного сета аренды мы используем Red25519, основанный на RedDSA [ZCASH]_
для подписи и проверки с использованием ослепленных ключей.
Подписи Red25519 основаны на кривой Ed25519, используя SHA-512 для хеша.

Red25519 идентичен стандартному Ed25519, кроме как указано ниже.


#### Вычисления подписания/проверки

Внешняя часть зашифрованного сета аренды использует ключи и подписи Red25519.

Red25519 почти идентичен Ed25519. Существуют два отличия:

Red25519 приватные ключи генерируются из случайных чисел и затем должны быть уменьшены mod L, где L определено выше.
Ed25519 приватные ключи генерируются из случайных чисел и затем "обрезаются" с использованием
побитовой маскировки к байтам 0 и 31. Это не делается для Red25519.
Функции GENERATE_ALPHA() и BLIND_PRIVKEY(), определенные выше, генерируют правильные
Red25519 приватные ключи используя mod L.

В Red25519, вычисление r для подписи использует дополнительные случайные данные,
и использует значение публичного ключа, а не хеш приватного ключа.
Из-за случайных данных каждая подписка Red25519 отличается, даже
при подписании тех же данных тем же ключом.

Подписание:

  ```text
T = 80 случайных байтов
  r = H*(T || публичныйключ || сообщение)
  // остальное то же, что и в Ed25519
```

Проверка:

  ```text
// то же, что и в Ed25519
```



Шифрование и обработка
```````````````````````
#### Выведение подкредитов
В рамках процесса ослепления, мы должны убедиться, что зашифрованный LS2 может быть
дешифрован только тем, кто знает соответствующий пункт назначения публичного ключа подписи.
Полный пункт назначения не требуется.
Для достижения этой цели мы выводим кредитиацию из подписи публичного ключа:

  ```text
A = пункт назначения публичного ключа подписи
  stA = тип подписи A, 2 байта big endian (0x0007 или 0x000b)
  stA' = тип подписи A', 2 байта big endian (0x000b)
  keydata = A || stA || stA'
  credential = H("credential", keydata)
```

Строка персонализации гарантирует, что кредитиация не конфликтует с каким-либо хешом, используемым
как ключ поиска DHT, таким как хеш просто назначения.

Для заданного ослепленного ключа мы затем выводим подкредитию:

  ```text
subcredential = H("subcredential", credential || заслепленныйпубличныйключ)
```

Подкредитиация включена в процесс выведения ключей ниже, так что эти
ключи привязаны к знанию публичного ключа подписи пункта назначения.

#### Шифрование слоя 1
Сначала подготавливается входной процесс для выведения ключей:

  ```text
outerInput = подкредитиация || временнаяМеткаПубликации
```

Затем генерируется случайная соль:

  ```text
outerSalt = CSRNG(32)
```

Затем выводится ключ, используемый для шифрования слоя 1:

  ```text
keys = HKDF(outerSalt, outerInput, "ELS2_L1K", 44)
  outerKey = keys[0:31]
  outerIV = keys[32:43]
```

Наконец, внутренний плейнтекст слоя шифруется и сериализуется:

  ```text
outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext)
```

#### Дешифрование слоя 1
Соль извлекается из внутреннего текста слоя шифрования:

  ```text
outerSalt = outerCiphertext[0:31]
```

Затем выводится ключ, использованный для шифрования слоя 1:

  ```text
outerInput = подкредитиация || временнаяМеткаПубликации
  keys = HKDF(outerSalt, outerInput, "ELS2_L1K", 44)
  outerKey = keys[0:31]
  outerIV = keys[32:43]
```

Наконец, внутренний шифртекст слоя дешифруется:

  ```text
outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end])
```

#### Шифрование слоя 2
Когда включена аутентификация клиента, ``authCookie`` вычисляется, как описано ниже.
Когда аутентификация клиента отключена, ``authCookie`` – это строка длиной ноль.

Шифрование продолжается, подобно слою 1:

  ```text
innerInput = authCookie || подкредитиация || временнаяМеткаПубликации
  innerSalt = CSRNG(32)
  keys = HKDF(innerSalt, innerInput, "ELS2_L2K", 44)
  innerKey = keys[0:31]
  innerIV = keys[32:43]
  innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext)
```

#### Дешифрование слоя 2
Когда включена аутентификация клиента, ``authCookie`` вычисляется, как описано ниже.
Когда аутентификация клиента отключена, ``authCookie`` – это строка длиной ноль.

Дешифрование продолжается подобно слою 1:

  ```text
innerInput = authCookie || подкредитиация || временнаяМеткаПубликации
  innerSalt = innerCiphertext[0:31]
  keys = HKDF(innerSalt, innerInput, "ELS2_L2K", 44)
  innerKey = keys[0:31]
  innerIV = keys[32:43]
  innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end])
```


Индивидуальная аутентификация клиента
``````````````````````````````````
Когда для пункта назначения включена индивидуальная аутентификация клиента, сервер поддерживает список
клиентов, которых он уполномочен дешифровать данные зашифрованного LS2. Данные,
хранимые для каждого клиента, зависят от механизма аутентификации и содержат
некоторую форму ключевых материалов, которые каждый клиент генерирует и отправляет
серверу через защищенный внешний канал.

Существуют два варианта реализации индивидуальной аутентификации клиента:

#### DH аутентификация клиента
Каждый клиент генерирует пару ключей DH ``[csk_i, cpk_i]`` и отправляет открытый ключ ``cpk_i``
на сервер.

Обработка сервера
^^^^^^^^^^^^^^^^^
Сервер генерирует новый ``authCookie`` и временную пару ключей DH:

  ```text
authCookie = CSRNG(32)
  esk = GENERATE_PRIVATE()
  epk = DERIVE_PUBLIC(esk)
```

Затем для каждого уполномоченного клиента сервер шифрует ``authCookie`` его открытым ключом:

  ```text
sharedSecret = DH(esk, cpk_i)
  authInput = sharedSecret || cpk_i || подкредитиация || временнаяМеткаПубликации
  okm = HKDF(epk, authInput, "ELS2_XCA", 52)
  clientKey_i = okm[0:31]
  clientIV_i = okm[32:43]
  clientID_i = okm[44:51]
  clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie)
```

Сервер помещает каждую пару ``[clientID_i, clientCookie_i]`` в слой 1
зашифрованного LS2, вместе с ``epk``.

Обработка клиента
^^^^^^^^^^^^^^^^^
Клиент использует его приватный ключ для вывода ожидаемого идентификатора клиента ``clientID_i``,
ключа шифрования ``clientKey_i`` и инициализирующего вектора ``clientIV_i``:

  ```text
sharedSecret = DH(csk_i, epk)
  authInput = sharedSecret || cpk_i || подкредитиация || временнаяМеткаПубликации
  okm = HKDF(epk, authInput, "ELS2_XCA", 52)
  clientKey_i = okm[0:31]
  clientIV_i = okm[32:43]
  clientID_i = okm[44:51]
```

Затем клиент ищет в данных авторизации слоя 1 запись, которая содержит
``clientID_i``. Если существует совпадающая запись, клиент дешифрует её, чтобы получить
``authCookie``:

  ```text
authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie_i)
```

#### Индивидуальная аутентификация клиента на основе предустановленного ключа (PSK)
Каждый клиент генерирует секретный 32-байтный ключ ``psk_i`` и отправляет его на сервер.
Альтернативно, сервер может сгенерировать секретный ключ и отправить его одному или нескольким клиентам.


Обработка на сервере
^^^^^^^^^^^^^^^^^
Сервер генерирует новый ``authCookie`` и соль:

  ```text
authCookie = CSRNG(32)
  authSalt = CSRNG(32)
```

Затем для каждого уполномоченного клиента сервер шифрует ``authCookie`` его предустановленным ключом:

  ```text
authInput = psk_i || подкредитиация || временнаяМеткаПубликации
  okm = HKDF(authSalt, authInput, "ELS2PSKA", 52)
  clientKey_i = okm[0:31]
  clientIV_i = okm[32:43]
  clientID_i = okm[44:51]
  clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie)
```

Сервер помещает каждую пару ``[clientID_i, clientCookie_i]`` в слой 1
зашифрованного LS2, вместе с ``authSalt``.

Обработка клиента
^^^^^^^^^^^^^^^^^
Клиент использует его предустановленный ключ для вывода ожидаемого идентификатора клиента ``clientID_i``,
ключа шифрования ``clientKey_i`` и инициализирующего вектора ``clientIV_i``:

  ```text
authInput = psk_i || подкредитиация || временнаяМеткаПубликации
  okm = HKDF(authSalt, authInput, "ELS2PSKA", 52)
  clientKey_i = okm[0:31]
  clientIV_i = okm[32:43]
  clientID_i = okm[44:51]
```

Затем клиент ищет в данных авторизации слоя 1 запись, которая содержит
``clientID_i``. Если существует совпадающая запись, клиент дешифрует её, чтобы получить
``authCookie``:

  ```text
authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie_i)
```

#### Соображения безопасности
Обе приведенные выше механизмы аутентификации клиентов предоставляют конфиденциальность членства клиента.
Субъект, который знает только Пункт Назначения, может видеть, сколько клиентов подписано в любое
время, но не может отслеживать, какие клиенты добавляются или отзываются.

Серверы ДОЛЖНЫ рандомизировать порядок клиентов каждый раз, когда они генерируют зашифрованный LS2, чтобы
предотвратить клиентам определение своего местоположения в списке и заключение, когда
другие клиенты добавлены или отозваны.

Сервер МОЖЕТ решить скрыть количество подписанных клиентов, вставляя случайные
записи в список данных аутентификации.

Преимущества DH аутентификации клиентов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- Безопасность схемы не зависит исключительно от внешнего канала обмена ключевыми материалами клиента.
  Приватный ключ клиента никогда не покидает его устройство, и поэтому противник,
  способный перехватить внешний канал обмена, но не способный взломать алгоритм DH,
  не может дешифровать зашифрованный LS2 или определить, насколько долго клиенту предоставляется
  доступ.

Недостатки DH аутентификации клиентов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- Требуется N + 1 операций DH на серверной стороне для N клиентов.
- Требуется одна операция DH на клиентской стороне.
- Требуется от клиента сгенерировать секретный ключ.

Преимущества PSK аутентификации клиентов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- Не требуется операций DH.
- Позволяет серверу генерировать секретный ключ.
- Позволяет серверу делиться одним ключом с несколькими клиентами, если это необходимо.

Недостатки PSK аутентификации клиентов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- Безопасность схемы критически зависит от внешнего канала обмена ключевыми материалами клиента.
  Противник, перехвативший канал обмена для определенного клиента, может дешифровать
  любой последующий зашифрованный LS2, для которого этот клиент уполномочен, а также определить,
  когда доступ клиента будет отозван.


Зашифрованный LS с Base 32 адресами
```````````````````````````````````

См. предложение 149.

Вы не можете использовать зашифрованный LS2 для bittorrent, из-за компактных ответов
объявления в 32 байтах. 32 байта содержат только хэш. Нет пространства для указания, что
сет аренд зашифрован или указывает типы подписей.



Зашифрованный LS с офлайн ключами
````````````````````````````````
Для зашифрованных сет аренд с офлайн ключами обязательно также генерировать ослепленные закрытые ключи до офлайн,
по одному на каждый день.

Поскольку необязательный блок офлайн подписи находится в незашифрованной части зашифрованного сета аренды,
любой собирающий скреплер фладфиллов может использовать его для отслеживания сета аренды (но не дешифровать его)
на протяжении нескольких дней.
Чтобы предотвратить это, владелец ключей должен также генерировать новые транзитные ключи
на каждый день.
Как транзитные, так и ослепленные ключи могут быть заранее сгенерированы и предоставлены в маршрутизатор
в пакете.

Для этого предложения не определен формат файла для упаковки множества транзитных и
ослепленных ключей и их предоставления клиенту или маршрутизатору.
В этом предложении также не определено улучшение I2CP, чтобы поддерживать
зашифрованные реплики сетов с арендами и офлайн ключами.



Примечания
`````

- Сервис, использующий зашифрованные сеты аренд, публикует зашифрованную версию в
  фладфиллы. Однако для эффективности он отправляет незашифрованные сеты аренд
  клиентам оберточном garlic сообщении после аутентификации (например, через белый список).

- Фладфиллы могут ограничивать максимальный размер до разумного значения, чтобы предотвратить злоупотребления.

- После дешифрования должно быть произведено несколько проверок, включая то,
  что внутренняя временная метка и истечение совпадают с теми, что на верхнем уровне.

- ChaCha20 была выбрана вместо AES. Хотя скорости подсхожи, если доступна аппаратная поддержка AES,
  ChaCha20 работает в 2.5-3 раза быстрее, если
  аппаратная поддержка AES недоступна, например, на устройствах ARM нижнего уровня.

- Мы не заботимся об скорости достаточно, чтобы использовать ключевой BLAKE2b. У него размер вывода
  достаточно велик, чтобы охватить самый большой n, который нам требуется (или мы можем вызвать его один раз
  для каждого желаемого ключа с аргументом счетчика). BLAKE2b значительно быстрее, чем SHA-256, и
  ключевой-BLAKE2b сократит общее количество вызовов хеш-функции.
  Однако см. предложение 148, где предложено, чтобы мы перешли на BLAKE2b по другим причинам.
  [НЕОФИЦИАЛЬНЫЕ-СКОРОСТИ-KDF]_


### Meta LS2

Он используется для замены мультихоминга. Как и любой сет аренд, он подписан
создателем. Это удостоверенный список хешей назначения.

Meta LS2 является верхом и, возможно, промежуточными узлами,
структуры дерева.
Он содержит ряд записей, каждая из которых указывает на LS, LS2 или другой Meta LS2
для поддержки массового мультихоминга.
Meta LS2 может содержать смесь записей LS, LS2 и Meta LS2.
Листья дерева всегда LS или LS2.
Дерево представляет собой DAG; циклы запрещены; клиенты, выполняющие запросы, должны обнаруживать и
отказываться от следования циклами.

Meta LS2 может иметь значительно более длительное истечение срока, чем стандартный LS или LS2.
Верхний уровень может иметь истечение срока в несколько часов после даты публикации.
Фладфиллы и клиенты будут накладывать ограничения на максимальное время истечения срока, которые TBD.

Сценарий использования для Meta LS2 – это массовый мультихоминг, но без
дополнительной защиты от корреляции маршрутизаторов к сетам аренд (во время перезапуска маршрутизатора), чем
предоставляется в настоящее время с LS или LS2.
Это эквивалентно "facebook" сценарию использования, который
вероятно не нуждается в защите от корреляции. Этот сценарий, вероятно, нуждается в офлайн ключах,
которые предоставляются в стандартном заголовке на каждом узле дерева.

Протокол обратной связи для координации между листовыми маршрутизаторами, промежуточными и мастером Meta LS подписантами
не определяется здесь. Требования чрезвычайно просты – просто проверьте, что
пир в сети, и публикуйте новый LS каждые несколько часов. Единственная сложность заключается
в выборе новых издающих надстроек на уровне мастера или промежуточного уровня Meta LS при сбое.

Смешанные и согласованные сеты аренд, где аренды от нескольких маршрутизаторов комбинируются, подписываются и публикуются
в едином сете аренд, документированы в предложении 140, "невидимый мультихоминг".
Это предложение неосуществимо в нынешнем виде, потому
что потоковые соединения не будут
"липкими" к одному маршрутизатору, см. http://zzz.i2p/topics/2335 .

Протокол обратной связи и взаимодействие с внутренностями роутеров и клиентов будет
достаточно сложен для невидимого мультихоминга.

Чтобы избежать перегрузки фадфилла на уровне мастера Meta LS, истечение должно
быть как минимум несколько часов. Клиенты должны кешировать мастер Meta LS и сохранять
его между перезапусками, если он не истечет.

Нам нужно определить некоторый алгоритм для клиентов, чтобы
проходить по дереву, включая резервные пути,
чтобы использование было распределено. Некоторая функция хеш дистанция, стоимость и случайность.
Если узел имеет и LS, или LS2, и Meta LS, нам нужно знать, когда он разрешает
использовать эти сеты аренды, и когда нужно продолжать проходить по дереву.




Поиск с помощью
    Флаг Standard LS (1)
Запись с помощью
    Meta LS2 тип (7)
Запись в
    Хеш пункта назначения
    Этот хеш затем используется для генерации ежедневного "ключа маршрутизации", как в LS1
Типичное истечение
    Часы. Максимум 18.2 часа (65535 секунд)
Опубликовано
    "мастерским" Пунктом Назначения или координатором, или промежуточными координаторами

Формат
``````
::

  Стандартный заголовок LS2, указанный выше

  Тип-специфическая часть Meta LS2
  - Свойства (маппинг как указано в спецификации общих структур, 2 нулевых байта, если нет)
  - Число записей (1 байт) Максимум TBD
  - Записи. Каждая запись содержит: (40 байтов)
    - Хеш (32 байта)
    - Флаги (2 байта)
      TBD. Установить все в ноль для совместимости с будущими использованиями.
    - Тип (1 байт) Тип сет аренд, на которые оно ссылается;
      1 для LS, 3 для LS2, 5 для зашифрованный, 7 для meta, 0 для неизвестного.
    - Стоимость (приоритет) (1 байт)
    - Истекает (4 байта) (4 байта, big endian, секунды с эпохи, перегружается в 2106)
  - Число отзывов (1 байт) Максимум TBD
  - Отзывы: Каждый отзыв содержит: (32 байта)
    - Хеш (32 байта)

  Стандартная подпись LS2:
  - Подпись (40+ байтов)
    Подпись всего вышеизложенного.

Флаги и свойства: на будущее использование


Примечания
`````
- Распределенная служба, использующая это, имела бы одного или нескольких "мастеров" с
  приватным ключом пункта назначения сервиса. Они бы (вне сети) определяли
  текущий список активных пунктов назначения и публиковали Meta LS2. Для
  обеспечения надежности, несколько мастеров могут мультихомить (т.е. одновременно публиковать) Meta LS2.

- Распределенная служба могла бы начать с одного пункта назначения или использовать старый стиль
  мультихоминга, затем перейти к Meta LS2. Стандартный поиск LS может вернуть
  любой из LS, LS2 или Meta LS2.

- Когда служба использует Meta LS2, у нее нет туннелей (аренды).


### Запись сервиса

Это индивидуальная запись, которая указывает, что пункт назначения участвует в
сервисе. Она отправляется от участника в фладфилл. Никогда не отправляется
самостоятельно фладфиллом, только как часть Списка сервисов. Запись сервиса также
используется для отзыва участия в сервисе, установив
истечение на ноль.

Это не LS2, но использует стандартный формат заголовка и подписи LS2.

Поиск с помощью
    n/a, см. Список сервисов
Запись с помощью
    Тип записи сервиса (9)
Запись в
    Хэш имени сервиса
    Этот хэш затем используется для генерации "ключа маршрутизации", как в LS1
Типичное истечение
    Часы. Максимум 18.2 часа (65535 секунд)
Опубликовано
    Пункт назначения

Формат
``````
::

  Стандартный заголовок LS2, указанный выше

  Тип-специфическая часть записи сервиса
  - Порт (2 байта, big endian) (0, если не указан)
  - Хэш имени сервиса (32 байта)

  Стандартная подпись LS2:
  - Подпись (40+ байтов)
    Подпись всего вышеизложенного.


Примечания
`````
- Если истечение все нули, фладфилл должен отозвать запись и больше не
  включать ее в список сервиса.

- Хранение: Фладфилл строго ограничивает хранение этих записей и
  ограничивает количество записей на хэш и их истечение. Может также использоваться белый список
  хэшей.

- Любой другой тип netdb на том же хэше имеет приоритет, поэтому запись сервиса никогда не
  перезаписывает LS/RI, но LS/RI перезаписывает все записи сервиса на этом хэше.



### Список сервисов

Это совсем не похоже на LS2 и использует другой формат.

Список сервисов создается и подписывается фладфиллом. Он неаутентифицирован
в том смысле, что любой может присоединиться к сервису, опубликовав Запись сервиса для
фладфилла.

Список сервисов содержит краткие записи сервиса, а не полные записи сервиса. Эти
содержат подписи, но только хэши, не полные пункты назначения, поэтому они не могут быть
проверены без полного пункта назначения.

Безопасность, если оно будет таковым, и желания сервисов TBD.
Фладфиллы могли бы ограничивать публикацию и поиск до белого списка сервисов,
но этот белый список может варьироваться в зависимости от реализации, или предпочтений оператора.
Может не быть возможно достичь консенсуса по общему, базовому белому списку
между реализациями.

Если имя сервиса включено в запись выше,
то операторы фладфиллов могут возразить; если только хэш включен,
нет верификации, и запись сервиса может "получить" доступ впереди
любого другого типа netdb и храниться в фладфилле.

Поиск с помощью
    Тип поиска списка сервисов (11)
Запись с помощью
    Тип списка сервисов (11)
Запись в
    Хэш имени сервиса
    Этот хэш затем используется для генерации "ключа маршрутизации", как в LS1
Типичное истечение
    Часы, не указаны в самом списке, согласно локальной политике
Опубликовано
    Никто, никогда не отправляется в фладфилл, никогда не фладируется.

Формат
``````
Не использует стандартный заголовок LS2, указанный выше.

::

  - Тип (1 байт)
    На самом деле не в заголовке, но часть данных, охваченных подписью.
    Взять из поля Database Store Message.
  - Хэш имени сервиса (скрытый, в сообщении Database Store)
  - Хэш создателя (фладфилл) (32 байта)
  - Временная метка публикации (8 байтов, big endian)

  - Число Кратких записей сервиса (1 байт)
  - Список Кратких записей сервиса:
    Каждая Краткая запись сервиса содержит (90+ байтов)
    - Хеш назначения (32 байта)
    - Временная метка публикации (8 байтов, big endian)
    - Истечет (4 байта, big endian) (смещение от публикации в мс)
    - Флаги (2 байта)
    - Порт (2 байта, big endian)
    - Длина подписи (2 байта, big endian)
    - Подпись назначения (40+ байтов)

  - Число записей отзыва (1 байт)
  - Список записей отзыва:
    Каждая запись отзыва содержит (86+ байтов)
    - Хеш назначения (32 байта)
    - Временная метка публикации (8 байтов, big endian)
    - Флаги (2 байта)
    - Порт (2 байта, big endian)
    - Длина подписи (2 байта, big endian)
    - Подпись назначения (40+ байтов)

  - Подпись фладфилла (40+ байтов)
    Подпись всего вышеизложенного.

Чтобы проверить подпись Списка сервисов:

- prepend хэш имени сервиса
- удалить хэш создателя
- Проверить подпись модифицированного содержимого

Чтобы проверить подпись каждого Краткого записи сервиса:

- Получить пункт назначения
- Проверить подпись (публикованная временная метка + истечение + флаги + порт + Хэш имени
  сервиса)

Чтобы проверить подпись каждой Записи отзыва:

- Получить пункт назначения
- Проверить подпись (публикованная временная метка + 4 нулевых байта + флаги + порт + Хэш
  имени сервиса)

Примечания
`````
- Мы используем длину подписи вместо типа подписи, чтобы поддерживать неизвестные типы
  подписей.

- Нет истечения срока действия списка сервисов, получатели могут принимать собственное
  решение, зависящее от политики или истечения индивидуальных записей.

- Списки сервисов не фладируются, только индивидуальные записи сервиса. Каждый
  фладфилл создает, подписывает и кеширует Список сервисов. Каждый использует свою
  политику для времени кеша и максимального количества записей сервисов и проверок.


## Необходимые изменения спецификации Общих Структур


### Сертификаты ключей

Не в рамках данного предложения.
См. предложения ECIES 144 и 145.


### Новые промежуточные структуры

Добавить новые структуры для Lease2, MetaLease, LeaseSet2Header и OfflineSignature.
Действительно, начиная с релиза 0.9.38.


### Новые Типы NetDB

Добавить структуры для каждого нового типа сет аренд, взятые из выше приведенной информации.
Для LeaseSet2, EncryptedLeaseSet и MetaLeaseSet,
действует начиная с релиза 0.9.38.
Для записи сервиса и списка услуг,
предварительно и не запланировано.


### Новый Тип Подписи

Добавить RedDSA_SHA512_Ed25519 Тип 11.
Публичный ключ – 32 байта; приватный ключ – 32 байта; хеш – 64 байта; подпись – 64 байта.



## Необходимые Изменения Спецификации Шифрования

Не входит в рамки данного предложения.
См. предложения 144 и 145.



## Необходимые Изменения I2NP

Добавить примечание: LS2 может быть опубликован только в фладфиллы с минимальной версией.


### Сообщение Поиска в Базе Данных

Добавить тип поиска списка сервисов.

Изменения
```````
::

  Байты флагов: поле типа поиска, в настоящее время биты 3-2, расширяются на биты 4-2.
  Тип поиска 0x04 определяется как поиск списка услуг.

  Добавить примечание: Поиск списка услуг может быть отправлен только в фладфиллы с минимальной версией.
  Минимальная версия – 0.9.38.


### Сообщение Записи в Базу Данных

Добавьте все новые типы записей.

Изменения
```````
::

  Байты типа: поле типа, в настоящее время бит 
