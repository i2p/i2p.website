---
title: "ECIES-X25519-AEAD-Ratchet"
number: "144"
author: "zzz, chisana, orignal"
created: "2018-11-22"
lastupdated: "2025-03-05"
status: "Closed"
thread: "http://zzz.i2p/topics/2639"
target: "0.9.46"
implementedin: "0.9.46"
---

## Примечание
Внедрение и тестирование в сети в процессе.
Подлежит небольшим изменениям.
Смотрите [SPEC]_ для официальной спецификации.

Следующие функции не реализованы в версии 0.9.46:

- MessageNumbers, Options, и Termination блоки
- Ответные протоколы на уровне протокола
- Нулевой статический ключ
- Мультикаст


## Обзор

Это предложение для первого нового типа сквозного шифрования
с начала I2P, чтобы заменить ElGamal/AES+SessionTags [Elg-AES]_.

Оно основывается на предыдущих работах следующим образом:

- Спецификация общих структур [Common]_
- Спецификация [I2NP]_ включая LS2
- ElGamal/AES+Session Tags [Elg-AES]_
- Обзор нового асимметричного шифрования http://zzz.i2p/topics/1768
- Краткий обзор криптографии [CRYPTO-ELG]_
- ECIES http://zzz.i2p/topics/2418
- [NTCP2]_ [Prop111]_
- 123 Новые записи netDB
- 142 Новый шаблон криптографии
- Протокол [Noise]_
- Алгоритм двойного ратчета [Signal]_

Цель - поддержка нового шифрования для сквозного общения,
от назначения к назначению.

Дизайн будет использовать рукопожатие Noise и фазу передачи данных, включая двойной ратчет Signal.

Все ссылки на Signal и Noise в этом предложении предоставлены только для справочной информации.
Знание протоколов Signal и Noise не требуется для понимания
или реализации этого предложения.


### Текущие использования ElGamal

Как обзор,
256-байтные открытые ключи ElGamal можно найти в следующих структурах данных.
Обратитесь к спецификации общих структур.

- В Router Identity
  Это ключ шифрования маршрутизатора.

- В Destination
  Открытый ключ назначения использовался для старого шифрования i2cp-to-i2cp
  которое было отключено в версии 0.6, в настоящее время не используется, кроме как
  для IV в шифровании LeaseSet, который устарел.
  Вместо этого используется открытый ключ в LeaseSet.

- В LeaseSet
  Это ключ шифрования назначения.

- В LS2
  Это ключ шифрования назначения.



### EncTypes в Key Certs

Как обзор,
мы добавили поддержку типов шифрования, когда добавили поддержку типов подписи.
Поле типа шифрования всегда равно нулю, как в Destinations, так и в RouterIdentities.
Будет ли это когда-либо изменено, TBD.
Смотрите спецификацию общих структур [Common]_.




### Ассиметричные использования криптографии

Как обзор, мы используем ElGamal для:

1) Сообщения о построении туннеля (ключ находится в RouterIdentity)
   Замена не охватывается этим предложением.
   Смотрите предложение 152 [Prop152]_.

2) Шифрование между маршрутизаторами для netdb и других I2NP сообщений (ключ находится в RouterIdentity)
   Зависит от этого предложения.
   Также требует предложения для 1) или вставки ключа в параметры RI.

3) Клиентское сквозное ElGamal+AES/SessionTag (ключ находится в LeaseSet, ключ назначения не используется)
   Замена ОХВАТЫВАЕТСЯ этим предложением.

4) Эфемерные DH для NTCP1 и SSU
   Замена не охватывается этим предложением.
   Смотрите предложение 111 для NTCP2.
   В настоящее время нет предложения для SSU2.


### Цели

- Обратная совместимость
- Требует и основывается на LS2 (предложение 123)
- Использование новых криптографических основных элементов, добавленных для NTCP2 (предложение 111)
- Не требует новых криптографических средств или примитивов для поддержки
- Сохранение разъединения криптографии и подписания; поддержка всех текущих и будущих версий
- Включение нового шифрования для назначений
- Включение нового шифрования для маршрутизаторов, но только для чесночных сообщений - построение туннеля будет
  отдельным предложением
- Не ломать ничего, что зависит от 32-байтных двоичных хешей назначений, например, битторрент
- Поддержка доставки сообщений 0-RTT с использованием эфемерно-статического DH
- Не требует буферизации / очереди сообщений на этом уровне протокола;
  продолжение поддержки неограниченной доставки сообщений в обоих направлениях без ожидания ответа
- Обновление до эфемерно-эфемерного DH после 1 RTT
- Поддержка обработки сообщений, приходящих не по порядку
- Поддержка 256-битной безопасности
- Добавление прямого секрета
- Добавление аутентификации (AEAD)
- Гораздо более эффективное использование процессора, чем ElGamal
- Не полагается на Java jbigi для повышения эффективности DH
- Минимизация операций DH
- Гораздо более эффективное использование полосы пропускания, чем ElGamal (514-байтный блок ElGamal)
- Поддержка нового и старого шифрования в одном туннеле при необходимости
- Получатель может эффективно различать новое и старое шифрование при использовании одного туннеля
- Другие не могут отличить новое от старого или будущего шифрования
- Устранение классификации длины новой и существующей сессии (поддержка заполнения)
- Не требуется новые сообщения I2NP
- Замена контрольной суммы SHA-256 в полезной нагрузке AES на AEAD
- Поддержка связывания передающих и принимающих сессий так, чтобы
  подтверждения могли происходить в рамках протокола, а не только из вне.
  Это также позволит ответам иметь прямой секрет сразу.
- Включение сквозного шифрования определенных сообщений (хранение RouterInfo)
  которые текущи не шифруются из-за нагрузки на процессор.
- Не изменять I2NP Garlic Message
  или формат Garlic Message Delivery Instructions.
- Устранение неиспользуемых или избыточных полей в Garlic Clove Set и Clove форматах.

Устранение нескольких проблем с тегами сессий, включая:

- Невозможность использовать AES до первого ответа
- Ненадежность и зависания, если предполагается доставка тегов
- Эффективность полосы пропускания, особенно при первой доставке
- Огромная неэффективность при хранении тегов
- Огромные затраты на передачу тегов
- Сложность реализации
- Сложность настройки для различных случаев использования
  (потоковое vs. datagrams, сервер vs. клиент, высокое vs. низкое использование полосы пропускания)
- Уязвимости истощения памяти из-за доставки тегов


### Не цели / Вне сферы

- Изменения формата LS2 (предложение 123 завершено)
- Новый алгоритм вращения DHT или генерации общедоступного случайного числа
- Новое шифрование для построения туннеля.
  Смотрите предложение 152 [Prop152]_.
- Новое шифрование для шифрования туннельного слоя.
  Смотрите предложение 153 [Prop153]_.
- Методы шифрования, передачи и приема I2NP DLM / DSM / DSRM сообщений.
  Не меняется.
- Не поддерживается общение LS1-to-LS2 или ElGamal/AES-to-this-proposal.
  Это предложение - двусторонний протокол.
  Назначения могут обрабатывать обратную совместимость, публикуя два lease set'а
  используя одни и те же туннели, или помещать оба типа шифрования в LS2.
- Изменения модели угроз
- Детали реализации не обсуждаются здесь и оставляются на усмотрение каждого проекта.
- (Оптимистично) Добавление расширений или хуков для поддержки мультикаст



### Обоснование

ElGamal/AES+SessionTag был нашим единственным сквозным протоколом около 15 лет,
фактически без изменений в протокол.
Теперь существуют криптографические примитивы, которые быстрее.
Нам необходимо улучшить безопасность протокола.
Мы также разработали эвристические стратегии и обходные пути, чтобы минимизировать
памятные и полосные накладные протокола, но эти стратегии
хрупкие, сложные для настройки и делают протокол еще более подверженным
разрушению, вызывающему сброс сессии.

На протяжении примерно этого же времени спецификация ElGamal/AES+SessionTag и связанная
документация описывали, насколько это дорого с полосой пропускания для доставки тегов сессии,
и предлагали заменить доставку тегов сессии на "синхронизированный PRNG".
Синхронизированный PRNG детерминированно генерирует одинаковые теги на обоих концах,
выводя их из общего сеерда.
Синхронизированный PRNG также можно назвать "ратчетом".
Это предложение (наконец-то) специфицирует этот механизм ратчета и устраняет доставку тегов.

С помощью ратчета (синхронизированного PRNG) для генерации
тегов сессии мы устраняем накладные расходы на отправку тегов сессии
в сообщении New Session и последующих сообщениях по мере необходимости.
Для типичного набора тегов в 32 тега это 1 КБ.
Это также устраняет хранение тегов сессии на отправляющей стороне,
таким образом уменьшая требования к хранению в два раза.

Полное двухстороннее рукопожатие, аналогичное шаблону Noise IK, необходимо для избежания атак на скомпрометированное ключевое подделывание (KCI).
Смотрите таблицу "Payload Security Properties" в [NOISE]_.
Для получения дополнительной информации о KCI смотрите документ https://www.usenix.org/system/files/conference/woot15/woot15-paper-hlauschek.pdf



### Модель угроз

Модель угроз несколько отличается от NTCP2 (предложение 111).
Узел-посредник - это OBEP и IBGW, которые предполагается имеют полный доступ к
текущему или историческому глобальному NetDB, сотрудничая с floodfills.

Цель заключается в предотвращении того, чтобы эти узлы-посредники классифицировали трафик как
новые и существующие сообщения сессии, или как новое шифрование против старого шифрования.



## Детальное предложение

Это предложение определяет новый сквозной протокол для замены ElGamal/AES+SessionTags.
Дизайн будет использовать рукопожатие Noise и фазу передачи данных, включая двойной ратчет Signal.


### Краткое изложение криптографического дизайна

К протоколу будут переработаны пять компонентов:


1) Форматы контейнера новой и существующей сессий
  заменены новыми форматами.
2) ElGamal (256-байтные открытые ключи, 128-байтные закрытые ключи) будет заменен
  на ECIES-X25519 (32-байтные открытые и закрытые ключи)
3) AES будет заменен на
  AEAD_ChaCha20_Poly1305 (ниже сокращенно как ChaChaPoly)
4) SessionTags будут заменены на ратчеты,
  которые фактически являются криптографическим, синхронизированным PRNG.
5) Полезная нагрузка AES, как определено в спецификации ElGamal/AES+SessionTags,
  заменена на блочный формат, аналогичный тому, что в NTCP2.

Каждое из пяти изменений представлено в своем разделе ниже.


### Новые криптографические примитивы для I2P

Существующие реализации маршрутизатора I2P потребуют реализации следующих стандартных криптографических примитивов,
которые не требуются для текущих протоколов I2P:

- ECIES (но это фактически X25519)
- Elligator2

Существующие реализации маршрутизатора I2P, которые еще не реализовали [NTCP2]_ ([Prop111]_)
требуют также реализации:

- Генерация и DH для ключей X25519
- AEAD_ChaCha20_Poly1305 (ниже сокращенно как ChaChaPoly)
- HKDF


### Crypto Type

Тип шифрования (используется в LS2) равен 4.
Это указывает на 32-байтный публичный ключ X25519 малого порядка байтов
и протокол конец-конца, описанный здесь.

Тип шифрования 0 - ElGamal.
Типы шифрования 1-3 зарезервированы для ECIES-ECDH-AES-SessionTag, смотрите предложение 145 [Prop145]_.


### Noise Protocol Framework

Это предложение предоставляет требования на основе Noise Protocol Framework
[NOISE]_ (Ревизия 34, 2018-07-11).
Noise имеет аналогичные свойства протоколу Station-To-Station
[STS]_, который является основой для протокола [SSU]_. В терминологии Noise, Alice
является инициатором, а Bob - откликом.

Это предложение основано на протоколе Noise Noise_IK_25519_ChaChaPoly_SHA256.
(Фактический идентификатор для функции первичного разветвления ключей - это "Noise_IKelg2_25519_ChaChaPoly_SHA256"
чтобы указать на расширения I2P - смотрите раздел KDF 1 ниже)
Этот протокол Noise использует следующие примитивы:

- Интерактивный шаблон рукопожатия: IK
  Alice немедленно передает свой статический ключ Bob (I)
  Alice уже знает статический ключ Bob (K)

- Односторонний шаблон рукопожатия: N
  Alice не передает свой статический ключ Bob (N)

- Функция DH: X25519
  X25519 DH с длиной ключа 32 байта, как указано в [RFC-7748]_.

- Функция шифрования: ChaChaPoly
  AEAD_CHACHA20_POLY1305, как указано в [RFC-7539]_ разделе 2.8.
  12-байтный nonce, первые 4 байта установлены в ноль.
  Идентично тому, что в [NTCP2]_.

- Хеш-функция: SHA256
  Стандартный 32-байтный хеш, уже широко используется в I2P.


Дополнения к Framework
````````````````````````````````````````

Это предложение определяет следующие улучшения для
Noise_IK_25519_ChaChaPoly_SHA256. Эти изменения обычно следуют рекомендациям в
[NOISE]_ разделе 13.

1) Уникальные эфемерные ключи кодируются с помощью [Elligator2]_.

2) Ответ префиксируется ясным текстовым тегом.

3) Формат полезной нагрузки определяется для сообщений 1, 2 и фазы данных.
   Конечно, это не определено в Noise.

Все сообщения включают заголовок Garlic Message [I2NP]_.
Фаза данных использует шифрование, схожее с, но несовместимое с фазой данных Noise.


### Шаблоны рукопожатий

Рукопожатия используют шаблоны рукопожатий [Noise]_.

Следующее сопоставление букв используется:

- e = одноразовый эфемерный ключ
- s = статический ключ
- p = сообщение полезной нагрузки

Одноразовые и Необязательные сессии аналогичны шаблону Noise N.

.. raw:: html

  {% highlight lang='dataspec' %}
<- s
  ...
  e es p ->

{% endhighlight %}

Связанные сессии аналогичны шаблону Noise IK.

.. raw:: html

  {% highlight lang='dataspec' %}
<- s
  ...
  e es s ss p ->
  <- tag e ee se
  <- p
  p ->

{% endhighlight %}


### Сессии

Текущий протокол ElGamal/AES+SessionTag является односторонним.
На этом уровне получатель не знает, откуда сообщение.
Исходящие и входящие сессии не связаны.
Подтверждения находятся вне протокола с использованием сообщения о статусе доставки (DeliveryStatusMessage)
(вложенного в GarlicMessage) в гвоздике.

Существенная неэффективность наблюдается в одностороннем протоколе.
Любой ответ также должен использовать дорогое сообщение 'New Session'.
Это вызывает увеличение полосы пропускания, использование процессора и памяти.

Существует также слабые места в безопасности в одностороннем протоколе.
Все сессии основываются на эфемерно-статическом DH.
Без пути возврата у Bob нет возможности "ратчеть" его статический ключ
в эфемерный ключ.
Без информации о том, откуда поступает сообщение, нет возможности использовать
полученный эфемерный ключ для исходящих сообщений,
поэтому первоначальный ответ также использует эфемерно-статический DH.

Для этого предложения мы определяем два механизма для создания двустороннего протокола -
"связывание" и "прикрепление".
Эти механизмы обеспечивают повышенную эффективность и безопасность.


Контекст сессии
````````````````

Как и в случае ElGamal/AES+SessionTags, все входящие и выходящие сессии
должны быть в данном контексте, либо в контексте маршрутизатора, либо
в контексте для определенного локального назначения.
В Java I2P этот контекст называется Session Key Manager.

Сессии не должны совместно использоваться между контекстами, так как это
позволило бы коррелировать различные локальные назначения,
или между локальным назначением и маршрутизатором.

Когда данное назначение поддерживает и ElGamal/AES+SessionTags,
и это предложение, оба типа сессий могут совместно использовать контекст.
Смотрите раздел 1c) ниже.



Профилирования входящих и исходящих сессий
`````````````````````````````````````````

Когда создается исходящая сессия у инициатора (Alice),
создается новая входящая сессия и связывается с исходящей сессией,
если не ожидается ответа (например, сырые датаграммы).

Новая входящая сессия всегда связывается с новой исходящей сессией,
если не запрашивается ответ (например, сырые датаграммы).

Если требуется ответ и привязан к удаленному назначению или маршрутизатору,
та новая исходящая сессия будет привязана к этому назначению или маршрутизатору,
и заменяет любую ранее существующую исходящую сессию для этого назначения или маршрутизатора.

Связывание входящих и исходящих сессий обеспечивает двусторонний протокол
с возможностью ратчета ключей DH.



Связывание сессий и назначений
````````````````````````````````

Существует только одна исходящая сессия для заданного назначения или маршрутизатора.
Может быть несколько текущих входящих сессий от данного назначения или маршрутизатора.
Как правило, когда создается новая входящая сессия, и трафик поступает
в этой сессии (что служит подтверждением), любые другие будут отмечены
для быстрого истечения, в течение одной минуты или около того.
Проверяется PN значение предыдущих отправленных сообщений, и если не было
непринятых сообщений (в пределах размера окна) в предыдущей входящей сессии,
предыдущая сессия может быть немедленно удалена.


Когда инициатор (Alice) создает исходящую сессию,
она связана с удаленным назначением (Bob),
и любая парная входящая сессия также будет связана с удаленным назначением.
По мере ратчета сессий они продолжают быть связаны с удаленным назначением.

Когда получатель (Bob) создает входящую сессию,
она может быть связана с удаленным назначением (Alice) по желанию Alice.
Если Alice включает информацию о связывании (ее статический ключ) в сообщение New Session,
сессия будет связана с этим назначением,
и будет создана исходящая сессия и связана с тем же назначением.
По мере ратчета сессий они продолжают быть связаны с удаленным назначением.


Преимущества связывания и прикрепления
````````````````````````````````````````

Для общего случая потоковой передачи мы ожидаем, что Alice и Bob будут использовать протокол следующим образом:

- Alice связывает новую исходящую сессию с новой входящей сессией, оба связаны с удаленным назначением (Bob).
- Alice включает информацию о связывании и подпись, а также запрос ответа в
  сообщение New Session, отправляемое Bob.
- Bob связывает новую входящую сессию с новой исходящей сессией, оба связаны с удаленным назначением (Alice).
- Bob отправляет ответ (подтверждение) Alice в привязанной сессии, с ратчетом до нового DH ключа.
- Alice ратчит до новой исходящей сессии с новым ключом Bob, связанной с существующей входящей сессией.

Связывая входящую сессию с удаленным назначением и связывая входящую сессию
со связанной исходящей сессией, связанной с тем же назначением, мы достигаем двух основных преимуществ:

1) Начальный ответ от Bob к Alice использует эфемерно-эфемерный DH

2) После того, как Alice получает ответ Bob и ратчит, все последующие сообщения от Alice к Bob
используют эфемерно-эфемерный DH.


Подтверждения сообщений
``````````````````````

В ElGamal/AES+SessionTags, когда LeaseSet вкладывается как чесночный гвоздик,
или теги доставляются, отправляющий маршрутизатор запрашивает подтверждение.
Это отдельный чесночный гвоздик, содержащий DeliveryStatus Message.
Для дополнительной безопасности DeliveryStatus Message заключено в Garlic Message.
Этот механизм находится вне протокола.

В новом протоколе, так как входящие и исходящие сессии связаны,
у нас могут быть подтверждения в рамках. Отдельное гвоздильное подтверждение не требуется.

Явное подтверждение просто является существующим сообщением сессии без блока I2NP.
Однако, в большинстве случаев, явного подтверждения можно избежать, так как есть обратный трафик.
Может быть желательно, чтобы реализации ожидали короткое время (возможно, сотню мс)
перед отправкой явного подтверждения, для дачи времени пропустить
прикладному уровню времени.

Реализации также будут нуждаться в откладывании любой отправки подтверждений до
обработки блока I2NP, так как Garlic Message может содержать сообщение хранения базы данных
с lease set. Недавний lease set будет необходим для маршрутизации подтверждения,
и удаленное назначение (содержащееся в lease set) будет необходимо для
проверки статического ключа связывания.


Временные сессии
````````````````

Исходящие сессии всегда должны кончаться раньше входящих сессий.
Как только исходящая сессия истекает, и создается новая, будет создана также новая
связанная входящая сессия. Если была старая входящая сессия,
ей разрешается истекать.


### Multicast

TBD


### Определения
Мы определяем следующие функции, соответствующие использованным криптографическим строительным блокам.

ZEROLEN
    нулевой массив байт

CSRNG(n)
    n-байтный выход из криптографически надежного генератора случайных чисел.

H(p, d)
    SHA-256 хеш-функция, принимающая строку персонализации p и данные d, и
    производящая вывод длиной 32 байта.
    Как определено в [NOISE]_.
    || ниже означает добавление.

    Использовать SHA-256 следующим образом::

        H(p, d) := SHA-256(p || d)

MixHash(d)
    SHA-256 хеш-функция, принимающая предыдущий хеш h и новые данные d,
    и производящая вывод длиной 32 байта.
    || ниже означает добавление.

    Использовать SHA-256 следующим образом::

        MixHash(d) := h = SHA-256(h || d)

STREAM
    AEAD ChaCha20/Poly1305, как указано в [RFC-7539]_.
    S_KEY_LEN = 32 и S_IV_LEN = 12.

    ENCRYPT(k, n, plaintext, ad)
        Шифрует открытый текст с использованием ключа k и nonce n, который ДОЛЖЕН быть уникальным для
        ключа k.
        Связанные данные ad необязательны.
        Возвращает шифротекст, размеры которого равны открытому тексту + 16 байт для HMAC.

        Весь зашифрованный текст должен быть неразличим с случайными данными, если ключ тайный.

    DECRYPT(k, n, ciphertext, ad)
        Дешифрует шифротекст с использованием ключа k и nonce n.
        Связанные данные ad необязательны.
        Возвращает открытый текст.

DH
    Система обмена ключами X25519. Закрытые ключи размером 32 байта, открытые ключи размером 32
    байта, производит выводы размером 32 байта. Обладает следующими
    функциями:

    GENERATE_PRIVATE()
        Генерирует новый закрытый ключ.

    DERIVE_PUBLIC(privkey)
        Возвращает открытый ключ, соответствующий данному закрытому ключу.

    GENERATE_PRIVATE_ELG2()
        Генерирует новый закрытый ключ, который сопоставляется с открытым ключом, подходящим для кодировки Elligator2.
        Вычисленные случайные ключи половинного значения будут не подходящими, и должны быть отброшены.

    ENCODE_ELG2(pubkey)
        Возвращает закодированный публичный ключ Elligator2, соответствующий данному открытому ключу (обратное сопоставление).
        Закодированные ключи имеют младший порядок байтов.
        Закодированный ключ должен быть 256 бит неразличим с случайными данными.
        Смотрите раздел Elligator2 ниже для спецификации.

    DECODE_ELG2(pubkey)
        Возвращает открытый ключ, соответствующий закодированному открытому ключу Elligator2.
        Смотрите раздел Elligator2 ниже для спецификации.

    DH(privkey, pubkey)
        Генерирует общий секрет из данных закрытого и открытого ключей.

HKDF(salt, ikm, info, n)
    Криптографическая функция разветвления ключей, которая принимает некоторый вводной ключевой материал ikm (который
    должен иметь хорошую энтропию, но не обязан быть равномерно случайной строкой), salt
    длиной 32 байта и контекстно-специфичное значение 'info' и производит вывод
    длиной n байт, подходящий для использования в качестве ключевого материала.

    Использовать HKDF, как указано в [RFC-5869]_, используя хеш-функцию HMAC SHA-256
    как указано в [RFC-2104]_. Это означает, что SALT_LEN максимально 32 байта.

MixKey(d)
    Использовать HKDF() с предыдущим chainKey и новыми данными d, и
    установить новый chainKey и k.
    Как определено в [NOISE]_.

    Использовать HKDF следующим образом::

        MixKey(d) := output = HKDF(chainKey, d, "", 64)
                     chainKey = output[0:31]
                     k = output[32:63]



### 1) Формат сообщения


Обзор текущего формата сообщения
````````````````````````````````

Garlic Message, как указано в [I2NP]_, следующий.
Поскольку цель заключается в том, чтобы промежуточные узлы не могли отличить новое от старого шифрования,
этот формат не может измениться, хотя поле длины является избыточным.
Формат показан с полным 16-байтным заголовком, хотя
фактический заголовок может иметь другой формат, в зависимости от используемого транспорта.

Когда данные расшифровываются, они содержат серию Garlic Cloves и дополнительные
данные, также известные как Clove Set.

Смотрите [I2NP]_ для подробностей и полной спецификации.


.. raw:: html

  {% highlight lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |type|      msg_id       |  expiration
  +----+----+----+----+----+----+----+----+
                           |  size   |chks|
  +----+----+----+----+----+----+----+----+
  |      length       |                   |
  +----+----+----+----+                   +
  |          encrypted data               |
  ~                                       ~
  ~                                       ~
  |                                       |
  +----+----+----+----+----+----+----+----+

{% endhighlight %}


Обзор зашифрованного формата данных
````````````````````````````````````

Текущий формат сообщения, используемый более 15 лет,
это ElGamal/AES+SessionTags.
В ElGamal/AES+SessionTags есть два формата сообщений:

1) Новая сессия:
- 514-байтный блок ElGamal
- AES блок (минимум 128 байт, кратно 16)

2) Существующая сессия:
- 32-байтный тег сессии
- AES блок (минимум 128 байт, кратно 16)

Минимальное заполнение до 128 реализовано в Java I2P, но не enforced при приеме.

Эти сообщения инкапсулируются в I2NP чесночное сообщение, которое содержит
поле длины, так что длина известна.

Обратите внимание, что нет определения для заполнения до длины не кратной 16,
поэтому Новая сессия всегда (mod 16 == 2),
а существующая сессия всегда (mod 16 == 0).
Нам нужно это исправить.

Получатель сначала пытается найти первые 32 байта как тег сессии.
Если он найден, он расшифровывает AES блок.
Если не найден, и данные имеют длину как минимум (514+16), он пытается расшифровать ElGamal блок,
и если удачно, расшифровывает AES блок.


Новые теги сессии и сравнение с Signal
```````````````````````````````````````

В Signal Double Ratchet, заголовок содержит:

- DH: Текущий ратчет публичного ключа
- PN: Длина цепочки предыдущего сообщения
- N: Номер сообщения

"Цепочки отправки" в Signal примерно эквивалентны нашим наборам тегов.
Используя тег сессии, мы можем устранить большинство этого.

В Новой сессии мы ставим в нечепкетированный заголовок только публичный ключ.

В Существующей сессии мы используем тег сессии для заголовка.
Тег сессии связан с текущим ратчетом публичного ключа,
и номером сообщения.

В обе новой и Существующей сессии PN и N содержатся в зашифрованной части.

В Signal все постоянно подвергается ратчету. Новый DH публичный ключ требует
получателя для ратчета и отправки нового публичного ключа назад, который также служит
как подтверждение для полученного публичного ключа.
Это было бы слишком много операций DH для нас.
Поэтому мы разделяем подтверждение полученного ключа и передачу нового публичного ключа.
Любое сообщение, использующее тег сессии, сгенерированный из нового DH публичного ключа, составляет ACK.
Мы передаем новый публичный ключ только тогда, когда хотим повторно зашифровать.

Максимальное количество сообщений до необходимости ратчета DH - 65535.

При передаче сессионного ключа, мы выводим "Набор тегов" из него,
вместо необходимости передачи тегов сессии также.
Набор тегов может содержать до 65536 тегов.
Однако, получатели должны реализовать стратегию "забегания вперед", вместо
генерации всех возможных тегов сразу.
Только генерируйте максимум N тегов за последний полученный хороший тег.
N может быть максимум 128, но 32 или даже меньше, может быть лучшим выбором.



### 1a) Формат новой сессии

Новый сессионный одноразовый публичный ключ (32 байта)
Зашифрованные данные и MAC (оставшиеся байты)

Сообщение New Session может содержать или не содержать статический публичный ключ отправителя.
Если он включен, обратная сессия связывается с этим ключом.
Статический ключ должен быть включен, если ожидается ответ,
т. е. для потоковой передачи и повторимых датаграмм.
Он не должен быть включен для необработанных датаграмм.

Сообщение New Session похоже на односторонний Noise [NOISE]_  шаблон
"N" (если статический ключ не отправлен),
или двухсторонний шаблон "IK" (если статический ключ отправлен).



### 1b) Формат новой сессии (с привязкой)

Длина составляет 96 + длина полезной нагрузки.
Зашифрованный формат:

.. raw:: html

  {% highlight lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   Новый efemерный публичный ключ      |
  +           32 байта                    +
  |   Закодировано с Elligator2           |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +         Статический ключ               +
  |     Зашифрованные данные ChaCha20     |
  +            32 байта                   +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Аутентификационный код Poly1305      |
  +      (MAC) для секции статического ключа
  +            16 байт                    +
  +----+----+----+----+----+----+----+----+
  |                                       |
  +          Секция полезной нагрузки     +
  |       Зашифрованные данные ChaCha20   |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Аутентификационный код Poly1305      |
  +       (MAC) для секции полезной       +
  |            16 байт                    |
  +----+----+----+----+----+----+----+----+

  Публичный ключ :: 32 байта, маленький порядок байтов, Elligator2, ясный текст

  Зашифрованное содержание секции статического ключа :: 32 байта

  Зашифрованное содержание секции полезной нагрузки :: оставшиеся данные минус 16 байт

  MAC :: аутентификационный код Poly1305, 16 байт

{% endhighlight %}


Новый efемерный публичный ключ
```````````````````````````````

Эфемерный ключ составляет 32 байта, закодированы с Elligator2.
Этот ключ никогда не используется повторно; новый ключ генерируется с
каждым сообщением, включая повторные передачи.

Статический ключ
`````````````````

При расшифровке, X25519 статический ключ Alice, 32 байта.


Полезная нагрузка
`````````````

Зашифрованная длина - это остаток данных.
Расшифрованная длина на 16 меньше, чем зашифрованная длина.
Данные полезной нагрузки должны содержать блок DateTime и обычно содержат один или несколько чесночных блоков Clove.
Смотрите раздел о полезной нагрузке ниже для формата и дополнительных требований.



### 1c) Формат новой сессии (без привязки)

Если требуется ответ, статический ключ не отправляется.


Длина составляет 96 + длина полезной нагрузки.
Зашифрованный формат:

.. raw:: html

  {% highlight lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   Новый efемерный публичный ключ      |
  +           32 байта                    +
  |   Закодировано с Elligator2           |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +           Секция флагов               +
  |     Зашифрованные данные ChaCha20     |
  +            32 байта                   +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Аутентификационный код Poly1305      |
  +      (MAC) для данной секции          +
  |            16 байт                    |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +          Секция полезной нагрузки     +
  |     Зашифрованные данные ChaCha20     |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Аутентификационный код Poly1305      |
  +       (MAC) для секции полезной       +
  |            16 байт                    |
  +----+----+----+----+----+----+----+----+

  Публичный ключ :: 32 байта, маленький порядок байтов, Elligator2, ясный текст

  Зашифрованное содержание секции флагов :: 32 байта

  Зашифрованное содержание секции полезной нагрузки :: оставшиеся данные минус 16 байт

  MAC :: аутентификационный код Poly1305, 16 байт

{% endhighlight %}

Новый efемерный ключ
`````````````````````````````

Эфемерный ключ Alice.
Эфемерный ключ составляет 32 байта, закодированы с Elligator2, маленький порядок байтов.
Этот ключ никогда не используется повторно; новый ключ генерируется с
каждым сообщением, включая повторные передачи.


Декодированные данные секции флагов
```````````````````````````````````

Секция флагов не содержит ничего.
Она всегда 32 байта длиной, потому что она должна быть такой же длины
как и статический ключ для сообщений New Session с привязкой.
Bob определяет, является ли это статическим ключом или секцией флагов
путем проверки, все ли 32 байта равны нулю.

TODO здесь нужны какие-либо флаги?

Полезная нагрузка
`````````````

Зашифрованная длина - это остаток данных.
Расшифрованная длина на 16 байт меньше зашифрованной длины.
Данные полезной нагрузки должны содержать блок DateTime и обычно содержат один или несколько чесночных блоков Clove.
Смотрите раздел о полезной нагрузке ниже для формата и дополнительных требований.




### 1d) Одноразовый формат (без привязки или сессии)

Если ожидается отправка только одного сообщения,
от начала сессии или статический ключ не требуется.


Длина составляет 96 + длина полезной нагрузки.
Зашифрованный формат:

.. raw:: html

  {% highlight lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |          Эфемерный публичный ключ     |
  +             32 байта                  +
  |   Закодирован с Elligator2            +
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +           Секция флагов               +
  |     Зашифрованные данные ChaCha20     |
  +            32 байта                   +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Аутентификационный код Poly1305      |
  +       (MAC) для вышеприведенной секции +
  |            16 байт                    |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +          Секция полезной нагрузки     +
  |     Зашифрованные данные ChaCha20     |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Аутентификационный код Poly1305      |
  +       (MAC) для секции полезной       +
  |            16 байт                    |
  +----+----+----+----+----+----+----+----+

  Публичный ключ :: 32 байта, маленький порядок байтов, Elligator2, ясный текст

  Зашифрованное содержание секции флагов :: 32 байта

  Зашифрованное содержание секции полезной нагрузки :: оставшиеся данные минус 16 байт

  MAC :: аутентификационный код Poly1305, 16 байт

{% endhighlight %}


Новый одноразовый ключ
```````````````````````

Одноразовый ключ составляет 32 байта, закодированное с Elligator2, маленький порядок байтов.
Этот ключ никогда не используется повторно; новый ключ генерируется с
каждым сообщением, включая повторные передачи.


Декодированные данные секции флагов
````````````````````````````````````````

Секция флагов не содержит ничего.
Она всегда 32 байта длиной, так как она должна быть такой же длиной,
как и секция статического ключа для сообщений New Session с привязкой.
Bob определяет, является ли это статическим ключом или секцией флагов
путем проверки, все ли 32 байта равны нулю.

TODO здесь нужны какие-либо флаги?

.. raw:: html

  {% highlight lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                                       |
  +             Все нули                  +
  |              32 байта                 |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+

  нули:: Все нули, 32 байта.

{% endhighlight %}


Полезная нагрузка
`````````````

Зашифрованная длина - это остаток данных.
Расшифрованная длина на 16 байт меньше зашифрованной длины.
Данные полезной нагрузки должны содержать блок DateTime и обычно содержат один или несколько чесночных блоков Clove.
Смотрите раздел о полезной нагрузке ниже для формата и дополнительных требований.



### 1f) KDF для Сообщения Новой Сессии

KDF для начального ChainKey
``````````````````````````

Это стандартное [NOISE]_ для IK с модифицированной строкой протокола.
Обратите внимание, что мы используем тот же инициализатор как для паттерна IK (связанные сессии),
так и для паттерна N (несвязанные сессии).

Имя протокола модифицировано по двум причинам.
Во-первых, чтобы указать, что эфемерные ключи закодированы с Elligator2,
а во-вторых, чтобы указать, что MixHash() вызывается перед вторым сообщением
для смешивания в значение тега.

.. raw:: html

  {% highlight lang='text' %}
Это паттерн сообщения "e":

  // Определение имени протокола.
  Установка protocol_name = "Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256"
   (40 байт, кодировка US-ASCII, без завершения NULL).

  // Определение Hash h = 32 байта
  h = SHA256(protocol_name);

  Определение ck = 32-байтная ключевая цепочка. Копируем данные h в ck.
  Установка chainKey = h

  // MixHash(null пролог)
  h = SHA256(h);

  // до этого момента все может быть предварительно рассчитано Alice для всех исходящих соединений

{% endhighlight %}


KDF для зашифрованного содержимого секции флагов/статического ключа
```````````````````````````````````````````````````````

.. raw:: html

  {% highlight lang='text' %}
Это паттерн сообщения "e":

  // Статические ключи X25519 Bob
  // bpk опубликован в lease set
  bsk = GENERATE_PRIVATE()
  bpk = DERIVE_PUBLIC(bsk)

  // Статический публичный ключ Bob
  // MixHash(bpk)
  // || ниже означает добавление
  h = SHA256(h || bpk);

  // до этого момента все может быть предварительно рассчитано Bob для всех входящих соединений

  // Эфемерные ключи X25519 Alice
  aesk = GENERATE_PRIVATE_ELG2()
  aepk = DERIVE_PUBLIC(aesk)

  // Эфемерный публичный ключ Alice
  // MixHash(aepk)
  // || ниже означает добавление
  h = SHA256(h || aepk);

  // h используется в качестве связанных данных для AEAD в сообщении New Session
  // Сохранение Hash h для KDF ответа на новую сессию
  // eapk отправляется в ясном тексте в
  // начало сообщения New Session
  elg2_aepk = ENCODE_ELG2(aepk)
  // Как расшифровано Bob
  aepk = DECODE_ELG2(elg2_aepk)

  Конец шаблона сообщения "e".

  Это шаблон сообщения "es":

  // Noise es
  sharedSecret = DH(aesk, bpk) = DH(bsk, aepk)

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  // Параметры ChaChaPoly для шифрования/дешифрования
  keydata = HKDF(chainKey, sharedSecret, "", 64)
  chainKey = keydata[0:31]

  // Параметры AEAD
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, flags/static key section, ad)

  Конец шаблона сообщения "es".

  Это шаблон сообщения "s":

  // MixHash(ciphertext)
  // Сохранение для KDF секции Payload
  h = SHA256(h || ciphertext)

  // Статические ключи X25519 Alice
  ask = GENERATE_PRIVATE()
  apk = DERIVE_PUBLIC(ask)

  Конец шаблона сообщения "s".


{% endhighlight %}



KDF для секции Payload (с статическим ключом Alice)
``````````````````````````````````````````````````

.. raw:: html

  {% highlight lang='text' %}
Это шаблон сообщения "ss":

  // Noise ss
  sharedSecret = DH(ask, bpk) = DH(bsk, apk)

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  // Параметры ChaChaPoly для шифрования/дешифрования
  // chainKey из секции Static Key
  Установка sharedSecret = X25519 DH результат
  keydata = HKDF(chainKey, sharedSecret, "", 64)
  chainKey = keydata[0:31]

  // Параметры AEAD
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, payload, ad)

  Конец шаблона сообщения "ss".

  // MixHash(ciphertext)
  // Сохранение для KDF ответа на новую сессию
  h = SHA256(h || ciphertext)

{% endhighlight %}


KDF для секции Payload (без статического ключа Alice)
````````````````````````````````````````````````````

Обратите внимание, что это шаблон Noise "N", но мы используем тот же "IK" инициализатор
как и для связанных сессий.

Сообщения сессии новые не могут быть идентифицированы как содержащие статический ключ Alice или нет
пока статический ключ не расшифрован и не проверено содержимое на наличие всех нулей.
Таким образом, приемник должен использовать "IK" состояние автомата для всех
сообщений новой сессии.
Если статический ключ состоит из всех нулей, шаблон сообщения "ss" должен быть пропущен.



.. raw:: html

  {% highlight lang='text' %}
chainKey = из секции Flags/Static key
  k = из секции Flags/Static key
  n = 1
  ad = h от секции Flags/Static key
  ciphertext = ENCRYPT(k, n, payload, ad)

{% endhighlight %}



### 1g) Формат ответа на новую сессию

Возможно отправить один или несколько ответов на новую сессию в ответ на одно сообщение новой сессии.
Каждый ответ помечен тегом, который сгенерирован из набора тегов для сессии.

Ответ новой сеанс состоит из двух частей.
Первая часть завершает рукопожатие Noise IK с добавленным тегом.
Длина первой части составляет 56 байт.
Вторая часть - это полезная нагрузка фазы передачи данных.
Длина второй части составляет 16 + длина полезной нагрузки.

Общая длина составляет 72 + длина полезной нагрузки.
Зашифрованный формат:

.. raw:: html

  {% highlight lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |       Тег сессии     8 байт           |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +         Эфемерный Публичный Ключ       +
  |                                       |
  +            32 байта                   +
  |   Закодирован с Elligator2            +
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Аутентификационный код Poly1305      |
  +   (MAC) для Секции Ключа (без данных) +
  |             16 байт                   |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +            Секция Полезной Нагрузки   +
  |   Зашифрованные данные ChaCha20       |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Аутентификационный код Poly1305      |
  +       (MAC) для секции полезной       +
  |            16 байт                    |
  +----+----+----+----+----+----+----+----+

  Тег :: 8 байт, ясный текст

  Публичный Ключ :: 32 байта, маленький порядок байтов, Elligator2, ясный текст

  MAC :: аутентификационный код Poly1305, 16 байт
         Примечание: Данные ChaCha20 с пустым текстом (ZEROLEN)

  Зашифрованное содержание секции полезной нагрузки :: оставшиеся данные минус 16 байт

  MAC :: аутентификационный код Poly1305, 16 байт

{% endhighlight %}

Тег сессии
```````````
Тег сгенерирован в KDF набора тегов, как инициализировано
в KDF инициализации DH ниже.
Ключ сессии из инициализации DH не используется.


Эфемерный ключ ответа на новую сессию
``````````````````````````````````

Эфемерный ключ Bob.
Эфемерный ключ составляет 32 байта, закодирован с Elligator2, младший порядок байтов.
Этот ключ никогда не используется повторно; новый ключ генерируется с
каждым сообщением, включая повторные передачи.


Полезная нагрузка
`````````````
Зашифрованная длина - это остаток данных.
Расшифрованная длина на 16 байт меньше зашифрованной длины.
Полезная нагрузка обычно будет содержать один или несколько чесночных гвоздиков.
Смотрите раздел о полезной нагрузке ниже для формата и дополнительных требований.


KDF для Набора тегов ответа
````````````````````````````

Один или несколько тегов создаются из Набора тегов, который инициализируется
с использованием KDF ниже, с использованием chainKey из сообщения новой сессии.

.. raw:: html

  {% highlight lang='text' %}
// Генерация набора тегов
  tagsetKey = HKDF(chainKey, ZEROLEN, "SessionReplyTags", 32)
  tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey)

{% endhighlight %}


KDF для Зашифрованного содержимого секции ключа ответа
``````````````````````````````````````````

.. raw:: html

  {% highlight lang='text' %}
// Ключи из сообщения новой сессии
  // Ключи X25519 Alice
  // apk и aepk отправляются в оригинальном сообщении новой сессии
  // ask = Закрытый статический ключ Alice
  // apk = Общедоступный статический ключ Alice
  // aesk = Закрытый эфемерный ключ Alice
  // aepk = Общедоступный эфемерный ключ Alice
  // Ключи X25519 Bob
  // bsk = Закрытый статический ключ Bob
  // bpk = Общедоступный статический ключ Bob

  // Генерация тега
  tagsetEntry = tagset_nsr.GET_NEXT_ENTRY()
  tag = tagsetEntry.SESSION_TAG

  // MixHash(tag)
  h = SHA256(h || tag)

  Это шаблон сообщения "e":

  // Эфемерные ключи X25519 Bob
  besk = GENERATE_PRIVATE_ELG2()
  bepk = DERIVE_PUBLIC(besk)

  // Эфемерный ключ Bob
  // MixHash(bepk)
  // || ниже означает добавление
  h = SHA256(h || bepk);

  // elg2_bepk отправляется в ясном тексте в
  // начало сообщения новой сессии
  elg2_bepk = ENCODE_ELG2(bepk)
  // Как расшифровано Bob
  bepk = DECODE_ELG2(elg2_bepk)

  Конец шаблона сообщения "e".

  Это шаблон сообщения "ee":

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  // Параметры ChaChaPoly для шифрования/дешифрования
  // chainKey из оригинальной секции Payload сообщения новой сессии
  sharedSecret = DH(aesk, bepk) = DH(besk, aepk)
  keydata = HKDF(chainKey, sharedSecret, "", 32)
  chainKey = keydata[0:31]

  Конец шаблона сообщения "ee".

  Это шаблон сообщения "se":

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  sharedSecret = DH(ask, bepk) = DH(besk, apk)
  keydata = HKDF(chainKey, sharedSecret, "", 64)
  chainKey = keydata[0:31]

  // Параметры AEAD
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, ZEROLEN, ad)

  Конец шаблона сообщения "se".

  // MixHash(ciphertext)
  h = SHA256(h || ciphertext)

  chainKey используется в ратчете ниже.

{% endhighlight %}


KDF для зашифрованного содержимого секции Payload
``````````````````````````````````````````

Это как первое сообщение существующей сессии,
после разветвления, но без отдельного тега.
Кроме того, мы используем хэшировку сверху, чтобы связывать
полезную нагрузку к сообщению NSR.


.. raw:: html

  {% highlight lang='text' %}
// разделить()
  keydata = HKDF(chainKey, ZEROLEN, "", 64)
  k_ab = keydata[0:31]
  k_ba = keydata[32:63]
  tagset_ab = DH_INITIALIZE(chainKey, k_ab)
  tagset_ba = DH_INITIALIZE(chainKey, k_ba)

  // Параметры AEAD для полезной нагрузки ответа на новую сессию
  k = HKDF(k_ba, ZEROLEN, "AttachPayloadKDF", 32)
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, payload, ad)
{% endhighlight %}


### Примечания

Могут быть отправлены несколько сообщений NSR в ответ на одно сообщение новой сессии, каждое с уникальными эфемерными ключами, в зависимости от размера ответа.

Alice и Bob обязаны использовать новые эфемерные ключи для каждого сообщения NS и NSR.

Alice должна получить одно из сообщений NSR Bob перед отправкой сообщений существующей сессии (ES),
а Bob должен получить сообщение ES от Alice перед отправкой сообщений ES.

``ChainKey`` и ``k`` из секции Payload сообщения NSR Bob используются
как входные данные для начального DH ратчета ES (в обоих направлениях, смотрите KDF ратчета DH).

Bob должен сохранять только существующие сессии для полученных сообщений ES от Alice.
Любые другие созданные входящие и исходящие сессии (для нескольких NSR) должны быть
немедленно удалены после получения первого сообщения ES Alice для данной сессии.



### 1h) Формат существующей сессии

Тег сессии (8 байт)
Зашифрованные данные и MAC (смотрите раздел 3 ниже)


Формат
``````
Зашифрованный:

.. raw:: html

  {% highlight lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |       Тег сессии                     |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +            Секция Полезной Нагрузки   +
  |   Зашифрованные данные ChaCha20       |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Аутентификационный код Poly1305      |
  +                (MAC)                  +
  |             16 байт                   |
  +----+----+----+----+----+----+----+----+

  Тег сессии :: 8 байт, ясный текст

  Зашифрованное содержание секции полезной нагрузки :: оставшиеся данные минус 16 байт

  MAC :: аутентификационный код Poly1305, 16 байт

{% endhighlight %}


Полезная нагрузка
```````
Зашифрованная длина - это остаток данных.
Расшифрованная длина на 16 байт меньше зашифрованной длины.
Смотрите раздел о полезной нагрузке ниже для формата и требований.


KDF
```

.. raw:: html

  {% highlight lang='text' %}
Смотрите раздел AEAD ниже.

  // Параметры AEAD для полезной нагрузки существующей сессии
  k = 32-байтный ключ сессии, связанный с этим тегом сессии
  n = Номер сообщения N в текущей цепочке, полученный из связанного тега сессии.
  ad = Тег сессии, 8 байт
  ciphertext = ENCRYPT(k, n, payload, ad)
{% endhighlight %}



### 2) ECIES-X25519


Формат: 32-байтные публичные и закрытые ключи, маленький порядок байтов.

Обоснование: Используется в [NTCP2]_.



### 2a) Elligator2

В стандартных рукопожатиях Noise, начальные сообщения рукопожатия в каждом направлении начинаются с
эфемерных ключей, которые передаются в ясном тексте.
Поскольку ключи X25519 отличимы от случайных данных, злоумышленник-средний может отличить
эти сообщения от сообщений существующей сессии, начинающихся с случайных тегов сессии.
В [NTCP2]_ ([Prop111]_) была применена низкая стоимость xor-функция с использованием ключа из вне для
обфускации ключа. Однако модель угроз здесь отличается; мы не хотим давать возможность никому натравливать МитМ на
идентификацию направления трафика или отличить
новые сообщения рукопожатия от сообщений существующей сессии.

Поэтому используется [Elligator2]_ для преобразования эфемерных ключей в сообщениях новой сессии и ответах на новую сессию
так, чтобы они не отличались от равномерно случайных строк.



Формат
``````

32-байтные публичные и закрытые ключи.
Закодированные ключи имеют младший порядок байтов.

Как определено в [Elligator2]_, закодированные ключи не отличимы от 254 случайных битов.
Мы требуем 256 случайных бит (32 байта). Поэтому, кодирование и декодирование
определены следующим образом:

Кодирование:

.. raw:: html

  {% highlight lang='text' %}
Определение ENCODE_ELG2()

  // Кодирование как определено в спецификации Elligator2
  encodedKey = encode(pubkey)
  // OR к двум случайным битам к MSB
  randomByte = CSRNG(1)
  encodedKey[31] |= (randomByte & 0xc0)
{% endhighlight %}


Декодирование:

.. raw:: html

  {% highlight lang='text' %}
Определение DECODE_ELG2()

  // Маскировать два случайных бита в MSB
  encodedKey[31] &= 0x3f
  // Декодирование, как определено в спецификации Elligator2
  pubkey = decode(encodedKey)
{% endhighlight %}




Обоснование
`````````````

Необходимо для предотвращения классификации трафика OBEP и IBGW.


Примечания
`````

Elligator2 удваивает среднее время генерации ключей, поскольку половина закрытых ключей
результаты в открытых ключах, не подходящих для кодирования с Elligator2.
Кроме того, время генерации ключа неограничено с экспоненциальным распределением,
поскольку генератор должен продолжать повторять, пока подходящая пара ключей не найдена.

Эти расходы могут быть управляемыми, генерируя ключи заранее,
в отдельном потоке, чтобы сохранять пул подходящих ключей.

Генератор выполняет функцию ENCODE_ELG2() для определения пригодности.
Поэтому генератор должен хранить результат ENCODE_ELG2()
чтобы не пришлось его повторно вычислять.

Кроме того, неподдерживаемые ключи можно добавить в пул ключей
используются для [NTCP2]_, где Elligator2 не используется.
Проблема безопасности, связанная с этим, TBD.




### 3) AEAD (ChaChaPoly)

AEAD с использованием ChaCha20 и Poly1305, так же, как в [NTCP2]_.
Это соответствует [RFC-7539]_, который также
используется аналогично в TLS [RFC-7905]_.



Входные данные для New Session и ответов на новую сессию
```````````````````````````````````````````````````

Входные данные для функций шифрования/дешифрования
для AEAD блока в сообщении новой сессии:

.. raw:: html

  {% highlight lang='dataspec' %}
k :: 32-байтный шифровальный ключ
       Смотрите KDF для новой сессии и ответов на новую сессию выше.

  n :: Неометочное основанное на счетчиках, 12 байт.
       n = 0

  ad :: Связанные данные, 32 байта.
        SHA256 хеш предшествующих данных, как выводит mixHash()

  data :: Открытый текст, 0 или более байт

{% endhighlight %}


Входные данные для Existing Session
```````````````````````````````````

Входные данные для функций шифрования/дешифрования
для блока AEAD в сообщении существующей сессии:

.. raw:: html

  {% highlight lang='dataspec' %}
k :: 32-байтный ключ сессии
       Как найдено из сопровождающего тега сессии.

  n :: Неометочное на основе счетчика, 12 байт.
       Начинается с 0 и увеличивается на каждое сообщение при передаче.
       Для приемника, значение
       как найдено из сопровождающего тега сессии.
       Первые четыре байта всегда равны нулю.
       Последние восемь байт - это номер сообщения (n), в кодировке младшего порядка байтов.
       Максимальное значение - 65535.
       Сессия должна быть ратчета при достижении N этого значения.
       Использование более высоких значений недопустимо.

  ad :: Связанные данные
        Тег сессии

  data :: Открытый текст, 0 или более байт

{% endhighlight %}


Зашифрованный формат
``````````````````

Выходной результат функции шифрования, вход функции дешифрования:

.. raw:: html

  {% highlight lang='dataspec' %}
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |       Зашифрованные данные ChaCha20   |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Аутентификационный код Poly1305      |
  +                (MAC)                  +
  |             16 байт                   |
  +----+----+----+----+----+----+----+----+

  зашифрованные данные :: Такой же размер, как у открытых данных, 0 - 65519 байт

  MAC :: аутентификационный код Poly1305, 16 байт

{% endhighlight %}

Примечания
`````
- Поскольку ChaCha20 является поточным шифром, открытые тексты не требуют заполнения.
  Дополнительные байты ключевого потока отбрасываются.

- Ключ для шифра (256 бит) согласовывается с помощью SHA256 KDF.
  Подробности KDF для каждого сообщения приведены в отдельных разделах ниже.

- ChaChaPoly кадров имеют известный размер, так как они заключены в сообщение данных I2NP.

- Для всех сообщений,
  дополнение внутри аутентифицированного
  кадра данных.


Обработка ошибок AEAD
`````````````````````

Все полученные данные, которые не проходят проверку AEAD, должны быть отброшены.
Ответ не возвращается.


Обоснование
```````````

Используется в [NTCP2]_.



### 4) Ратчеты

Мы все еще используем теги сессии, как ранее, но используем ратчеты для их генерации.
Теги сессии также имели опцию повторного ключа, которую мы никогда не реализовали.
Поэтому это как двойной ратчет, но мы никогда не выполняли второй.

Здесь мы определяем что-то аналогичное двойному ратчету Signal.
Теги сессии генерируются детерминированно и идентично на
стороне отправителя и получателя.

Используя симметричный ратчет ключей/тегов, мы устраняем использование памяти для сохранения тегов сессии на стороне отправителя.
Мы также устраняем издержки полосы пропускания на отправку наборов тегов.
Использование на стороне приемника все еще значительно, но мы можем еще больше снизить его,
так как мы уменьшим тег сессии с 32 байт до 8 байт.

Мы не используем заголовочное шифрование, как указано (и необязательно) в Signal,
мы используем вместо этого теги сессии.

Путем использования ратчета DH мы достигаем прямого секрета, который никогда не был реализован
в ElGamal/AES+SessionTags.

Примечание: одноразовый публичный ключ в новой сессии не является частью ратчета, его единственная функция
заключается в шифровании начального ключа DH ратчета Alice.


Номера сообщений
