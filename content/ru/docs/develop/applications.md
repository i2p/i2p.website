---
title: "Разработка приложений"
description: "Зачем писать приложения специально для I2P, ключевые концепции, варианты разработки и простое руководство для начала работы"
slug: "applications"
lastUpdated: "2025-10"
accurateFor: "2.10.0"
type: docs
---

## Зачем писать код специально для I2P?

Существует несколько способов использования приложений в I2P. Используя [I2PTunnel](/docs/api/i2ptunnel/), вы можете использовать обычные приложения без необходимости программировать явную поддержку I2P. Это очень эффективно для сценариев клиент-сервер, когда вам нужно подключиться к одному веб-сайту. Вы можете просто создать туннель с помощью I2PTunnel для подключения к этому веб-сайту, как показано на Рисунке 1.

Если ваше приложение является распределённым, ему потребуются соединения с большим количеством узлов. При использовании I2PTunnel вам нужно будет создать новый туннель для каждого узла, с которым вы хотите связаться, как показано на рисунке 2. Этот процесс, конечно, можно автоматизировать, но запуск большого количества экземпляров I2PTunnel создаёт значительные накладные расходы. Кроме того, при работе со многими протоколами вам потребуется заставить всех использовать один и тот же набор портов для всех узлов — например, если вы хотите надёжно запустить DCC-чат, все должны договориться, что порт 10001 — это Алиса, порт 10002 — это Боб, порт 10003 — это Чарли и так далее, поскольку протокол включает специфичную для TCP/IP информацию (хост и порт).

Обычные сетевые приложения часто отправляют множество дополнительных данных, которые могут быть использованы для идентификации пользователей. Имена хостов, номера портов, часовые пояса, кодировки символов и т.д. часто отправляются без уведомления пользователя. Поэтому разработка сетевого протокола специально с учетом анонимности может помочь избежать компрометации личности пользователей.

Также следует учитывать соображения эффективности при определении способа взаимодействия поверх I2P. Библиотека streaming и компоненты, построенные на её основе, работают с подтверждениями соединения, аналогичными TCP, в то время как базовые протоколы I2P (I2NP и I2CP) являются строго основанными на сообщениях (как UDP или в некоторых случаях raw IP). Важное различие заключается в том, что в I2P коммуникация происходит через длинную широкополосную сеть — каждое сквозное сообщение будет иметь значительные задержки, но может содержать полезную нагрузку до нескольких КБ. Приложение, которому требуется простой запрос и ответ, может избавиться от любого состояния и устранить задержку, возникающую при установлении и завершении соединения, используя датаграммы (с наилучшим усилием) без необходимости беспокоиться об определении MTU или фрагментации сообщений.

<figure style="text-align:center; margin: 2rem 0;">
  <img src="/images/i2ptunnel_serverclient.png" alt="Creating a server-client connection using I2PTunnel only requires creating a single tunnel." />
  <figcaption>Figure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel.</figcaption>
</figure>
<figure style="text-align:center; margin: 2rem 0;">
  <img src="/images/i2ptunnel_peertopeer.png" alt="Setting up connections for a peer-to-peer applications requires a very large amount of tunnels." />
  <figcaption>Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels.</figcaption>
</figure>
Подводя итог, несколько причин для написания специального кода для I2P:

- Создание большого количества экземпляров I2PTunnel потребляет значительный объём ресурсов, что создаёт проблемы для распределённых приложений (для каждого пира требуется новый tunnel).
- Общие сетевые протоколы часто передают много дополнительных данных, которые могут быть использованы для идентификации пользователей. Программирование специально для I2P позволяет создать сетевой протокол, который не допускает утечки такой информации, сохраняя анонимность и безопасность пользователей.
- Сетевые протоколы, разработанные для использования в обычном интернете, могут быть неэффективными в I2P — сети с гораздо более высокой задержкой.

I2P поддерживает стандартный [интерфейс плагинов](/docs/specs/plugin/) для разработчиков, чтобы приложения могли быть легко интегрированы и распространены.

Приложения, написанные на Java и доступные/запускаемые через HTML-интерфейс с использованием стандартного webapps/app.war, могут быть рассмотрены для включения в дистрибутив I2P.

## Важные концепции

Есть несколько изменений, к которым нужно привыкнуть при использовании I2P:

### Направления

Приложение, работающее в I2P, отправляет сообщения из уникальной криптографически защищённой конечной точки — "destination" — и получает сообщения на неё. С точки зрения TCP или UDP, destination можно (в значительной степени) считать эквивалентом пары имя хоста плюс номер порта, хотя есть несколько различий.

- I2P destination сам по себе является криптографической конструкцией — все данные, отправленные на него, шифруются так, как если бы IPsec был повсеместно развёрнут, а (анонимизированное) местоположение конечной точки подписывается так, как если бы DNSSEC был повсеместно развёрнут.
- I2P destinations являются мобильными идентификаторами — они могут быть перемещены с одного I2P router на другой (или даже могут работать в режиме "multihome" — функционировать на нескольких router одновременно). Это существенно отличается от мира TCP или UDP, где одна конечная точка (порт) должна оставаться на одном хосте.
- I2P destinations громоздкие и большие по размеру — внутри они содержат 2048-битный открытый ключ ElGamal для шифрования, 1024-битный открытый ключ DSA для подписи и сертификат переменного размера, который может содержать proof of work или скрытые данные.

Существуют способы обращения к этим большим и неудобным адресам назначения по коротким и понятным именам (например, "irc.duck.i2p"), но эти методы не гарантируют глобальную уникальность (поскольку они хранятся локально в базе данных на машине каждого пользователя), а текущий механизм не особенно масштабируем и безопасен (обновления списка хостов управляются с помощью "подписок" на службы именования). Возможно, когда-нибудь появится безопасная, человекочитаемая, масштабируемая и глобально уникальная система именования, но приложения не должны зависеть от её наличия. [Дополнительная информация о системе именования](/docs/overview/naming/) доступна.

Хотя большинству приложений не нужно различать протоколы и порты, I2P *поддерживает* их. Сложные приложения могут указывать протокол, порт отправителя и порт получателя для каждого сообщения отдельно, чтобы мультиплексировать трафик на одном destination. Подробности см. на [странице о датаграммах](/docs/api/datagrams/). Простые приложения работают, прослушивая «все протоколы» на «всех портах» destination.

### Анонимность и конфиденциальность

I2P обеспечивает прозрачное сквозное шифрование и аутентификацию для всех данных, передаваемых по сети — если Боб отправляет данные на destination Алисы, только destination Алисы может их получить, и если Боб использует библиотеку датаграмм или потоковую библиотеку, Алиса точно знает, что данные были отправлены с destination Боба.

Конечно, I2P прозрачно анонимизирует данные, передаваемые между Алисой и Бобом, но никак не анонимизирует содержание того, что они отправляют. Например, если Алиса отправляет Бобу форму со своим полным именем, государственными идентификационными документами и номерами кредитных карт, I2P ничего не может с этим поделать. Поэтому протоколы и приложения должны учитывать, какую информацию они пытаются защитить, а какую готовы раскрыть.

### I2P дейтаграммы могут достигать нескольких КБ

Приложения, использующие I2P-датаграммы (как обычные, так и с возможностью ответа), по сути можно рассматривать с точки зрения UDP — датаграммы неупорядочены, доставляются по принципу «best effort» и не требуют установления соединения — но в отличие от UDP, приложениям не нужно беспокоиться об определении MTU и можно просто отправлять большие датаграммы. Хотя верхний предел номинально составляет 32 КБ, сообщение фрагментируется при передаче, что снижает надёжность доставки в целом. В настоящее время не рекомендуется использовать датаграммы размером более 10 КБ. Подробности см. на [странице о датаграммах](/docs/api/datagrams/). Для многих приложений 10 КБ данных достаточно для всего запроса или ответа, что позволяет им прозрачно работать в I2P как UDP-подобное приложение без необходимости реализовывать фрагментацию, повторные отправки и т.д.

## Параметры разработки

Существует несколько способов передачи данных через I2P, каждый со своими преимуществами и недостатками. Библиотека streaming lib является рекомендуемым интерфейсом, используемым большинством I2P-приложений.

### Библиотека потоковой передачи

[Полная библиотека streaming](/docs/specs/streaming/) теперь является стандартным интерфейсом. Она позволяет программировать с использованием TCP-подобных сокетов, как объясняется в [руководстве по разработке с использованием Streaming](#developing-with-the-streaming-library).

### BOB

BOB — это [Basic Open Bridge](/docs/legacy/bob/), позволяющий приложению на любом языке программирования устанавливать потоковые соединения в I2P и из него. На данный момент отсутствует поддержка UDP, но она планируется в ближайшем будущем. BOB также содержит несколько инструментов, таких как генерация ключей destination и проверка соответствия адреса спецификациям I2P. Актуальную информацию и приложения, использующие BOB, можно найти на этом [I2P Site](http://bob.i2p/).

### SAM, SAM V2, SAM V3

*SAM не рекомендуется. SAM V2 приемлем, SAM V3 рекомендуется.*

SAM — это протокол [Simple Anonymous Messaging](/docs/legacy/sam/) (простой анонимный обмен сообщениями), позволяющий приложению, написанному на любом языке, взаимодействовать с SAM bridge через обычный TCP-сокет, при этом bridge мультиплексирует весь его I2P-трафик, прозрачно координируя шифрование/дешифрование и обработку событий. SAM поддерживает три режима работы:

- потоки, когда Алиса и Боб хотят надежно отправлять данные друг другу в правильном порядке
- датаграммы с возможностью ответа, когда Алиса хочет отправить Бобу сообщение, на которое Боб может ответить
- необработанные датаграммы, когда Алиса хочет получить максимальную пропускную способность и производительность, а Боб не волнуется, аутентифицирован ли отправитель данных или нет (например, передаваемые данные самоаутентифицируются)

SAMv3 преследует ту же цель, что и SAM и SAM V2, но не требует мультиплексирования/демультиплексирования. Каждый I2P поток обрабатывается собственным сокетом между приложением и мостом SAM. Кроме того, датаграммы могут отправляться и приниматься приложением через датаграммную связь с мостом SAM.

[SAM V2](/docs/legacy/samv2/) — это новая версия, используемая imule, которая исправляет некоторые проблемы в [SAM](/docs/legacy/sam/).

[SAM V3](/docs/api/samv3/) используется imule начиная с версии 1.4.0.

### I2PTunnel

Приложение I2PTunnel позволяет приложениям создавать специфические TCP-подобные туннели к узлам путём создания либо 'клиентских' приложений I2PTunnel (которые прослушивают определённый порт и подключаются к определённому I2P destination при каждом открытии сокета к этому порту), либо 'серверных' приложений I2PTunnel (которые прослушивают определённый I2P destination и при каждом новом I2P-соединении выполняют outproxy к определённому TCP-хосту/порту). Эти потоки являются 8-битно чистыми и аутентифицированы и защищены через ту же библиотеку потоковой передачи, что использует SAM, но создание множества уникальных экземпляров I2PTunnel связано с нетривиальными накладными расходами, поскольку каждый имеет свой собственный уникальный I2P destination и свой собственный набор tunnel, ключей и т.д.

### SOCKS

I2P поддерживает прокси SOCKS V4 и V5. Исходящие соединения работают хорошо. Входящие (серверные) соединения и функциональность UDP могут быть неполными и непроверенными.

### Ministreaming

*Удалено*

Раньше существовала простая библиотека "ministreaming", но теперь ministreaming.jar содержит только интерфейсы для полной библиотеки streaming.

### Датаграммы

*Рекомендуется для UDP-подобных приложений*

[Библиотека Datagram](/docs/api/datagrams/) позволяет отправлять пакеты, похожие на UDP. Можно использовать:

- Датаграммы с возможностью ответа
- Необработанные датаграммы

### I2CP

*Не рекомендуется*

[I2CP](/docs/specs/i2cp/) сам по себе является языконезависимым протоколом, но для реализации библиотеки I2CP на чём-то отличном от Java требуется написать значительное количество кода (процедуры шифрования, маршаллинг объектов, асинхронная обработка сообщений и т. д.). Хотя кто-то может написать библиотеку I2CP на C или другом языке, скорее всего, будет более полезным использовать вместо этого библиотеку SAM для C.

### Веб-приложения

I2P поставляется с веб-сервером Jetty, и настройка для использования Apache вместо него довольно проста. Любая стандартная технология веб-приложений должна работать.

## Начало разработки — Простое руководство

Для разработки с использованием I2P требуется рабочая установка I2P и среда разработки на ваш выбор. Если вы используете Java, вы можете начать разработку с [библиотеки streaming](#developing-with-the-streaming-library) или библиотеки datagram. При использовании другого языка программирования можно применять SAM или BOB.

### Разработка с использованием библиотеки Streaming

Ниже приведена сокращённая и модернизированная версия примера с исходной страницы. Полный пример см. на устаревшей странице или в наших примерах на Java в кодовой базе.

```java
// Server example (excerpt)
I2PSocketManager manager = I2PSocketManagerFactory.createManager();
I2PServerSocket server = manager.getServerSocket();
I2PSocket socket = server.accept();
BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
String s;
while ((s = br.readLine()) != null) {
    System.out.println("Received: " + s);
}
```
*Пример кода: базовый сервер, принимающий данные.*

```java
// Client example (excerpt)
I2PSocketManager manager = I2PSocketManagerFactory.createManager();
Destination dest = new Destination(serverDestBase64);
I2PSocket socket = manager.connect(dest);
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
bw.write("Hello I2P!\n");
bw.flush();
```
*Пример кода: клиент подключается и отправляет строку.*
