---
title: "Управляемые клиенты"
description: "Как управляемые маршрутизатором приложения интегрируются с ClientAppManager и сопоставителем портов"
slug: "managed-clients"
lastUpdated: "2025-10"
accurateFor: "2.10.0"
---

## 1. Обзор

Записи в [`clients.config`](/docs/specs/configuration/#clients-config) указывают роутеру, какие приложения запускать при старте. Каждая запись может работать как **управляемый** клиент (предпочтительно) или как **неуправляемый** клиент. Управляемые клиенты взаимодействуют с `ClientAppManager`, который:

- Создает экземпляр приложения и отслеживает состояние жизненного цикла для консоли роутера
- Предоставляет пользователю элементы управления запуском/остановкой и обеспечивает корректное завершение работы при выходе из роутера
- Размещает легковесный **реестр клиентов** и **маппер портов**, чтобы приложения могли обнаруживать сервисы друг друга

Неуправляемые клиенты просто вызывают метод `main()`; используйте их только для устаревшего кода, который невозможно модернизировать.

## 2. Реализация управляемого клиента

Управляемые клиенты должны реализовывать либо `net.i2p.app.ClientApp` (для пользовательских приложений), либо `net.i2p.router.app.RouterApp` (для расширений router). Предоставьте один из конструкторов ниже, чтобы менеджер мог передать аргументы контекста и конфигурации:

```java
public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)
```
```java
public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args)
```
Массив `args` содержит значения, настроенные в `clients.config` или отдельных файлах в `clients.config.d/`. По возможности расширяйте вспомогательные классы `ClientApp` / `RouterApp`, чтобы унаследовать стандартную логику жизненного цикла.

### 2.1 Lifecycle Methods

Ожидается, что управляемые клиенты реализуют:

- `startup()` - выполняет инициализацию и возвращает управление незамедлительно. Должен вызвать `manager.notify()` хотя бы один раз для перехода из состояния INITIALIZED.
- `shutdown(String[] args)` - освобождает ресурсы и останавливает фоновые потоки. Должен вызвать `manager.notify()` хотя бы один раз для изменения состояния на STOPPING или STOPPED.
- `getState()` - сообщает консоли, работает ли приложение, запускается, останавливается или завершилось с ошибкой

Менеджер вызывает эти методы по мере того, как пользователи взаимодействуют с консолью.

### 2.2 Advantages

- Точная отчетность о статусе в консоли роутера
- Чистые перезапуски без утечек потоков или статических ссылок
- Меньший объем используемой памяти после остановки приложения
- Централизованное логирование и отчетность об ошибках через внедренный контекст

## 3. Unmanaged Clients (Fallback Mode)

Если настроенный класс не реализует управляемый интерфейс, роутер запускает его путем вызова `main(String[] args)` и не может отслеживать полученный процесс. Консоль показывает ограниченную информацию, и хуки завершения работы могут не выполниться. Используйте этот режим для скриптов или одноразовых утилит, которые не могут применить управляемые API.

## 4. Client Registry

Управляемые и неуправляемые клиенты могут регистрировать себя в менеджере, чтобы другие компоненты могли получать ссылку по имени:

```java
manager.register(this);
```
Регистрация использует возвращаемое значение `getName()` клиента в качестве ключа реестра. Известные регистрации включают `console`, `i2ptunnel`, `Jetty`, `outproxy` и `update`. Получите клиент с помощью `ClientAppManager.getRegisteredApp(String name)` для координации функций (например, консоль запрашивает у Jetty детали статуса).

Обратите внимание, что реестр клиентов и маппер портов являются отдельными системами. Реестр клиентов обеспечивает межприложенное взаимодействие посредством поиска по имени, в то время как маппер портов сопоставляет имена сервисов с комбинациями host:port для обнаружения сервисов.

## 3. Неуправляемые клиенты (режим отката)

Маппер портов предоставляет простой справочник для внутренних TCP-сервисов. Регистрируйте loopback-порты, чтобы участники проекта избегали жёстко заданных адресов:

```java
context.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445);
```
Или с явным указанием хоста:

```java
context.portMapper().register(PortMapper.SVC_HTTP_PROXY, "127.0.0.1", 4444);
```
Поиск сервисов выполняется с помощью `PortMapper.getPort(String name)` (возвращает -1, если не найден) или `getPort(String name, int defaultPort)` (возвращает значение по умолчанию, если не найден). Проверить статус регистрации можно с помощью `isRegistered(String name)`, а получить зарегистрированный хост — с помощью `getActualHost(String name)`.

Общие константы сервиса маппинга портов из `net.i2p.util.PortMapper`:

- `SVC_CONSOLE` - Консоль роутера (порт по умолчанию 7657)
- `SVC_HTTP_PROXY` - HTTP прокси (порт по умолчанию 4444)
- `SVC_HTTPS_PROXY` - HTTPS прокси (порт по умолчанию 4445)
- `SVC_I2PTUNNEL` - Менеджер I2PTunnel
- `SVC_SAM` - SAM мост (порт по умолчанию 7656)
- `SVC_SAM_SSL` - SAM мост SSL
- `SVC_SAM_UDP` - SAM UDP
- `SVC_BOB` - BOB мост (порт по умолчанию 2827)
- `SVC_EEPSITE` - Стандартный eepsite (порт по умолчанию 7658)
- `SVC_HTTPS_EEPSITE` - HTTPS eepsite
- `SVC_IRC` - IRC tunnel (порт по умолчанию 6668)
- `SVC_SUSIDNS` - SusiDNS

Примечание: `httpclient`, `httpsclient` и `httpbidirclient` — это типы tunnel для i2ptunnel (используются в конфигурации `tunnel.N.type`), а не константы сервиса port mapper.

## 4. Реестр клиентов

### 2.1 Методы жизненного цикла

Начиная с версии 0.9.42, router поддерживает разделение конфигурации на отдельные файлы в директории `clients.config.d/`. Каждый файл содержит свойства для одного клиента, где все свойства имеют префикс `clientApp.0.`:

```
clientApp.0.main=net.i2p.router.web.RouterConsoleRunner
clientApp.0.name=Router Console
clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/
clientApp.0.delay=0
clientApp.0.onBoot=true
```
Это рекомендуемый подход для новых установок и плагинов.

### 2.2 Преимущества

Для обратной совместимости традиционный формат использует последовательную нумерацию:

```
clientApp.0.main=net.i2p.router.web.RouterConsoleRunner
clientApp.0.name=Router Console
clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/
clientApp.1.main=net.i2p.apps.systray.UrlLauncher
clientApp.1.name=URL Launcher
clientApp.1.delay=5
```
### 6.3 Configuration Properties

**Обязательно:** - `main` - Полное имя класса, реализующего ClientApp или RouterApp, или содержащего статический метод `main(String[] args)`

**Опционально:** - `name` - Отображаемое имя для консоли router (по умолчанию имя класса) - `args` - Аргументы, разделённые пробелами или табуляцией (поддерживает строки в кавычках) - `delay` - Секунды до запуска (по умолчанию 120) - `onBoot` - Принудительно устанавливает `delay=0` если true - `startOnLoad` - Включает/отключает клиент (по умолчанию true)

**Специфичные для плагина:** - `stopargs` - Аргументы, передаваемые при остановке - `uninstallargs` - Аргументы, передаваемые при удалении плагина - `classpath` - Дополнительные записи classpath, разделённые запятыми

**Подстановка переменных для плагинов:** - `$I2P` - базовый каталог I2P - `$CONFIG` - каталог конфигурации пользователя (например, ~/.i2p) - `$PLUGIN` - каталог плагина - `$OS` - название операционной системы - `$ARCH` - название архитектуры

## 5. Port Mapper

- Предпочитайте управляемые клиенты; используйте неуправляемые только в крайнем случае.
- Держите инициализацию и завершение работы облегчёнными, чтобы операции консоли оставались отзывчивыми.
- Используйте описательные имена в реестре и для портов, чтобы диагностические инструменты (и конечные пользователи) понимали, что делает сервис.
- Избегайте статических синглтонов - полагайтесь на внедрённый контекст и менеджер для совместного использования ресурсов.
- Вызывайте `manager.notify()` при всех переходах состояния для поддержания точного статуса консоли.
- Если вам необходимо запускаться в отдельной JVM, документируйте, как логи и диагностика передаются в основную консоль.
- Для внешних программ рассмотрите использование ShellService (добавлен в версии 1.7.0) для получения преимуществ управляемого клиента.

## 6. Формат конфигурации

Управляемые клиенты были введены в **версии 0.9.4** (17 декабря 2012 года) и остаются рекомендуемой архитектурой по состоянию на **версию 2.10.0** (9 сентября 2025 года). Основные API оставались стабильными без каких-либо критических изменений за весь этот период:

- Сигнатуры конструкторов не изменены
- Методы жизненного цикла (startup, shutdown, getState) не изменены
- Методы регистрации ClientAppManager не изменены
- Методы регистрации и поиска PortMapper не изменены

Значимые улучшения: - **0.9.42 (2019)** - структура каталогов clients.config.d/ для отдельных файлов конфигурации - **1.7.0 (2021)** - добавлен ShellService для отслеживания состояния внешних программ - **2.10.0 (2025)** - текущий релиз без изменений в API управляемых клиентов

Следующий крупный релиз будет требовать Java 17+ как минимум (требование инфраструктуры, а не изменение API).

## References

- [Спецификация clients.config](/docs/specs/configuration/#clients-config)
- [Спецификация конфигурационного файла](/docs/specs/configuration/)
- [Указатель технической документации I2P](/docs/)
- [ClientAppManager Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientAppManager.html) (API 0.9.66)
- [PortMapper Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/util/PortMapper.html) (API 0.9.66)
- [Интерфейс ClientApp](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) (API 0.9.66)
- [Интерфейс RouterApp](https://i2p.github.io/i2p.i2p/net/i2p/router/app/RouterApp.html) (API 0.9.66)
- [Альтернативная Javadoc (стабильная версия)](https://docs.i2p-projekt.de/javadoc/)
- [Альтернативная Javadoc (clearnet-зеркало)](https://eyedeekay.github.io/javadoc-i2p/)

> **Примечание:** Сеть I2P размещает полную документацию по адресу http://idk.i2p/javadoc-i2p/, для доступа к которой требуется I2P router. Для доступа из обычного интернета используйте зеркало GitHub Pages, указанное выше.
