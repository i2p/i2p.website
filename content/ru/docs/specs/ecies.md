---
title: "Спецификация шифрования ECIES-X25519-AEAD-Ratchet"
description: "Интегрированная схема шифрования на эллиптических кривых для I2P (X25519 + AEAD)"
slug: "ecies"
lastUpdated: "2025-10"
accurateFor: "2.10.0"
toc: true
---

## Обзор

### Назначение

ECIES-X25519-AEAD-Ratchet — современный протокол сквозного шифрования I2P, заменяющий устаревшую систему ElGamal/AES+SessionTags. Он обеспечивает прямую секретность, аутентифицированное шифрование и значительные улучшения производительности и безопасности.

### Основные улучшения по сравнению с ElGamal/AES+SessionTags

- **Ключи меньшего размера**: 32-байтные ключи против 256-байтных открытых ключей ElGamal (снижение на 87,5%)
- **Прямая секретность**: достигается посредством DH ratcheting (поэтапное обновление ключей) (отсутствует в устаревшем протоколе)
- **Современная криптография**: X25519 DH, ChaCha20-Poly1305 AEAD, SHA-256
- **Аутентифицированное шифрование**: встроенная аутентификация через схему AEAD
- **Двунаправленный протокол**: сопряжённые сессии (входящая/исходящая) против однонаправленного устаревшего протокола
- **Эффективные теги**: 8-байтные сеансовые теги против 32-байтных тегов (снижение на 75%)
- **Маскировка трафика**: кодирование Elligator2 делает рукопожатия неотличимыми от случайных данных

### Статус развертывания

- **Первый релиз**: Версия 0.9.46 (25 мая 2020 г.)
- **Развертывание в сети**: Завершено по состоянию на 2020 год
- **Текущий статус**: Зрелый, широко развернут (более 5 лет в эксплуатации)
- **Поддержка router (маршрутизатор I2P)**: Требуется версия 0.9.46 или выше
- **Требования к Floodfill (специальные узлы индексирования netDb)**: Практически 100%-ное принятие для зашифрованных запросов

### Статус реализации

**Полностью реализовано:** - Сообщения новой сессии (NS) с привязкой - Сообщения ответа новой сессии (NSR) - Сообщения существующей сессии (ES) - Механизм DH-трещотки - Трещотки для Session tag (тегов сессии) и симметричных ключей - Блоки DateTime, NextKey, ACK, ACK Request, Garlic Clove (долька Garlic) и Padding

**Не реализовано (на момент версии 0.9.50):** - блок MessageNumbers (тип 6) - блок Options (тип 5) - блок Termination (тип 4) - Автоматические ответы на уровне протокола - Режим с нулевым статическим ключом - Мультикаст-сессии

**Примечание**: Статус реализации для версий с 1.5.0 по 2.10.0 (2021–2025) требует проверки, так как некоторые функции могли быть добавлены.

---

## Основа протокола

### Noise Protocol Framework (фреймворк протоколов Noise)

ECIES-X25519-AEAD-Ratchet основан на [Noise Protocol Framework](https://noiseprotocol.org/) (фреймворк протоколов Noise) (ревизия 34, 2018-07-11), в частности на шаблоне рукопожатия **IK** (интерактивный, с известным удалённым статическим ключом) с расширениями, специфичными для I2P.

### Идентификатор протокола Noise

```
Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256
```
**Компоненты идентификатора:** - `Noise` - Базовый фреймворк - `IK` - Интерактивный шаблон рукопожатия с известным удалённым статическим ключом - `elg2` - Кодирование Elligator2 для эфемерных ключей (расширение I2P) - `+hs2` - MixHash вызывается перед вторым сообщением для смешивания тега (расширение I2P) - `25519` - Функция Диффи—Хеллмана X25519 - `ChaChaPoly` - Шифр AEAD ChaCha20-Poly1305 - `SHA256` - Хэш-функция SHA-256

### Шаблон рукопожатия Noise

**Нотация шаблона IK:**

```
<- s                    (Bob's static key known to Alice)
...
-> e, es, s, ss         (Alice sends ephemeral, DH es, static key, DH ss)
<- e, ee, se            (Bob sends ephemeral, DH ee, DH se)
```
**Значения токенов:** - `e` - передача эфемерного ключа - `s` - передача статического ключа - `es` - DH (Диффи-Хеллман) между эфемерным ключом Алисы и статическим ключом Боба - `ss` - DH между статическим ключом Алисы и статическим ключом Боба - `ee` - DH между эфемерным ключом Алисы и эфемерным ключом Боба - `se` - DH между статическим ключом Боба и эфемерным ключом Алисы

### Свойства безопасности Noise (протокольный фреймворк)

Используя терминологию Noise, паттерн IK обеспечивает:

<table style="width:100%; border-collapse:collapse; margin-bottom:1.5rem;">
  <thead>
    <tr>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Message</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Authentication Level</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Confidentiality Level</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Message&nbsp;1 (NS)</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Level&nbsp;1 (sender auth, KCI vulnerable)</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Level&nbsp;2 (weak forward secrecy)</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Message&nbsp;2 (NSR)</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Level&nbsp;2 (mutual auth)</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Level&nbsp;4 (weak forward secrecy)</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Transport (ES)</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Level&nbsp;2 (mutual auth)</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Level&nbsp;5 (strong forward secrecy)</td>
    </tr>
  </tbody>
</table>
**Уровни аутентификации:** - **Уровень 1**: Полезная нагрузка аутентифицирована как принадлежащая владельцу статического ключа отправителя, но уязвима для Key Compromise Impersonation (подмена личности при компрометации ключа, KCI) - **Уровень 2**: Устойчива к атакам KCI после NSR

**Уровни конфиденциальности:** - **Уровень 2**: Прямая секретность (forward secrecy), если статический ключ отправителя впоследствии компрометирован - **Уровень 4**: Прямая секретность, если эфемерный ключ отправителя впоследствии компрометирован - **Уровень 5**: Полная прямая секретность после удаления обоих эфемерных ключей

### Различия между IK и XK

Паттерн IK отличается от паттерна XK, используемого в NTCP2 и SSU2:

1. **Четыре операции DH (Диффи—Хеллмана)**: IK использует 4 операции DH (es, ss, ee, se) против 3 у XK
2. **Мгновенная аутентификация**: Алиса аутентифицируется в первом сообщении (уровень аутентификации 1)
3. **Более быстрое достижение прямой секретности**: Полная прямая секретность (уровень 5) достигается после второго сообщения (1-RTT)
4. **Компромисс**: Полезная нагрузка первого сообщения не обладает прямой секретностью (в отличие от XK, где все полезные нагрузки обладают прямой секретностью)

**Сводка**: IK обеспечивает доставку ответа Боба за 1-RTT с полной прямой секретностью, ценой отсутствия прямой секретности для начального запроса.

### Концепции Signal Double Ratchet (алгоритма «двойной трещотки»)

ECIES (интегрированная схема шифрования на эллиптических кривых) использует идеи из [Signal Double Ratchet Algorithm](https://signal.org/docs/specifications/doubleratchet/):

- **Ратчет DH**: Обеспечивает прямую секретность за счет периодического обмена новыми ключами DH
- **Ратчет симметричных ключей**: Выводит новые сеансовые ключи для каждого сообщения
- **Ратчет Session Tag (меток сеанса)**: Детерминированно генерирует одноразовые session tags

**Ключевые отличия от Signal:** - **Менее частый ratcheting (механизм пошагового обновления ключей)**: I2P выполняет ratcheting только при необходимости (при близком исчерпании тегов или по политике) - **Сессионные теги вместо шифрования заголовков**: использует детерминированные теги, а не зашифрованные заголовки - **Явные ACK**: использует in-band блоки ACK, вместо того чтобы полагаться только на обратный трафик - **Раздельные ratchet'ы для тегов и ключей**: эффективнее для получателя (можно отложить вычисление ключа)

### Расширения I2P для протокола Noise

1. **Кодирование Elligator2**: Эфемерные ключи кодируются так, чтобы быть неотличимыми от случайных
2. **Метка, добавляемая перед NSR**: Метка сессии добавляется перед сообщением NSR (Noise Session Request — запрос сессии Noise) для корреляции
3. **Определённый формат полезной нагрузки**: Блочная структура полезной нагрузки для всех типов сообщений
4. **Инкапсуляция I2NP**: Все сообщения обёрнуты в заголовки I2NP Garlic Message (многочастного сообщения I2P)
5. **Отдельная фаза данных**: Транспортные сообщения (ES) отличаются от стандартной фазы данных Noise

---

## Криптографические примитивы

### Диффи-Хеллман на X25519

**Спецификация**: [RFC 7748](https://tools.ietf.org/html/rfc7748)

**Ключевые свойства:** - **Размер закрытого ключа**: 32 байта - **Размер открытого ключа**: 32 байта - **Размер общего секрета**: 32 байта - **Порядок байт**: младший порядок байт (little-endian) - **Кривая**: Curve25519

**Операции:**

### X25519 GENERATE_PRIVATE()

Генерирует случайный 32-байтный закрытый ключ:

```
privkey = CSRNG(32)
```
### X25519 DERIVE_PUBLIC(privkey)

Вычисляет соответствующий открытый ключ:

```
pubkey = curve25519_scalarmult_base(privkey)
```
Возвращает 32-байтный открытый ключ в формате little-endian.

### X25519 DH(privkey, pubkey)

Выполняет согласование ключей Диффи-Хеллмана:

```
sharedSecret = curve25519_scalarmult(privkey, pubkey)
```
Возвращает 32-байтовый общий секрет.

**Примечание по безопасности**: Реализации обязаны проверять, что общий секрет не состоит полностью из нулей (слабый ключ). В таком случае отклоните и прервите рукопожатие.

### ChaCha20-Poly1305 AEAD (аутентифицированное шифрование с дополнительными данными)

**Спецификация**: [RFC 7539](https://tools.ietf.org/html/rfc7539) раздел 2.8

**Параметры:** - **Размер ключа**: 32 байта (256 бит) - **Размер nonce (одноразового значения)**: 12 байт (96 бит) - **Размер MAC**: 16 байт (128 бит) - **Размер блока**: 64 байта (внутренний)

**Формат нонса:**

```
Byte 0-3:   0x00 0x00 0x00 0x00  (always zero)
Byte 4-11:  Little-endian counter (message number N)
```
**Схема AEAD:**

AEAD (аутентифицированное шифрование с дополнительными данными) объединяет потоковый шифр ChaCha20 с алгоритмом MAC Poly1305:

1. Сгенерируйте ключевой поток ChaCha20 на основе ключа и nonce (одноразовое число)
2. Зашифруйте открытый текст с помощью операции XOR (исключающего ИЛИ) с ключевым потоком
3. Вычислите MAC (код аутентификации сообщения) Poly1305 над (associated data (дополнительные аутентифицируемые данные) || шифртекстом)
4. Добавьте 16-байтный MAC к шифртексту

### ChaCha20-Poly1305 ENCRYPT(k, n, plaintext, ad)

Шифрует открытый текст с аутентификацией:

```python
# Inputs
k = 32-byte cipher key
n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number)
plaintext = data to encrypt (0 to 65519 bytes)
ad = associated data (optional, used in MAC calculation)

# Output
ciphertext = chacha20_encrypt(k, n, plaintext)
mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n))
return ciphertext || mac  # Total length = len(plaintext) + 16
```
**Свойства:** - Шифртекст имеет ту же длину, что и открытый текст (потоковый шифр) - Выходные данные имеют размер plaintext_length + 16 байт (включает MAC) - Все выходные данные неотличимы от случайных данных, если ключ секретен - MAC аутентифицирует как ассоциированные данные, так и шифртекст

### ChaCha20-Poly1305 DECRYPT(k, n, ciphertext, ad)

Расшифровывает и проверяет аутентификацию:

```python
# Split ciphertext and MAC
ct_without_mac = ciphertext[0:-16]
received_mac = ciphertext[-16:]

# Verify MAC
expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n))
if not constant_time_compare(received_mac, expected_mac):
    raise AuthenticationError("MAC verification failed")

# Decrypt
plaintext = chacha20_decrypt(k, n, ct_without_mac)
return plaintext
```
**Критические требования безопасности:** - Nonces (одноразовые числа) ДОЛЖНЫ быть уникальными для каждого сообщения с одним и тем же ключом - Nonces НЕ ДОЛЖНЫ переиспользоваться (катастрофический сбой при повторном использовании) - Проверка MAC ДОЛЖНА использовать константное по времени сравнение для предотвращения тайминговых атак - Неуспешная проверка MAC ДОЛЖНА приводить к полному отклонению сообщения (без частичной расшифровки)

### Хеш-функция SHA-256

**Спецификация**: NIST FIPS 180-4

**Свойства:** - **Размер вывода**: 32 байта (256 бит) - **Размер блока**: 64 байта (512 бит) - **Уровень безопасности**: 128 бит (устойчивость к коллизиям)

**Операции:**

### SHA-256 H(p, d)

Хэш SHA-256 со строкой персонализации:

```
H(p, d) := SHA256(p || d)
```
Где `||` обозначает конкатенацию, `p` — строка персонализации, `d` — данные.

### SHA-256 MixHash(d) (смешанный хеш)

Обновляет текущий хэш новыми данными:

```
h = SHA256(h || d)
```
Используется на протяжении всего рукопожатия Noise для поддержания хэша транскрипта.

### Деривация ключей HKDF

**Спецификация**: [RFC 5869](https://tools.ietf.org/html/rfc5869)

**Описание**: Функция деривации ключей на основе HMAC с использованием SHA-256

**Параметры:** - **Хэш-функция**: HMAC-SHA256 - **Длина соли**: До 32 байт (размер выходных данных SHA-256) - **Длина вывода**: Переменная (до 255 * 32 байт)

**Функция HKDF:**

```python
def HKDF(salt, ikm, info, length):
    """
    Args:
        salt: Salt value (32 bytes max for SHA-256)
        ikm: Input key material (any length)
        info: Context-specific info string
        length: Desired output length in bytes
    
    Returns:
        output: Derived key material (length bytes)
    """
    # Extract phase
    prk = HMAC-SHA256(salt, ikm)
    
    # Expand phase
    n = ceil(length / 32)
    t = b''
    okm = b''
    for i in range(1, n + 1):
        t = HMAC-SHA256(prk, t || info || byte(i))
        okm = okm || t
    
    return okm[0:length]
```
**Типичные сценарии использования:**

```python
# Generate two keys (64 bytes total)
keydata = HKDF(chainKey, sharedSecret, "KDFDHRatchetStep", 64)
nextRootKey = keydata[0:31]
chainKey = keydata[32:63]

# Generate session tag (8 bytes)
tagdata = HKDF(chainKey, CONSTANT, "SessionTagKeyGen", 64)
nextChainKey = tagdata[0:31]
sessionTag = tagdata[32:39]

# Generate symmetric key (32 bytes)
keydata = HKDF(chainKey, ZEROLEN, "SymmetricRatchet", 64)
nextChainKey = keydata[0:31]
sessionKey = keydata[32:63]
```
**Строки info, используемые в ECIES:** - `"KDFDHRatchetStep"` - вывод ключа для DH-трещотки - `"TagAndKeyGenKeys"` - инициализация ключей цепочки меток и цепочки ключей - `"STInitialization"` - инициализация трещотки сеансовых меток - `"SessionTagKeyGen"` - генерация сеансовых меток - `"SymmetricRatchet"` - генерация симметрических ключей - `"XDHRatchetTagSet"` - ключ набора меток DH-трещотки - `"SessionReplyTags"` - генерация набора меток NSR - `"AttachPayloadKDF"` - вывод ключа полезной нагрузки NSR

### Кодирование Elligator2 (криптографическая схема отображения точек эллиптической кривой в равномерно распределённые случайные данные)

**Назначение**: Кодировать открытые ключи X25519 так, чтобы они были неотличимы от равномерно распределённых случайных 32-байтовых строк.

**Спецификация**: [Статья Elligator2](https://elligator.cr.yp.to/elligator-20130828.pdf)

**Проблема**: Стандартные публичные ключи X25519 имеют распознаваемую структуру. Наблюдатель может определить сообщения рукопожатия, обнаруживая эти ключи, даже если содержимое зашифровано.

**Решение**: Elligator2 обеспечивает биективное отображение между ~50% корректных открытых ключей X25519 и на вид случайными 254-битными строками.

**Генерация ключей с использованием Elligator2:**

### Elligator2 GENERATE_PRIVATE_ELG2()

Генерирует закрытый ключ, которому соответствует открытый ключ, кодируемый по схеме Elligator2 (алгоритм маскировки открытых ключей):

```python
while True:
    privkey = CSRNG(32)
    pubkey = DERIVE_PUBLIC(privkey)
    
    # Test if public key is Elligator2-encodable
    try:
        encoded = ENCODE_ELG2(pubkey)
        # Success - this key pair is suitable
        return privkey
    except NotEncodableError:
        # Try again with new random key
        continue
```
**Важно**: Примерно 50% случайно сгенерированных закрытых ключей приводят к получению некодируемых открытых ключей. Такие закрытые ключи необходимо отбросить и попытаться сгенерировать заново.

**Оптимизация производительности**: заранее генерируйте ключи в фоновом потоке, чтобы поддерживать пул подходящих пар ключей и избежать задержек во время рукопожатия.

### Elligator2 ENCODE_ELG2(pubkey)

Кодирует открытый ключ в 32 байта, похожие на случайные:

```python
def ENCODE_ELG2(pubkey):
    """
    Encodes X25519 public key using Elligator2.
    
    Args:
        pubkey: 32-byte X25519 public key (little-endian)
    
    Returns:
        encoded: 32-byte encoded key indistinguishable from random
    
    Raises:
        NotEncodableError: If pubkey cannot be encoded
    """
    # Perform Elligator2 representative calculation
    # Returns 254-bit value (31.75 bytes)
    encodedKey = elligator2_encode(pubkey)
    
    # Add 2 random bits to MSB to make full 32 bytes
    randomByte = CSRNG(1)
    encodedKey[31] |= (randomByte & 0xc0)
    
    return encodedKey
```
**Подробности кодирования:** - Elligator2 даёт 254 бита (не полные 256) - Старшие 2 бита 31-го байта — случайное заполнение - Результат равномерно распределён по 32-байтовому пространству - Успешно кодирует примерно 50% валидных публичных ключей X25519

### Elligator2 DECODE_ELG2(encodedKey)

Декодируется обратно в исходный открытый ключ:

```python
def DECODE_ELG2(encodedKey):
    """
    Decodes Elligator2-encoded key back to X25519 public key.
    
    Args:
        encodedKey: 32-byte encoded key
    
    Returns:
        pubkey: 32-byte X25519 public key (little-endian)
    """
    # Mask out 2 random padding bits from MSB
    encodedKey[31] &= 0x3f
    
    # Perform Elligator2 representative inversion
    pubkey = elligator2_decode(encodedKey)
    
    return pubkey
```
**Свойства безопасности:** - Закодированные ключи вычислительно неотличимы от случайных байтов - Ни один статистический тест не может надежно обнаружить ключи, закодированные с использованием Elligator2 - Декодирование детерминированно (один и тот же закодированный ключ всегда дает один и тот же открытый ключ) - Кодирование биективно для ~50% ключей в кодируемом подмножестве

**Примечания по реализации:** - Сохраняйте закодированные ключи на этапе генерации, чтобы избежать повторного кодирования во время рукопожатия - Неподходящие ключи, полученные при генерации Elligator2 (метод маскировки точек эллиптической кривой), можно использовать для NTCP2 (которому Elligator2 не требуется) - Фоновая генерация ключей критически важна для производительности - Среднее время генерации удваивается из-за 50% уровня отбраковки

---

## Форматы сообщений

### Обзор

ECIES (интегрированная схема шифрования на эллиптических кривых) определяет три типа сообщений:

1. **New Session (NS)**: Начальное сообщение рукопожатия от Алисы к Бобу
2. **New Session Reply (NSR)**: Ответное сообщение рукопожатия от Боба Алисе
3. **Existing Session (ES)**: Все последующие сообщения в обоих направлениях

Все сообщения инкапсулируются в формате I2NP Garlic Message с дополнительными слоями шифрования.

### Контейнер Garlic Message протокола I2NP

Все сообщения ECIES (схема интегрированного шифрования на эллиптических кривых) обернуты в стандартные заголовки I2NP Garlic Message:

```
+----+----+----+----+----+----+----+----+
|type|      msg_id       |  expiration   |
+----+----+----+----+----+----+----+----+
                         |  size   |chks|
+----+----+----+----+----+----+----+----+
|      length       |                   |
+----+----+----+----+                   +
|          encrypted data               |
~                                       ~
```
**Поля:** - `type`: 0x26 (Garlic Message — чесночное сообщение) - `msg_id`: 4-байтовый идентификатор сообщения I2NP - `expiration`: 8-байтовая метка времени Unix (миллисекунды) - `size`: 2-байтовый размер полезной нагрузки - `chks`: 1-байтовая контрольная сумма - `length`: 4-байтовая длина зашифрованных данных - `encrypted data`: ECIES-зашифрованная полезная нагрузка

**Назначение**: Обеспечивает идентификацию сообщений и их маршрутизацию на уровне I2NP. Поле `length` позволяет получателям узнать общий размер зашифрованной полезной нагрузки.

### Сообщение новой сессии (NS)

Сообщение New Session инициирует новый сеанс от Алисы к Бобу. Оно бывает в трех вариантах:

1. **С привязкой** (1b): Включает статический ключ Алисы для двунаправленной связи
2. **Без привязки** (1c): Не включает статический ключ для однонаправленной связи
3. **Однократный** (1d): Режим одиночного сообщения без установления сеанса

### Сообщение NS с привязкой (тип 1b)

**Сценарий использования**: Потоковая передача, датаграммы с возможностью ответа, любой протокол, требующий ответов

**Общая длина**: 96 + payload_length байт

**Формат**:

```
+----+----+----+----+----+----+----+----+
|                                       |
+                                       +
|   New Session Ephemeral Public Key    |
+             32 bytes                  +
|     Encoded with Elligator2           |
+                                       +
|                                       |
+----+----+----+----+----+----+----+----+
|                                       |
+         Static Key Section            +
|       ChaCha20 encrypted data         |
+            32 bytes                   +
|                                       |
+                                       +
|                                       |
+----+----+----+----+----+----+----+----+
|  Poly1305 Message Authentication Code |
+    (MAC) for Static Key Section       +
|             16 bytes                  |
+----+----+----+----+----+----+----+----+
|                                       |
+            Payload Section            +
|       ChaCha20 encrypted data         |
~          Variable length              ~
|                                       |
+                                       +
|                                       |
+----+----+----+----+----+----+----+----+
|  Poly1305 Message Authentication Code |
+         (MAC) for Payload Section     +
|             16 bytes                  |
+----+----+----+----+----+----+----+----+
```
**Сведения о поле:**

**Эфемерный открытый ключ** (32 байта, в открытом виде): - одноразовый открытый ключ X25519 Алисы - кодируется с помощью Elligator2 (неотличим от случайных данных) - генерируется заново для каждого сообщения NS (никогда не переиспользуется) - формат little-endian (порядок байтов от младшего к старшему)

**Раздел статического ключа** (32 байта зашифровано, 48 байт с MAC): - Содержит статический открытый ключ X25519 Алисы (32 байта) - Зашифровано с помощью ChaCha20 - Аутентифицировано с помощью Poly1305 MAC (16 байт) - Используется Бобом для привязки сеанса к назначению Алисы

**Секция полезной нагрузки** (переменной длины, зашифрована, +16 байт MAC): - Содержит garlic cloves (подсообщения внутри garlic-сообщения) и другие блоки - Должна включать блок DateTime в качестве первого блока - Обычно включает блоки Garlic Clove с данными приложения - Может включать NextKey block (блок следующего ключа) для немедленного ratchet (механизм пошаговой смены ключей) - Шифруется с помощью ChaCha20 - Аутентифицируется с помощью Poly1305 MAC (16 байт)

**Свойства безопасности:** - Эфемерный ключ обеспечивает компонент прямой секретности - Статический ключ аутентифицирует Алису (привязка к назначению) - Обе секции имеют отдельные MAC для разделения доменов - Всего рукопожатие выполняет 2 операции DH (es, ss)

### Сообщение NS без привязки (тип 1c)

**Сценарий использования**: Сырые датаграммы, где ответ не ожидается и не желателен

**Общая длина**: 96 + payload_length байт

**Формат**:

```
+----+----+----+----+----+----+----+----+
|                                       |
+                                       +
|   New Session Ephemeral Public Key    |
+             32 bytes                  +
|     Encoded with Elligator2           |
+                                       +
|                                       |
+----+----+----+----+----+----+----+----+
|                                       |
+           Flags Section               +
|       ChaCha20 encrypted data         |
+            32 bytes                   +
|           All zeros                   |
+                                       +
|                                       |
+----+----+----+----+----+----+----+----+
|  Poly1305 Message Authentication Code |
+         (MAC) for above section       +
|             16 bytes                  |
+----+----+----+----+----+----+----+----+
|                                       |
+            Payload Section            +
|       ChaCha20 encrypted data         |
~          Variable length              ~
|                                       |
+                                       +
|                                       |
+----+----+----+----+----+----+----+----+
|  Poly1305 Message Authentication Code |
+         (MAC) for Payload Section     +
|             16 bytes                  |
+----+----+----+----+----+----+----+----+
```
**Ключевое отличие**: Раздел Flags содержит 32 байта нулей вместо статического ключа.

**Определение**: Боб определяет тип сообщения, расшифровав 32-байтовую секцию и проверив, что все байты равны нулю: - Все нули → непривязанный сеанс (тип 1c) - Ненулевые → привязанный сеанс со статическим ключом (тип 1b)

**Свойства:** - Отсутствие статического ключа означает отсутствие привязки к назначению Алисы - Боб не может отправлять ответы (назначение неизвестно) - Выполняет только 1 операцию DH - Следует шаблону Noise "N", а не "IK" - Более эффективно, если ответы никогда не требуются

**Раздел флагов** (зарезервирован для будущего использования): В настоящее время все биты равны нулю. В будущих версиях может использоваться для согласования возможностей.

### Одноразовое сообщение NS (тип 1d)

**Сценарий использования**: Одно анонимное сообщение без сеанса и без ожидания ответа

**Общая длина**: 96 + payload_length байт

**Формат**: Идентичен NS без привязки (тип 1c)

**Отличия**:  - Тип 1c может отправлять несколько сообщений в той же сессии (далее следуют сообщения ES) - Тип 1d отправляет ровно одно сообщение без установления сессии - На практике реализации изначально могут обрабатывать их одинаково

**Свойства:** - Максимальная анонимность (без статического ключа, без сеанса) - Состояние сеанса не сохраняется ни одной стороной - Следует шаблону Noise "N" - Одна операция Диффи—Хеллмана (es)

### Сообщение «Ответ на новый сеанс» (NSR)

Боб отправляет одно или несколько сообщений NSR в ответ на сообщение NS от Алисы. NSR завершает рукопожатие Noise IK и устанавливает двунаправленный сеанс.

**Общая длина**: 72 + payload_length байт

**Формат**:

```
+----+----+----+----+----+----+----+----+
|       Session Tag   8 bytes           |
+----+----+----+----+----+----+----+----+
|                                       |
+        Ephemeral Public Key           +
|                                       |
+            32 bytes                   +
|     Encoded with Elligator2           |
+                                       +
|                                       |
+----+----+----+----+----+----+----+----+
|  Poly1305 Message Authentication Code |
+  (MAC) for Key Section (empty)        +
|             16 bytes                  |
+----+----+----+----+----+----+----+----+
|                                       |
+            Payload Section            +
|       ChaCha20 encrypted data         |
~          Variable length              ~
|                                       |
+                                       +
|                                       |
+----+----+----+----+----+----+----+----+
|  Poly1305 Message Authentication Code |
+         (MAC) for Payload Section     +
|             16 bytes                  |
+----+----+----+----+----+----+----+----+
```
**Сведения о поле:**

**Метка сеанса** (8 байт, в открытом виде): - Генерируется из набора тегов NSR (см. разделы по KDF (функция выработки ключа)) - Соотносит этот ответ с NS-сообщением Алисы - Позволяет Алисе определить, на какой NS отвечает этот NSR - Одноразовая (никогда не используется повторно)

**Эфемерный открытый ключ** (32 байта, в открытом виде): - Одноразовый открытый ключ X25519 Боба - Закодирован с помощью Elligator2 (метод маскировки эллиптических ключей) - Генерируется заново для каждого сообщения NSR - Должен отличаться для каждого отправленного NSR

**MAC секции ключа** (16 байт): - Аутентифицирует пустые данные (ZEROLEN) - Часть протокола Noise IK (шаблон se) - Использует хэш транскрипта в качестве ассоциированных данных - Критично для связывания NSR с NS

**Раздел полезной нагрузки** (переменной длины): - Содержит garlic cloves (дольки «garlic»-сообщения) и блоки - Обычно включает ответы уровня приложения - Может быть пустым (NSR только с ACK) - Максимальный размер: 65519 байт (65535 - 16-байтный MAC)

**Несколько сообщений NSR:**

Боб может отправить несколько сообщений NSR в ответ на один NS:
- У каждого NSR уникальный эфемерный ключ
- У каждого NSR уникальный тег сеанса
- Алиса использует первый полученный NSR для завершения рукопожатия
- Остальные NSR являются избыточными (на случай потери пакетов)

**Критический тайминг:** - Алиса должна получить один NSR, прежде чем отправлять сообщения ES - Боб должен получить одно сообщение ES, прежде чем отправлять сообщения ES - NSR устанавливает двунаправленные сеансовые ключи с помощью операции split()

**Свойства безопасности:** - Завершает рукопожатие Noise IK - Выполняет 2 дополнительные операции Диффи — Хеллмана (DH) (ee, se) - Итого 4 операции DH для NS+NSR - Обеспечивает взаимную аутентификацию (Уровень 2) - Обеспечивает слабую прямую секретность (Уровень 4) для полезной нагрузки NSR

### Сообщение Existing Session (ES)

Все сообщения после NS/NSR handshake (рукопожатия NS/NSR) используют формат Existing Session (формат «существующего сеанса»). Сообщения ES используются двунаправленно Алисой и Бобом.

**Общая длина**: 8 + payload_length + 16 байт (минимум 24 байта)

**Формат**:

```
+----+----+----+----+----+----+----+----+
|       Session Tag   8 bytes           |
+----+----+----+----+----+----+----+----+
|                                       |
+            Payload Section            +
|       ChaCha20 encrypted data         |
~          Variable length              ~
|                                       |
+                                       +
|                                       |
+----+----+----+----+----+----+----+----+
|  Poly1305 Message Authentication Code |
+              (MAC)                    +
|             16 bytes                  |
+----+----+----+----+----+----+----+----+
```
**Сведения о поле:**

**Тег сеанса** (8 байт, в открытом виде): - Генерируется из текущего исходящего набора тегов - Идентифицирует сеанс и номер сообщения - Получатель по тегу находит ключ сеанса и nonce (одноразовое число) - Одноразовое использование (каждый тег используется ровно один раз) - Формат: первые 8 байт результата HKDF

**Раздел Payload** (переменная длина): - Содержит garlic cloves (подсообщения в garlic encryption) и блоки - Обязательных блоков нет (может быть пустым) - Распространённые блоки: Garlic Clove, NextKey, ACK, ACK Request, Padding - Максимальный размер: 65519 байт (65535 - 16-байтный MAC)

**MAC** (16 байт): - Тег аутентификации Poly1305 - Вычисляется по всей полезной нагрузке - Ассоциированные данные: 8-байтовый тег сессии - Должен корректно проверяться, иначе сообщение отклоняется

**Процесс поиска тегов:**

1. Получатель извлекает 8-байтовый тег
2. Ищет тег во всех текущих входящих наборах тегов
3. Получает соответствующий сеансовый ключ и номер сообщения N
4. Формирует nonce (одноразовое значение): `[0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)]`
5. Расшифровывает полезную нагрузку с использованием AEAD с тегом в качестве ассоциированных данных
6. Удаляет тег из набора тегов (одноразовое использование)
7. Обрабатывает расшифрованные блоки

**Тег сеанса не найден:**

Если тег не найден ни в одном наборе тегов: - Возможно, это сообщение NS → попытаться расшифровать как NS - Возможно, это сообщение NSR → попытаться расшифровать как NSR - Возможно, это пришедший не по порядку ES → ненадолго подождать обновления набора тегов - Возможно, это атака повторного воспроизведения (replay-атака) → отклонить - Возможно, данные повреждены → отклонить

**Пустая полезная нагрузка:**

Сообщения ES могут иметь пустую полезную нагрузку (0 байт): - Служит явным ACK (подтверждение получения) при получении ACK Request (запрос подтверждения) - Обеспечивает ответ на уровне протокола без данных приложения - Всё равно расходует session tag (тег сеанса) - Полезно, когда вышележащему уровню нечего немедленно отправлять

**Свойства безопасности:** - Полная прямая секретность (уровень 5) после получения NSR - Аутентифицированное шифрование посредством AEAD (аутентифицированное шифрование с дополнительными данными) - Тег используется в качестве дополнительных ассоциированных данных - Максимум 65535 сообщений на tagset (набор тегов) до необходимости ratchet (механизма пошагового обновления ключей)

---

## Функции деривации ключей

В этом разделе описаны все операции KDF (функции деривации ключа), используемые в ECIES, и приводятся полные криптографические выводы.

### Обозначения и константы

**Константы:** - `ZEROLEN` - Байтовый массив нулевой длины (пустая строка) - `||` - Оператор конкатенации

**Переменные:** - `h` - Текущий хэш стенограммы обмена (32 байта) - `chainKey` - Ключ сцепления для HKDF (32 байта) - `k` - Ключ симметричного шифра (32 байта) - `n` - Nonce (одноразовое значение) / номер сообщения

**Ключи:** - `ask` / `apk` - статический закрытый/открытый ключ Алисы - `aesk` / `aepk` - эфемерный закрытый/открытый ключ Алисы - `bsk` / `bpk` - статический закрытый/открытый ключ Боба - `besk` / `bepk` - эфемерный закрытый/открытый ключ Боба

### Функции выработки ключей для сообщений NS

### KDF 1: начальный ключ цепочки

Выполняется один раз при инициализации протокола (может быть предварительно вычислено):

```python
# Protocol name (40 bytes, ASCII, no null termination)
protocol_name = "Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256"

# Initialize hash
h = SHA256(protocol_name)

# Initialize chaining key
chainKey = h

# MixHash with empty prologue
h = SHA256(h)

# State: chainKey and h initialized
# Can be precalculated for all outbound sessions
```
**Результат:** - `chainKey` = Начальный цепной ключ для всех последующих KDF (функций выработки ключей) - `h` = Начальный хэш-транскрипт

### KDF 2: Смешивание статического ключа Боба

Боб выполняет это один раз (может быть предварительно вычислено для всех входящих сеансов):

```python
# Bob's static keys (published in LeaseSet)
bsk = GENERATE_PRIVATE()
bpk = DERIVE_PUBLIC(bsk)

# Mix Bob's public key into hash
h = SHA256(h || bpk)

# State: h updated with Bob's identity
# Can be precalculated by Bob for all inbound sessions
```
### KDF 3: Генерация эфемерного ключа Алисы

Алиса генерирует новые ключи для каждого сообщения NS:

```python
# Generate ephemeral key pair suitable for Elligator2
aesk = GENERATE_PRIVATE_ELG2()
aepk = DERIVE_PUBLIC(aesk)

# Mix ephemeral public key into hash
h = SHA256(h || aepk)

# Elligator2 encode for transmission
elg2_aepk = ENCODE_ELG2(aepk)

# State: h updated with Alice's ephemeral key
# Send elg2_aepk as first 32 bytes of NS message
```
### KDF 4: Раздел статического ключа NS (es DH — временно-статический Диффи‑Хеллман)

Выводит ключи для шифрования статического ключа Алисы:

```python
# Perform first DH (ephemeral-static)
sharedSecret = DH(aesk, bpk)  # Alice computes
# Equivalent: sharedSecret = DH(bsk, aepk)  # Bob computes

# Derive cipher key from shared secret
keydata = HKDF(chainKey, sharedSecret, "", 64)
chainKey = keydata[0:31]
k = keydata[32:63]

# AEAD encryption parameters
nonce = 0
associated_data = h  # Current hash transcript

# Encrypt static key section
if binding_requested:
    plaintext = apk  # Alice's static public key (32 bytes)
else:
    plaintext = bytes(32)  # All zeros for unbound

ciphertext = ENCRYPT(k, nonce, plaintext, associated_data)
# ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes

# Mix ciphertext into hash
h = SHA256(h || ciphertext)

# State: Static key section encrypted, h updated
# Send ciphertext (48 bytes) as next part of NS message
```
### KDF 5: Секция полезной нагрузки NS (ss DH, только с привязкой)

Для привязанных сеансов выполните второй обмен ключами Диффи — Хеллмана для шифрования полезной нагрузки:

```python
if binding_requested:
    # Alice's static keys
    ask = GENERATE_PRIVATE()  # Alice's long-term key
    apk = DERIVE_PUBLIC(ask)
    
    # Perform second DH (static-static)
    sharedSecret = DH(ask, bpk)  # Alice computes
    # Equivalent: sharedSecret = DH(bsk, apk)  # Bob computes
    
    # Derive cipher key
    keydata = HKDF(chainKey, sharedSecret, "", 64)
    chainKey = keydata[0:31]
    k = keydata[32:63]
    
    nonce = 0
    associated_data = h
else:
    # Unbound: reuse keys from static key section
    # chainKey and k unchanged
    nonce = 1  # Increment nonce (reusing same key)
    associated_data = h

# Encrypt payload
payload = build_payload()  # DateTime + Garlic Cloves + etc.
ciphertext = ENCRYPT(k, nonce, payload, associated_data)

# Mix ciphertext into hash
h = SHA256(h || ciphertext)

# State: Payload encrypted, h contains complete NS transcript
# Save chainKey and h for NSR processing
# Send ciphertext as final part of NS message
```
**Важные примечания:**

1. **Bound vs Unbound** (связанное против несвязанного): 
   - Bound выполняет 2 операции DH (es + ss)
   - Unbound выполняет 1 операцию DH (только es)
   - Unbound увеличивает nonce (одноразовое число) вместо выведения нового ключа

2. **Безопасность при повторном использовании ключей**:
   - Разные nonces (одноразовые значения) (0 против 1) предотвращают повторное использование ключа/nonce
   - Разные associated data (ассоциированные данные) (h отличается) обеспечивают domain separation (разделение доменов)

3. **Хеширование транскрипта**:
   - `h` теперь содержит: protocol_name, пустой пролог, bpk, aepk, static_key_ciphertext, payload_ciphertext
   - Этот транскрипт связывает воедино все части сообщения NS

### KDF для набора тегов ответа NSR

Боб генерирует теги для сообщений NSR:

```python
# Chain key from NS payload section
# chainKey = final chainKey from NS KDF

# Generate tagset key
tagsetKey = HKDF(chainKey, ZEROLEN, "SessionReplyTags", 32)

# Initialize NSR tagset (see DH_INITIALIZE below)
tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey)

# Get tag for this NSR
tagsetEntry = tagset_nsr.GET_NEXT_ENTRY()
tag = tagsetEntry.SESSION_TAG  # 8 bytes

# State: tag available for NSR message
# Send tag as first 8 bytes of NSR
```
### Функции выработки ключей для сообщений NSR

### KDF 6: Генерация эфемерного ключа NSR

Боб генерирует новый эфемерный ключ для каждого NSR (технический термин без устоявшегося перевода):

```python
# Mix tag into hash (I2P extension to Noise)
h = SHA256(h || tag)

# Generate ephemeral key pair
besk = GENERATE_PRIVATE_ELG2()
bepk = DERIVE_PUBLIC(besk)

# Mix ephemeral public key into hash
h = SHA256(h || bepk)

# Elligator2 encode for transmission
elg2_bepk = ENCODE_ELG2(bepk)

# State: h updated with tag and Bob's ephemeral key
# Send elg2_bepk as bytes 9-40 of NSR message
```
### KDF 7: Секция ключей NSR (ee и se DH)

Выводит ключи для секции ключей NSR:

```python
# Perform third DH (ephemeral-ephemeral)
sharedSecret_ee = DH(aesk, bepk)  # Alice computes
# Equivalent: sharedSecret_ee = DH(besk, aepk)  # Bob computes

# Mix ee into chain
keydata = HKDF(chainKey, sharedSecret_ee, "", 32)
chainKey = keydata[0:31]

# Perform fourth DH (static-ephemeral)
sharedSecret_se = DH(ask, bepk)  # Alice computes
# Equivalent: sharedSecret_se = DH(besk, apk)  # Bob computes

# Derive cipher key from se
keydata = HKDF(chainKey, sharedSecret_se, "", 64)
chainKey = keydata[0:31]
k = keydata[32:63]

# AEAD encryption of empty data (key section has no payload)
nonce = 0
associated_data = h
ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data)
# ciphertext = 16 bytes (MAC only, no plaintext)

# Mix ciphertext into hash
h = SHA256(h || ciphertext)

# State: Key section encrypted, chainKey contains all 4 DH results
# Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR
```
**Критично**: На этом завершается Noise IK handshake (рукопожатие протокола Noise по схеме IK). `chainKey` теперь содержит результаты всех 4 операций DH (es, ss, ee, se).

### KDF 8: раздел полезной нагрузки NSR

Выводит ключи для шифрования полезной нагрузки NSR:

```python
# Split chainKey into bidirectional keys
keydata = HKDF(chainKey, ZEROLEN, "", 64)
k_ab = keydata[0:31]   # Alice → Bob key
k_ba = keydata[32:63]  # Bob → Alice key

# Initialize ES tagsets for both directions
tagset_ab = DH_INITIALIZE(chainKey, k_ab)  # Alice → Bob
tagset_ba = DH_INITIALIZE(chainKey, k_ba)  # Bob → Alice

# Derive NSR payload key (Bob → Alice)
k_nsr = HKDF(k_ba, ZEROLEN, "AttachPayloadKDF", 32)

# Encrypt NSR payload
nonce = 0
associated_data = h  # Binds payload to entire NSR
payload = build_payload()  # Usually application reply
ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data)

# State: Bidirectional ES sessions established
# tagset_ab and tagset_ba ready for ES messages
# Send ciphertext as bytes 57+ of NSR message
```
**Важные примечания:**

1. **Операция разделения**: 
   - Создает независимые ключи для каждого направления
   - Предотвращает повторное использование ключей между направлениями Alice→Bob и Bob→Alice

2. **Привязка полезной нагрузки NSR**:
   - Использует `h` как ассоциированные данные, чтобы связать полезную нагрузку с рукопожатием
   - Отдельный KDF ("AttachPayloadKDF") обеспечивает разделение доменов

3. **Готовность ES**:
   - После NSR обе стороны могут отправлять сообщения ES
   - Алиса должна получить NSR перед отправкой ES
   - Боб должен получить ES перед отправкой ES

### KDF (функции выработки ключей) для сообщений ES

Сообщения ES используют предварительно сгенерированные сеансовые ключи из наборов тегов:

```python
# Sender gets next tag and key
tagsetEntry = outbound_tagset.GET_NEXT_ENTRY()
tag = tagsetEntry.SESSION_TAG     # 8 bytes
k = tagsetEntry.SESSION_KEY       # 32 bytes
N = tagsetEntry.INDEX             # Message number

# Construct nonce (12 bytes)
nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N)

# AEAD encryption
associated_data = tag  # Tag is associated data
payload = build_payload()
ciphertext = ENCRYPT(k, nonce, payload, associated_data)

# Send: tag || ciphertext (8 + len(ciphertext) bytes)
```
**Процесс получателя:**

```python
# Extract tag
tag = message[0:8]

# Look up tag in inbound tagsets
tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag)
if tagsetEntry is None:
    # Not an ES message, try NS/NSR decryption
    return try_handshake_decryption(message)

k = tagsetEntry.SESSION_KEY
N = tagsetEntry.INDEX

# Construct nonce
nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N)

# AEAD decryption
associated_data = tag
ciphertext = message[8:]
try:
    payload = DECRYPT(k, nonce, ciphertext, associated_data)
except AuthenticationError:
    # MAC verification failed, reject message
    return reject_message()

# Process payload blocks
process_payload(payload)

# Remove tag from tagset (one-time use)
inbound_tagset.remove(tag)
```
### Функция DH_INITIALIZE

Создаёт набор тегов для одного направления:

```python
def DH_INITIALIZE(rootKey, k):
    """
    Initializes a tagset with session tag and symmetric key ratchets.
    
    Args:
        rootKey: Chain key from previous DH ratchet (32 bytes)
        k: Key material from split() or DH ratchet (32 bytes)
    
    Returns:
        tagset: Initialized tagset object
    """
    # Derive next root key and chain key
    keydata = HKDF(rootKey, k, "KDFDHRatchetStep", 64)
    nextRootKey = keydata[0:31]
    chainKey_tagset = keydata[32:63]
    
    # Derive separate chain keys for tags and keys
    keydata = HKDF(chainKey_tagset, ZEROLEN, "TagAndKeyGenKeys", 64)
    sessTag_ck = keydata[0:31]   # Session tag chain key
    symmKey_ck = keydata[32:63]  # Symmetric key chain key
    
    # Create tagset object
    tagset = Tagset()
    tagset.nextRootKey = nextRootKey
    tagset.sessTag_chainKey = sessTag_ck
    tagset.symmKey_chainKey = symmKey_ck
    tagset.lastIndex = -1
    
    return tagset
```
**Контексты использования:**

1. **Набор тегов NSR**: `DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR)`
2. **Наборы тегов ES**: `DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba)`
3. **Наборы тегов с храповым механизмом**: `DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH)`

---

## Храповые механизмы

ECIES использует три синхронизированных механизма ratchet (криптографическая «трещотка») для обеспечения прямой секретности и эффективного управления сессиями.

### Обзор Ratchet (механизма последовательного обновления ключей)

**Три типа Ratchet (криптографический механизм последовательного обновления ключей):**

1. **DH Ratchet**: Выполняет обмен ключами Диффи-Хеллмана для генерации новых корневых ключей (Ratchet — механизм последовательного обновления ключей)
2. **Session Tag Ratchet**: Детерминированно выводит одноразовые метки сеанса
3. **Symmetric Key Ratchet**: Выводит ключи сеанса для шифрования сообщений

**Связь:**

```
DH Ratchet (periodic)
    ↓
Creates new tagset
    ↓
Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message)
    ↓                                                      ↓
Session Tags (8 bytes each)                      Session Keys (32 bytes each)
```
**Ключевые свойства:**

- **Отправитель**: Генерирует теги и ключи по требованию (хранение не требуется)
- **Получатель**: Предварительно генерирует теги для окна опережения (требуется хранение)
- **Синхронизация**: Индекс тега определяет индекс ключа (N_tag = N_key)
- **Прямая секретность**: Достигается посредством периодического DH ratchet (механизм обновления ключей на основе Диффи—Хеллмана)
- **Эффективность**: Получатель может отложить вычисление ключа до получения тега

### Трещотка Диффи — Хеллмана

DH ratchet (механизм ратчета Диффи—Хеллмана) обеспечивает прямую секретность путем периодического обмена новыми эфемерными ключами.

### Частота DH-ратчета

**Обязательные условия для Ratchet (механизма криптографического обновления ключей):** - Набор тегов приближается к исчерпанию (максимальный тег — 65535) - Политики, зависящие от реализации:   - Порог по количеству сообщений (например, каждые 4096 сообщений)   - Порог по времени (например, каждые 10 минут)   - Порог по объёму данных (например, каждые 100 МБ)

**Рекомендуемый первый ратчет**: Около номера тега 4096, чтобы не достичь лимита

**Максимальные значения:** - **Максимальный идентификатор набора тегов**: 65535 - **Максимальный идентификатор ключа**: 32767 - **Максимальное число сообщений на один набор тегов**: 65535 - **Теоретический максимальный объём данных на сессию**: ~6.9 TB (64K наборов тегов × 64K сообщений × 1730 байт в среднем)

### Идентификаторы тегов и ключей DH Ratchet (механизм ратчета на основе Диффи—Хеллмана)

**Начальный набор тегов** (после рукопожатия): - Идентификатор набора тегов: 0 - Блоки NextKey ещё не отправлялись - Идентификаторы ключей не назначены

**После первой трещотки**: - ID набора тегов: 1 = (1 + ID ключа Алисы + ID ключа Боба) = (1 + 0 + 0) - Алиса отправляет NextKey с ID ключа 0 - Боб отвечает сообщением NextKey с ID ключа 0

**Последующие наборы тегов**: - ID набора тегов = 1 + ID ключа отправителя + ID ключа получателя - Пример: Набор тегов 5 = (1 + sender_key_2 + receiver_key_2)

**Таблица эволюции набора тегов:**

<table style="width:100%; border-collapse:collapse; margin-bottom:1.5rem;">
  <thead>
    <tr>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Tag Set ID</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Sender Key ID</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Receiver Key ID</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">0</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">n/a</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">n/a</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Initial tag set (post-NSR)</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">1</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">0 *</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">0 *</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">First ratchet (both generate new keys)</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">2</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">1 *</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">0</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Sender generates new key</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">3</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">1</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">1 *</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Receiver generates new key</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">4</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">2 *</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">1</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Sender generates new key</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">5</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">2</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">2 *</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Receiver generates new key</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">...</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">...</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">...</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Pattern repeats</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">65534</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">32767 *</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">32766</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Second-to-last tag set</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">65535</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">32767</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">32767 *</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Final tag set</td>
    </tr>
  </tbody>
</table>
\* = Новый ключ, сгенерированный этим ratchet (криптографический механизм смены ключей)

**Правила идентификаторов ключей:** - Идентификаторы идут последовательно, начиная с 0 - Идентификаторы увеличиваются только при генерации нового ключа - Максимальный идентификатор ключа — 32767 (15 бит) - После идентификатора ключа 32767 требуется новый сеанс

### Последовательность обмена сообщениями в DH Ratchet (криптографический храповик Диффи — Хеллмана)

**Роли:** - **Отправитель тегов**: Владеет набором исходящих тегов, отправляет сообщения - **Получатель тегов**: Владеет набором входящих тегов, принимает сообщения

**Шаблон:** Отправитель тегов инициирует ratchet (механизм последовательного обновления ключей), когда набор тегов почти исчерпан.

**Диаграмма потока сообщений:**

```
Tag Sender                         Tag Receiver

       ... using tag set #0 ...

(Tag set #0 approaching exhaustion)
(Generate new key #0)

NextKey forward, request reverse, with key #0  -------->
(Repeat until NextKey ACK received)
                                   (Generate new key #0)
                                   (Perform DH: sender_key_0 × receiver_key_0)
                                   (Create inbound tag set #1)

        <---------------           NextKey reverse, with key #0
                                   (Repeat until tag from tag set #1 received)

(Receive NextKey with key #0)
(Perform DH: sender_key_0 × receiver_key_0)
(Create outbound tag set #1)


       ... using tag set #1 ...


(Tag set #1 approaching exhaustion)
(Generate new key #1)

NextKey forward, with key #1        -------->
(Repeat until NextKey ACK received)
                                   (Reuse existing key #0)
                                   (Perform DH: sender_key_1 × receiver_key_0)
                                   (Create inbound tag set #2)

        <--------------            NextKey reverse, id 0 (ACK)
                                   (Repeat until tag from tag set #2 received)

(Receive NextKey with id 0)
(Perform DH: sender_key_1 × receiver_key_0)
(Create outbound tag set #2)


       ... using tag set #2 ...


(Tag set #2 approaching exhaustion)
(Reuse existing key #1)

NextKey forward, request reverse, id 1  -------->
(Repeat until NextKey received)
                                   (Generate new key #1)
                                   (Perform DH: sender_key_1 × receiver_key_1)
                                   (Create inbound tag set #3)

        <--------------            NextKey reverse, with key #1

(Receive NextKey with key #1)
(Perform DH: sender_key_1 × receiver_key_1)
(Create outbound tag set #3)


       ... using tag set #3 ...

       (Pattern repeats: even-numbered tag sets
        use forward key, odd-numbered use reverse key)
```
**Шаблоны Ratchet (механизм обновления ключей):**

**Создание наборов тегов с чётными номерами** (2, 4, 6, ...): 1. Отправитель создаёт новый ключ 2. Отправитель отправляет блок NextKey с новым ключом 3. Получатель отправляет блок NextKey со старым идентификатором ключа (ACK, подтверждение) 4. Оба выполняют DH (Диффи-Хеллман) с использованием (нового ключа отправителя × старого ключа получателя)

**Создание наборов тегов с нечётными номерами** (3, 5, 7, ...): 1. Отправитель запрашивает обратный ключ (отправляет NextKey с флагом запроса) 2. Получатель генерирует новый ключ 3. Получатель отправляет блок NextKey с новым ключом 4. Обе стороны выполняют DH (Диффи-Хеллмана) с (старый ключ отправителя × новый ключ получателя)

### Формат блока NextKey

См. раздел Payload Format для подробной спецификации блока NextKey.

**Ключевые элементы:** - **Байт флагов**:   - Бит 0: Ключ присутствует (1) или только ID (0)   - Бит 1: Обратный ключ (1) или прямой ключ (0)   - Бит 2: Запросить обратный ключ (1) или без запроса (0) - **ID ключа**: 2 байта, big-endian (0-32767) - **Публичный ключ**: 32 байта X25519 (если бит 0 = 1)

**Пример блоков NextKey:**

```python
# Sender initiates ratchet with new key (key ID 0, tag set 1)
NextKey(flags=0x01, key_id=0, pubkey=sender_key_0)

# Receiver replies with new key (key ID 0, tag set 1)
NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0)

# Sender ratchets again with new key (key ID 1, tag set 2)
NextKey(flags=0x01, key_id=1, pubkey=sender_key_1)

# Receiver ACKs with old key ID (tag set 2)
NextKey(flags=0x02, key_id=0)

# Sender requests reverse key (tag set 3)
NextKey(flags=0x04, key_id=1)

# Receiver sends new reverse key (key ID 1, tag set 3)
NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1)
```
### KDF для DH-ратчета

При обмене новыми ключами:

```python
# Tag sender generates or reuses key
if generating_new:
    sender_sk = GENERATE_PRIVATE()
    sender_pk = DERIVE_PUBLIC(sender_sk)
else:
    # Reuse existing key pair
    sender_pk = existing_sender_pk

# Tag receiver generates or reuses key
if generating_new:
    receiver_sk = GENERATE_PRIVATE()
    receiver_pk = DERIVE_PUBLIC(receiver_sk)
else:
    # Reuse existing key pair
    receiver_pk = existing_receiver_pk

# Both parties perform DH
sharedSecret = DH(sender_sk, receiver_pk)

# Derive tagset key
tagsetKey = HKDF(sharedSecret, ZEROLEN, "XDHRatchetTagSet", 32)

# Get next root key from previous tagset
rootKey = previous_tagset.nextRootKey

# Initialize new tagset
new_tagset = DH_INITIALIZE(rootKey, tagsetKey)

# Tag sender: outbound tagset
# Tag receiver: inbound tagset
```
**Критические временные требования:**

**Отправитель тегов:** - Немедленно создаёт новый исходящий набор тегов - Немедленно начинает использовать новые теги - Удаляет старый исходящий набор тегов

**Получатель тегов:** - Создает новый набор входящих тегов - Сохраняет старый набор входящих тегов в течение льготного периода (3 минуты) - Принимает теги из обоих наборов — старого и нового — в течение льготного периода - Удаляет старый набор входящих тегов по окончании льготного периода

### Управление состоянием DH-ратчета

**Состояние отправителя:** - Текущий исходящий набор тегов - ID набора тегов и ID ключей - Следующий корневой ключ (для следующего ratchet (криптографический ратчет)) - Количество сообщений в текущем наборе тегов

**Состояние получателя:** - Текущий входящий набор тегов (в льготный период их может быть два) - Номера предыдущих сообщений (PN) для обнаружения пропусков - Окно упреждения предварительно сгенерированных тегов - Следующий корневой ключ (для следующего ratchet (криптографический ратчет))

**Правила переходов состояний:**

1. **До первого Ratchet (криптографический механизм эволюции ключей)**:
   - Используется набор тегов 0 (из NSR)
   - Идентификаторы ключей не назначены

2. **Инициация Ratchet (механизм пошагового обновления ключей)**:
   - Сгенерировать новый ключ (если в этом раунде ключ генерирует отправитель)
   - Отправить блок NextKey (блок «следующего» ключа) в ES message (сообщение ES)
   - Дождаться ответа NextKey перед созданием нового исходящего набора тегов

3. **Получение запроса Ratchet (механизма поэтапного обновления ключей)**:
   - Сгенерировать новый ключ (если в этом раунде ключ генерирует получатель)
   - Выполнить DH с полученным ключом
   - Создать новый набор входящих тегов
   - Отправить ответ NextKey
   - Сохранить старый набор входящих тегов на переходный период

4. **Завершение Ratchet (криптографического механизма обновления ключей)**:
   - Получить ответ NextKey
   - Выполнить DH (обмен Диффи—Хеллмана)
   - Создать новый исходящий набор тегов
   - Начать использовать новые теги

### Session Tag Ratchet (трещоточный механизм для меток сеанса)

Ратчет сеансовых тегов детерминированным образом генерирует одноразовые сеансовые теги длиной 8 байт.

### Назначение Session Tag Ratchet (криптографическая трещотка)

- Заменяет явную передачу тегов (ElGamal отправлял 32-байтные теги)
- Позволяет получателю предварительно генерировать теги для окна упреждения
- Отправитель генерирует по мере необходимости (хранение не требуется)
- Синхронизируется с ratchet (механизм последовательного обновления ключей) симметричного ключа по индексу

### Формула ратчета тегов сеанса

**Инициализация:**

```python
# From DH_INITIALIZE
sessTag_ck = initial_chain_key  # 32 bytes

# Initialize session tag ratchet
keydata = HKDF(sessTag_ck, ZEROLEN, "STInitialization", 64)
sessTag_chainKey = keydata[0:31]    # First chain key
SESSTAG_CONSTANT = keydata[32:63]   # Constant for all tags in this tagset
```
**Генерация тега (для тега N):**

```python
# Generate tag N
keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, "SessionTagKeyGen", 64)
sessTag_chainKey_N = keydata[0:31]  # Chain key for next tag
tag_N = keydata[32:39]              # Session tag (8 bytes)

# Chain continues for each tag
# tag_0, tag_1, tag_2, ..., tag_65535
```
**Полная последовательность:**

```python
# Tag 0
keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, "SessionTagKeyGen", 64)
sessTag_chainKey_0 = keydata_0[0:31]
tag_0 = keydata_0[32:39]

# Tag 1
keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, "SessionTagKeyGen", 64)
sessTag_chainKey_1 = keydata_1[0:31]
tag_1 = keydata_1[32:39]

# Tag N
keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, "SessionTagKeyGen", 64)
sessTag_chainKey_N = keydata_N[0:31]
tag_N = keydata_N[32:39]
```
### Реализация отправителя Session Tag Ratchet (ratchet — механизм последовательного обновления)

```python
class OutboundTagset:
    def __init__(self, sessTag_ck):
        # Initialize
        keydata = HKDF(sessTag_ck, ZEROLEN, "STInitialization", 64)
        self.chainKey = keydata[0:31]
        self.constant = keydata[32:63]
        self.index = -1
    
    def get_next_tag(self):
        # Increment index
        self.index += 1
        
        if self.index > 65535:
            raise TagsetExhausted("Ratchet required")
        
        # Generate tag
        keydata = HKDF(self.chainKey, self.constant, "SessionTagKeyGen", 64)
        self.chainKey = keydata[0:31]
        tag = keydata[32:39]
        
        return (tag, self.index)
```
**Процесс отправителя:** 1. Вызовите `get_next_tag()` для каждого сообщения 2. Используйте возвращённый тег в сообщении ES 3. Сохраните индекс N для возможного отслеживания ACK (подтверждений) 4. Хранение тегов не требуется (генерируются по запросу)

### Реализация получателя Session Tag Ratchet (механизма ратчета меток сеанса)

```python
class InboundTagset:
    def __init__(self, sessTag_ck, look_ahead=32):
        # Initialize
        keydata = HKDF(sessTag_ck, ZEROLEN, "STInitialization", 64)
        self.chainKey = keydata[0:31]
        self.constant = keydata[32:63]
        self.index = -1
        self.look_ahead = look_ahead
        self.tags = {}  # Dictionary: tag -> index
        
        # Pre-generate initial tags
        self.extend(look_ahead)
    
    def extend(self, count):
        """Generate 'count' more tags"""
        for _ in range(count):
            self.index += 1
            
            if self.index > 65535:
                return  # Cannot exceed maximum
            
            # Generate tag
            keydata = HKDF(self.chainKey, self.constant, "SessionTagKeyGen", 64)
            self.chainKey = keydata[0:31]
            tag = keydata[32:39]
            
            # Store tag
            self.tags[tag] = self.index
    
    def lookup_tag(self, tag):
        """Look up tag and return index"""
        if tag in self.tags:
            index = self.tags[tag]
            # Remove tag (one-time use)
            del self.tags[tag]
            return index
        return None
    
    def check_and_extend(self):
        """Extend if tag count is low"""
        current_count = len(self.tags)
        if current_count < self.look_ahead // 2:
            # Extend to restore window
            self.extend(self.look_ahead - current_count)
```
**Процесс получателя:** 1. Предварительно сгенерировать теги для окна упреждения (например, 32 тега) 2. Сохранить теги в хеш-таблице или словаре 3. При получении сообщения выполнить поиск тега, чтобы получить индекс N 4. Удалить тег из хранилища (одноразовое использование) 5. Расширить окно, если число тегов падает ниже порога

### Стратегия упреждающей подготовки сеансовых тегов

**Цель**: баланс между использованием памяти и обработкой сообщений, приходящих не по порядку

**Рекомендуемые размеры просмотра вперёд:**

<table style="width:100%; border-collapse:collapse; margin-bottom:1.5rem;">
  <thead>
    <tr>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Tagset Type</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:center;">Initial Size</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:center;">Maximum Size</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">NSR tagset</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">12</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">12</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Short-lived</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">ES tagset 0</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">24</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">160</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Initial ES tagset</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">ES tagset 1+</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">160</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">160</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Ratcheted tagsets</td>
    </tr>
  </tbody>
</table>
**Адаптивный просмотр вперёд:**

```python
# Dynamic look-ahead based on highest tag received
look_ahead = min(tsmax, tsmin + N // 4)

# Example:
# tsmin = 24, tsmax = 160
# N = 0:   look_ahead = min(160, 24 + 0/4) = 24
# N = 100: look_ahead = min(160, 24 + 100/4) = 49
# N = 500: look_ahead = min(160, 24 + 500/4) = 149
# N = 544: look_ahead = min(160, 24 + 544/4) = 160
```
**Обрезать позади:**

```python
# Trim tags far behind highest received
trim_behind = look_ahead // 2

# If highest received tag is N=100, trim tags below N=50
```
**Расчёт памяти:**

```python
# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes
# Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset

# With multiple sessions:
# 100 inbound sessions × 2.5 KB = 250 KB total
```
### Обработка сеансовых тегов, полученных не по порядку

**Сценарий**: Сообщения приходят не по порядку

```
Expected: tag_5, tag_6, tag_7, tag_8
Received: tag_5, tag_7, tag_6, tag_8
```
**Поведение получателя:**

1. Получение tag_5:
   - Поиск: найден по индексу 5
   - Обработать сообщение
   - Удалить tag_5
   - Наибольший принятый: 5

2. Получить tag_7 (не по порядку):
   - Поиск: найден по индексу 7
   - Обработать сообщение
   - Удалить tag_7
   - Наибольший полученный номер: 7
   - Примечание: tag_6 всё ещё в хранилище (ещё не получен)

3. Получение tag_6 (с задержкой):
   - Поиск: найден по индексу 6
   - Обработать сообщение
   - Удалить tag_6
   - Максимальный принятый: 7 (без изменений)

4. Получаем tag_8:
   - Поиск: найден по индексу 8
   - Обработать сообщение
   - Удалить tag_8
   - Наибольший полученный индекс: 8

**Обслуживание окна:** - Отслеживать наибольший полученный индекс - Вести список отсутствующих индексов (разрывы) - Расширять окно исходя из наибольшего индекса - Необязательно: удалять старые разрывы по истечении тайм-аута

### Трещотка симметричных ключей

symmetric key ratchet (механизм храповика для симметричных ключей) генерирует 32-байтные ключи шифрования, синхронизированные с тегами сеанса.

### Назначение симметричного ключевого ратчета

- Обеспечивает уникальный ключ шифрования для каждого сообщения
- Синхронизирован с session tag ratchet (механизм ратчета тегов сессии; тот же индекс)
- Отправитель может генерировать по требованию
- Получатель может отложить генерацию до получения тега

### Формула Symmetric Key Ratchet (механизм пошагового обновления симметричных ключей)

**Инициализация:**

```python
# From DH_INITIALIZE
symmKey_ck = initial_chain_key  # 32 bytes

# No additional initialization needed
# Unlike session tag ratchet, no constant is derived
```
**Генерация ключа (для N-го ключа):**

```python
# Generate key N
SYMMKEY_CONSTANT = ZEROLEN  # Empty string
keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, "SymmetricRatchet", 64)
symmKey_chainKey_N = keydata[0:31]  # Chain key for next key
key_N = keydata[32:63]              # Session key (32 bytes)
```
**Полная последовательность:**

```python
# Key 0
keydata_0 = HKDF(symmKey_ck, ZEROLEN, "SymmetricRatchet", 64)
symmKey_chainKey_0 = keydata_0[0:31]
key_0 = keydata_0[32:63]

# Key 1
keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, "SymmetricRatchet", 64)
symmKey_chainKey_1 = keydata_1[0:31]
key_1 = keydata_1[32:63]

# Key N
keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, "SymmetricRatchet", 64)
symmKey_chainKey_N = keydata_N[0:31]
key_N = keydata_N[32:63]
```
### Реализация отправителя симметричного ключевого ратчета

```python
class OutboundKeyRatchet:
    def __init__(self, symmKey_ck):
        self.chainKey = symmKey_ck
        self.index = -1
    
    def get_key(self, index):
        """Generate key for specific index"""
        # Fast-forward to desired index if needed
        while self.index < index:
            self.index += 1
            keydata = HKDF(self.chainKey, ZEROLEN, "SymmetricRatchet", 64)
            self.chainKey = keydata[0:31]
            if self.index == index:
                return keydata[32:63]
        
        # Should not reach here if called correctly
        raise ValueError("Key already generated")
```
**Процесс отправителя:** 1. Получить следующий тег и его индекс N 2. Сгенерировать ключ для индекса N 3. Использовать ключ для шифрования сообщения 4. Хранение ключа не требуется

### Реализация получателя симметрического ключевого ратчета

**Стратегия 1: Отложенная генерация (рекомендуется)**

```python
class InboundKeyRatchet:
    def __init__(self, symmKey_ck):
        self.chainKey = symmKey_ck
        self.index = -1
        self.cache = {}  # Optional: cache recently used keys
    
    def get_key(self, index):
        """Generate key for specific index"""
        # Check cache first (optional optimization)
        if index in self.cache:
            key = self.cache[index]
            del self.cache[index]
            return key
        
        # Fast-forward to desired index
        while self.index < index:
            self.index += 1
            keydata = HKDF(self.chainKey, ZEROLEN, "SymmetricRatchet", 64)
            self.chainKey = keydata[0:31]
            
            if self.index == index:
                return keydata[32:63]
        
        raise ValueError("Index already passed")
```
**Процесс отложенной генерации:** 1. Получить сообщение ES с тегом 2. Найти тег, чтобы получить индекс N 3. Сгенерировать ключи с 0 по N (если еще не сгенерированы) 4. Использовать ключ N для расшифровки сообщения 5. Цепной ключ теперь находится на индексе N

**Преимущества:** - Минимальное использование памяти - Ключи генерируются только при необходимости - Простая реализация

**Недостатки:** - Необходимо сгенерировать все ключи от 0 до N при первом использовании - Невозможно обрабатывать сообщения, пришедшие не по порядку, без кэширования

**Стратегия 2: Предварительная генерация с Tag Window (окно тегов) (альтернативный вариант)**

```python
class InboundKeyRatchet:
    def __init__(self, symmKey_ck):
        self.chainKey = symmKey_ck
        self.index = -1
        self.keys = {}  # Dictionary: index -> key
    
    def extend(self, count):
        """Pre-generate 'count' more keys"""
        for _ in range(count):
            self.index += 1
            keydata = HKDF(self.chainKey, ZEROLEN, "SymmetricRatchet", 64)
            self.chainKey = keydata[0:31]
            key = keydata[32:63]
            self.keys[self.index] = key
    
    def get_key(self, index):
        """Retrieve pre-generated key"""
        if index in self.keys:
            key = self.keys[index]
            del self.keys[index]
            return key
        return None
```
**Процесс предварительной генерации:** 1. Предварительно сгенерировать ключи, соответствующие окну тегов (например, 32 ключа) 2. Хранить ключи, индексированные по номеру сообщения 3. При получении тега найти соответствующий ключ 4. Расширять окно по мере использования тегов

**Преимущества:** - Естественно обрабатывает сообщения, приходящие не по порядку - Быстрое получение ключа (без задержки на генерацию)

**Недостатки:** - Более высокий расход памяти (32 байта на ключ против 8 байт на тег) - Необходимо поддерживать синхронизацию ключей с тегами

**Сравнение памяти:**

```python
# Look-ahead of 160:
# Tags only:  160 × 16 bytes = 2.5 KB
# Tags+Keys:  160 × (16 + 32) bytes = 7.5 KB
# 
# For 100 sessions:
# Tags only:  250 KB
# Tags+Keys:  750 KB
```
### Синхронизация симметрического ратчета с метками сеанса

**Критическое требование**: Индекс тега сессии ДОЛЖЕН быть равен индексу симметричного ключа

```python
# Sender
tag, index = outbound_tagset.get_next_tag()
key = outbound_keyratchet.get_key(index)  # Same index
nonce = construct_nonce(index)
ciphertext = ENCRYPT(key, nonce, payload, tag)

# Receiver
index = inbound_tagset.lookup_tag(tag)
key = inbound_keyratchet.get_key(index)  # Same index
nonce = construct_nonce(index)
plaintext = DECRYPT(key, nonce, ciphertext, tag)
```
**Режимы отказа:**

Если нарушается синхронизация: - Использован неверный ключ для расшифрования - Проверка MAC не удалась - Сообщение отклонено

**Предотвращение:** - Всегда используйте один и тот же индекс для тега и ключа - Никогда не пропускайте индексы ни в одном из ratchet (механизм пошагового обновления ключей) - Осторожно обрабатывайте сообщения, поступающие не по порядку

### Формирование одноразового значения (nonce) для Symmetric Ratchet (симметрического механизма трещотки)

Nonce (одноразовое число) вычисляется из номера сообщения:

```python
def construct_nonce(index):
    """
    Construct 12-byte nonce for ChaCha20-Poly1305
    
    Args:
        index: Message number (0-65535)
    
    Returns:
        nonce: 12-byte nonce
    """
    # First 4 bytes are always zero
    nonce = bytearray(12)
    nonce[0:4] = b'\x00\x00\x00\x00'
    
    # Last 8 bytes are little-endian message number
    nonce[4:12] = index.to_bytes(8, byteorder='little')
    
    return bytes(nonce)
```
**Примеры:**

```python
index = 0:     nonce = 0x00000000 0000000000000000
index = 1:     nonce = 0x00000000 0100000000000000
index = 255:   nonce = 0x00000000 FF00000000000000
index = 256:   nonce = 0x00000000 0001000000000000
index = 65535: nonce = 0x00000000 FFFF000000000000
```
**Важные свойства:** - Одноразовые значения уникальны для каждого сообщения в наборе тегов - Одноразовые значения никогда не повторяются (это обеспечивается одноразовыми тегами) - 8-байтовый счетчик допускает 2^64 сообщений (мы используем только 2^16) - Формат одноразового значения соответствует конструкции на основе счетчика из RFC 7539

---

## Управление сеансами

### Контекст сеанса

Все входящие и исходящие сессии должны принадлежать определённому контексту:

1. **Контекст router**: Сеансы для самого router
2. **Контекст Destination (назначение)**: Сеансы для конкретного локального Destination (клиентского приложения)

**Критическое правило**: Сеансы НЕ ДОЛЖНЫ разделяться между контекстами для предотвращения корреляционных атак.

**Реализация:**

```python
class SessionKeyManager:
    """Context for managing sessions (router or destination)"""
    def __init__(self, context_id):
        self.context_id = context_id
        self.inbound_sessions = {}   # far_end_dest -> [sessions]
        self.outbound_sessions = {}  # far_end_dest -> session
        self.static_keypair = generate_keypair()  # Context's identity
    
    def get_outbound_session(self, destination):
        """Get or create outbound session to destination"""
        if destination not in self.outbound_sessions:
            self.outbound_sessions[destination] = create_outbound_session(destination)
        return self.outbound_sessions[destination]
    
    def add_inbound_session(self, session, destination=None):
        """Add inbound session, optionally bound to destination"""
        if destination:
            if destination not in self.inbound_sessions:
                self.inbound_sessions[destination] = []
            self.inbound_sessions[destination].append(session)
        else:
            # Unbound session
            self.inbound_sessions[None].append(session)
```
**Реализация I2P на Java:**

В Java I2P, класс `SessionKeyManager` предоставляет эту функциональность: - Один `SessionKeyManager` на router - Один `SessionKeyManager` на локальный destination (адрес назначения) - Раздельное управление сеансами ECIES и ElGamal в каждом контексте

### Привязка сеанса

**Привязка** связывает сеанс с конкретным удалённым адресатом.

### Привязанные сеансы

**Характеристики:** - Включать статический ключ отправителя в сообщение NS - Получатель может идентифицировать destination (назначение) отправителя - Обеспечивает двунаправленную связь - Один исходящий сеанс на destination - Может иметь несколько входящих сеансов (во время переходов)

**Сценарии использования:** - Потоковые соединения (похожие на TCP) - repliable datagrams (датаграммы с возможностью ответа) - Любой протокол, требующий схемы запрос/ответ

**Процесс привязки:**

```python
# Alice creates bound outbound session
outbound_session = OutboundSession(
    destination=bob_destination,
    static_key=alice_static_key,
    bound=True
)

# Alice sends NS with static key
ns_message = build_ns_message(
    ephemeral_key=alice_ephemeral_key,
    static_key=alice_static_key,  # Included for binding
    payload=data
)

# Bob receives NS
bob_receives_ns(ns_message)
# Bob extracts Alice's static key
alice_static_key = decrypt_static_key_section(ns_message)

# Bob looks up Alice's destination (from bundled LeaseSet)
alice_destination = lookup_destination_by_static_key(alice_static_key)

# Bob creates bound inbound session
inbound_session = InboundSession(
    destination=alice_destination,
    bound=True
)

# Bob pairs with outbound session
outbound_session = OutboundSession(
    destination=alice_destination,
    bound=True
)
```
**Преимущества:** 1. **Эфемерный-эфемерный DH**: Ответ использует ee DH (полная прямая секретность) 2. **Непрерывность сеанса**: Ratchets (механизм смены ключей) поддерживают привязку к тому же адресу назначения 3. **Безопасность**: Предотвращает перехват сессии (аутентификация по статическому ключу) 4. **Эффективность**: Одна сессия на адрес назначения (без дублирования)

### Непривязанные сеансы

**Характеристики:** - Нет статического ключа в сообщении NS (раздел флагов состоит из одних нулей) - Получатель не может идентифицировать отправителя - Только односторонняя связь - Разрешены несколько сеансов к одному и тому же назначению

**Сценарии использования:** - Сырые дейтаграммы (fire-and-forget — без подтверждения доставки) - Анонимная публикация - Широковещательные сообщения

**Свойства:** - Более анонимно (нет идентификации отправителя) - Более эффективно (1 DH (Диффи — Хеллман) против 2 DH при рукопожатии) - Ответы невозможны (получатель не знает, куда отвечать) - Без ратчета сеанса (однократное или ограниченное использование)

### Сопряжение сеансов

**Сопряжение** соединяет входящий сеанс с исходящим сеансом для двусторонней связи.

### Создание сопряжённых сеансов

**Перспектива Алисы (инициатор):**

```python
# Create outbound session to Bob
outbound_session = create_outbound_session(bob_destination)

# Create paired inbound session
inbound_session = create_inbound_session(
    paired_with=outbound_session,
    bound_to=bob_destination
)

# Link them
outbound_session.paired_inbound = inbound_session
inbound_session.paired_outbound = outbound_session

# Send NS message
send_ns_message(outbound_session, payload)
```
**Перспектива Боба (ответчик):**

```python
# Receive NS message
ns_message = receive_ns_message()

# Create inbound session
inbound_session = create_inbound_session_from_ns(ns_message)

# If NS contains static key (bound):
if ns_message.has_static_key():
    alice_destination = extract_destination(ns_message)
    inbound_session.bind_to(alice_destination)
    
    # Create paired outbound session
    outbound_session = create_outbound_session(alice_destination)
    
    # Link them
    outbound_session.paired_inbound = inbound_session
    inbound_session.paired_outbound = outbound_session

# Send NSR
send_nsr_message(inbound_session, outbound_session, payload)
```
### Преимущества сопряжения сеансов

1. **In-band ACKs (подтверждения в том же канале)**: Могут подтверждать сообщения без отдельного clove (вложения внутри garlic message)
2. **Эффективное Ratcheting (пошаговое обновление ключей)**: Оба направления обновляют ключи совместно
3. **Управление потоком**: Можно реализовать back-pressure (обратное давление: ограничение потока при перегрузке) между парными сессиями
4. **Согласованность состояния**: Проще поддерживать синхронизированное состояние

### Правила сопряжения сессий

- Исходящий сеанс может быть несопряжённым (непривязанный NS (namespace — пространство имён))
- Входящий сеанс для привязанного NS должен быть сопряжён
- Сопряжение происходит при создании сеанса, а не после
- Сопряжённые сеансы имеют одинаковую привязку к назначению
- Обновления ratchet (криптографический ратчет) происходят независимо, но согласованно

### Жизненный цикл сеанса

### Жизненный цикл сеанса: фаза создания

**Создание исходящей сессии (Алиса):**

```python
def create_outbound_session(destination, bound=True):
    session = OutboundSession()
    session.destination = destination
    session.bound = bound
    session.state = SessionState.NEW
    session.created_time = now()
    
    # Generate keys for NS message
    session.ephemeral_keypair = generate_elg2_keypair()
    if bound:
        session.static_key = context.static_keypair.public_key
    
    # Will be populated after NSR received
    session.outbound_tagset = None
    session.inbound_tagset = None
    
    return session
```
**Создание входящей сессии (Bob):**

```python
def create_inbound_session_from_ns(ns_message):
    session = InboundSession()
    session.state = SessionState.ESTABLISHED
    session.created_time = now()
    
    # Extract from NS
    session.remote_ephemeral_key = ns_message.ephemeral_key
    session.remote_static_key = ns_message.static_key
    
    if session.remote_static_key:
        session.bound = True
        session.destination = lookup_destination(session.remote_static_key)
    else:
        session.bound = False
        session.destination = None
    
    # Generate keys for NSR
    session.ephemeral_keypair = generate_elg2_keypair()
    
    # Create tagsets from KDF
    session.inbound_tagset = create_tagset_from_nsr()
    session.outbound_tagset = create_tagset_from_nsr()
    
    return session
```
### Жизненный цикл сеанса: активная фаза

**Переходы состояний:**

```
NEW (outbound only)
  ↓
  NS sent
  ↓
PENDING_REPLY (outbound only)
  ↓
  NSR received
  ↓
ESTABLISHED
  ↓
  ES messages exchanged
  ↓
ESTABLISHED (ongoing)
  ↓
  (optional) RATCHETING
  ↓
ESTABLISHED
```
**Поддержание активной сессии:**

```python
def maintain_active_session(session):
    # Update last activity time
    session.last_activity = now()
    
    # Check for ratchet needed
    if session.outbound_tagset.needs_ratchet():
        initiate_ratchet(session)
    
    # Check for incoming ratchet
    if received_nextkey_block():
        process_ratchet(session)
    
    # Trim old tags from inbound tagset
    session.inbound_tagset.expire_old_tags()
    
    # Check session health
    if session.idle_time() > SESSION_TIMEOUT:
        mark_session_idle(session)
```
### Жизненный цикл сеанса: фаза истечения срока действия

**Значения тайм-аутов сеанса:**

<table style="width:100%; border-collapse:collapse; margin-bottom:1.5rem;">
  <thead>
    <tr>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Session Type</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:center;">Sender Timeout</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:center;">Receiver Timeout</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">NSR tagset</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">N/A</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">3 minutes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Short-lived</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">ES tagset 0</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">8 minutes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">10 minutes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Initial</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">ES tagset 1+</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">8 minutes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">10 minutes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Ratcheted</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Old tagset</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">N/A</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">3 minutes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">After ratchet</td>
    </tr>
  </tbody>
</table>
**Логика истечения срока действия:**

```python
def check_session_expiration():
    for session in active_sessions:
        # Outbound session expiration (sender)
        if session.is_outbound():
            if session.idle_time() > 8 * 60:  # 8 minutes
                expire_outbound_session(session)
        
        # Inbound session expiration (receiver)
        else:
            if session.idle_time() > 10 * 60:  # 10 minutes
                expire_inbound_session(session)
    
    # Old tagsets (after ratchet)
    for tagset in old_tagsets:
        if tagset.age() > 3 * 60:  # 3 minutes
            delete_tagset(tagset)
```
**Критическое правило**: срок действия исходящих сессий ДОЛЖЕН истекать раньше, чем у входящих, чтобы предотвратить рассинхронизацию.

**Корректное завершение:**

```python
def terminate_session(session, reason=0):
    # Send Termination block (if implemented)
    send_termination_block(session, reason)
    
    # Mark session for deletion
    session.state = SessionState.TERMINATED
    
    # Keep session briefly for final messages
    schedule_deletion(session, delay=30)  # 30 seconds
    
    # Notify paired session
    if session.paired_session:
        session.paired_session.mark_remote_terminated()
```
### Несколько сообщений NS

**Сценарий**: Сообщение NS (поиск в netDb) от Алисы потеряно или ответ NSR (ответ на поиск в netDb) потерян.

**Поведение Алисы:**

```python
class OutboundSession:
    def __init__(self):
        self.ns_messages_sent = []
        self.ns_timer = None
        self.max_ns_attempts = 5
    
    def send_ns_message(self, payload):
        # Generate new ephemeral key for each NS
        ephemeral_key = generate_elg2_keypair()
        
        ns_message = build_ns_message(
            ephemeral_key=ephemeral_key,
            static_key=self.static_key,
            payload=payload
        )
        
        # Store state for this NS
        ns_state = {
            'ephemeral_key': ephemeral_key,
            'chainkey': compute_chainkey(ns_message),
            'hash': compute_hash(ns_message),
            'tagset': derive_nsr_tagset(ns_message),
            'sent_time': now()
        }
        self.ns_messages_sent.append(ns_state)
        
        # Send message
        send_message(ns_message)
        
        # Set timer for retry
        if not self.ns_timer:
            self.ns_timer = set_timer(1.0, self.on_ns_timeout)
    
    def on_ns_timeout(self):
        if len(self.ns_messages_sent) >= self.max_ns_attempts:
            # Give up
            fail_session("No NSR received after {self.max_ns_attempts} attempts")
            return
        
        # Retry with new NS message
        send_ns_message(self.payload)
    
    def on_nsr_received(self, nsr_message):
        # Cancel timer
        cancel_timer(self.ns_timer)
        
        # Find which NS this NSR responds to
        tag = nsr_message.tag
        for ns_state in self.ns_messages_sent:
            if tag in ns_state['tagset']:
                # This NSR corresponds to this NS
                self.active_ns_state = ns_state
                break
        
        # Process NSR and complete handshake
        complete_handshake(nsr_message, self.active_ns_state)
        
        # Discard other NS states
        self.ns_messages_sent = []
```
**Важные свойства:**

1. **Уникальные эфемерные ключи**: Каждый NS использует собственный эфемерный ключ
2. **Независимые рукопожатия**: Каждый NS создает отдельное состояние рукопожатия
3. **Корреляция NSR**: Тег NSR указывает, на какой NS он отвечает
4. **Очистка состояния**: Неиспользованные состояния NS удаляются после успешного NSR

**Предотвращение атак:**

Чтобы предотвратить истощение ресурсов:

```python
# Limit NS sending rate
max_ns_rate = 5 per 10 seconds per destination

# Limit total NS attempts
max_ns_attempts = 5

# Limit total pending NS states
max_pending_ns = 10 per context
```
### Несколько сообщений NSR (Session Request — запрос сеанса)

**Сценарий**: Боб отправляет несколько NSR (служебных ответных сообщений) (например, данные ответа разбиты на несколько сообщений).

**Поведение Боба:**

```python
class InboundSession:
    def send_nsr_replies(self, payload_chunks):
        # One NS received, multiple NSRs to send
        for chunk in payload_chunks:
            # Generate new ephemeral key for each NSR
            ephemeral_key = generate_elg2_keypair()
            
            # Get next tag from NSR tagset
            tag = self.nsr_tagset.get_next_tag()
            
            nsr_message = build_nsr_message(
                tag=tag,
                ephemeral_key=ephemeral_key,
                payload=chunk
            )
            
            send_message(nsr_message)
        
        # Wait for ES message from Alice
        self.state = SessionState.AWAITING_ES
```
**Поведение Алисы:**

```python
class OutboundSession:
    def on_nsr_received(self, nsr_message):
        if self.state == SessionState.PENDING_REPLY:
            # First NSR received
            complete_handshake(nsr_message)
            self.state = SessionState.ESTABLISHED
            
            # Create ES sessions
            self.es_outbound_tagset = derive_es_outbound_tagset()
            self.es_inbound_tagset = derive_es_inbound_tagset()
            
            # Send ES message (ACK)
            send_es_message(empty_payload)
        
        elif self.state == SessionState.ESTABLISHED:
            # Additional NSR received
            # Decrypt and process payload
            payload = decrypt_nsr_payload(nsr_message)
            process_payload(payload)
            
            # These NSRs are from other NS attempts, ignore handshake
```
**Очистка Боба:**

```python
class InboundSession:
    def on_es_received(self, es_message):
        # First ES received from Alice
        # This confirms which NSR Alice used
        
        # Clean up other handshake states
        for other_ns_state in self.pending_ns_states:
            if other_ns_state != self.active_ns_state:
                delete_ns_state(other_ns_state)
        
        # Delete unused NSR tagsets
        for tagset in self.nsr_tagsets:
            if tagset != self.active_nsr_tagset:
                delete_tagset(tagset)
        
        self.state = SessionState.ESTABLISHED
```
**Важные свойства:**

1. **Допускается несколько NSR**: Боб может отправлять несколько NSR на один NS
2. **Разные эфемерные ключи**: Каждый NSR должен использовать уникальный эфемерный ключ
3. **Один и тот же набор тегов для NSR**: Все NSR для одного NS используют один и тот же набор тегов
4. **Первый ES побеждает**: Первый ES от Алисы определяет, какой NSR оказался успешным
5. **Очистка после ES**: Боб удаляет неиспользованные состояния после получения ES

### Автомат состояний сеанса

**Полная диаграмма состояний:**

```
                    Outbound Session                    Inbound Session

                         NEW
                          |
                     send NS
                          |
                   PENDING_REPLY -------------------- receive NS ---> ESTABLISHED
                          |                                                |
                   receive NSR                                        send NSR
                          |                                                |
                    ESTABLISHED <---------- receive ES ------------- AWAITING_ES
                          |                     |                          |
                    ┌─────┴─────┐               |                    receive ES
                    |           |               |                          |
              send ES      receive ES           |                    ESTABLISHED
                    |           |               |                          |
                    └─────┬─────┘               |                ┌─────────┴─────────┐
                          |                     |                |                   |
                          |                     |          send ES              receive ES
                          |                     |                |                   |
                          |                     |                └─────────┬─────────┘
                          |                     |                          |
                          └─────────────────────┴──────────────────────────┘
                                              ACTIVE
                                                |
                                         idle timeout
                                                |
                                             EXPIRED
```
**Описания состояний:**

- **NEW**: Исходящий сеанс создан, NS ещё не отправлен
- **PENDING_REPLY**: NS отправлен, ожидается NSR
- **AWAITING_ES**: NSR отправлен, ожидается первый ES от Алисы
- **ESTABLISHED**: Рукопожатие завершено, можно отправлять/принимать ES
- **ACTIVE**: Активный обмен сообщениями ES
- **RATCHETING**: Выполняется DH ratchet (механизм ратчета Диффи‑Хеллмана) (подмножество состояния ACTIVE)
- **EXPIRED**: Сеанс завершился по тайм-ауту, ожидает удаления
- **TERMINATED**: Сеанс явно прекращён

---

## Формат полезной нагрузки

Раздел полезной нагрузки всех сообщений ECIES (NS, NSR, ES) использует блочный формат, аналогичный NTCP2.

### Структура блока

**Общий формат:**

```
+----+----+----+----+----+----+----+----+
|blk |  size   |       data             |
+----+----+----+                        +
|                                       |
~               ...                     ~
|                                       |
+----+----+----+----+----+----+----+----+
|blk |  size   |       data             |
+----+----+----+                        +
|                                       |
~               ...                     ~
|                                       |
+----+----+----+----+----+----+----+----+
```
**Поля:**

- `blk`: 1 байт - номер типа блока
- `size`: 2 байта - размер поля данных в формате big-endian (0-65516)
- `data`: переменная длина - данные, специфичные для блока

**Ограничения:**

- Максимальный фрейм ChaChaPoly (шифр ChaCha20-Poly1305): 65535 байт
- Poly1305 MAC (код аутентификации сообщения): 16 байт
- Максимальный суммарный размер блоков: 65519 байт (65535 - 16)
- Максимальный размер одного блока: 65519 байт (включая 3-байтовый заголовок)
- Максимальный размер данных одного блока: 65516 байт

### Типы блоков

**Определённые типы блоков:**

<table style="width:100%; border-collapse:collapse; margin-bottom:1.5rem;">
  <thead>
    <tr>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:center;">Type</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Name</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Size</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Status</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Usage</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">0</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">DateTime</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">7 bytes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Implemented</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Required in NS</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">1-3</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Reserved</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">-</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">-</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Future use</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">4</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Termination</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">9+ bytes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Unimplemented</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Session termination</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">5</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Options</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">21+ bytes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Unimplemented</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Session options</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">6</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">MessageNumbers</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">5 bytes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Unimplemented</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">PN value</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">7</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">NextKey</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">3 or 35 bytes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Implemented</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">DH ratchet</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">8</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">ACK</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">4+ bytes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Implemented</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Message acknowledgment</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">9</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">ACK Request</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">3 bytes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Implemented</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Request ACK</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">10</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Reserved</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">-</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">-</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Future use</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">11</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Garlic Clove</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Variable</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Implemented</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Application data</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">12-223</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Reserved</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">-</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">-</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Future use</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">224-253</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Experimental</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Variable</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">-</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Testing features</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">254</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Padding</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Variable</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Implemented</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Traffic shaping</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">255</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Reserved</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">-</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">-</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Future extension</td>
    </tr>
  </tbody>
</table>
**Обработка неизвестных блоков:**

Реализации ДОЛЖНЫ игнорировать блоки с неизвестными номерами типов и рассматривать их как заполнение. Это обеспечивает совместимость с будущими версиями.

### Правила упорядочивания блоков

### Порядок сообщений NS

**Обязательно:** - блок DateTime ДОЛЖЕН быть первым

**Разрешено:** - Garlic Clove (тип 11; долька в сообщении Garlic) - Параметры (тип 5) - если реализовано - Заполнение (тип 254)

**Запрещено:** - NextKey, ACK, ACK Request, Termination, MessageNumbers

**Пример валидной полезной нагрузки NS:**

```
DateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254)
```
### Упорядочивание сообщений NSR

**Обязательные:** - Нет (полезная нагрузка может быть пустой)

**Разрешено:** - Garlic Clove (элемент «чесночного» сообщения) (тип 11) - Опции (тип 5) - если реализовано - Заполнение (тип 254)

**Запрещено:** - DateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers

**Пример валидной полезной нагрузки NSR:**

```
Garlic Clove (11) | Garlic Clove (11) | Padding (254)
```
или

```
(empty - ACK only)
```
### Порядок сообщений ES

**Требуется:** - нет (полезная нагрузка может быть пустой)

**Допускается (в любом порядке):** - Garlic Clove (долька garlic-сообщения) (type 11) - NextKey (следующий ключ) (type 7) - ACK (type 8) - ACK Request (type 9) - Завершение (type 4) - если реализовано - MessageNumbers (номера сообщений) (type 6) - если реализовано - Параметры (type 5) - если реализовано - Заполнение (type 254)

**Особые правила:** - Termination (завершение) ДОЛЖЕН быть последним блоком (кроме Padding) - Padding (заполнение) ДОЛЖЕН быть последним блоком - Допускается несколько Garlic Cloves (отдельных «долек» сообщения Garlic) - Допускается до 2 блоков NextKey (следующий ключ) (прямой и обратный) - НЕ допускается несколько блоков Padding

**Примеры допустимых полезных нагрузок ES:**

```
Garlic Clove (11) | ACK (8) | Padding (254)
```
```
NextKey (7) | Garlic Clove (11) | Garlic Clove (11)
```
```
NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11)
```
```
ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254)
```
### Блок даты и времени (тип 0)

**Назначение**: Метка времени для предотвращения атак повторного воспроизведения и проверки смещения часов

**Размер**: 7 байт (3 байта заголовка + 4 байта данных)

**Формат:**

```
+----+----+----+----+----+----+----+
| 0  |    4    |     timestamp     |
+----+----+----+----+----+----+----+
```
**Поля:**

- `blk`: 0
- `size`: 4 (big-endian; старший байт первым)
- `timestamp`: 4 байта - отметка времени Unix в секундах (без знака, big-endian)

**Формат временной метки:**

```python
timestamp = int(time.time())  # Seconds since 1970-01-01 00:00:00 UTC
# Wraps around in year 2106 (4-byte unsigned maximum)
```
**Правила проверки:**

```python
MAX_CLOCK_SKEW_PAST = 5 * 60      # 5 minutes
MAX_CLOCK_SKEW_FUTURE = 2 * 60    # 2 minutes

def validate_datetime(timestamp):
    now = int(time.time())
    age = now - timestamp
    
    if age < -MAX_CLOCK_SKEW_FUTURE:
        return False  # Too far in future
    
    if age > MAX_CLOCK_SKEW_PAST:
        return False  # Too old
    
    return True
```
**Предотвращение повторных атак:**

```python
class ReplayFilter:
    def __init__(self, duration=5*60):
        self.duration = duration  # 5 minutes
        self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001)
        self.cleanup_timer = RepeatTimer(60, self.cleanup)
    
    def check_replay(self, ephemeral_key, timestamp):
        # Check timestamp validity
        if not validate_datetime(timestamp):
            return False
        
        # Check if ephemeral key seen recently
        if ephemeral_key in self.seen_messages:
            return False  # Replay attack
        
        # Add to seen messages
        self.seen_messages.add(ephemeral_key)
        return True
    
    def cleanup(self):
        # Expire old entries (Bloom filter automatically ages out)
        pass
```
**Примечания по реализации:**

1. **NS Messages**: DateTime ДОЛЖЕН быть первым блоком
2. **NSR/ES Messages**: DateTime обычно не включается
3. **Окно повторов**: 5 минут — минимально рекомендуемое значение
4. **Фильтр Блума**: Рекомендуется для эффективного обнаружения повторов
5. **Смещение часов**: Допускайте отставание до 5 минут и опережение до 2 минут

### Garlic Clove Block (блок «зубчика чеснока», тип 11)

**Назначение**: Инкапсулирует сообщения I2NP для доставки

**Формат:**

```
+----+----+----+----+----+----+----+----+
| 11 |  size   |                        |
+----+----+----+                        +
|      Delivery Instructions            |
~                                       ~
|                                       |
+----+----+----+----+----+----+----+----+
|type|  Message_ID       | Expiration  |
+----+----+----+----+----+----+----+----+
     |      I2NP Message body           |
+----+                                  +
~                                       ~
|                                       |
+----+----+----+----+----+----+----+----+
```
**Поля:**

- `blk`: 11
- `size`: Общий размер clove (вложенного сообщения в garlic-сообщении) (переменный)
- `Delivery Instructions`: Как указано в спецификации I2NP
- `type`: тип сообщения I2NP (1 байт)
- `Message_ID`: идентификатор сообщения I2NP (4 байта)
- `Expiration`: метка времени Unix в секундах (4 байта)
- `I2NP Message body`: данные сообщения переменной длины

**Форматы инструкций доставки:**

**Локальная доставка** (1 байт):

```
+----+
|0x00|
+----+
```
**Доставка до Destination (адрес назначения в I2P)** (33 байта):

```
+----+----+----+----+----+----+----+----+
|0x01|                                  |
+----+        Destination Hash         +
|              32 bytes                 |
+                                       +
|                                       |
+----+----+----+----+----+----+----+----+
```
**Доставка к Router** (33 байта):

```
+----+----+----+----+----+----+----+----+
|0x02|                                  |
+----+         Router Hash              +
|              32 bytes                 |
+                                       +
|                                       |
+----+----+----+----+----+----+----+----+
```
**Доставка через Tunnel** (37 байт):

```
+----+----+----+----+----+----+----+----+
|0x03|         Tunnel ID                |
+----+----+----+----+----+              +
|           Router Hash                 |
+              32 bytes                 +
|                                       |
+                                       +
|                                       |
+----+----+----+----+----+----+----+----+
```
**Заголовок сообщения I2NP** (всего 9 байт):

```
+----+----+----+----+----+----+----+----+
|type|      msg_id       |  expiration   |
+----+----+----+----+----+----+----+----+
     |                                   |
```
- `type`: тип сообщения I2NP (Database Store, Database Lookup, Data и т. д.)
- `msg_id`: 4-байтовый идентификатор сообщения
- `expiration`: 4-байтовая метка времени Unix (в секундах)

**Важные отличия от формата ElGamal Clove:**

1. **Без сертификата**: Поле сертификата опущено (не используется в ElGamal)
2. **Нет Clove ID**: Clove ID опущен (всегда был 0)
3. **Нет поля Clove Expiration**: Вместо этого используется срок истечения сообщения I2NP
4. **Компактный заголовок**: 9-байтный заголовок I2NP по сравнению с более крупным форматом ElGamal
5. **Каждый Clove (долька) — отдельный блок**: Нет структуры CloveSet (набор долек)

**Несколько долек:**

```python
# Multiple Garlic Cloves in one message
payload = [
    build_datetime_block(),
    build_garlic_clove(i2np_message_1),
    build_garlic_clove(i2np_message_2),
    build_garlic_clove(i2np_message_3),
    build_padding_block()
]
```
**Распространённые типы сообщений I2NP в Cloves (дольках):**

<table style="width:100%; border-collapse:collapse; margin-bottom:1.5rem;">
  <thead>
    <tr>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:center;">Type</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Name</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Usage</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">1</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">DatabaseStore</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Publishing LeaseSet</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">2</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">DatabaseLookup</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Requesting LeaseSet</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">5</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">DeliveryStatus</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">ACK (legacy, avoid in ECIES)</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">20</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Data</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Streaming data</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">21</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Garlic</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Nested garlic messages</td>
    </tr>
  </tbody>
</table>
**Обработка зубчиков:**

```python
def process_garlic_clove(clove_data):
    # Parse delivery instructions
    delivery_type = clove_data[0]
    
    if delivery_type == 0x00:
        # Local delivery
        offset = 1
    elif delivery_type == 0x01:
        # Destination delivery
        dest_hash = clove_data[1:33]
        offset = 33
    elif delivery_type == 0x02:
        # Router delivery
        router_hash = clove_data[1:33]
        offset = 33
    elif delivery_type == 0x03:
        # Tunnel delivery
        tunnel_id = struct.unpack('>I', clove_data[1:5])[0]
        router_hash = clove_data[5:37]
        offset = 37
    
    # Parse I2NP header
    i2np_type = clove_data[offset]
    msg_id = struct.unpack('>I', clove_data[offset+1:offset+5])[0]
    expiration = struct.unpack('>I', clove_data[offset+5:offset+9])[0]
    
    # Extract I2NP body
    i2np_body = clove_data[offset+9:]
    
    # Process message
    process_i2np_message(i2np_type, msg_id, expiration, i2np_body)
```
### Блок NextKey (Тип 7)

**Назначение**: обмен ключами DH ratchet (механизм ратчета Диффи-Хеллмана)

**Формат (ключ присутствует - 38 байт):**

```
+----+----+----+----+----+----+----+----+
| 7  |   35    |flag|  key ID |         |
+----+----+----+----+----+----+         +
|                                       |
+     Next DH Ratchet Public Key        +
|              32 bytes                 |
+                                       +
|                                       |
+                             +----+----+
|                             |
+----+----+----+----+----+----+
```
**Формат (только ID ключа - 6 байт):**

```
+----+----+----+----+----+----+
| 7  |    3    |flag|  key ID |
+----+----+----+----+----+----+
```
**Поля:**

- `blk`: 7
- `size`: 3 (только ID) или 35 (с ключом)
- `flag`: 1 байт - биты флагов
- `key ID`: 2 байта - идентификатор ключа Big-endian (старший байт первым) (0-32767)
- `Public Key`: 32 байта - открытый ключ X25519 (little-endian, младший байт первым), если бит 0 flag = 1

**Биты флагов:**

```
Bit 7 6 5 4 3 2 1 0
    | | | | | | | |
    | | | | | | | +-- Bit 0: Key present (1) or ID only (0)
    | | | | | | +---- Bit 1: Reverse key (1) or forward key (0)
    | | | | | +------ Bit 2: Request reverse key (1) or no request (0)
    | | | | |
    +-+-+-+-+-------- Bits 3-7: Reserved (set to 0)
```
**Примеры флагов:**

```python
# Forward key present
flags = 0x01  # Binary: 00000001

# Reverse key present
flags = 0x03  # Binary: 00000011

# Forward key ID only (ACK)
flags = 0x00  # Binary: 00000000

# Reverse key ID only (ACK)
flags = 0x02  # Binary: 00000010

# Forward key ID with reverse request
flags = 0x04  # Binary: 00000100
```
**Правила идентификаторов ключей:**

- ID идут последовательно: 0, 1, 2, ..., 32767
- ID увеличивается только при генерации нового ключа
- Один и тот же ID используется для нескольких сообщений до следующего ratchet (механизма пошагового обновления ключей)
- Максимальный ID — 32767 (после этого необходимо начать новую сессию)

**Примеры использования:**

```python
# Initiating ratchet (sender generates new key)
nextkey = NextKeyBlock(
    flags=0x01,           # Key present, forward
    key_id=0,
    public_key=sender_new_pk
)

# Replying to ratchet (receiver generates new key)
nextkey = NextKeyBlock(
    flags=0x03,           # Key present, reverse
    key_id=0,
    public_key=receiver_new_pk
)

# Acknowledging ratchet (no new key from sender)
nextkey = NextKeyBlock(
    flags=0x02,           # ID only, reverse
    key_id=0
)

# Requesting reverse ratchet
nextkey = NextKeyBlock(
    flags=0x04,           # Request reverse, forward ID
    key_id=1
)
```
**Логика обработки:**

```python
def process_nextkey_block(block):
    flags = block.flags
    key_id = block.key_id
    
    key_present = (flags & 0x01) != 0
    is_reverse = (flags & 0x02) != 0
    request_reverse = (flags & 0x04) != 0
    
    if key_present:
        public_key = block.public_key
        
        if is_reverse:
            # Reverse key received
            perform_dh_ratchet(receiver_key=public_key, key_id=key_id)
            # Sender should ACK with own key ID
        else:
            # Forward key received
            perform_dh_ratchet(sender_key=public_key, key_id=key_id)
            # Receiver should reply with reverse key
            send_reverse_key(generate_new_key())
    
    else:
        # Key ID only (ACK)
        if is_reverse:
            # Reverse key ACK
            confirm_reverse_ratchet(key_id)
        else:
            # Forward key ACK
            confirm_forward_ratchet(key_id)
    
    if request_reverse:
        # Sender requests receiver to generate new key
        send_reverse_key(generate_new_key())
```
**Несколько NextKey Blocks (блоков NextKey):**

Одно сообщение ES может содержать до 2 блоков NextKey, когда в обоих направлениях одновременно выполняется ratcheting (криптографический механизм храповика):

```python
# Both directions ratcheting
payload = [
    NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key),  # Forward
    NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key),  # Reverse
    build_garlic_clove(data)
]
```
### Блок ACK (тип 8)

**Назначение**: Подтверждение получения сообщений in-band (в рамках того же канала связи)

**Формат (одиночный ACK - 7 байт):**

```
+----+----+----+----+----+----+----+
| 8  |    4    |tagsetid |   N     |
+----+----+----+----+----+----+----+
```
**Формат (несколько подтверждений):**

```
+----+----+----+----+----+----+----+----+
| 8  |  size   |tagsetid |   N     |    |
+----+----+----+----+----+----+----+    +
|            more ACKs                  |
~               ...                     ~
|                                       |
+----+----+----+----+----+----+----+----+
```
**Поля:**

- `blk`: 8
- `size`: 4 * число ACK (подтверждений) (минимум 4)
- Для каждого ACK:
  - `tagsetid`: 2 байта - идентификатор набора тегов в порядке старшего байта первым (0-65535)
  - `N`: 2 байта - номер сообщения в порядке старшего байта первым (0-65535)

**Определение Tag Set ID (идентификатора набора тегов):**

```python
# Tag set 0 (initial, after NSR)
tagset_id = 0

# After first ratchet (tag set 1)
# Both Alice and Bob sent key ID 0
tagset_id = 1 + 0 + 0 = 1

# After second ratchet (tag set 2)
# Alice sent key ID 1, Bob still using key ID 0
tagset_id = 1 + 1 + 0 = 2

# After third ratchet (tag set 3)
# Alice still using key ID 1, Bob sent key ID 1
tagset_id = 1 + 1 + 1 = 3
```
**Пример одиночного ACK (подтверждение):**

```python
# ACK message from tag set 5, message number 127
ack_block = ACKBlock(
    tagset_id=5,
    message_number=127
)

# Wire format (7 bytes):
# 08 00 04 00 05 00 7F
# |  |  |  |  |  |  |
# |  |  |  |  |  |  +-- N (127)
# |  |  |  |  +--------- N high byte
# |  |  |  +------------ tagset_id (5)
# |  |  +--------------- tagset_id high byte
# |  +------------------ size (4)
# +--------------------- type (8)
```
**Пример нескольких ACK:**

```python
# ACK three messages
ack_block = ACKBlock([
    (tagset_id=3, N=42),
    (tagset_id=3, N=43),
    (tagset_id=4, N=0)
])

# Wire format (15 bytes):
# 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00
#                (ts=3, N=42) (ts=3, N=43) (ts=4, N=0)
```
**Обработка:**

```python
def process_ack_block(block):
    num_acks = block.size // 4
    
    for i in range(num_acks):
        offset = i * 4
        tagset_id = struct.unpack('>H', block.data[offset:offset+2])[0]
        message_num = struct.unpack('>H', block.data[offset+2:offset+4])[0]
        
        # Mark message as acknowledged
        mark_acked(tagset_id, message_num)
        
        # May trigger retransmission timeout cancellation
        cancel_retransmit_timer(tagset_id, message_num)
```
**Когда отправлять ACKs (подтверждения):**


**Тайминг ACK (подтверждений):**

```python
class ACKManager:
    def __init__(self):
        self.pending_acks = []
        self.ack_timer = None
    
    def request_ack(self, tagset_id, message_num):
        self.pending_acks.append((tagset_id, message_num))
        
        if not self.ack_timer:
            # Delay ACK briefly to allow higher layer to respond
            self.ack_timer = set_timer(0.1, self.send_acks)  # 100ms
    
    def send_acks(self):
        if self.pending_acks and not has_outbound_data():
            # No higher layer data, send explicit ACK
            send_es_message(build_ack_block(self.pending_acks))
        
        # Otherwise, ACK will piggyback on next ES message
        self.pending_acks = []
        self.ack_timer = None
```
### Блок запроса ACK (Тип 9)

**Назначение**: Запрос подтверждения получения текущего сообщения по основному каналу (in-band acknowledgment)

**Формат:**

```
+----+----+----+----+
| 9  |    1    |flg |
+----+----+----+----+
```
**Поля:**

- `blk`: 9
- `size`: 1
- `flg`: 1 байт - Флаги (все биты в настоящее время не используются, установлены в 0)

**Использование:**

```python
# Request ACK for this message
payload = [
    build_ack_request_block(),
    build_garlic_clove(important_data)
]
```
**Ответ получателя:**

Когда получен ACK Request (запрос подтверждения):

1. **С немедленными данными**: включить ACK-блок в немедленный ответ
2. **Без немедленных данных**: запустить таймер (например, 100 мс) и отправить пустой ES с ACK, если таймер истечет
3. **Идентификатор набора тегов**: использовать текущий ID входящего набора тегов
4. **Номер сообщения**: использовать номер сообщения, связанный с полученным тегом сеанса

**Обработка:**

```python
def process_ack_request(message):
    # Extract message identification
    tagset_id = message.tagset_id
    message_num = message.message_num
    
    # Schedule ACK
    schedule_ack(tagset_id, message_num)
    
    # If no data to send immediately, start timer
    if not has_pending_data():
        set_timer(0.1, lambda: send_ack_only(tagset_id, message_num))
```
**Когда использовать ACK Request (запрос подтверждения):**

1. **Критические сообщения**: Сообщения, которые должны быть подтверждены
2. **Доставка LeaseSet**: При включении LeaseSet в пакет
3. **Session Ratchet (механизм обновления ключей сеанса)**: После отправки блока NextKey (блок следующего ключа)
4. **Окончание передачи**: Когда у отправителя больше нет данных для отправки, но он хочет получить подтверждение

**Когда НЕ следует использовать:**

1. **Потоковый протокол**: Потоковый слой обрабатывает подтверждения (ACK)
2. **Высокочастотные сообщения**: Избегайте запроса ACK для каждого сообщения (накладные расходы)
3. **Неважные дейтаграммы**: Сырые дейтаграммы обычно не нуждаются в ACK

### Блок завершения (Тип 4)

**Статус**: НЕ РЕАЛИЗОВАНО

**Назначение**: Корректно завершить сеанс

**Формат:**

```
+----+----+----+----+----+----+----+----+
| 4  |  size   | rsn|     addl data     |
+----+----+----+----+                   +
~               ...                     ~
+----+----+----+----+----+----+----+----+
```
**Поля:**

- `blk`: 4
- `size`: 1 или более байт
- `rsn`: 1 байт - код причины
- `addl data`: Необязательные дополнительные данные (формат зависит от причины)

**Коды причин:**

<table style="width:100%; border-collapse:collapse; margin-bottom:1.5rem;">
  <thead>
    <tr>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:center;">Code</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Meaning</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Additional Data</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">0</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Normal close / unspecified</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">None</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">1</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Termination received</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">None</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">2</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Idle timeout</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">None (implementation-specific)</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">3</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Resource exhaustion</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">None (implementation-specific)</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">4+</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Reserved</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Implementation-specific</td>
    </tr>
  </tbody>
</table>
**Использование (когда будет реализовано):**

```python
# Normal session close
termination = TerminationBlock(
    reason=0,
    additional_data=b''
)

# Session termination due to received termination
termination = TerminationBlock(
    reason=1,
    additional_data=b''
)
```
**Правила:**

- ДОЛЖЕН быть последним блоком, за исключением Padding (выравнивание)
- Padding ДОЛЖЕН следовать за Termination (блок завершения) при наличии
- Не допускается в сообщениях NS или NSR
- Допускается только в сообщениях ES

### Блок параметров (Тип 5)

**Статус**: НЕ РЕАЛИЗОВАНО

**Назначение**: Согласовать параметры сеанса

**Формат:**

```
+----+----+----+----+----+----+----+----+
| 5  |  size   |ver |flg |STL |STimeout |
+----+----+----+----+----+----+----+----+
|  SOTW   |  RITW   |tmin|tmax|rmin|rmax|
+----+----+----+----+----+----+----+----+
|  tdmy   |  rdmy   |  tdelay |  rdelay |
+----+----+----+----+----+----+----+----+
|              more_options             |
~               ...                     ~
|                                       |
+----+----+----+----+----+----+----+----+
```
**Поля:**

- `blk`: 5
- `size`: 21 или более байт
- `ver`: 1 байт - версия протокола (должна быть 0)
- `flg`: 1 байт - флаги (все биты в настоящее время не используются)
- `STL`: 1 байт - длина тега сеанса (должна быть равна 8)
- `STimeout`: 2 байта - таймаут простоя сеанса в секундах (big-endian — старший байт первым)
- `SOTW`: 2 байта - окно исходящих тегов отправителя (big-endian)
- `RITW`: 2 байта - окно входящих тегов получателя (big-endian)
- `tmin`, `tmax`, `rmin`, `rmax`: по 1 байту каждый - параметры заполнения (фиксированная точка 4.4)
- `tdmy`: 2 байта - максимальный объём фиктивного трафика, который готов отправлять (байт/с, big-endian)
- `rdmy`: 2 байта - запрашиваемый фиктивный трафик (байт/с, big-endian)
- `tdelay`: 2 байта - максимальная задержка внутри сообщения, которую готов вставить (мс, big-endian)
- `rdelay`: 2 байта - запрашиваемая задержка внутри сообщения (мс, big-endian)
- `more_options`: переменной длины - будущие расширения

**Параметры дополнения (4.4 с фиксированной точкой):**

```python
def encode_padding_ratio(ratio):
    """
    Encode padding ratio as 4.4 fixed-point
    
    ratio: 0.0 to 15.9375
    returns: 0x00 to 0xFF
    """
    return int(ratio * 16)

def decode_padding_ratio(encoded):
    """
    Decode 4.4 fixed-point to ratio
    
    encoded: 0x00 to 0xFF
    returns: 0.0 to 15.9375
    """
    return encoded / 16.0

# Examples:
# 0x00 = 0.0 (no padding)
# 0x01 = 0.0625 (6.25% padding)
# 0x10 = 1.0 (100% padding - double traffic)
# 0x80 = 8.0 (800% padding - 9x traffic)
# 0xFF = 15.9375 (1593.75% padding)
```
**Согласование окна тегов:**

```python
# SOTW: Sender's recommendation for receiver's inbound window
# RITW: Sender's declaration of own inbound window

# Receiver calculates actual inbound window:
inbound_window = calculate_window(
    sender_suggestion=SOTW,
    own_constraints=MAX_INBOUND_TAGS,
    own_resources=available_memory()
)

# Sender uses:
# - RITW to know how far ahead receiver will accept
# - Own SOTW to hint optimal window size
```
**Значения по умолчанию (когда параметры не согласованы):**

```python
DEFAULT_OPTIONS = {
    'version': 0,
    'session_tag_length': 8,
    'session_timeout': 600,  # 10 minutes
    'sender_outbound_tag_window': 160,
    'receiver_inbound_tag_window': 160,
    'tmin': 0x00,  # No minimum padding
    'tmax': 0x10,  # Up to 100% padding
    'rmin': 0x00,  # No minimum requested
    'rmax': 0x10,  # Up to 100% requested
    'tdmy': 0,     # No dummy traffic
    'rdmy': 0,     # No dummy traffic requested
    'tdelay': 0,   # No delay
    'rdelay': 0    # No delay requested
}
```
### Блок номеров сообщений (Тип 6)

**Статус**: НЕ РЕАЛИЗОВАНО

**Назначение**: указать последнее сообщение, отправленное в предыдущем наборе тегов (позволяет обнаруживать пропуски)

**Формат:**

```
+----+----+----+----+----+
| 6  |    2    |  PN    |
+----+----+----+----+----+
```
**Поля:**

- `blk`: 6
- `size`: 2
- `PN`: 2 байта — номер последнего сообщения предыдущего набора тегов (big-endian (старший байт первым), 0-65535)

**Определение PN (Previous Number — предыдущее число):**

PN — это индекс последнего тега, отправленного в предыдущем наборе тегов.

**Использование (когда будет реализовано):**

```python
# After ratcheting to new tag set
# Old tag set: sent messages 0-4095
# New tag set: sending first message

payload = [
    MessageNumbersBlock(PN=4095),
    build_garlic_clove(data)
]
```
**Преимущества для получателя:**

```python
def process_message_numbers(pn_value):
    # Receiver can now:
    
    # 1. Determine if any messages were skipped
    highest_received_in_old_tagset = 4090
    if pn_value > highest_received_in_old_tagset:
        missing_count = pn_value - highest_received_in_old_tagset
        # 5 messages were never received
    
    # 2. Delete tags higher than PN from old tagset
    for tag_index in range(pn_value + 1, MAX_TAG_INDEX):
        delete_tag(old_tagset, tag_index)
    
    # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes)
    schedule_deletion(old_tagset, delay=120)
```
**Правила:**

- НЕ ДОЛЖЕН отправляться в наборе тегов 0 (нет предыдущего набора тегов)
- Отправляется только в ES messages (сообщениях формата ES)
- Отправляется только в первом или первых сообщениях нового набора тегов
- Значение PN берётся с точки зрения отправителя (последний тег, отправленный отправителем)

**Связь с Signal:**

В Signal Double Ratchet PN находится в заголовке сообщения. В ECIES PN находится в зашифрованной полезной нагрузке и является необязательным.

### Блок заполнения (тип 254)

**Назначение**: противодействие анализу трафика и маскировка размера сообщений

**Формат:**

```
+----+----+----+----+----+----+----+----+
|254 |  size   |      padding           |
+----+----+----+                        +
|                                       |
~               ...                     ~
|                                       |
+----+----+----+----+----+----+----+----+
```
**Поля:**

- `blk`: 254
- `size`: 0-65516 байт (big-endian — старший байт вперёд)
- `padding`: Случайные или нулевые данные

**Правила:**

- ДОЛЖЕН быть последним блоком в сообщении
- Несколько блоков заполнения НЕ допускаются
- Может иметь нулевую длину (только 3-байтовый заголовок)
- Данные заполнения могут быть нулями или случайными байтами

**Паддинг по умолчанию:**

```python
DEFAULT_PADDING_MIN = 0
DEFAULT_PADDING_MAX = 15

def generate_default_padding():
    size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX)
    data = random.bytes(size)  # or zeros
    return PaddingBlock(size, data)
```
**Стратегии противодействия анализу трафика:**

**Стратегия 1: Случайный размер (по умолчанию)**

```python
# Add 0-15 bytes random padding to each message
padding_size = random.randint(0, 15)
padding_block = PaddingBlock(padding_size, random.bytes(padding_size))
```
**Стратегия 2: Округление до кратного**

```python
# Round total message size to next multiple of 64
target_size = ((message_size + 63) // 64) * 64
padding_size = target_size - message_size - 3  # -3 for block header
padding_block = PaddingBlock(padding_size, random.bytes(padding_size))
```
**Стратегия 3: Фиксированные размеры сообщений**

```python
# Always send 1KB messages
TARGET_MESSAGE_SIZE = 1024
padding_size = TARGET_MESSAGE_SIZE - message_size - 3
padding_block = PaddingBlock(padding_size, random.bytes(padding_size))
```
**Стратегия 4: Согласованное заполнение (Options block — блок параметров)**

```python
# Calculate padding based on negotiated parameters
# tmin, tmax from Options block
min_padding = int(payload_size * tmin_ratio)
max_padding = int(payload_size * tmax_ratio)
padding_size = random.randint(min_padding, max_padding)
padding_block = PaddingBlock(padding_size, random.bytes(padding_size))
```
**Сообщения, состоящие только из заполнения:**

Сообщения могут целиком состоять из заполнения (без данных приложения):

```python
# Dummy traffic message
payload = [
    PaddingBlock(random.randint(100, 500), random.bytes(...))
]
```
**Примечания по реализации:**

1. **Полностью нулевое заполнение**: Допустимо (будет зашифровано ChaCha20)
2. **Случайное заполнение**: Не добавляет дополнительной безопасности после шифрования, но использует больше энтропии
3. **Производительность**: Генерация случайного заполнения может быть затратной; рассмотрите использование нулей
4. **Память**: Большие блоки заполнения потребляют пропускную способность; будьте осторожны с максимальным размером

---

## Руководство по реализации

### Предварительные требования

**Криптографические библиотеки:**

- **X25519**: libsodium, NaCl, или Bouncy Castle
- **ChaCha20-Poly1305**: libsodium, OpenSSL 1.1.0+, или Bouncy Castle
- **SHA-256**: OpenSSL, Bouncy Castle, или встроенная поддержка на уровне языка
- **Elligator2**: Ограниченная поддержка в библиотеках; может потребоваться собственная реализация

**Реализация Elligator2 (криптографический алгоритм маскировки публичных ключей):**

Elligator2 (криптографический метод маскировки открытых ключей на эллиптических кривых) не широко реализован. Варианты:

1. **OBFS4** (протокол маскировки трафика для Tor): подключаемый транспорт obfs4 для Tor включает реализацию Elligator2 (криптографический метод маскировки публичных ключей)
2. **Собственная реализация**: основана на [статье Elligator2](https://elligator.cr.yp.to/elligator-20130828.pdf)
3. **kleshni/Elligator**: эталонная реализация на GitHub

**Примечание по Java I2P:** Java I2P использует библиотеку net.i2p.crypto.eddsa с собственными дополнениями Elligator2 (криптографическая схема маскировки точек эллиптической кривой).

### Рекомендуемый порядок реализации

**Этап 1: Основная криптография** 1. генерация и обмен DH-ключами X25519 2. шифрование/расшифрование AEAD ChaCha20-Poly1305 3. хеширование SHA-256 и MixHash (операция смешивания хэша) 4. деривация ключей HKDF 5. кодирование/декодирование Elligator2 (поначалу можно использовать тестовые векторы)

**Фаза 2: Форматы сообщений** 1. Сообщение NS (без привязки) - самый простой формат 2. Сообщение NS (с привязкой) - добавляет статический ключ 3. Сообщение NSR 4. Сообщение ES 5. Разбор и генерация блоков

**Этап 3: Управление сеансами** 1. Создание и хранение сеанса 2. Управление набором тегов (для отправителя и получателя) 3. Ratchet (механизм пошагового обновления) для тегов сеанса 4. Ratchet симметричного ключа 5. Поиск тегов и управление окном

**Этап 4: DH-ратчет** 1. Обработка блока NextKey 2. KDF для DH-ратчета 3. Создание набора тегов после ратчета 4. Управление несколькими наборами тегов

**Фаза 5: Логика протокола** 1. Машина состояний для NS/NSR/ES 2. Защита от повторного воспроизведения (DateTime, фильтр Блума) 3. Логика повторной передачи (множественные NS/NSR) 4. Обработка ACK

**Этап 6: Интеграция** 1. Обработка I2NP Garlic Clove (вложенного элемента в garlic-сообщении) 2. Упаковка LeaseSet 3. Интеграция потокового протокола 4. Интеграция протокола дейтаграмм

### Реализация отправителя

**Жизненный цикл исходящего сеанса:**

```python
class OutboundSession:
    def __init__(self, destination, bound=True):
        self.destination = destination
        self.bound = bound
        self.state = SessionState.NEW
        
        # Keys for NS message
        self.ephemeral_keypair = generate_elg2_keypair()
        if bound:
            self.static_key = context.static_keypair
        
        # Will be populated after NSR
        self.outbound_tagset = None
        self.outbound_keyratchet = None
        self.inbound_tagset = None
        self.inbound_keyratchet = None
        
        # Timing
        self.created_time = now()
        self.last_activity = now()
        
        # Retransmission
        self.ns_attempts = []
        self.ns_timer = None
    
    def send_initial_message(self, payload):
        """Send NS message"""
        # Build NS message
        ns_message = self.build_ns_message(payload)
        
        # Send
        send_to_network(self.destination, ns_message)
        
        # Track for retransmission
        self.ns_attempts.append({
            'message': ns_message,
            'time': now(),
            'ephemeral_key': self.ephemeral_keypair,
            'kdf_state': self.save_kdf_state()
        })
        
        # Start timer
        self.ns_timer = set_timer(1.0, self.on_ns_timeout)
        self.state = SessionState.PENDING_REPLY
    
    def build_ns_message(self, payload):
        """Construct NS message"""
        # KDF initialization
        chainKey, h = self.initialize_kdf()
        
        # Ephemeral key section
        elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key)
        h = SHA256(h || self.destination.static_key)
        h = SHA256(h || self.ephemeral_keypair.public_key)
        
        # es DH
        es_shared = DH(self.ephemeral_keypair.private_key, 
                       self.destination.static_key)
        keydata = HKDF(chainKey, es_shared, "", 64)
        chainKey = keydata[0:31]
        k_static = keydata[32:63]
        
        # Encrypt static key section
        if self.bound:
            static_section = self.static_key.public_key
        else:
            static_section = bytes(32)
        
        static_ciphertext = ENCRYPT(k_static, 0, static_section, h)
        h = SHA256(h || static_ciphertext)
        
        # ss DH (if bound)
        if self.bound:
            ss_shared = DH(self.static_key.private_key, 
                          self.destination.static_key)
            keydata = HKDF(chainKey, ss_shared, "", 64)
            chainKey = keydata[0:31]
            k_payload = keydata[32:63]
            nonce = 0
        else:
            k_payload = k_static
            nonce = 1
        
        # Build payload blocks
        payload_data = self.build_ns_payload(payload)
        
        # Encrypt payload
        payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h)
        h = SHA256(h || payload_ciphertext)
        
        # Save KDF state for NSR processing
        self.ns_chainkey = chainKey
        self.ns_hash = h
        
        # Assemble message
        return elg2_ephemeral + static_ciphertext + payload_ciphertext
    
    def build_ns_payload(self, application_data):
        """Build NS payload blocks"""
        blocks = []
        
        # DateTime block (required, first)
        blocks.append(build_datetime_block())
        
        # Garlic Clove(s) with application data
        blocks.append(build_garlic_clove(application_data))
        
        # Optionally bundle LeaseSet
        if should_send_leaseset():
            blocks.append(build_garlic_clove(build_leaseset_store()))
        
        # Padding
        blocks.append(build_padding_block(random.randint(0, 15)))
        
        return encode_blocks(blocks)
    
    def on_nsr_received(self, nsr_message):
        """Process NSR and establish ES session"""
        # Cancel retransmission timer
        cancel_timer(self.ns_timer)
        
        # Parse NSR
        tag = nsr_message[0:8]
        elg2_bob_ephemeral = nsr_message[8:40]
        key_section_mac = nsr_message[40:56]
        payload_ciphertext = nsr_message[56:]
        
        # Find corresponding NS attempt
        ns_state = self.find_ns_by_tag(tag)
        if not ns_state:
            raise ValueError("NSR tag doesn't match any NS")
        
        # Restore KDF state
        chainKey = ns_state['chainkey']
        h = ns_state['hash']
        
        # Decode Bob's ephemeral key
        bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral)
        
        # Mix tag and Bob's ephemeral into hash
        h = SHA256(h || tag)
        h = SHA256(h || bob_ephemeral)
        
        # ee DH
        ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral)
        keydata = HKDF(chainKey, ee_shared, "", 32)
        chainKey = keydata[0:31]
        
        # se DH
        se_shared = DH(self.static_key.private_key, bob_ephemeral)
        keydata = HKDF(chainKey, se_shared, "", 64)
        chainKey = keydata[0:31]
        k_key_section = keydata[32:63]
        
        # Verify key section MAC
        try:
            DECRYPT(k_key_section, 0, key_section_mac, h)
        except AuthenticationError:
            raise ValueError("NSR key section MAC verification failed")
        
        h = SHA256(h || key_section_mac)
        
        # Split for bidirectional ES
        keydata = HKDF(chainKey, ZEROLEN, "", 64)
        k_ab = keydata[0:31]  # Alice → Bob
        k_ba = keydata[32:63]  # Bob → Alice
        
        # Initialize ES tagsets
        self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab)
        self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba)
        
        # Decrypt NSR payload
        k_nsr = HKDF(k_ba, ZEROLEN, "AttachPayloadKDF", 32)
        try:
            payload = DECRYPT(k_nsr, 0, payload_ciphertext, h)
        except AuthenticationError:
            raise ValueError("NSR payload MAC verification failed")
        
        # Process NSR payload blocks
        self.process_payload_blocks(payload)
        
        # Session established
        self.state = SessionState.ESTABLISHED
        self.last_activity = now()
        
        # Send ES message (implicit ACK)
        self.send_es_ack()
    
    def send_es_message(self, payload):
        """Send ES message"""
        if self.state != SessionState.ESTABLISHED:
            raise ValueError("Session not established")
        
        # Get next tag and key
        tag, index = self.outbound_tagset.get_next_tag()
        key = self.outbound_keyratchet.get_key(index)
        
        # Construct nonce
        nonce = construct_nonce(index)
        
        # Build payload blocks
        payload_data = self.build_es_payload(payload)
        
        # AEAD encryption
        ciphertext = ENCRYPT(key, nonce, payload_data, tag)
        
        # Assemble message
        es_message = tag + ciphertext
        
        # Send
        send_to_network(self.destination, es_message)
        
        # Update activity
        self.last_activity = now()
        
        # Check if ratchet needed
        if self.outbound_tagset.should_ratchet():
            self.initiate_ratchet()
```
### Реализация получателя

**Жизненный цикл входящего сеанса:**

```python
class InboundSession:
    def __init__(self):
        self.state = None
        self.bound = False
        self.destination = None
        
        # Keys
        self.remote_ephemeral_key = None
        self.remote_static_key = None
        self.ephemeral_keypair = None
        
        # Tagsets
        self.inbound_tagset = None
        self.outbound_tagset = None
        
        # Timing
        self.created_time = None
        self.last_activity = None
        
        # Paired session
        self.paired_outbound = None
    
    @staticmethod
    def try_decrypt_ns(message):
        """Attempt to decrypt as NS message"""
        # Parse NS structure
        elg2_ephemeral = message[0:32]
        static_ciphertext = message[32:80]  # 32 + 16
        payload_ciphertext = message[80:]
        
        # Decode ephemeral key
        try:
            alice_ephemeral = DECODE_ELG2(elg2_ephemeral)
        except:
            return None  # Not a valid Elligator2 encoding
        
        # Check replay
        if is_replay(alice_ephemeral):
            return None
        
        # KDF initialization
        chainKey, h = initialize_kdf()
        
        # Mix keys
        h = SHA256(h || context.static_keypair.public_key)
        h = SHA256(h || alice_ephemeral)
        
        # es DH
        es_shared = DH(context.static_keypair.private_key, alice_ephemeral)
        keydata = HKDF(chainKey, es_shared, "", 64)
        chainKey = keydata[0:31]
        k_static = keydata[32:63]
        
        # Decrypt static key section
        try:
            static_data = DECRYPT(k_static, 0, static_ciphertext, h)
        except AuthenticationError:
            return None  # Not a valid NS message
        
        h = SHA256(h || static_ciphertext)
        
        # Check if bound or unbound
        if static_data == bytes(32):
            # Unbound
            alice_static_key = None
            k_payload = k_static
            nonce = 1
        else:
            # Bound - perform ss DH
            alice_static_key = static_data
            ss_shared = DH(context.static_keypair.private_key, alice_static_key)
            keydata = HKDF(chainKey, ss_shared, "", 64)
            chainKey = keydata[0:31]
            k_payload = keydata[32:63]
            nonce = 0
        
        # Decrypt payload
        try:
            payload = DECRYPT(k_payload, nonce, payload_ciphertext, h)
        except AuthenticationError:
            return None
        
        h = SHA256(h || payload_ciphertext)
        
        # Create session
        session = InboundSession()
        session.state = SessionState.ESTABLISHED
        session.created_time = now()
        session.last_activity = now()
        session.remote_ephemeral_key = alice_ephemeral
        session.remote_static_key = alice_static_key
        session.bound = (alice_static_key is not None)
        session.ns_chainkey = chainKey
        session.ns_hash = h
        
        # Extract destination if bound
        if session.bound:
            session.destination = extract_destination_from_payload(payload)
        
        # Process payload
        session.process_payload_blocks(payload)
        
        return session
    
    def send_nsr_reply(self, reply_payload):
        """Send NSR message"""
        # Generate NSR tagset
        tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, "SessionReplyTags", 32)
        nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey)
        
        # Get tag
        tag, _ = nsr_tagset.get_next_tag()
        
        # Mix tag into hash
        h = SHA256(self.ns_hash || tag)
        
        # Generate ephemeral key
        self.ephemeral_keypair = generate_elg2_keypair()
        bob_ephemeral = self.ephemeral_keypair.public_key
        elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral)
        
        # Mix ephemeral key
        h = SHA256(h || bob_ephemeral)
        
        chainKey = self.ns_chainkey
        
        # ee DH
        ee_shared = DH(self.ephemeral_keypair.private_key, 
                      self.remote_ephemeral_key)
        keydata = HKDF(chainKey, ee_shared, "", 32)
        chainKey = keydata[0:31]
        
        # se DH
        se_shared = DH(context.static_keypair.private_key, 
                      self.remote_ephemeral_key)
        keydata = HKDF(chainKey, se_shared, "", 64)
        chainKey = keydata[0:31]
        k_key_section = keydata[32:63]
        
        # Encrypt key section (empty)
        key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h)
        h = SHA256(h || key_section_ciphertext)
        
        # Split for bidirectional ES
        keydata = HKDF(chainKey, ZEROLEN, "", 64)
        k_ab = keydata[0:31]  # Alice → Bob
        k_ba = keydata[32:63]  # Bob → Alice
        
        # Initialize ES tagsets
        self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab)
        self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba)
        
        # Build reply payload
        payload_data = build_payload_blocks(reply_payload)
        
        # Encrypt payload
        k_nsr = HKDF(k_ba, ZEROLEN, "AttachPayloadKDF", 32)
        payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h)
        
        # Assemble NSR
        nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext
        
        # Send
        send_to_network(self.destination, nsr_message)
        
        # Wait for ES
        self.state = SessionState.AWAITING_ES
        self.last_activity = now()
    
    def on_es_received(self, es_message):
        """Process first ES message"""
        if self.state == SessionState.AWAITING_ES:
            # First ES received, confirms session
            self.state = SessionState.ESTABLISHED
        
        # Process ES message
        self.process_es_message(es_message)
    
    def process_es_message(self, es_message):
        """Decrypt and process ES message"""
        # Extract tag
        tag = es_message[0:8]
        ciphertext = es_message[8:]
        
        # Look up tag
        index = self.inbound_tagset.lookup_tag(tag)
        if index is None:
            raise ValueError("Tag not found")
        
        # Get key
        key = self.inbound_keyratchet.get_key(index)
        
        # Construct nonce
        nonce = construct_nonce(index)
        
        # Decrypt
        try:
            payload = DECRYPT(key, nonce, ciphertext, tag)
        except AuthenticationError:
            raise ValueError("ES MAC verification failed")
        
        # Process blocks
        self.process_payload_blocks(payload)
        
        # Update activity
        self.last_activity = now()
```
### Классификация сообщений

**Различение типов сообщений:**

```python
def classify_message(message):
    """Determine message type"""
    
    # Minimum lengths
    if len(message) < 24:
        return None  # Too short
    
    # Check for session tag (8 bytes)
    tag = message[0:8]
    
    # Try ES decryption first (most common)
    session = lookup_session_by_tag(tag)
    if session:
        return ('ES', session)
    
    # Try NSR decryption (tag + Elligator2 key)
    if len(message) >= 72:
        # Check if bytes 8-40 are valid Elligator2
        try:
            nsr_ephemeral = DECODE_ELG2(message[8:40])
            nsr_session = find_pending_nsr_by_tag(tag)
            if nsr_session:
                return ('NSR', nsr_session)
        except:
            pass
    
    # Try NS decryption (starts with Elligator2 key)
    if len(message) >= 96:
        try:
            ns_ephemeral = DECODE_ELG2(message[0:32])
            ns_session = InboundSession.try_decrypt_ns(message)
            if ns_session:
                return ('NS', ns_session)
        except:
            pass
    
    # Check ElGamal/AES (for dual-key compatibility)
    if len(message) >= 514:
        if (len(message) - 2) % 16 == 0:
            # Might be ElGamal NS
            return ('ELGAMAL_NS', None)
        elif len(message) % 16 == 0:
            # Might be ElGamal ES
            return ('ELGAMAL_ES', None)
    
    return None  # Unknown message type
```
### Лучшие практики управления сессиями

**Хранилище сеанса:**

```python
class SessionKeyManager:
    def __init__(self):
        # Outbound sessions (one per destination)
        self.outbound_sessions = {}  # destination -> OutboundSession
        
        # Inbound sessions (multiple per destination during transition)
        self.inbound_sessions = []  # [InboundSession]
        
        # Session tag lookup (fast path for ES messages)
        self.tag_to_session = {}  # tag -> InboundSession
        
        # Limits
        self.max_inbound_sessions = 1000
        self.max_tags_per_session = 160
    
    def get_outbound_session(self, destination):
        """Get or create outbound session"""
        if destination not in self.outbound_sessions:
            session = OutboundSession(destination)
            self.outbound_sessions[destination] = session
        return self.outbound_sessions[destination]
    
    def add_inbound_session(self, session):
        """Add new inbound session"""
        # Check limits
        if len(self.inbound_sessions) >= self.max_inbound_sessions:
            self.expire_oldest_session()
        
        self.inbound_sessions.append(session)
        
        # Add tags to lookup table
        self.register_session_tags(session)
    
    def register_session_tags(self, session):
        """Register session's tags in lookup table"""
        for tag in session.inbound_tagset.get_all_tags():
            self.tag_to_session[tag] = session
    
    def lookup_tag(self, tag):
        """Fast tag lookup"""
        return self.tag_to_session.get(tag)
    
    def expire_sessions(self):
        """Periodic session expiration"""
        now_time = now()
        
        # Expire outbound sessions
        for dest, session in list(self.outbound_sessions.items()):
            if session.idle_time(now_time) > 8 * 60:
                del self.outbound_sessions[dest]
        
        # Expire inbound sessions
        expired = []
        for session in self.inbound_sessions:
            if session.idle_time(now_time) > 10 * 60:
                expired.append(session)
        
        for session in expired:
            self.remove_inbound_session(session)
    
    def remove_inbound_session(self, session):
        """Remove inbound session and clean up tags"""
        self.inbound_sessions.remove(session)
        
        # Remove tags from lookup
        for tag in session.inbound_tagset.get_all_tags():
            if tag in self.tag_to_session:
                del self.tag_to_session[tag]
```
**Управление памятью:**

```python
class TagMemoryManager:
    def __init__(self, max_memory_kb=10240):  # 10 MB default
        self.max_memory = max_memory_kb * 1024
        self.current_memory = 0
        self.max_tags_per_session = 160
        self.min_tags_per_session = 32
    
    def calculate_tag_memory(self, session):
        """Calculate memory used by session tags"""
        tag_count = len(session.inbound_tagset.tags)
        # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional)
        # + overhead
        bytes_per_tag = 16 if session.defer_keys else 48
        return tag_count * bytes_per_tag
    
    def check_pressure(self):
        """Check if under memory pressure"""
        return self.current_memory > (self.max_memory * 0.9)
    
    def handle_pressure(self):
        """Reduce memory usage when under pressure"""
        if not self.check_pressure():
            return
        
        # Strategy 1: Reduce look-ahead windows
        for session in all_sessions:
            if session.look_ahead > self.min_tags_per_session:
                session.reduce_look_ahead(self.min_tags_per_session)
        
        # Strategy 2: Trim old tags aggressively
        for session in all_sessions:
            session.inbound_tagset.trim_behind(aggressive=True)
        
        # Strategy 3: Refuse new ratchets
        for session in all_sessions:
            if session.outbound_tagset.should_ratchet():
                session.defer_ratchet = True
        
        # Strategy 4: Expire idle sessions early
        expire_idle_sessions(threshold=5*60)  # 5 min instead of 10
```
### Стратегии тестирования

**Модульные тесты:**

```python
def test_x25519_dh():
    """Test X25519 key exchange"""
    alice_sk = GENERATE_PRIVATE()
    alice_pk = DERIVE_PUBLIC(alice_sk)
    
    bob_sk = GENERATE_PRIVATE()
    bob_pk = DERIVE_PUBLIC(bob_sk)
    
    # Both sides compute same shared secret
    alice_shared = DH(alice_sk, bob_pk)
    bob_shared = DH(bob_sk, alice_pk)
    
    assert alice_shared == bob_shared

def test_elligator2_encode_decode():
    """Test Elligator2 roundtrip"""
    sk = GENERATE_PRIVATE_ELG2()
    pk = DERIVE_PUBLIC(sk)
    
    encoded = ENCODE_ELG2(pk)
    decoded = DECODE_ELG2(encoded)
    
    assert decoded == pk

def test_chacha_poly_encrypt_decrypt():
    """Test ChaCha20-Poly1305 AEAD"""
    key = CSRNG(32)
    nonce = construct_nonce(42)
    plaintext = b"Hello, I2P!"
    ad = b"associated_data"
    
    ciphertext = ENCRYPT(key, nonce, plaintext, ad)
    decrypted = DECRYPT(key, nonce, ciphertext, ad)
    
    assert decrypted == plaintext

def test_session_tag_ratchet():
    """Test session tag generation"""
    sessTag_ck = CSRNG(32)
    tagset = SessionTagRatchet(sessTag_ck)
    
    # Generate 100 tags
    tags = [tagset.get_next_tag() for _ in range(100)]
    
    # All tags should be unique
    assert len(set(tags)) == 100
    
    # Each tag should be 8 bytes
    for tag in tags:
        assert len(tag) == 8
```
**Интеграционные тесты:**

```python
def test_ns_nsr_handshake():
    """Test NS/NSR handshake"""
    # Alice creates outbound session
    alice_session = OutboundSession(bob_destination, bound=True)
    
    # Alice sends NS
    ns_message = alice_session.build_ns_message(b"Hello Bob")
    
    # Bob receives NS
    bob_session = InboundSession.try_decrypt_ns(ns_message)
    assert bob_session is not None
    assert bob_session.bound == True
    
    # Bob sends NSR
    nsr_message = bob_session.build_nsr_message(b"Hello Alice")
    
    # Alice receives NSR
    alice_session.on_nsr_received(nsr_message)
    assert alice_session.state == SessionState.ESTABLISHED
    
    # Both should have matching ES tagsets
    # (Cannot directly compare, but can test by sending ES messages)

def test_es_bidirectional():
    """Test ES messages in both directions"""
    # (After NS/NSR handshake)
    
    # Alice sends ES to Bob
    es_alice_to_bob = alice_session.send_es_message(b"Data from Alice")
    
    # Bob receives ES
    bob_session.process_es_message(es_alice_to_bob)
    
    # Bob sends ES to Alice
    es_bob_to_alice = bob_session.send_es_message(b"Data from Bob")
    
    # Alice receives ES
    alice_session.process_es_message(es_bob_to_alice)

def test_dh_ratchet():
    """Test DH ratchet"""
    # (After established session)
    
    # Alice initiates ratchet
    alice_session.initiate_ratchet()
    nextkey_alice = build_nextkey_block(
        flags=0x01,
        key_id=0,
        public_key=alice_new_key
    )
    
    # Send to Bob
    bob_session.process_nextkey_block(nextkey_alice)
    
    # Bob replies
    nextkey_bob = build_nextkey_block(
        flags=0x03,
        key_id=0,
        public_key=bob_new_key
    )
    
    # Send to Alice
    alice_session.process_nextkey_block(nextkey_bob)
    
    # Both should now be using new tagsets
    assert alice_session.outbound_tagset.id == 1
    assert bob_session.inbound_tagset.id == 1
```
**Тестовые векторы:**

Реализовать тестовые векторы из спецификации:

1. **Рукопожатие Noise IK**: Используйте стандартные тестовые векторы Noise
2. **HKDF**: Используйте тестовые векторы из RFC 5869
3. **ChaCha20-Poly1305**: Используйте тестовые векторы из RFC 7539
4. **Elligator2**: Используйте тестовые векторы из статьи по Elligator2 или из OBFS4

**Тестирование на совместимость:**

1. **Java I2P**: Протестируйте на совместимость с эталонной реализацией Java I2P
2. **i2pd**: Протестируйте на совместимость с реализацией i2pd на C++
3. **Захваты пакетов**: Используйте диссектор Wireshark (если доступен) для проверки форматов сообщений
4. **Межреализационное тестирование**: Создайте тестовый стенд, который может отправлять/принимать данные между реализациями

### Соображения по производительности

**Генерация ключей:**

Генерация ключей Elligator2 (криптографическая схема маскировки ключей) вычислительно затратна (50% уровень отбраковки):

```python
class KeyPool:
    """Pre-generate keys in background thread"""
    def __init__(self, pool_size=10):
        self.pool = Queue(maxsize=pool_size)
        self.generator_thread = Thread(target=self.generate_keys, daemon=True)
        self.generator_thread.start()
    
    def generate_keys(self):
        while True:
            if not self.pool.full():
                keypair = generate_elg2_keypair()
                # Also compute encoded form
                encoded = ENCODE_ELG2(keypair.public_key)
                self.pool.put((keypair, encoded))
            else:
                sleep(0.1)
    
    def get_keypair(self):
        try:
            return self.pool.get(timeout=1.0)
        except Empty:
            # Pool exhausted, generate inline
            return generate_elg2_keypair()
```
**Поиск тегов:**

Используйте хеш-таблицы для поиска тегов за O(1):

```python
class FastTagLookup:
    def __init__(self):
        self.tag_to_session = {}  # Python dict is hash table
    
    def add_tag(self, tag, session, index):
        # 8-byte tag as bytes is hashable
        self.tag_to_session[tag] = (session, index)
    
    def lookup_tag(self, tag):
        return self.tag_to_session.get(tag)
```
**Оптимизация памяти:**

Отложенная генерация симметричного ключа:

```python
class DeferredKeyRatchet:
    """Only generate keys when needed"""
    def __init__(self, symmKey_ck):
        self.chainKey = symmKey_ck
        self.index = -1
        self.cache = LRUCache(maxsize=32)  # Cache recent keys
    
    def get_key(self, index):
        # Check cache first
        if index in self.cache:
            return self.cache[index]
        
        # Generate keys up to index
        while self.index < index:
            self.index += 1
            keydata = HKDF(self.chainKey, ZEROLEN, "SymmetricRatchet", 64)
            self.chainKey = keydata[0:31]
            
            if self.index == index:
                key = keydata[32:63]
                self.cache[index] = key
                return key
```
**Пакетная обработка:**

Обрабатывайте несколько сообщений пакетно:

```python
def process_message_batch(messages):
    """Process multiple messages efficiently"""
    results = []
    
    # Group by type
    ns_messages = []
    nsr_messages = []
    es_messages = []
    
    for msg in messages:
        msg_type = classify_message(msg)
        if msg_type[0] == 'NS':
            ns_messages.append(msg)
        elif msg_type[0] == 'NSR':
            nsr_messages.append(msg)
        elif msg_type[0] == 'ES':
            es_messages.append(msg)
    
    # Process in batches
    # ES messages are most common, process first
    for msg in es_messages:
        results.append(process_es_message(msg))
    
    for msg in nsr_messages:
        results.append(process_nsr_message(msg))
    
    for msg in ns_messages:
        results.append(process_ns_message(msg))
    
    return results
```
---

## Соображения безопасности

### Модель угроз

**Возможности противника:**

1. **Пассивный наблюдатель**: Может наблюдать весь сетевой трафик
2. **Активный атакующий**: Может внедрять, изменять, отбрасывать, повторно воспроизводить сообщения
3. **Скомпрометированный узел**: Может скомпрометировать router или назначение
4. **Анализ трафика**: Может выполнять статистический анализ шаблонов трафика

**Цели безопасности:**

1. **Конфиденциальность**: Содержимое сообщений скрыто от наблюдателя
2. **Аутентификация**: Личность отправителя подтверждена (для привязанных сеансов)
3. **Прямая секретность**: Прошлые сообщения остаются секретными, даже если ключи скомпрометированы
4. **Защита от повторов**: Нельзя повторно передать старые сообщения
5. **Маскировка трафика**: Рукопожатия неотличимы от случайных данных

### Криптографические предположения

**Предположения о сложности:**

1. **X25519 CDH**: Вычислительная задача Диффи — Хеллмана трудна на Curve25519
2. **ChaCha20 PRF**: ChaCha20 является псевдослучайной функцией
3. **Poly1305 MAC**: Poly1305 обеспечивает неподделываемость при атаке с выбранным сообщением
4. **SHA-256 CR**: SHA-256 обладает стойкостью к коллизиям
5. **HKDF Security**: HKDF извлекает и расширяет, обеспечивая равномерно распределённые ключи

**Уровни безопасности:**

- **X25519**: стойкость ~128 бит (порядок кривой 2^252)
- **ChaCha20**: ключи 256 бит, стойкость 256 бит
- **Poly1305**: стойкость 128 бит (вероятность коллизии)
- **SHA-256**: стойкость к коллизиям 128 бит, стойкость к поиску прообраза 256 бит

### Управление ключами

**Генерация ключей:**

```python
# CRITICAL: Use cryptographically secure RNG
def CSRNG(length):
    # GOOD: os.urandom, secrets.token_bytes (Python)
    # GOOD: /dev/urandom (Linux)
    # GOOD: BCryptGenRandom (Windows)
    # BAD: random.random(), Math.random() (NOT cryptographically secure)
    return os.urandom(length)

# CRITICAL: Validate keys
def validate_x25519_key(pubkey):
    # Check for weak keys (all zeros, small order points)
    if pubkey == bytes(32):
        raise WeakKeyError("All-zero public key")
    
    # Perform DH to check for weak shared secrets
    test_shared = DH(test_private_key, pubkey)
    if test_shared == bytes(32):
        raise WeakKeyError("Results in zero shared secret")
```
**Хранилище ключей:**

```python
# CRITICAL: Protect private keys
class SecureKeyStorage:
    def __init__(self):
        # Store in memory with protection
        self.keys = {}
        
        # Option 1: Memory locking (prevent swapping to disk)
        # mlock(self.keys)
        
        # Option 2: Encrypted storage
        # self.encryption_key = derive_from_password()
    
    def store_key(self, key_id, private_key):
        # Option: Encrypt before storage
        # encrypted = encrypt(private_key, self.encryption_key)
        # self.keys[key_id] = encrypted
        self.keys[key_id] = private_key
    
    def delete_key(self, key_id):
        # Securely wipe memory
        if key_id in self.keys:
            key = self.keys[key_id]
            # Overwrite with zeros before deletion
            for i in range(len(key)):
                key[i] = 0
            del self.keys[key_id]
```
**Ротация ключей:**

```python
# CRITICAL: Rotate keys regularly
class KeyRotationPolicy:
    def __init__(self):
        self.max_messages_per_tagset = 4096  # Ratchet before 65535
        self.max_tagset_age = 10 * 60       # 10 minutes
        self.max_session_age = 60 * 60      # 1 hour
    
    def should_ratchet(self, tagset):
        return (tagset.messages_sent >= self.max_messages_per_tagset or
                tagset.age() >= self.max_tagset_age)
    
    def should_replace_session(self, session):
        return session.age() >= self.max_session_age
```
### Меры по противодействию атакам

### Меры против атак повторного воспроизведения

**Валидация даты и времени:**

```python
MAX_CLOCK_SKEW_PAST = 5 * 60
MAX_CLOCK_SKEW_FUTURE = 2 * 60

def validate_datetime(timestamp):
    now = int(time.time())
    age = now - timestamp
    
    if age < -MAX_CLOCK_SKEW_FUTURE:
        raise ReplayError("Timestamp too far in future")
    
    if age > MAX_CLOCK_SKEW_PAST:
        raise ReplayError("Timestamp too old")
    
    return True
```
**Фильтр Блума для сообщений NS:**

```python
class ReplayFilter:
    def __init__(self, capacity=100000, error_rate=0.001, duration=5*60):
        self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate)
        self.duration = duration
        self.entries = []  # (timestamp, ephemeral_key)
    
    def check_replay(self, ephemeral_key, timestamp):
        # Validate timestamp
        if not validate_datetime(timestamp):
            return False
        
        # Check Bloom filter
        if ephemeral_key in self.bloom:
            # Potential replay (or false positive)
            # Check exact match in entries
            for ts, key in self.entries:
                if key == ephemeral_key:
                    return False  # Definite replay
        
        # Add to filter
        self.bloom.add(ephemeral_key)
        self.entries.append((timestamp, ephemeral_key))
        
        # Expire old entries
        self.expire_old_entries()
        
        return True
    
    def expire_old_entries(self):
        now = int(time.time())
        self.entries = [(ts, key) for ts, key in self.entries
                       if now - ts < self.duration]
```
**Одноразовое использование сеансового тега:**

```python
def process_session_tag(tag):
    # Look up tag
    entry = tagset.lookup_tag(tag)
    if entry is None:
        raise ValueError("Invalid session tag")
    
    # CRITICAL: Remove tag immediately (one-time use)
    tagset.remove_tag(tag)
    
    # Use associated key
    return entry.key, entry.index
```
### Меры по снижению риска подмены личности при компрометации ключа (KCI)

**Проблема**: аутентификация сообщений NS уязвима к атаке KCI (имперсонация при компрометации ключа) (Уровень аутентификации 1)

**Меры по смягчению**:

1. Перейдите на NSR (уровень аутентификации 2) как можно скорее
2. Не доверяйте полезной нагрузке NS при выполнении операций, критичных для безопасности
3. Дождитесь подтверждения NSR перед выполнением необратимых действий

```python
def process_ns_message(ns_message):
    # NS authenticated at Level 1 (KCI vulnerable)
    # Do NOT perform security-critical operations yet
    
    # Extract sender's static key
    sender_key = ns_message.static_key
    
    # Mark session as pending Level 2 authentication
    session.auth_level = 1
    session.sender_key = sender_key
    
    # Send NSR
    send_nsr_reply(session)

def process_first_es_message(es_message):
    # Now we have Level 2 authentication (KCI resistant)
    session.auth_level = 2
    
    # Safe to perform security-critical operations
    process_security_critical_operation(es_message)
```
### Меры противодействия атакам отказа в обслуживании

**Защита от флуда NS:**

```python
class NSFloodProtection:
    def __init__(self):
        self.ns_count = defaultdict(int)  # source -> count
        self.ns_timestamps = defaultdict(list)  # source -> [timestamps]
        
        self.max_ns_per_source = 5
        self.rate_window = 10  # seconds
        self.max_concurrent_ns = 100
    
    def check_ns_allowed(self, source):
        # Global limit
        total_pending = sum(self.ns_count.values())
        if total_pending >= self.max_concurrent_ns:
            return False
        
        # Per-source rate limit
        now = time.time()
        timestamps = self.ns_timestamps[source]
        
        # Remove old timestamps
        timestamps = [ts for ts in timestamps if now - ts < self.rate_window]
        self.ns_timestamps[source] = timestamps
        
        # Check rate
        if len(timestamps) >= self.max_ns_per_source:
            return False
        
        # Allow NS
        timestamps.append(now)
        self.ns_count[source] += 1
        return True
    
    def on_session_established(self, source):
        # Decrease pending count
        if self.ns_count[source] > 0:
            self.ns_count[source] -= 1
```
**Ограничения на хранение тегов:**

```python
class TagStorageLimit:
    def __init__(self, max_tags=1000000):
        self.max_tags = max_tags
        self.current_tags = 0
    
    def can_create_session(self, look_ahead):
        if self.current_tags + look_ahead > self.max_tags:
            return False
        return True
    
    def add_tags(self, count):
        self.current_tags += count
    
    def remove_tags(self, count):
        self.current_tags -= count
```
**Адаптивное управление ресурсами:**

```python
class AdaptiveResourceManager:
    def __init__(self):
        self.load_level = 0  # 0 = low, 1 = medium, 2 = high, 3 = critical
    
    def adjust_parameters(self):
        if self.load_level == 0:
            # Normal operation
            return {
                'max_look_ahead': 160,
                'max_sessions': 1000,
                'session_timeout': 10 * 60
            }
        
        elif self.load_level == 1:
            # Moderate load
            return {
                'max_look_ahead': 80,
                'max_sessions': 800,
                'session_timeout': 8 * 60
            }
        
        elif self.load_level == 2:
            # High load
            return {
                'max_look_ahead': 32,
                'max_sessions': 500,
                'session_timeout': 5 * 60
            }
        
        else:  # load_level == 3
            # Critical load
            return {
                'max_look_ahead': 16,
                'max_sessions': 200,
                'session_timeout': 3 * 60
            }
```
### Устойчивость к анализу трафика

**Кодирование Elligator2:**

Гарантирует, что сообщения рукопожатия неотличимы от случайных:

```python
# NS and NSR start with Elligator2-encoded ephemeral keys
# Observer cannot distinguish from random 32-byte string
```
**Стратегии заполнения:**

```python
# Resist message size fingerprinting
def add_padding(payload, strategy='random'):
    if strategy == 'random':
        # Random padding 0-15 bytes
        size = random.randint(0, 15)
    
    elif strategy == 'round':
        # Round to next 64-byte boundary
        target = ((len(payload) + 63) // 64) * 64
        size = target - len(payload) - 3  # -3 for block header
    
    elif strategy == 'fixed':
        # Always 1KB messages
        size = 1024 - len(payload) - 3
    
    return build_padding_block(size)
```
**Атаки по времени:**

```python
# CRITICAL: Use constant-time operations
def constant_time_compare(a, b):
    """Constant-time byte string comparison"""
    if len(a) != len(b):
        return False
    
    result = 0
    for x, y in zip(a, b):
        result |= x ^ y
    
    return result == 0

# CRITICAL: Constant-time MAC verification
def verify_mac(computed_mac, received_mac):
    if not constant_time_compare(computed_mac, received_mac):
        # Always take same time regardless of where comparison fails
        raise AuthenticationError("MAC verification failed")
```
### Подводные камни реализации

**Распространенные ошибки:**

1. **Повторное использование nonce (одноразового значения)**: НИКОГДА не используйте повторно пары (key, nonce)
   ```python
   # BAD: Reusing nonce with same key
   ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1)
   ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2)  # CATASTROPHIC

# ПРАВИЛЬНО: Уникальный одноразовый номер для каждого сообщения    ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1)    ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2)

   ```

2. **Ephemeral Key Reuse**: Generate fresh ephemeral key for each NS/NSR
   ```python
# ПЛОХО: Повторное использование эфемерного ключа    ephemeral_key = generate_elg2_keypair()    send_ns_message(ephemeral_key)    send_ns_message(ephemeral_key)  # ПЛОХО

# ХОРОШО: Новый ключ для каждого сообщения    send_ns_message(generate_elg2_keypair())    send_ns_message(generate_elg2_keypair())

   ```

3. **Weak RNG**: Use cryptographically secure random number generator
   ```python
# ПЛОХО: Некриптографический генератор случайных чисел    import random    key = bytes([random.randint(0, 255) for _ in range(32)])  # НЕБЕЗОПАСНО

# ХОРОШО: Криптографически стойкий RNG (генератор случайных чисел)    import os    key = os.urandom(32)

   ```

4. **Timing Attacks**: Use constant-time comparisons
   ```python
# ПЛОХО: сравнение с ранним выходом    if computed_mac == received_mac:  # утечка по времени

       pass
   
# ПРАВИЛЬНО: Сравнение за константное время    if constant_time_compare(computed_mac, received_mac):

       pass
   ```

5. **Incomplete MAC Verification**: Always verify before using data
   ```python
# ПЛОХО: Расшифровка до проверки    plaintext = chacha20_decrypt(key, nonce, ciphertext)    mac_ok = verify_mac(mac, plaintext)  # СЛИШКОМ ПОЗДНО    if not mac_ok:

       return error
   
# ХОРОШО: AEAD проверяет перед расшифрованием    try:

       plaintext = DECRYPT(key, nonce, ciphertext, ad)  # Verifies MAC first
except AuthenticationError:

       return error
   ```

6. **Key Deletion**: Securely wipe keys from memory
   ```python
# ПЛОХО: Простое удаление    del private_key  # Все еще в памяти

# ПРАВИЛЬНО: Перезаписывайте перед удалением    for i in range(len(private_key)):

       private_key[i] = 0
del private_key

   ```

### Security Audits

**Recommended Audits:**

1. **Cryptographic Review**: Expert review of KDF chains and DH operations
2. **Implementation Audit**: Code review for timing attacks, key management, RNG usage
3. **Protocol Analysis**: Formal verification of handshake security properties
4. **Side-Channel Analysis**: Timing, power, and cache attacks
5. **Fuzzing**: Random input testing for parser robustness

**Test Cases:**

```python
# Критически важные для безопасности тест-кейсы

def test_nonce_uniqueness():

    """Ensure nonces are never reused"""
    nonces = set()
    for i in range(10000):
        nonce = construct_nonce(i)
        assert nonce not in nonces
        nonces.add(nonce)

def test_key_isolation():

    """Ensure sessions don't share keys"""
    session1 = create_session(destination1)
    session2 = create_session(destination2)
    
    assert session1.key != session2.key

def test_replay_prevention():

    """Ensure replay attacks are detected"""
    ns_message = create_ns_message()
    
    # First delivery succeeds
    assert process_ns_message(ns_message) == True
    
    # Replay fails
    assert process_ns_message(ns_message) == False

def test_mac_verification():

    """Ensure MAC verification is enforced"""
    key = CSRNG(32)
    nonce = construct_nonce(0)
    plaintext = b"test"
    ad = b"test_ad"
    
    ciphertext = ENCRYPT(key, nonce, plaintext, ad)
    
    # Correct MAC verifies
    assert DECRYPT(key, nonce, ciphertext, ad) == plaintext
    
    # Corrupted MAC fails
    corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF])
    with pytest.raises(AuthenticationError):
        DECRYPT(key, nonce, corrupted, ad)
```

---

## Configuration and Deployment

### I2CP Configuration

**Enable ECIES Encryption:**

```properties
# Только ECIES (схема интегрированного шифрования на эллиптических кривых) (рекомендуется для новых развертываний)

i2cp.leaseSetEncType=4

# Двухключевая (ECIES (схема шифрования на эллиптических кривых) + ElGamal (криптосистема Эль-Гамаля) для совместимости)

i2cp.leaseSetEncType=4,0

# Только ElGamal (устаревший, не рекомендуется)

i2cp.leaseSetEncType=0

```

**LeaseSet Type:**

```properties
# Стандартный LS2 (leaseSet версии 2; наиболее распространённый)

i2cp.leaseSetType=3

# Зашифрованный LS2 (blinded destinations — скрытые назначения)

i2cp.leaseSetType=5

# Мета LS2 (несколько назначений)

i2cp.leaseSetType=7

```

**Additional Options:**

```properties
# Статический ключ для ECIES (необязательно, автоматически создаётся, если не указано)

# 32-байтный открытый ключ X25519, закодированный в Base64

i2cp.leaseSetPrivateKey=<base64-encoded-key>

# Тип подписи (для LeaseSet)

i2cp.leaseSetSigningPrivateKey=<base64-encoded-key> i2cp.leaseSetSigningType=7  # Ed25519

```

### Java I2P Configuration

**router.config:**

```properties
# ECIES между router-ами

i2p.router.useECIES=true

```

**Build Properties:**

```java
// Для клиентов I2CP (Java) Properties props = new Properties(); props.setProperty("i2cp.leaseSetEncType", "4"); props.setProperty("i2cp.leaseSetType", "3");

I2PSession session = i2pClient.createSession(props);

```

### i2pd Configuration

**i2pd.conf:**

```ini
[ограничения]

# Лимит памяти для сессий ECIES (схема интегрированного шифрования на эллиптических кривых)

ecies.memory = 128M

[ecies]

# Включить ECIES (интегрированная схема шифрования на эллиптических кривых)

enabled = true

# Только ECIES (схема шифрования на эллиптических кривых) или dual-key (двухключевой режим)

compatibility = true  # true = dual-key (двухключевой режим), false = ECIES-only (только ECIES)

```

**Tunnels Configuration:**

```ini
[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat

# Только ECIES (интегрированная схема шифрования на эллиптических кривых)

ecies = true

```

### Compatibility Matrix

**Router Version Support:**

<table style="width:100%; border-collapse:collapse; margin-bottom:1.5rem;">
  <thead>
    <tr>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Version</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:center;">ECIES Support</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:center;">LS2 Support</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:center;">Dual-Key</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">&lt; 0.9.38</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">❌ No</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">❌ No</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">N/A</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Legacy only</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">0.9.38-0.9.45</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">❌ No</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">✅ Yes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">N/A</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">LS2 only</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">0.9.46-0.9.50</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">✅ Yes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">✅ Yes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">✅ Yes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Initial ECIES</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">1.5.0+</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">✅ Yes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">✅ Yes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">✅ Yes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Current</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">2.0.0+</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">✅ Yes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">✅ Yes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem; text-align:center;">✅ Yes</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Current</td>
    </tr>
  </tbody>
</table>

**Destination Compatibility:**

<table style="width:100%; border-collapse:collapse; margin-bottom:1.5rem;">
  <thead>
    <tr>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Destination Type</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Can Connect To</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">ECIES-only</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">ECIES-only, Dual-key</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Requires 0.9.46+ routers</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Dual-key</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Any</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Maximum compatibility</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">ElGamal-only</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">ElGamal-only, Dual-key</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Legacy</td>
    </tr>
  </tbody>
</table>

**FloodFill Requirements:**

- **ECIES-only destinations**: Require majority of floodfills on 0.9.46+ for encrypted lookups
- **Dual-key destinations**: Work with any floodfill version
- **Current status**: Near 100% floodfill adoption as of 2025

### Migration Guide

**Migrating from ElGamal to ECIES:**

**Step 1: Enable Dual-Key Mode**

```properties
# Добавить ECIES, сохранив ElGamal

i2cp.leaseSetEncType=4,0

```

**Step 2: Monitor Connections**

```bash
# Проверьте типы соединений

i2prouter.exe status

# или

http://127.0.0.1:7657/peers

```

**Step 3: Switch to ECIES-Only (after testing)**

```properties
# Удалить ElGamal (криптографический алгоритм Эль‑Гамаля)

i2cp.leaseSetEncType=4

```

**Step 4: Restart Application**

```bash
# Перезапустите I2P router или приложение

systemctl restart i2p

# или

i2prouter.exe restart

```

**Rollback Plan:**

```properties
# Вернитесь к режиму только ElGamal при возникновении проблем

i2cp.leaseSetEncType=0

```

### Performance Tuning

**Session Limits:**

```properties
# Максимальное число входящих сеансов

i2p.router.maxInboundSessions=1000

# Максимальное количество исходящих сеансов

i2p.router.maxOutboundSessions=1000

# Тайм-аут сеанса (секунды)

i2p.router.sessionTimeout=600

```

**Memory Limits:**

```properties
# Лимит хранения тегов (КБ)

i2p.ecies.maxTagMemory=10240  # 10 МБ

# Окно упреждающего просмотра

i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32

```

**Ratchet Policy:**

```properties
# Сообщения до начала ratchet (криптографического механизма «трещотка»)

i2p.ecies.ratchetThreshold=4096

# Время до срабатывания ratchet (криптографический механизм обновления ключей) (секунды)

i2p.ecies.ratchetTimeout=600  # 10 минут

```

### Monitoring and Debugging

**Logging:**

```properties
# Включить отладочное логирование для ECIES (интегрированная схема шифрования на эллиптических кривых)

logger.i2p.router.transport.ecies=DEBUG

```

**Metrics:**

Monitor these metrics:

1. **NS Success Rate**: Percentage of NS messages receiving NSR
2. **Session Establishment Time**: Time from NS to first ES
3. **Tag Storage Usage**: Current memory usage for tags
4. **Ratchet Frequency**: How often sessions ratchet
5. **Session Lifetime**: Average session duration

**Common Issues:**

1. **NS Timeout**: No NSR received
   - Check destination is online
   - Check floodfill availability
   - Verify LeaseSet published correctly

2. **High Memory Usage**: Too many tags stored
   - Reduce look-ahead window
   - Decrease session timeout
   - Implement aggressive expiration

3. **Frequent Ratchets**: Sessions ratcheting too often
   - Increase ratchet threshold
   - Check for retransmissions

4. **Session Failures**: ES messages failing to decrypt
   - Verify tag synchronization
   - Check for replay attacks
   - Validate nonce construction

---

## References

### Specifications

1. **ECIES Proposal**: [Proposal 144](/proposals/144-ecies-x25519-aead-ratchet/)
2. **I2NP**: [I2NP Specification](/docs/specs/i2np/)
3. **Common Structures**: [Common Structures Specification](/docs/specs/common-structures/)
4. **NTCP2**: [NTCP2 Specification](/docs/specs/ntcp2/)
5. **SSU2**: [SSU2 Specification](/docs/specs/ssu2/)
6. **I2CP**: [I2CP Specification](/docs/specs/i2cp/)
7. **ElGamal/AES+SessionTags**: [ElGamal/AES Specification](/docs/legacy/elgamal-aes/)

### Cryptographic Standards

1. **Noise Protocol Framework**: [Noise Specification](https://noiseprotocol.org/noise.html) (Revision 34, 2018-07-11)
2. **Signal Double Ratchet**: [Signal Specification](https://signal.org/docs/specifications/doubleratchet/)
3. **RFC 7748**: [Elliptic Curves for Security (X25519)](https://tools.ietf.org/html/rfc7748)
4. **RFC 7539**: [ChaCha20 and Poly1305 for IETF Protocols](https://tools.ietf.org/html/rfc7539)
5. **RFC 5869**: [HKDF (HMAC-based Key Derivation Function)](https://tools.ietf.org/html/rfc5869)
6. **RFC 2104**: [HMAC: Keyed-Hashing for Message Authentication](https://tools.ietf.org/html/rfc2104)
7. **Elligator2**: [Elligator Paper](https://elligator.cr.yp.to/elligator-20130828.pdf)

### Implementation Resources

1. **Java I2P**: [i2p.i2p Repository](https://github.com/i2p/i2p.i2p)
2. **i2pd (C++)**: [i2pd Repository](https://github.com/PurpleI2P/i2pd)
3. **OBFS4 (Elligator2)**: [obfs4proxy Repository](https://gitlab.com/yawning/obfs4)

### Additional Information

1. **I2P Website**: [/](/)
2. **I2P Forum**: [https://i2pforum.net](https://i2pforum.net)
3. **I2P Wiki**: [https://wiki.i2p-projekt.de](https://wiki.i2p-projekt.de)

---

## Appendix A: KDF Summary

**All KDF Operations in ECIES:**

<table style="width:100%; border-collapse:collapse; margin-bottom:1.5rem;">
  <thead>
    <tr>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Operation</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Input</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Info String</th>
      <th style="border:1px solid var(--color-border); padding:0.5rem; background:var(--color-bg-secondary); text-align:left;">Output</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">NS Initial ChainKey</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">protocol_name</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">(none - SHA256)</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">h, chainKey</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">NS Static Key Section</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey, es_shared</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">""</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey, k</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">NS Payload Section (bound)</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey, ss_shared</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">""</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey, k</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">NSR Tagset</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">"SessionReplyTags"</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">tagsetKey</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">NSR ee DH</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey, ee_shared</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">""</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">NSR se DH</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey, se_shared</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">""</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey, k</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">NSR Split</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">""</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">k_ab, k_ba</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">NSR Payload</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">k_ba</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">"AttachPayloadKDF"</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">k_nsr</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">DH Initialize</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">rootKey, k</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">"KDFDHRatchetStep"</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">nextRootKey, chainKey</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Tag and Key Chain Keys</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">"TagAndKeyGenKeys"</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">sessTag_ck, symmKey_ck</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Session Tag Init</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">sessTag_ck</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">"STInitialization"</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey, CONSTANT</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Session Tag Gen</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey, CONSTANT</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">"SessionTagKeyGen"</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey, tag</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">Symmetric Key Gen</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">"SymmetricRatchet"</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">chainKey, key</td>
    </tr>
    <tr>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">DH Ratchet</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">sharedSecret</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">"XDHRatchetTagSet"</td>
      <td style="border:1px solid var(--color-border); padding:0.5rem;">tagsetKey</td>
    </tr>
  </tbody>
</table>

---

## Appendix B: Message Size Calculator

**Calculate message sizes for capacity planning:**

```python
def calculate_ns_size(payload_size, bound=True):

    """Calculate New Session message size"""
    ephemeral_key = 32
    static_section = 32 + 16  # encrypted + MAC
    payload_encrypted = payload_size + 16  # + MAC
    
    return ephemeral_key + static_section + payload_encrypted

def calculate_nsr_size(payload_size):

    """Calculate New Session Reply message size"""
    tag = 8
    ephemeral_key = 32
    key_section_mac = 16
    payload_encrypted = payload_size + 16  # + MAC
    
    return tag + ephemeral_key + key_section_mac + payload_encrypted

def calculate_es_size(payload_size):

    """Calculate Existing Session message size"""
    tag = 8
    payload_encrypted = payload_size + 16  # + MAC
    
    return tag + payload_encrypted

# Примеры

print("NS (с привязкой, полезная нагрузка 1 КБ):", calculate_ns_size(1024, bound=True), "байт")

# Вывод: 1120 байт

print("NSR (1 КБ полезной нагрузки):", calculate_nsr_size(1024), "байт")

# Вывод: 1096 байт

print("ES (полезная нагрузка 1 КБ):", calculate_es_size(1024), "байт")

# Вывод: 1048 байт

```

---

## Appendix C: Glossary

**AEAD**: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity

**Authentication Level**: Noise protocol security property indicating strength of sender identity verification

**Binding**: Association of a session with a specific far-end destination

**ChaCha20**: Stream cipher designed by Daniel J. Bernstein

**ChainKey**: Cryptographic key used in HKDF chains to derive subsequent keys

**Confidentiality Level**: Noise protocol security property indicating strength of forward secrecy

**DH**: Diffie-Hellman key agreement protocol

**Elligator2**: Encoding technique to make elliptic curve points indistinguishable from random

**Ephemeral Key**: Short-lived key used only for a single handshake

**ES**: Existing Session message (used after handshake completion)

**Forward Secrecy**: Property ensuring past communications remain secure if keys are compromised

**Garlic Clove**: I2NP message container for end-to-end delivery

**HKDF**: HMAC-based Key Derivation Function

**IK Pattern**: Noise handshake pattern where initiator sends static key immediately

**KCI**: Key Compromise Impersonation attack

**KDF**: Key Derivation Function - cryptographic function for generating keys from other keys

**LeaseSet**: I2P structure containing a destination's public keys and tunnel information

**LS2**: LeaseSet version 2 with encryption type support

**MAC**: Message Authentication Code - cryptographic checksum proving authenticity

**MixHash**: Noise protocol function for maintaining running hash transcript

**NS**: New Session message (initiates new session)

**NSR**: New Session Reply message (response to NS)

**Nonce**: Number used once - ensures unique encryption even with same key

**Pairing**: Linking an inbound session with an outbound session for bidirectional communication

**Poly1305**: Message authentication code designed by Daniel J. Bernstein

**Ratchet**: Cryptographic mechanism for deriving sequential keys

**Session Tag**: 8-byte one-time identifier for existing session messages

**Static Key**: Long-term key associated with a destination's identity

**Tag Set**: Collection of session tags derived from a common root

**X25519**: Elliptic curve Diffie-Hellman key agreement using Curve25519

---