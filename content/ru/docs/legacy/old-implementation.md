---
title: "Старая реализация Tunnel (устаревшая)"
description: "Архивное описание архитектуры tunnel, использовавшейся до версии I2P 0.6.1.10."
slug: "old-implementation"
lastUpdated: "2005-06"
accurateFor: "0.6.1"
reviewStatus: "needs-review"
---

> **Статус «устаревшее»:** Этот материал сохранён исключительно для исторической справки. Он описывает tunnel-систему, поставлявшуюся до I2P&nbsp;0.6.1.10, и не должен использоваться для современной разработки. Для рекомендаций по промышленной эксплуатации обратитесь к [текущей реализации](/docs/specs/implementation/).

Исходная подсистема tunnel также использовала однонаправленные tunnels, но отличалась структурой сообщений, механизмом обнаружения дубликатов и стратегией построения. Многие разделы ниже отражают структуру устаревшего документа для облегчения сравнения.

## 1. Обзор Tunnel

- Tunnels строились как упорядоченные последовательности пиров, выбранных создателем.
- Длины tunnels находились в диапазоне 0–7 hops (переходов), при этом было несколько настроек для заполнения, ограничения скорости и генерации chaff (мусорного трафика).
- Входящие tunnels доставляли сообщения от недоверенного шлюза к создателю (конечной точке); исходящие tunnels пересылали данные от создателя наружу.
- Срок жизни tunnels составлял 10 минут, после чего строились новые tunnels (часто с использованием тех же пиров, но с другими tunnel IDs).

## 2. Функционирование в устаревшей архитектуре

### 2.1 Предварительная обработка сообщений

Шлюзы накопили ≤32&nbsp;KB полезной нагрузки I2NP, выбрали заполнение и сформировали полезную нагрузку, содержащую:

- Двухбайтовое поле длины заполнения и соответствующее число случайных байтов
- Последовательность пар `{instructions, I2NP message}`, описывающих цели доставки, фрагментацию и необязательные задержки
- Полные сообщения I2NP, дополненные до границы в 16 байт

Инструкции доставки упаковывали маршрутную информацию в битовые поля (тип доставки, флаги задержки, флаги фрагментации и необязательные расширения). Фрагментированные сообщения содержали 4-байтовый идентификатор сообщения плюс флаг индекса/последнего фрагмента.

### 2.2 Шифрование на шлюзе

В устаревшем дизайне длина tunnel на этапе шифрования была фиксирована — восемь переходов. Шлюзы накладывали слоями блоки AES-256/CBC и блоки контрольной суммы, чтобы каждый переход мог проверять целостность, не уменьшая полезную нагрузку. Сама контрольная сумма представляла собой блок, полученный на основе SHA-256, встроенный в сообщение.

### 2.3 Поведение участников

Узлы отслеживали идентификаторы входящих tunnel, проверяли целостность на раннем этапе и отбрасывали дубликаты перед пересылкой. Поскольку padding (заполнение) и проверочные блоки были встроены, размер сообщения оставался постоянным независимо от числа хопов.

### 2.4 Обработка конечной точки

Конечные точки последовательно расшифровали многослойные блоки, проверили контрольные суммы и разделили полезную нагрузку обратно на закодированные инструкции и сообщения I2NP для последующей доставки.

## 3. Построение Tunnel (устаревший процесс)

1. **Выбор пиров:** Пиры выбирались из локально ведённых профилей (exploratory — исследовательские, client — клиентские). В исходном документе уже подчёркивалось снижение риска [атаки предшественника](https://en.wikipedia.org/wiki/Predecessor_attack) путём повторного использования упорядоченных списков пиров для каждого пула tunnel.
2. **Доставка запросов:** Сообщения построения передавались от хопа к хопу, с зашифрованными секциями для каждого пира. Альтернативные идеи, такие как телескопическое расширение, перемаршрутизация на середине пути или удаление блоков контрольной суммы, обсуждались как эксперименты, но так и не были приняты.
3. **Пулы:** У каждой локальной Destination (адрес назначения) были отдельные входящие и исходящие пулы. Настройки включали желаемое количество, резервные tunnels, разброс длины, ограничение скорости и политики пэддинга.

## 4. Концепции ограничения скорости и смешивания

Старый документ предложил несколько стратегий, которые повлияли на последующие релизы:

- Взвешенное случайное раннее отбрасывание (WRED) для контроля перегрузок
- Дросселирование для каждого tunnel на основе скользящих средних недавнего использования
- Необязательные настройки chaff (фиктивного трафика) и пакетирования (реализовано не полностью)

## 5. Архивные альтернативы

Разделы исходного документа рассматривали идеи, которые так и не были внедрены:

- Удаление блоков контрольных сумм для сокращения обработки на каждом хопе
- Телескопирование tunnels по ходу для изменения состава пиров
- Переход на двунаправленные tunnels (в итоге отклонено)
- Использование более коротких хэшей или иных схем дополнения

Эти идеи остаются ценным историческим контекстом, но не отражают актуальную кодовую базу.

## Ссылки

- Оригинальный архив устаревших документов (до версии 0.6.1.10)
- [Обзор Tunnel](/docs/overview/tunnel-routing/) по актуальной терминологии
- [Профилирование и выбор пиров](/docs/overview/tunnel-routing#peer-selection/) по современным эвристикам
