---
title: "NTCP 2"
number: "111"
author: "EinMByte, orignal, psi, str4d, zzz"
created: "2014-02-13"
lastupdated: "2019-08-13"
status: "Closed"
thread: "http://zzz.i2p/topics/1577"
supercedes: "106"
target: "0.9.36"
implementedin: "0.9.36"
editor: "manas, str4d, zzz"
---

## Poznámka
Fáze návrhu je uzavřená.
Viz [SPEC](/en/docs/spec/ntcp2/) pro oficiální specifikaci.
Tento návrh může být stále odkazován pro základní informace.


## Přehled

Tento návrh popisuje autentizovaný protokol pro dohodu o klíči za účelem zlepšení
odolnosti [NTCP](/en/docs/transport/ntcp/) vůči různým formám automatické identifikace a útokům.

Návrh je organizován následovně: jsou prezentovány bezpečnostní cíle,
následuje diskuze o základním protokolu. Dále je uvedena kompletní specifikace
všech protokolových zpráv. Nakonec jsou diskutovány routerové adresy a identifikace verzí. Je také zahrnuta příloha pojednávající o generickém útoku na běžné schémata doplňování, stejně jako příloha obsahující několik kandidátů pro autentizované šifrování.

Stejně jako u jiných transportů I2P, NTCP2 je definováno výhradně
pro point-to-point (router-to-router) přenos zpráv I2NP.
Není to univerzální datový kanál.


## Motivace

Data [NTCP](/en/docs/transport/ntcp/) jsou šifrována po první zprávě (a první zpráva
vypadá jako náhodná data), čímž je znemožněna identifikace protokolu prostřednictvím
„analýzy payloadu“. Je stále zranitelný proti identifikaci protokolu prostřednictvím
„analýzy toku“. To proto, že první 4 zprávy (tj. handshake) mají
fixní délku (288, 304, 448 a 48 bytů).

Přidáním náhodného množství náhodných dat do každé z těchto zpráv můžeme výrazně ztížit identifikaci.

Autoři uznávají, že standardní bezpečnostní praktiky by navrhovaly použití existujícího protokolu jako TLS, ale toto je [Prop104](/en/proposals/104/) a má vlastní problémy. Kde je to vhodné, byly přidány odstavce „budoucí práce“, aby naznačily chybějící funkce nebo předměty diskuse.


## Cíle Designu

- Podporovat NTCP 1 a 2 na jednom portu, automaticky rozpoznat a publikovat jako jeden
  „transport“ (tj. [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) v [NetDB](/en/docs/how/network-database/).

- Publikovat podporu pouze pro verzi 1, pouze pro verzi 2, nebo 1+2 v NetDB v samostatném
  poli a výchozí nastavit na verzi 1 pouze (nevážat podporu verzí na konkrétní verzi routeru)

- Zajistit, aby všechny implementace (Java/i2pd/Kovri/go) mohly přidat podporu verze 2
  (nebo ne) podle svého vlastního harmonogramu

- Přidat náhodné doplňování do všech zpráv NTCP včetně handshake a datových zpráv
  (tj. obfuscace délky, aby všechny zprávy nebyly násobkem 16 bytů)
  Poskytnout mechanismus voleb, aby obě strany mohly požadovat minimální a maximální doplňování
  a/nebo rozložení doplňování. Specifika rozložení doplňování jsou
  závislá na implementaci a nemusí být specifikována v samotném protokolu.

- Obfuscovat obsah zpráv, které nejsou šifrovány (1 a 2),
  dostatečně, aby DPI boxy a AV podpisy nemohly snadno klasifikovat je.
  Také zajistit, aby zprávy směřující k jednomu peeru nebo sadě peerů neměly
  podobný vzor bitů.

- Opravit ztrátu bitů v DH kvůli Java formátu [Ticket1112](https://trac.i2p2.i2p/ticket/1112), možná (pravděpodobně?)
  přepnutím na X25519.

- Přepnout na skutečnou funkci odvozování klíče (KDF) místo používání výsledku DH
  jak je?

- Přidat „odolnost vůči sondování“ (jak to nazývá Tor); to zahrnuje odolnost vůči replay útokům.

- Udržet dvoustrannou autentizovanou výměnu klíčů (2W-AKE). 1W-AKE není pro naši aplikaci dostatečná.

- Pokračovat v použití podpisů s proměnlivým typem a délkou (z
  zveřejněného [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) podepisovacího klíče) jako součást autentizace.
  Spoléhat se na statický veřejný klíč zveřejněný v RouterInfo jako jinou část
  autentizace.

- Přidat volby/verzi v handshake pro budoucí rozšiřitelnost.

- Přidat odolnost vůči zlovolnému TCP segmentování MiTM, pokud je to možné.

- Nepřidávat výrazně k požadavkům na CPU pro nastavení spojení; pokud je to možné,
  výrazně je snížit.

- Přidat autentizaci zpráv (MAC), možná HMAC-SHA256 a Poly1305, a
  odstranit checksum Adler.

- Zkrátit a zjednodušit hlavičku I2NP:
  Zkrátit expiraci na 4 bajty, jako v SSU.
  Odstranit jednobajtový zkrácený kontrolní součet SHA256.

- Pokud je to možné, zredukovat handshake skládající se ze 4 zpráv a dvou cest na
  handshake skládající se ze 3 zpráv a jedné cesty, jako v [SSU](/en/docs/transport/ssu/).
  To by vyžadovalo přesunutí Bobova podpisu z zprávy 4 do zprávy 2.
  Proškolte důvod pro 4 zprávy v desetiletých emailových/statusech/schůzkových archivech.

- Minimalizovat režii protokolu před doplňováním. Zatímco doplňování bude přidáno,
  a možná hodně z toho, režie před doplňováním je stále režie.
  Nízkopásmové uzly musí být schopny používat NTCP2.

- Zachovávat časová razítka pro detekci replay útoků a odchylky.

- Vyhnout se jakýmkoli problémům roku 2038 v časových razítkách, musí fungovat alespoň do roku 2106.

- Zvýšit maximální velikost zprávy z 16K na 32K nebo 64K.

- Jakékoli nové kryptografické primitivy by měly být snadno dostupné v knihovnách pro použití v Java
  (1.7), C++ a Go router implementacích.

- Zahrnout zástupce vývojářů routerů Java, C++ a Go do designu.

- Minimalizovat změny (ale stále jich bude hodně).

- Podporovat obě verze v společné sadě kódu (to nemusí být možné a
  je to závislé na implementaci v každém případě).


### Necíle

- Neprůstřelná odolnost vůči DPI... to by byly pluggable transporty,
  [Prop109](/en/proposals/109/).

- Transport na bázi TLS (nebo podobný HTTPS)... to by byl [Prop104](/en/proposals/104/).

- Je v pořádku změnit symetrickou streamovou kryptografii.

- Odolnost vůči DPI založená na načasování (mezi zprávami mohou být
  implementačně závislé načasování/zpoždění; mezizprávní zpoždění mohou být zavedeny kdykoli,
  včetně před odesláním náhodného doplňování, například). Umělé
  zpoždění (co obfs4 nazývá IAT nebo inter-arrival čas) jsou nezávislá na
  protokolu samotném.

- Možnost popřít účast na sezení (je tam podpisy).

Necíle, které mohou být částečně přehodnoceny nebo diskutovány:

- Stupeň ochrany proti Deep Packet Inspection (DPI)

- Post-kvantová (PQ) bezpečnost

- Možnost popřít účast



### Související cíle

- Implementovat Test Setup pro NTCP 1/2


## Bezpečnostní cíle

Zvažujeme tři strany:

- Alice, která si přeje navázat nové sezení.
- Bob, se kterým Alice chce navázat sezení.
- Mallory, „muž uprostřed“ mezi Alice a Bobem.

Maximálně dva účastníci se mohou podílet na aktivních útocích.

Alice a Bob mají oba v držení statický klíčový pár, který je obsažen
ve jejich [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/).

Navrhovaný protokol se snaží umožnit Alice a Bobovi dohodnout se na sdíleném
tajemství (K) za následujících podmínek:

1) Ochrana soukromého klíče: ani Bob, ani Mallory se nedozví nic o Aliceho
   soukromém statickém klíči. Symetricky, Alice se nic nedozví o Bobově
   soukromém statickém klíči.

2) Klíč K je znám pouze Alice a Bobovi.

3) Dokonalé dopředné utajení: dohoda o klíči zůstává tajemstvím i v budoucnu,
   i když statické soukromé klíče Alice a/nebo Boba jsou odhalené
   po dohodnutí klíče.

4) Dvoustranná autentizace: Alice má jistotu, že navázala sezení
   s Bobem, a naopak.

5) Ochrana proti online DPI: Postarat se o to, že není triviální detekovat, že
   Alice a Bob jsou zapojení do protokolu pomocí pouze jednoduchých technik
   pro Deep Packet Inspection (DPI). Viz níže.

6) Omezená deniabilita: ani Alice, ani Bob nemohou popřít účast v
   protokolu, ale pokud jeden z nich vyzradí sdílený klíč, druhá strana
   může popřít autentičnost obsahu přenesených dat.

Tento návrh se snaží poskytnout všech pět požadavků založených na
protokolu Station-To-Station (STS) [STS]_. Všimněte si, že tento protokol
je také základem pro protokol [SSU](/en/docs/transport/ssu/).


### Další diskuze o DPI

Předpokládáme dvě složky DPI:

1) Online DPI
`````````````

Online DPI kontrolující všechny toky v reálném čase. Připojení může být blokováno
nebo jinak poškozeno. Data připojení nebo metadata mohou být identifikována a
uložena pro offline analýzu.
Online DPI nemá přístup k databázi sítě I2P.
Online DPI má pouze omezené schopnosti reálného času, včetně výpočtu délky,
inspekce polí a jednoduchých výpočtů jako XOR.
Online DPI má schopnost rychlých kryptografických funkcí v reálném čase
jako AES, AEAD a hashování, ale tyto by byly příliš nákladné, aby byly aplikovány
na většinu nebo všechny toky. Jakákoli aplikace těchto kryptografických
operací by se aplikovala pouze na toky na IP/port kombinace
dříve identifikované offline analýzou.
Online DPI nemá schopnost vysoce nákladných kryptografických funkcí
jako DH nebo elligator2.
Online DPI není navrženo specificky pro detekci I2P, i když může mít
omezená pravidla klasifikace k tomuto účelu.

Cílem je zabránit identifikaci protokolu online DPI.

Pojem online nebo "jednoduchý" DPI je zde považován za
tohoto protivníka se schopnostmi:

1) Schopnost kontrolovat všechna data, která cílový subjekt odesílá nebo přijímá.

2) Schopnost provádět operace na pozorovaných datech, jako je
   aplikace blokových šifer nebo hashovacích funkcí.

3) Schopnost uchovávat a porovnávat s již odeslanými zprávami.

4) Schopnost modifikovat, zpožďovat nebo fragmentovat pakety.

Nicméně, předpokládá se, že online DPI má následující omezení:

5) Neschopnost mapovat IP adresy na hash info routeru. I když je to jednoduché
   s přístupem v reálném čase k databázi sítě,
   vyžadovalo by to systém DPI specificky navržený k cílení na I2P.

6) Neschopnost použít informace o načasování k detekci protokolu. 

7) Obecně řečeno, ve výbavě online DPI nejsou žádné vestavěné
   nástroje specificky navržené pro detekci I2P. To zahrnuje
   tvorbu "honeypotů", které by například zahrnovaly ve svých
   zprávách nenáhodné doplňování. Všimněte si, že to nevylučuje
   systémy strojového učení nebo vysoce konfigurovatelné DPI nástroje,
   pokud splňují ostatní požadavky.

Abychom proti analyzování payloadu, je zajištěno, že všechny zprávy jsou
nerozeznatelné od náhodných. To také vyžaduje, aby jejich délka byla
náhodná, což je složitější než jen přidání náhodného doplnění. Ve skutečnosti,
v příloze A, autoři argumentují, že naivní (tj. rovnoměrné) schéma doplnění
problém neřeší. Příloha A proto navrhuje zahrnout buď
náhodná zpoždění, nebo vyvinout alternativní schéma doplnění, které
může poskytnout rozumnou ochranu proti navrhovanému útoku.

Abychom ochránili proti šesté položce výše, implementace by měly zahrnovat
náhodná zpoždění v protokolu. Tyto techniky nejsou zakryté tímto návrhem,
ale mohly by také vyřešit problémy s délkou doplnění.
Stručně řečeno, návrh poskytuje dobrou ochranu proti analýze payloadu
(pokud jsou zohledněny úvahy v příloze A), ale pouze omezenou ochranu
proti analýze toku.


2) Offline DPI
``````````````

Offline DPI kontrolující data uložená online DPI pro pozdější analýzu.
Offline DPI může být navrženo specificky k detekci I2P.
Offline DPI má v reálném čase přístup k databázi sítě I2P.
Offline DPI má přístup k této a dalším specifikacím I2P.
Offline DPI má neomezenou výpočetní schopnost, včetně
všech kryptografických funkcí definovaných v této specifikaci.

Offline DPI nemá schopnost blokovat existující připojení. 
Offline DPI má schopnost provádět téměř v reálném čase (do minuty po
nastavení) vysílání na host/port stran, například TCP RST. 
Offline DPI má schopnost provádět téměř v reálném čase (do minuty po
nastavení) přehrávání předchozích zpráv (přizpůsobených nebo ne) pro "probing" nebo
jiné důvody.

Cílem není zabránit identifikaci protokolu offline DPI.
Veškeré dekódování obfuskovaných dat v prvních dvou zprávách, které
jsou implementovány v I2P routerech, mohou být také implementovány offline DPI.

Cílem je odmítnout pokus o připojení pomocí přehrání předchozích zpráv.


Budoucí práce
`````````````

- Zvážit chování protokolu, když pakety jsou ztracené nebo
  přeřazené útočníkem. Nedávné zajímavé práce v této oblasti lze najít v
  [IACR-1150](https://eprint.iacr.org/2015/1150).

- Poskytnout přesnější klasifikaci DPI systémů, s přihlédnutím k
  existující literatuře vztahující se k danému tématu.

- Diskutovat formální bezpečnost navrhovaného protokolu, ideálně s ohledem na
  model útoku DPI.


## Noise Protocol Framework

Tento návrh poskytuje požadavky založené na Noise Protocol Framework
[NOISE](http://noiseprotocol.org/) (Revize 33, 2017-10-04).
Noise má podobné vlastnosti jako protokol Station-To-Station
[STS]_, který je základem protokolu [SSU](/en/docs/transport/ssu/). V terminologii Noise je Alice
iniciátorem a Bob je respondentem.

NTCP2 je založen na Noise protokolu Noise_XK_25519_ChaChaPoly_SHA256.
(Skutečný identifikátor pro počáteční KDF
je "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256"
pro označení rozšíření I2P - viz sekce KDF 1 níže)
Tento Noise protokol používá následující primitivy:

- Handshake Pattern: XK
  Alice přenáší svůj klíč Bobovi (X)
  Alice už zná Bobův statický klíč (K)

- DH Funkce: X25519
  X25519 DH s délkou klíče 32 bytů, jak je specifikováno v [RFC-7748](https://tools.ietf.org/html/rfc7748).

- Cipher Funkce: ChaChaPoly
  AEAD_CHACHA20_POLY1305, jak je specifikováno v [RFC-7539](https://tools.ietf.org/html/rfc7539) sekce 2.8.
  12 bytu nonce, přičemž první 4 byty jsou vždy nula.

- Hash Funkce: SHA256
  Standardní 32bytový hash, již rozsáhle používán v I2P.


## Přídavky do Frameworku

Tento návrh definuje následující vylepšení
Noise_XK_25519_ChaChaPoly_SHA256. Ty obecně následují pokyny ve
[NOISE](http://noiseprotocol.org/) sekce 13.

1) Přechodné klíče v čitelném textu jsou obfuskovány šifrováním AES pomocí známého
   klíče a IV. To je rychlejší než elligator2.

2) Náhodné doplňování je přidáno ke zprávám 1 a 2.
   Časování náhodného doplňování je zahrnuto do výpočtu hashů handshake (MixHash).
   Viz sekce KDF pro zprávu 2 a zprávu 3 část 1.
   Náhodné AEAD doplňování je přidáno ke zprávě 3 a datovým fázovým zprávám.

3) Je přidáno dvoubytové pole délky rámce, které je vyžadováno pro Noise přes TCP,
   a jako v obfs4. Toto je použito pouze v datových fázových zprávách.
   Zpráva 1 a 2 AEAD rámce jsou fixní délky.
   Zpráva 3 část 1 AEAD rámec má pevně danou délku.
   Délka AEAD rámce části 2 zprávy 3 je specifikována ve zprávě 1.

4) Dvoubytové pole délky rámce je obfuskováno pomocí SipHash-2-4,
   jako v obfs4.

5) Formát payloadu je definován pro zprávy 1, 2, 3 a datovou fázi.
   Samozřejmě, to není definováno v Noise.


## Nové kryptografické primitivy pro I2P

Existující implementace I2P routerů budou vyžadovat implementace pro
následující standardní kryptografické primitivy,
které nejsou potřebné pro současné I2P protokoly:

1) X25519 generování klíčů a DH

2) AEAD_ChaCha20_Poly1305 (zkráceno jako ChaChaPoly níže)

3) SipHash-2-4


## Odhad režie zpracování

Velikosti zpráv pro tři zprávy:

1) 64 bytů + doplnění   (NTCP bylo 288 bytů)
2) 64 bytů + doplnění   (NTCP bylo 304 bytů)
3) cca 64 bytů + Alice router info + doplnění   Průměrná router info má asi 750
   bytů   Celkem průměrně 814 bytů před doplněním (NTCP bylo 448 bytů)
4) není vyžadována v NTCP2   (NTCP bylo 48 bytů)

Celkem před doplněním:
NTCP2: 942 bytů
NTCP: 1088 bytů
Všimněte si, že pokud se Alice připojila k Bobovi za účelem odeslání
DatabaseStore Message jejího RouterInfo, tato zpráva není vyžadována,
čímž se ušetří přibližně 800 bytů.

Následující kryptografické operace jsou vyžadovány každou stranou k dokončení
handshake a zahájení datové fáze:

- AES: 2
- SHA256: 7 (Alice), 6 (Bob) (nepočítaje 1 Alice, 2 Bob předběžně vypočtené pro
  všechny připojení) (nepočítaje HMAC-SHA256)
- HMAC-SHA256: 19
- ChaChaPoly: 4
- X25519 generování klíčů: 1
- X25519 DH: 3
- Verifikace podpisu: 1 (Bob) (Alice předtím podepsala při generování jejího
  RI)  Předpokládáme Ed25519 (závisí na typu podpisu RI)


Následující kryptografické operace jsou vyžadovány každou stranou pro každou datovou fázovou zprávu:

- SipHash: 1
- ChaChaPoly: 1



## Zprávy

Všechny zprávy NTCP2 jsou kratší než nebo rovny 65537 bytům. Formát zprávy
je založen na zprávách Noise, s úpravami pro rámcování a nerozeznatelnost.
Implementace používající standardní knihovny Noise mohou potřebovat předepracovat přijaté
zprávy tak, aby odpovídaly/neodpovídaly formátu zpráv Noise. Všechna šifrovaná pole jsou AEAD
ciphertexty.


Sekvence ustavení je následující:

Alice                           Bob

  SessionRequest ------------------->
  <------------------- SessionCreated
  SessionConfirmed ----------------->
Použitím terminologie Noise, sekvence ustavení a dat je následující:
(Flagy Security Properties)

XK(s, rs):           Authentication   Confidentiality
    <- s
    ...
    -> e, es                  0                2
    <- e, ee                  2                1
    -> s, se                  2                5
    <-                        2                5
Jakmile je sezení ustaveno, může Alice a Bob vyměňovat datové zprávy.

Všechny typy zpráv (SessionRequest, SessionCreated, SessionConfirmed, Data a
TimeSync) jsou specifikovány v této sekci.

Některé notace::

  - RH_A = Router Hash pro Alice (32 bytů)
  - RH_B = Router Hash pro Boba (32 bytů)


### Autentizované šifrování

Existují tři samostatné instance autentizovaného šifrování (CipherStates).
Jeden během handshake fáze, a dva (transmit a receive) pro datovou fázi.
Každý má svůj vlastní klíč z KDF.

Šifrovaná/autentizovaná data budou reprezentována jako 

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   Šifrovaná a autentizovaná data      |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
ChaCha20/Poly1305
`````````````````

Formát šifrovaných a autentizovaných dat.

Vstupy pro funkce šifrování/dešifrování:

k :: 32 bytový klíč pro šifrování, jak bylo vygenerováno z KDF

  nonce :: Nepřímoivý nonce, 12 bytů.
           Začíná na 0 a zvyšuje se pro každou zprávu.
           První čtyři byty jsou vždy nula.
           Posledních osm bytů je čítač, kódován jako malý endian.
           Maximální hodnota je 2**64 - 2.
           Připojení musí být zrušeno a znovu spuštěno po
           dosažení této hodnoty.
           Hodnota 2**64 - 1 nesmí být nikdy odeslána.

  ad :: Ve fázi handshake:
        Související data, 32 bajtů.
        SHA256 hash všech předchozích dat.
        Ve fázi dat:
        Nula bajtů

  data :: Prostá data, 0 nebo více bajtů

Výstup funkce šifrování, vstup funkce dešifrování:

+----+----+----+----+----+----+----+----+
  |Obfs délka |                            |
  +----+----+                             +
  |       Šifrovaná data ChaCha20         |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 kód pro autentizaci zprávy  |
  +              (MAC)                    +
  |             16 bytů                   |
  +----+----+----+----+----+----+----+----+

  Obfs délka :: Délka (šifrovaná data + MAC) k následování, 16 - 65535
              Obfuskování pomocí SipHash (viz níže)
              Nepoužívá se ve zprávě 1 nebo 2, nebo části 3 v části 1, kde je délka fixní
              Nepoužívá se ve zprávě 3 v části 1, protože délka je specifikována ve zprávě 1

  šifrovaná data :: Stejná velikost jako prostá data, 0 - 65519 bytů

  MAC :: Kód Poly1305 pro autentizaci zprávy, 16 bytů

Pro ChaCha20 to, co je zde popsáno, odpovídá [RFC-7539](https://tools.ietf.org/html/rfc7539), které je také
podobně použito v TLS [RFC-7905](https://tools.ietf.org/html/rfc7905).

Poznámky
`````
- Protože ChaCha20 je proudová šifra, prosté texty nemusí být doplněny.
  Další keystream byty jsou ignorovány.

- Klíč pro šifrování (256 bitů) je dohodnut prostřednictvím SHA256 KDF.
  Detaily KDF pro každou zprávu jsou v samostatných sekcích níže.

- ChaChaPoly rámce pro zprávu 1, 2 a první část zprávy 3,
  mají známou velikost. Počínaje druhou částí zprávy 3,
  rámce mají proměnlivou velikost. Velikost části 1 zprávy 3 je specifikována ve zprávě 1.
  Počínaje datovou fází jsou rámce předloženy dvoubytovou délkou
  obfuskovanou pomocí SipHash, jako v obfs4.

- Doplňování je mimo rámec autentizovaných dat ve zprávách 1 a 2.
  Doplňování se používá v KDF pro další zprávu, takže manipulace bude
  detekována. Počínaje zprávou 3 je doplňování uvnitř
  rámce autentizovaných dat.


AEAD Zpracování chyb
`````````````````````
- Ve zprávách 1, 2 a ve zprávách 3 v částech 1 a 2 je velikost AEAD zprávy známá předem.
  V případě selhání autentizace AEAD musí příjemce zastavit další zpracování zprávy a uzavřít
  spojení bez odpovědi. Mělo by se jednat o abnormální uzavření (TCP RST).

- Pro odolnost vůči sondování by měl Bob po selhání AEAD
  nastavit náhodný časovač (rozsah TBD) a poté přečíst náhodný počet bajtů (rozsah TBD)
  než uzavře socket. Bob by měl udržovat černou listinu IP adres s
  opakovanými neúspěchy.

- Ve fází dat je velikost AEAD zprávy „šifrována“ (obfuskována) pomocí SipHash.
  Je třeba dbát na to, aby se nevytvořil dešifrovací orákulum.
  V případě selhání autentizace AEAD v fázi dat by měl
  příjemce nastavit náhodný časový limit (rozsah TBD) a poté přečíst náhodný počet bajtů (rozsah TBD).
  Po čtení, nebo při vypršení časového limitu pro čtení, by měl příjemce odeslat payload
  s blokem ukončení obsahujícím kód důvodu „selhání AEAD“,
  a uzavřít spojení.

- Provést stejnou akci chyby pro neplatnou hodnotu pole délky ve fází dat.


### Funkce odvozování klíče (KDF) (pro handshake zprávu 1)

KDF generuje šifrovací klíč pro handshake fázi k z výsledku DH,
pomocí HMAC-SHA256(key, data) podle [RFC-2104](https://tools.ietf.org/html/rfc2104).
Jedná se o funkce InitializeSymmetric(), MixHash() a MixKey(),
přesně tak, jak jsou definovány ve specifikaci Noise.

Toto je „e“ vzor zprávy:

  // Definuj protokol_name.
  Nastavit protocol_name = "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256"
   (48 bytů, US-ASCII kódováno, bez ukončení NUL).

  // Definuj Hash h = 32 bajtů
  h = SHA256(protocol_name);

  Definuj ck = 32 bajtový řetězový klíč. Zkopírovat h data na ck.
  Nastavit ck = h

  Definuj rs = Bobův 32- bytový statický klíč, jak je zveřejněn v RouterInfo

  // MixHash(null prologue)
  h = SHA256(h);

  // až sem, může být vše předem vypočteno Alicí pro všechna odchozí připojení

  // Alice musí zde zkontrolovat, zda Bobův statický klíč je platným bodem na křivce.

  // Bob statický klíč
  // MixHash(rs)
  // || níže znamená připojit
  h = SHA256(h || rs);

  // až sem, může být vše předem vypočteno Bobem pro všechna příchozí připojení

  Toto je "e" vzor zprávy:

  Alice generuje svůj znovuoživitelný DH klíčový pár e.

  // Alice pomíjivý klíč X
  // MixHash(e.pubkey)
  // || níže znamená připojit
  h = SHA256(h || e.pubkey);

  // h je použito jako související data pro AEAD ve zprávě 1
  // Uložit Hash h pro KDF zprávy 2


  Konec "e" vzoru zprávy.

  Toto je „es“ vzor zprávy:

  // DH(e, rs) == DH(s, re)
  Definuj input_key_material = 32 bajtový DH výsledek Alisina pomíjivého klíče a Bobova statického klíče
  Nastavit input_key_material = X25519 DH výsledek

  // MixKey(DH())

  Definuj temp_key = 32 bajtů
  Definuj HMAC-SHA256(key, data) jak je v [RFC-2104](https://tools.ietf.org/html/rfc2104)
  // Generuj dočasný klíč z řetězového klíče a výsledku DH
  // ck je řetězový klíč, jak je definováno výše
  temp_key = HMAC-SHA256(ck, input_key_material)
  // přepsat výsledek DH v paměti, již není potřeba
  input_key_material = (všechny nuly)

  // Výstup 1
  // Nastavit nový řetězový klíč z dočasného klíče
  // byte() níže znamená jeden bajt
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // Výstup 2
  // Generuj šifrovací klíč k
  Definuj k = 32 bajtů
  // || níže znamená připojit
  // byte() níže znamená jeden bajt
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
  // přepsat temp_key v paměti, již není potřeba
  temp_key = (všechny nuly)

  // uložit řetězový klíč ck pro KDF zprávy 2


  Konec "es" vzoru zprávy.

### 1) SessionRequest

Alice posílá Bobovi.

Noise obsah: Alice pomíjivý klíč X
Noise payload: 16 bajtový blok voleb
Ne-noise payload: Náhodné doplňování

(Flagy Security Properties)

XK(s, rs):           Authentication   Confidentiality
    -> e, es                  0                2

    Autentizace: Žádné (0).
    Tento payload mohl být odeslán kteroukoliv stranou, včetně aktivního útočníka.

    Důvěrnost: 2.
    Šifrování ke známému příjemci, přední utajení pro kompromitaci odesílatele
    pouze, náchylné k replay útoku. Tento payload je šifrován pouze na základě
    DHs zahrnující statický klíčový pár příjemce. Pokud bude příjemcův statický
    soukromý klíč kompromitován, i kdyby později, tento payload lze dešifrovat.
    Tato zpráva může být také přehrána, protože neexistuje žádný přechodný
    příspěvek od příjemce.

    „e“: Alice generuje nový pomíjivý klíčový pár a uloží jej do proměnné e,
          zapíše pomíjivý veřejný klíč jako čitelný text do
          vyrovnávací paměti zprávy a hashuje veřejný klíč spolu se starou
          h pro derivaci nového h.

    „es“: DH je vykonán mezi pomíjivým klíčovým párem Alice a
          statickým klíčovým párem Bob. Výsledek je sežán spolu se starou
          ck pro derivaci nové ck a k, a n je nastaveno na nulu.


Hodnota X je šifrována k zajištění nerozeznatelnosti payloadu
a unikátnosti, což je nezbytné opatření proti DPI.
Používáme AES šifrování k dosažení tohoto,
místo složitějších a pomalejších alternativ jako elligator2.
Asymetrické šifrování na Bobův veřejný klíč routeru by bylo příliš pomalé.
AES šifrování používá RH_B jako klíč a Bobův IV, jak je zveřejněno
v databázi sítě.

AES šifrování je pouze pro odolnost vůči DPI.
Kterákoli strana zná Bobův router hash a IV, které jsou zveřejněny v databázi sítě,
může dešifrovat hodnotu X v této zprávě.

Doplňování není šifrováno Alicí.
Může být nezbytné, aby Bob dešifroval doplňování,
aby zabránil útokům načasováním.


Surový obsah:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        obfuskované s RH_B             +
  |       AES-CBC-256 šifrovaný X         |
  +             (32 bytů)                 +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaChaPoly rámec                    |
  +             (32 bytů)                 +
  |   k definované v KDF pro zprávu 1     |
  +   n = 0                               +
  |   viz KDF pro související data        |
  +----+----+----+----+----+----+----+----+
  |     nešifrované autentizováno         |
  ~         doplňování (volitelné)        ~
  |     délka definovaná v bloku voleb    |
  +----+----+----+----+----+----+----+----+

  X :: 32 bytů, AES-256-CBC šifrovaný X25519 pomíjivý klíč, malý endian
          klíč: RH_B
          iv: Jak je zveřejněno v Bobově vstupu databáze sítě

  doplňování :: Náhodná data, 0 nebo více bytů.
             Celková délka zprávy musí být 65535 bytů nebo méně.
             Celková délka zprávy musí být 287 bytů nebo méně, pokud
             Bob zveřejňuje svou adresu jako NTCP
             (viz sekce Detekce verze níže).
             Alice a Bob použijí data pro doplňování v KDF pro zprávu 2.
             Je autentizováno, takže jakákoli manipulace způsobí,
             že další zpráva selže.

Nešifrovaná data (Poly1305 autentizační značka není zobrazena):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                   X                   |
  +              (32 bytů)                +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               volby                   |
  +              (16 bytů)                +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     nešifrované autentizováno         |
  +         doplňování (volitelné)        +
  |     délka definovaná v bloku voleb    |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  X :: 32 bytů, X25519 pomíjivý klíč, malý endian

  volby :: Blok voleb, 16 bytů, viz níže

  doplňování :: Náhodná data, 0 nebo více bytů.
             Celková délka zprávy musí být 65535 bytů nebo méně.
             Celková délka zprávy musí být 287 bytů nebo méně, pokud
             Bob zveřejňuje svou adresu jako "NTCP"
             (viz sekce Detekce verze níže)
             Alice a Bob použijí data pro doplňování v KDF pro zprávu 2.
             Je autentizováno, takže jakákoli manipulace způsobí,
             že další zpráva selže.

Blok voleb:
Poznámka: Všechna pole jsou big-endian.

+----+----+----+----+----+----+----+----+
  | id | ver|  padLen | m3p2len | Rsvd(0) |
  +----+----+----+----+----+----+----+----+
  |        tsA        |   Reserved (0)    |
  +----+----+----+----+----+----+----+----+

  id :: 1 byte, ID sítě (momentálně 2, kromě testovacích sítí)
        K verzi 0.9.42. Viz návrh 147.

  ver :: 1 byte, verze protokolu (momentálně 2)

  padLen :: 2 bajty, délka doplňování, 0 nebo více
            Min/max pokyny TBD. Náhodná velikost od 0 do 31 bajtů minimum?
            (Distribuce k určení, viz příloha A.)

  m3p2Len :: 2 bajty, délka druhého AEAD rámce v SessionConfirmed
             (zpráva 3 část 2) Viz poznámky níže

  Rsvd :: 2 bajty, nastaveno na 0 pro kompatibilitu s budoucími volbami

  tsA :: 4 bajty, Unix časové razítko, nepodepsané sekundy.
         Přetáčí se v roce 2106

  Reserved :: 4 bajty, nastaveno na 0 pro kompatibilitu s budoucími volbami

Poznámky
`````
- Když se publikovaná adresa uvede jako "NTCP", Bob podporuje oba protokoly NTCP a NTCP2 na
  stejném portu. Pro kompatibilitu, když se Alice připojuje k adrese
  publikované jako "NTCP", musí omezit maximální velikost této zprávy,
  včetně doplňování, na 287 bajtů nebo méně. 
  To usnadňuje automatickou identifikaci protokolu pomocí Boba. 
  Když je publikováno jako "NTCP2", neexistuje žádné omezení velikosti. 
  Viz sekce Publikované adresy a Detekce verzí níže.

- Jedinečná hodnota X v počátečním AES bloku zajišťuje, že ciphertext
  je jedinečný pro každé sezení.

- Bob musí odmítnout připojení, kde hodnota časového razítka je příliš daleko
  od aktuálního času. Maximální dovolená doba rozdílu je „D“. 
  Bob musí udržovat lokální mezipaměť hodnot použitých v handshake a odmítnout duplikáty,
  aby zabránil opakovaným útokům. Hodnoty v mezipaměti musí mít životnost
  alespoň 2*D. Hodnoty mezipaměti jsou závislé na implementaci, avšak 32-bytová hodnota X 
  (nebo její šifrovaný ekvivalent) může být použita.

- Klíče Diffie-Hellman mohou být opětovně použity pouze jednou, aby se zabránilo kryptografickým útokům,
  a opětovné použití bude odmítnuto jako opakovaný útok.

- Možnosti "KE" a "auth" musí být kompatibilní, tj. sdílené tajemství K musí
  být odpovídající velikosti. Pokud budou přidány další možnosti "auth", toto by mohlo
  implicitně změnit význam vlajky "KE" pro použití jiného KDF nebo jiného
  zkracujícího rozdělení.

- Bob musí zde ověřit, zda Alice pomíjivý klíč je platným bodem na křivce.

- Doplňování by mělo být omezeno na rozumné množství. Bob může odmítnout připojení
  s nadměrným doplňováním. Bob specifikuje možnosti doplňování v zprávě 2.
  Ad min/max pokyny TBD. Náhodná velikost od 0 do 31 bajtů minimum?
  (Distribuce k určení, viz příloha A.)

- Při jakémkoliv selhání, včetně AEAD, DH, časového razítka, podezření na opakování, nebo
  selhání ověření klíče, Bob musí zastavit další zpracování zprávy a uzavřít
  spojení bez odpovědi. 
  Mělo by se jednat o abnormální uzavření (TCP RST).
  Pro odolnost vůči sondování, po selhání AEAD
  Bob by měl nastavit náhodný časovač (rozsah TBD) a poté přečíst náhodný počet bajtů (rozsah TBD),
  než uzavře socket.

- Zmírnění DoS: DH je relativně drahá operace. Jako u předchozího NTCP protokolu,
  routery by měly přijmout všechny nezbytné opatření, aby zabránily vyčerpání CPU nebo
  vyčerpání připojení. Nastavte limity na maximální aktivní připojení a maximální
  připojení ve fázi nastavení. Vynucujte časové limity čtení (jak na jednotlivé čtení, tak na celkové pro „slowloris“).
  Omezte opakovaná nebo současná připojení ze stejného zdroje.
  Udržujte černé listiny pro zdroje, které opakovaně selhávají.
  Neodpovídejte na selhání AEAD.

- Aby bylo usnadněno rychlé rozpoznání verze a handshake, implementace musí
  zajistit, že Alice shromažďuje a poté najednou vypouští celý obsah první
  zprávy, včetně doplňování. 
  To zvyšuje pravděpodobnost, že data budou obsažena v jednom TCP paketu (pokud nebudou 
  segmentována OS nebo middleboxy) a přijata Bobem najednou.
  Toto platí jak pro NTCP, tak NTCP2 handshake.

- Pole „ver“: Celkový protokol Noise, rozšíření, a NTCP protokol
  včetně specifikace payloadu, indikující NTCP2.
  Toto pole může být použito k indikaci podpory pro budoucí změny.

- Délka části 2 zprávy 3: Toto je velikost druhého AEAD rámce (včetně 16-bytového MAC)
  obsahující Alice router info a volitelné doplňování, které budou odeslány v
  zprávě SessionConfirmed. Jelikož routy periodicky regenerují a znovu zveřejňují
  své RouterInfo, velikost aktuálního RouterInfo se může změnit před
  odesláním zprávy 3. Implementace musí zvolit jednu z dvou strategií:
  a) uložit aktuální RouterInfo pro odeslání ve zprávě 3, aby byla známa velikost,
  a případně přidat prostor pro doplnění;
  b) zvýšit specifikovanou velikost tak, aby umožnila případné zvětšení
  RouterInfo velikosti, a vždy přidat doplnění, když je zpráva 3 ve skutečnosti odeslána.
  V obou případech musí specifikovaná délka „m3p2len“ ve zprávě 1 přesně odpovídat
  velikosti tohoto rámce, když je odeslána ve zprávě 3.

- Bob musí selhat připojení, pokud zůstane nějaká příchozí data po validaci
  zprávy 1 a čtení doplňování. Neměly by být žádná další data od Alice,
  protože Bob ještě neodpověděl zprávou 2.

- Pole ID sítě se používá k rychlému rozpoznání cross-network připojení.
  Pokud je toto pole nenulové a neodpovídá Bobově ID sítě,
  Bob by měl odpojit a zablokovat budoucí připojení.
  Od verze 0.9.42. Viz návrh 147 pro více informací.



### Funkce odvozování klíče (KDF) (pro handshake zprávu 2 a zprávu 3 část 1)

```
// vzít h uložený z KDF pro zprávu 1
// MixHash(ciphertext)
h = SHA256(h || 32 bajtový šifrovaný payload ze zprávy 1)

// MixHash(doplňování)
// Pouze pokud délka doplňování není nula
h = SHA256(h || náhodné doplňování ze zprávy 1)

Toto je „e“ vzor zprávy:

Bob generuje svůj pomíjivý DH klíčový pár e.

// h je z KDF pro handshake zprávu 1
// Bob pomíjivý klíč Y
// MixHash(e.pubkey)
// || níže znamená připojit
h = SHA256(h || e.pubkey);

// h je použit jako související data pro AEAD ve zprávě 2
// Uchovat Hash h pro KDF zprávy 3

Konec "e" vzoru zprávy.

Toto je „ee“ vzor zprávy:

// DH(e, re)
Definuj input_key_material = 32 bajtový DH výsledek pomíjivého klíče Alice a pomíjivého klíče Boba
Nastavit input_key_material = X25519 DH výsledek
// přepsat pohotovostní klíč Alice paměti, již není potřeba
// Alice:
e(veřejný a soukromý) = (vždy nuly)
// Bob:
re = (vždy nuly)

// MixKey(DH())

Definuj temp_key = 32 bajtů
Definuj HMAC-SHA256(key, data) jak je v [RFC-2104](https://tools.ietf.org/html/rfc2104)
// Generuj dočasný klíč z řetězového klíče a výsledku DH
// ck je řetězový klíč, z KDF pro handshake zprávu 1
temp_key = HMAC-SHA256(ck, input_key_material)
// přepsat výsledek DH v paměti, již není potřeba
input_key_material = (vždy nuly)

// Výstup 1
// Nastav nový řetězový klíč z dočasného klíče
// byte() níže znamená jeden bajt
ck =       HMAC-SHA256(temp_key, byte(0x01)).

// Výstup 2
// Generuj šifrovací klíč k
Definuj k = 32 bajtů
// || níže znamená připojit
// byte() níže znamená jeden bajt
k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
// přepsat temp_key v paměti, již není potřeba
temp_key = (vždy nuly)

// uložit řetězový klíč ck pro KDF zprávy 3

Konec "ee" vzoru zprávy.
```

### 2) SessionCreated

Bob posílá Alis

Noise obsah: Bobův pomíjivý klíč Y
Noise payload: 16 bajtový blok voleb
Nepoužitý payload: Náhodné doplňování

(Flagy Security Properties)

XK(s, rs):           Authentication   Confidentiality
    <- e, ee                  2                1

    Autentizace: 2.
    Autentizace odesílatele odolná proti key-compromise impersonation (KCI).
    Autentizace odesílatele je založena na pomíjivém-stavickém DH („es“ nebo „se“)
    mezi statickým klíčovým párem odesílatele a pomíjivým klíčovým párem příjemce.
    Za předpokladu, že odpovídající soukromé klíče jsou bezpečné, tuto autentizaci nelze padělat.

    Důvěrnost: 1.
    Šifrování k pomíjivému příjemci.
    Tento payload má přední utajení, protože šifrování zahrnuje pomíjivý-pomíjivý DH („ee“).
    Nicméně odesílatel neautentizoval příjemce,
    takže tento payload může být odeslán komukoli, včetně aktivního útočníka.


    „e“: Bob generuje nový pomíjivý klíčový pár a uloží jej do proměnné e,
    zapíše pomíjivý veřejný klíč jako prostý text do vyrovnávací paměti zprávy,
    a hashuje veřejný klíč spolu se starou h pro derivaci nového h.

    „ee“: Proveden DH mezi bobovým pomíjivým klíčovým párem a pomíjivým klíčovým párem Alice.
    Výsledek je sežán spolu se starou ck pro derivaci nové ck a k, a n je nastaveno na nulu.

Hodnota Y je šifrována k zajištění nerozeznatelnosti payloadu a unikátnosti,
které jsou nezbytnými opatřeními vůči DPI.
Používáme AES šifrování k dosažení tohoto,
místo složitějších a pomalejších alternativ jako elligator2.
Asymetrické šifrování na Alicin veřejný klíč routeru by bylo příliš pomalé.
AES šifrování používá Bobův hash routeru jako klíč a AES stav z zprávy 1
(který byl inicializován Bobovým IV, jak je zveřejněno v databázi sítě).

AES šifrování je pouze pro odolnost vůči DPI.
Každá strana, která zná Bobův hash routeru a IV, které jsou zveřejněny v 
databázi sítě, a zachytila prvních 32 bajtů zprávy 1, může dešifrovat 
hodnotu Y v této zprávě.


Surový obsah:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        obfuskováno s RH_B             +
  |       AES-CBC-256 šifrovaný Y         |
  +              (32 bajtů)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |   ChaChaPoly rámec                    |
  +   Šifrovaná a autentizovaná data      +
  |   32 bajty                            |
  +   k definovaná v KDF pro zprávu 2     +
  |   n = 0; viz KDF pro související data |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     nešifrované autentizováno         |
  +         doplňování (volitelné)        +
  |     délka definována v bloku voleb    |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 bajtů, AES-256-CBC šifrovaný X25519 pomíjivý klíč, malý endian
          klíč: RH_B
          iv: Použití AES stavu zprávy 1

Nešifrovaná data (Poly1305 autentizační značka není zobrazena):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                  Y                    |
  +              (32 bajtů)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               volby                   |
  +              (16 bajtů)               +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     nešifrované autentizováno         |
  +         doplňování (volitelné)        +
  |     délka definována v bloku voleb    |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 bajtů, X25519 pomíjivý klíč, malý endian

  volby :: Blok voleb, 16 bytů, viz níže

  doplňování :: Náhodná data, 0 nebo více bajtů.
             Celková délka zprávy musí být 65535 bajtů nebo méně.
             Alice a Bob použijí data pro doplňování v KDF pro zprávu 3 část 1.
             Je to autentizováno, takže jakákoli manipulace způsobí,
             že další zpráva selže.

Poznámky
`````

- Alice musí zde ověřit, že Bobův pomíjivý klíč je platným bodem na křivce.

- Doplňování by mělo být omezeno na rozumné množství.
  Alice může odmítnout připojení s nadměrným doplňováním.
  Alice specifikuje možnosti doplňování v zprávě 3.
  Návrhy pro min/max TBD. Náhodná velikost od 0 do 31 bajtů minimum?
  (Distribuce k určení, viz příloha A.)

- Při jakékoli chybě, včetně AEAD, DH, časového razítka, podezření na opakování nebo
  selhání ověření klíče, Alice musí zastavit další zpracování zprávy a uzavřít
  spojení bez odpovědi. Mělo by se jednat o abnormální uzavření (TCP RST).

- Aby bylo usnadněno rychlé handshaking, implementace musí zajistit, že Bob
  shromažďuje a pak najednou vypouští celý obsah první 
  zprávy najednou, včetně doplňování. 
  To zvyšuje pravděpodobnost, že data budou obsažena v jednom TCP paketu (pokud nebudou 
  segmentována OS nebo middleware) a přijata Alice. 
  To je také pro efektivitu a aby se zajistila účinnost náhodného doplňování.

- Alice musí připojení selhat, pokud zůstanou nějaká příchozí data po ověření
  zprávy 2 a čtení doplňování. Neměla by být žádná další data od Boba,
  protože Alice ještě neodpověděla zprávou 3.


Blok volby:
Poznámka: Všechna pole jsou big-endian.

+----+----+----+----+----+----+----+----+
  | Rsvd(0) | padLen  |   Reserved (0)    |
  +----+----+----+----+----+----+----+----+
  |        tsB        |   Reserved (0)    |
  +----+----+----+----+----+----+----+----+

  Reserved :: 10 bajtů celkem, nastaveno na 0 pro kompatibilitu s budoucími volbami

  padLen :: 2 bajty, big endian, délka doplňování, 0 nebo více
            Návrhy pro min/max TBD. Náhodná velikost od 0 do 31 bajtů minimum?
            (Distribuce k určení, viz příloha A.)

  tsB :: 4 bajty, big endian, Unix časové razítko, nepodepsané sekundy.
         Přetáčí se v roce 2106

Poznámky
`````
- Alice musí odmítnout připojení, kde hodnota časového razítka je příliš daleko
  od aktuálního času. Maximální dovolená doba rozdílu je „D“. 
  Alice musí udržovat lokální mezipaměť hodnot použitých v handshake a odmítnout duplikáty,
  aby zabránila opakovaným útokům. Hodnoty v mezipaměti musí mít životnost
  alespoň 2*D. Hodnoty mezipaměti jsou závislé na implementaci, ale 32-bytová hodnota Y
  (nebo její šifrovaný ekvivalent) mohou být použity.

Problémy
``````
- Zahrnout možnosti minima/ maxima doplňování zde?



### Šifrování pro handshake zprávu 3 část 1, pomocí KDF zprávy 2)

```
// vzít h uložený z KDF zprávy 2
// MixHash(ciphertext)
h = SHA256(h || 24 bajtový šifrovaný payload ze zprávy 2)

// MixHash(doplňování)
// Pouze pokud délka doplňování není nula
h = SHA256(h || náhodné doplňování ze zprávy 2)
// h je použit jako související data pro AEAD ve zprávě 3 část 1, níže

Toto je „s“ vzor zprávy:

Definuj s = Alicin statický veřejný klíč, 32 bytů

// ŠifrujAHash(s.publickey)
// ŠifrováníSA(souVisSeData, s.publickey)
// AEAD_ChaCha20_Poly1305(klíč, nonce, souvisejícíData, data)
// k je z handshake zprávy 1
// n je 1
ciphertext = AEAD_ChaCha20_Poly1305(k, n++, h, s.publickey)
// MixHash(ciphertext)
// || níže znamená připojit
h = SHA256(h || ciphertext);

// h je použit jako související data pro AEAD ve zprávě 3 část 2

Konec „s“ vzoru zprávy.
```

### Funkce odvozování klíče (KDF) (pro handshake zprávu 3 část 2)

Toto je „se“ vzor zprávy:

  // DH(s, re) == DH(e, rs)
  Definuj input_key_material = 32 bajtový DH výsledek Alisina statického klíče a Bobova pomíjivého klíče
  Nastavit input_key_material = X25519 DH výsledek
  // přepsat Bobov pohotovostní klíč v paměti, již není potřeba
  // Alice:
  re = (vždy nuly)
  // Bob:
  e(veřejný a soukromý) = (vždy nuly)

  // MixKey(DH())

  Definuj temp_key = 32 bajtů
  Definuj HMAC-SHA256(key, data) jak je v [RFC-2104](https://tools.ietf.org/html/rfc2104)
  // Generuj dočasný klíč z řetězového klíče a výsledku DH
  // ck je řetězový klíč, z KDF pro handshake zprávu 1
  temp_key = HMAC-SHA256(ck, input_key_material)
  // přepsat výsledek DH v paměti, již není potřeba
  input_key_material = (vždy nuly)

  // Výstup 1
  // Nastav nový řetězový klíč z dočasného klíče
  // byte() níže znamená jeden bajt
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // Výstup 2
  // Generuj šifrovací klíč k
  Definuj k = 32 bajtů
  // || níže znamená připojit
  // byte() níže znamená jeden bajt
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).

  // h z zprávy 3 část 1 je použit jako související data pro AEAD ve zprávě 3 část 2

  // ŠifrujAHash(payload)
  // ŠifrováníSA(h, payload)
  // AEAD_ChaCha20_Poly1305(klíč, nonce, souvisejícíData, data)
  // n je 0
  ciphertext = AEAD_ChaCha20_Poly1305(k, n++, h, payload)
  // MixHash(ciphertext)
  // || níže znamená připojit
  h = SHA256(h || ciphertext);

  // uchovat řetězový klíč ck pro generování KDF pro datovou fázi
  // uchovat hash h pro generování Dalšího symetrického klíče (SipHash) KDF

  Konec „se“ vzoru zprávy.

  // přepsat dočasný klíč v paměti, již není potřeba
  temp_key = (všechny nuly)

### 3) SessionConfirmed

Alice posílá Bobovi.

Noise obsah: Alice statický klíč
Noise payload: Aliceho RouterInfo a náhodné doplňování
Nepoužitý payload: žádný

(Flagy Security Properties)


XK(s, rs):           Authentication   Confidentiality
    -> s, se                  2                5

    Autentizace: 2.
    Autentizace odesílatele odolná proti key-compromise impersonation (KCI).
    Autentizace odesílatele je založena na pomíjivém-stavickém DH („es“ nebo „se“)
    mezi statickým klíčovým párem odesílatele a pomíjivým klíčovým párem příjemce.
    Za předpokladu, že odpovídající soukromé klíče jsou bezpečné, tuto autentizaci nelze padělat.

    Důvěrnost: 5.
    Šifrování ke známému příjemci, silné přední utajení.
    Tento payload je šifrován na základě pomíjivého-pomíjivého DH i
    pomíjivého-statikového DH se statickým klíčovým párem příjemce.
    Za předpokladu, že pomíjivé soukromé klíče jsou bezpečné a příjemce není aktivně
    napodobován útočníkem, který ukradl jeho statický soukromý klíč, tento payload
    nemůže být dešifrován.

    „s“: Alice píše svůj statický veřejný klíč z proměnné s do
    vyrovnávací paměti zprávy, šifruje ho, a hashuje výst
