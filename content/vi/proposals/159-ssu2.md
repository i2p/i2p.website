```yaml
---
title: "SSU2"
number: "159"
author: "eyedeekay, orignal, zlatinb, zzz"
created: "2021-09-12"
lastupdated: "2025-03-05"
status: "Closed"
thread: "http://zzz.i2p/topics/2612"
target: "0.9.56"
---

## Trạng thái

Kế hoạch triển khai:


| Tính năng | Đang thử nghiệm (không là mặc định) Kích hoạt mặc định |
|-----------|--------------------------------------------------------|
| Mã kiểm tra địa phương | 2022-02 |
| Mã kiểm tra chung | 2022-03 |
| Thử nghiệm chung trong mạng | 0.9.54 | 2022-05 |
| Đóng băng giao thức cơ bản | 0.9.54 | 2022-05 |
| Basic Session | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Xác nhận địa chỉ (Thử lại) | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Fragmenented RI trong bắt tay | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Token mới | 0.9.55 | 2022-08 | 0.9.57 | 2022-11 |
| Đóng băng giao thức mở rộng | 0.9.55 | 2022-08 |
| Relay | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Kiểm tra Peer | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Kích hoạt ngẫu nhiên cho 2% | 0.9.55 | 2022-08 |
| Xác thực đường dẫn | 0.9.55+ dev | 0.9.56 | 2022-11 |
| Di chuyển kết nối | 0.9.55+ dev | 0.9.56 | 2022-11 |
| Cờ ACk ngay lập tức | 0.9.55+ dev | 0.9.56 | 2022-11 |
| Xoay vòng khóa | 0.9.57 | 2023-02 | 0.9.58 | 2023-05 |
| Vô hiệu hóa SSU 1 (i2pd) | 0.9.56 | 2022-11 |
| Vô hiệu hóa SSU 1 (Java I2P) | 0.9.58 | 2023-05 | 0.9.61 | 2023-12 |

Phiên cơ bản bao gồm giai đoạn bắt tay và dữ liệu.
Giao thức mở rộng bao gồm chuyển tiếp và kiểm tra đồng đẳng.



## Tổng quan

Đề xuất này mô tả giao thức thỏa thuận khóa có xác thực để nâng cao khả năng
kháng cự của [SSU](/en/docs/transport/ssu/) đối với các hình thức nhận diện tự động và các cuộc tấn công.

Đề xuất được tổ chức như sau: các mục tiêu bảo mật được trình bày,
theo sau là thảo luận về giao thức cơ bản. Tiếp theo, một đặc tả hoàn chỉnh
của tất cả các thông điệp giao thức được đưa ra. Cuối cùng, các địa chỉ bộ định tuyến và nhận diện phiên bản được thảo luận.

Giống như các phương tiện I2P khác, SSU2 được định nghĩa cho việc truyền tải điểm-điểm (từ bộ định tuyến tới bộ định tuyến) của các thông điệp I2NP.
Nó không phải là một ống dẫn dữ liệu đa mục đích.
Giống như [SSU](/en/docs/transport/ssu/), nó cũng cung cấp hai dịch vụ bổ sung:
Chuyển tiếp để vượt qua NAT, và Kiểm tra đồng đẳng để xác định khả năng tiếp cận vào.
Nó cũng cung cấp dịch vụ thứ ba, không có trong SSU, để di chuyển kết nối
khi một đồng đẳng thay đổi IP hoặc cổng.

## Động lực

SSU là lớp giao thức duy nhất còn lại yêu cầu ElGamal, điều này rất chậm.
Kiểm soát luồng cho SSU phức tạp và không hoạt động tốt.
Các phần của SSU dễ bị tấn công giả mạo địa chỉ.
Giao thức bắt tay không sử dụng Noise.

## Mục tiêu thiết kế

- Giảm sử dụng CPU bằng cách loại bỏ ElGamal. Sử dụng X25519 cho DH.

- Duy trì các chức năng Kiểm tra đồng đẳng và Chuyển tiếp, và tăng cường bảo mật cho chúng.

- Làm cho việc triển khai dễ dàng hơn bằng cách cho phép các thuật toán kiểm soát luồng tiêu chuẩn.

- Giảm độ trễ thiết lập.
  Thời gian thiết lập trung bình hiện tại là khoảng 135 ms cho NTCP2 và 187 ms cho SSU,
  mặc dù NTCP2 có thêm một lần quay lại; thay thế ElGamal trong
  SSU2 nên giúp giảm nó, nhưng các thay đổi khác cũng có thể giúp ích.

- Duy trì hoặc tăng cường thông lượng tối đa so với SSU 1,
  được đo lường qua một loạt độ trễ mô phỏng và tỷ lệ mất gói trên một mạng kiểm tra.

- Ngăn chặn khuếch đại và điều hướng sai lưu lượng từ các địa chỉ nguồn giả mạo
  thông qua "xác nhận địa chỉ".

- Làm cho việc nhận dạng gói dễ dàng hơn, để giảm sự phụ thuộc vào các phương pháp dự phòng và
  heuristic làm cho mã trở nên quá phức tạp.

- Định hình và cải thiện di chuyển kết nối khi IP hoặc cổng của đồng đẳng thay đổi.
  Không di chuyển các kết nối cho đến khi xác nhận địa chỉ hoàn tất, để ngăn chặn các cuộc tấn công.
  Một số triển khai SSU 1 sử dụng phương pháp heuristic đắt đỏ để xử lý các thay đổi cổng
  do gán lại NAT. Không có triển khai SSU 1 nào có thể xử lý thay đổi IP.

- Hỗ trợ SSU 1 và 2 trên một cổng duy nhất, tự động nhận diện, và được công bố như một
  "phương tiện" duy nhất (tức là [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) trong [NetDB](/en/docs/how/network-database/).

- Công bố hỗ trợ cho phiên bản 1 chỉ, 2 chỉ, hoặc 1+2 trong NetDB trong một trường riêng biệt, và mặc định là phiên bản 1 chỉ (không liên kết hỗ trợ phiên bản với một phiên bản router cụ thể)

- Đảm bảo rằng tất cả các triển khai (Java/i2pd/Go) có thể thêm hỗ trợ phiên bản 2 (hoặc không) theo hết lịch trình riêng của họ

- Thêm đệm ngẫu nhiên vào tất cả các thông điệp bao gồm các thông điệp bắt tay và dữ liệu.
  Tất cả các đệm phải được bao phủ bởi MAC, không giống như đệm cuối gói trong SSU 1.
  Cung cấp cơ chế tùy chọn cho cả hai bên để yêu cầu đệm tối thiểu và tối đa
  và/hoặc phân phối đệm. Cụ thể về phân phối đệm phụ thuộc vào việc triển khai và có thể hoặc không được chỉ định trong chính giao thức.

- Làm mờ tiêu đề và nội dung của các thông điệp không được mã hóa đầy đủ đủ để mà các hộp DPI và các chữ ký AV không dễ dàng phân loại chúng.
  Cũng đảm bảo rằng các thông điệp được gửi tới một địa chỉ đồng đẳng cụ thể hoặc nhóm đồng đẳng không có một mẫu bit tương tự.

- Sửa chữa mất bit trong DH do định dạng Java [Ticket1112](http://{{ i2pconv('trac.i2p2.i2p') }}/ticket/1112), và tăng tốc DH
  bằng cách chuyển sang X25519.

- Chuyển sang chức năng rút ngắn khóa thực sự (KDF) hơn là sử dụng kết quả DH như nó có.

- Thêm "khả năng chống thăm dò" (như Tor gọi); điều này bao gồm kháng replay.

- Duy trì trao đổi khóa xác thực hai chiều (2W-AKE). 1W-AKE không đủ
  cho ứng dụng của chúng tôi.

- Dựa vào khóa công khai tĩnh được công bố trong RouterInfo như một phần khác của
  xác thực.

- Thêm tùy chọn/phiên bản trong bắt tay để mở rộng về sau.

- Không thêm đáng kể vào yêu cầu CPU cho thiết lập kết nối; nếu có, giảm nó đáng kể.

- Loại bỏ yêu cầu đệm thành bội số của 16 byte được
  áp đặt bởi mã hóa AES trong SSU 1.

- Sử dụng ChaCha/Poly1305 tiêu chuẩn cho mã hóa và MAC,
  thay thế mã hóa AES và MAC không chuẩn HMAC-MD5-128 được sử dụng trong SSU 1.

- Sử dụng khóa mã hóa riêng biệt cho phát và nhận, thay vì
  khóa chung cho cả hai hướng được sử dụng trong SSU 1.

- Sử dụng bắt tay 3 thông điệp, một chuyến đi vòng, như trong [NTCP2](/en/proposals/111-ntcp-2/).
  Bỏ qua độ trễ chờ các thông điệp dữ liệu khiến cho
  [SSU](/en/docs/transport/ssu/) trở thành một tục đoạn hai lượt vòng.

- Cải thiện hiệu quả của ACK và NACK,
  cái mà rất tệ trong SSU 1. Giảm băng thông yêu cầu
  cho ACK và NACK, và tăng kích thước gói có sẵn cho dữ liệu.
  Mã hóa NACK cho một khoảng tin nhắn bị thiếu hiệu quả,
  điều này phổ biến qua WiFi.

- Giảm độ phức tạp cần thiết để triển khai phản rời rạc thông điệp I2NP.
  Bỏ qua các cơ chế phân mảnh và mã hóa cho các thông điệp I2NP hoàn toàn.

- Tối thiểu hóa chi phí giao thức trước khi đệm, đặc biệt là cho ACK.
  Mặc dù đệm sẽ được thêm vào,
  chi phí trước đệm vẫn là chi phí.
  Các nút băng thông thấp phải có thể sử dụng SSU2.

- Duy trì dấu thời gian cho phát hiện lại và lệch.

- Tránh bất kỳ vấn đề năm 2038 nào trong dấu thời gian, phải hoạt động ít nhất đến năm 2106.

- Tăng tối thiểu MTU từ 620 đến 1280 cho hiệu quả, dễ thực hiện,
  và tăng kích thước thông điệp I2NP tối đa.
  Phân mảnh và lắp ráp lại là rất tốn kém.
  Bằng cách cung cấp chỗ cho thông điệp hầm dài 1028 byte, một số lượng lớn thông điệp I2NP
  sẽ không yêu cầu phân mảnh.

- Tăng tối đa MTU từ 1488 (1484 cho IPv6) lên 1500 cho hiệu quả.
  Loại bỏ yêu cầu rằng MTU là bội số của 16.

- Tăng kích thước thông điệp I2NP tối đa từ khoảng 32K trong SSU 1
  tới khoảng 64 KB như trong NTCP2.

- Loại bỏ chữ ký của các trường IP và cổng từ bắt tay,
  để router không biết
  IP ngoài và cổng của chúng sẽ có thể kết nối.

- Giữ lại cơ chế khám phá IP/cổng từ SSU 1 trong bắt tay,
  để router có thể học được IP ngoài và cổng của chúng.

- Bao gồm đại diện của các nhà phát triển router Java, C++, và Go trong thiết kế.

### Không phải mục tiêu

- Khả năng kháng lại DPI chống đạn... đó sẽ là các phương tiện cắm thêm,
  [Prop109](/en/proposals/109-hashcash/).

- Một phương tiện dựa trên TLS (hoặc giống như HTTPS)... đó sẽ là [Prop104](/en/proposals/104-new-protocol/).

- Khả năng kháng DPI dựa trên thời gian (thời gian giữa các thông điệp/các trễ có thể
  phụ thuộc vào việc triển khai; các trễ trong thông điệp có thể được đưa vào bất kỳ
  điểm nào, bao gồm trước khi gửi các đệm ngẫu nhiên, ví dụ). Các
  trễ nhân tạo (những gì obfs4 gọi là IAT hoặc thời gian giữa các lần đến) độc lập với
  chính giao thức.

- Khả năng không thừa nhận tham gia vào một phiên (có chữ ký ở đó).

Các mục tiêu không phải có thể được xem xét lại một phần hoặc thảo luận:

- Mức độ bảo vệ chống lại Kiểm Tra Gói Sâu (DPI)

- Bảo mật sau Lượng Tử (PQ)

- Khả năng không thừa nhận

## Mục tiêu An ninh

Chúng tôi xem xét ba bên:

- Alice, người muốn thiết lập một phiên mới.
- Bob, với người mà Alice muốn thiết lập một phiên.
- Mallory, "người giữa" giữa Alice và Bob.

Tối đa hai người tham gia có thể tham gia vào các cuộc tấn công chủ động.

Alice và Bob đều có một cặp khóa tĩnh, được chứa trong [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) của họ.

Giao thức đề xuất này cố gắng cho phép Alice và Bob đồng ý về một khóa bí mật
chung (K) dưới các yêu cầu sau:

1) Bảo mật khóa riêng: Cả Bob và Mallory không học được gì về khóa riêng của Alice.
   Đối xứng, Alice không học được gì về khóa riêng của Bob.

2) Khóa phiên K chỉ được biết đến bởi Alice và Bob.

3) Bảo mật tiếp liên hoàn hảo: khóa phiên đã thỏa thuận vẫn là bí mật trong
   tương lai, thậm chí khi các khóa riêng của Alice và/hoặc Bob bị tiết lộ sau khi
   khóa đã được thỏa thuận.

4) Xác thực hai chiều: Alice chắc chắn rằng cô đã thiết lập một phiên với Bob, và ngược lại.

5) Bảo vệ chống DPI trực tuyến: Đảm bảo rằng không dễ để phát hiện rằng
   Alice và Bob đang tham gia vào giao thức chỉ bằng cách sử dụng các kỹ thuật
   kiểm tra gói sâu (DPI) đơn giản. Xem bên dưới.

6) Khả năng không thừa nhận hạn chế: Cả Alice và Bob không thể phủ nhận
   việc tham gia vào giao thức, nhưng nếu một trong hai bên rò rỉ khóa chia sẻ,
   bên kia có thể phủ nhận tính xác thực của nội dung dữ liệu đã truyền.

Đề xuất hiện tại cố gắng cung cấp cả năm yêu cầu dựa trên giao thức
Station-To-Station (STS) [STS](https://en.wikipedia.org/wiki/Station-to-Station_protocol). Lưu ý rằng giao thức này cũng là
cơ sở cho giao thức [SSU](/en/docs/transport/ssu/).

### Thảo luận DPI bổ sung

Chúng tôi giả định có hai thành phần DPI:

DPI trực tuyến
```````````````

DPI trực tuyến kiểm tra tất cả các luồng trong thời gian thực. Các kết nối có thể bị chặn hoặc
can thiệp theo các cách khác. Dữ liệu kết nối hoặc siêu dữ liệu có thể bị
xác định và lưu trữ để phân tích ngoại tuyến. DPI trực tuyến không có
truy cập vào cơ sở dữ liệu mạng I2P. DPI trực tuyến chỉ
có khả năng tính toán hạn chế trong thời gian thực, bao gồm việc
tính độ dài, kiểm tra trường, và các phép tính đơn giản như XOR. DPI trực tuyến có khả năng
xử lý nhanh các hàm mã hóa trong thời gian thực như ChaCha20, AEAD, và hàm băm, nhưng
những thao tác này quá tốn kém để áp dụng cho hầu hết
hoặc tất cả các luồng. Bất kỳ ứng dụng nào của các thao tác mã hóa này
chỉ áp dụng cho các luồng trên các tổ hợp IP/Port đã được xác định trước đó
bởi phân tích ngoại tuyến. DPI trực tuyến không có khả năng các hàm mã hóa có
chi phí cao như DH hoặc elligator2. DPI trực tuyến không được thiết kế đặc biệt để
phát hiện I2P, mặc dù nó có thể có các quy tắc phân loại hạn chế cho
mục đích đó.

Nó là một mục tiêu để ngăn chặn việc nhận diện giao thức bởi

DPI ngoại tuyến
`````````````````

DPI ngoại tuyến kiểm tra dữ liệu được lưu trữ bởi DPI trực tuyến để phân tích sau.
DPI ngoại tuyến có thể được thiết kế đặc biệt để phát hiện I2P.
DPI ngoại tuyến có truy cập thời gian thực tới cơ sở dữ liệu mạng I2P.
DPI ngoại tuyến có truy cập tới các đặc tả này hoặc các đặc tả khác của I2P.
DPI ngoại tuyến có khả năng tính toán không giới hạn, bao gồm
tất cả các hàm mã hóa được định nghĩa trong đặc tả này.

DPI ngoại tuyến không có khả năng chặn các kết nối hiện tại. DPI
ngoại tuyến có khả năng gửi gần-thời gian thực (trong vòng vài phút của
thiết lập) tới máy chủ/port của các bên thông qua chèn gói. DPI ngoại tuyến
có khả năng gần-thời gian thực (trong vòng vài phút của thiết lập) phát lại
các thông điệp trước đó (đã sửa đổi hoặc không) cho "thăm dò"

Nó không phải là mục tiêu để ngăn chặn việc nhận diện giao thức bởi
DPI ngoại tuyến.
Mọi thao tác giải mã dữ liệu bị làm mờ trong hai thông điệp đầu tiên
được thực hiện bởi các router I2P, cũng có thể được thực hiện bởi DPI ngoại tuyến.

Nó là mục tiêu để từ chối các nỗ lực kết nối sử dụng phát lại các thông điệp trước đó.

### Xác thực địa chỉ

Sau đây được sao chép từ QUIC [RFC-9000](https://www.rfc-editor.org/rfc/rfc9000.html).
Đối với mỗi phần, hãy xem xét và chỉnh sửa.

Xác thực địa chỉ đảm bảo rằng một endpoint không thể được sử dụng cho một
cuộc tấn công khuếch đại lưu lượng. Trong một cuộc tấn công như vậy, một gói được gửi đến
máy chủ với thông tin địa chỉ nguồn giả mạo xác định nạn nhân.
Nếu máy chủ tạo ra nhiều hoặc lớn hơn các gói tin để đáp lại
gói đó, kẻ tấn công có thể sử dụng máy chủ để gửi nhiều dữ liệu hơn
đối với nạn nhân hơn là nó có thể tự mình gửi.

Biện pháp phòng vệ chính chống lại các cuộc tấn công khuếch đại là xác minh rằng một
đồng đẳng có thể nhận các gói tin tại địa chỉ truyền tải mà nó
tuyên bố. Do đó, sau khi nhận các gói tin từ một địa chỉ chưa được xác thực,
một endpoint phải hạn chế lượng dữ liệu nó gửi tới địa chỉ chưa được xác thực đó
tới ba lần so với lượng dữ liệu nhận được từ địa chỉ đó. Giới hạn này
về kích thước các phản hồi được gọi là
giới hạn chống khuếch đại.

Xác thực địa chỉ được thực hiện cả khi thiết lập kết nối
(xem Phần 8.1) và khi di chuyển kết nối (xem Phần 8.2).

Xác thực địa chỉ khi Thiết lập Kết nối
```````````````````````````````````````````````

Thiết lập kết nối ngầm chứa đựng xác thực địa chỉ cho
cả hai endpoint. Đặc biệt, nhận được một gói tin được bảo vệ bằng
khóa Bắt tay xác nhận rằng đồng đẳng đã xử lý thành công một
gói Khởi tạo. Khi một endpoint đã xử lý thành công một
gói Bắt tay từ đồng đẳng, nó có thể xem địa chỉ đồng đẳng là
đã được xác thực.

Ngoài ra, một endpoint có thể coi địa chỉ đồng đẳng đã được xác thực nếu
đồng đẳng sử dụng một ID kết nối được chọn bởi endpoint và
ID kết nối chứa ít nhất 64 bit entropy.

Đối với khách hàng, giá trị của trường Destination ID Kết nối trong
gói Khởi tạo đầu tiên của nó cho phép nó xác nhận địa chỉ máy chủ như
một phần của việc xử lý thành công bất kỳ gói nào. Các gói Khởi tạo từ
máy chủ được bảo vệ bằng khóa được sinh ra từ giá trị này
(xem Phần 5.2 của [QUIC-TLS]). Ngoài ra, giá trị được phản hồi
bởi máy chủ trong các gói Đàm phán Phiên bản (Phần 6) hoặc được bao gồm
trong Thẻ Toàn vẹn trong các gói Retry (Phần 5.8 của [QUIC-TLS]).

Trước khi xác nhận địa chỉ khách hàng, máy chủ không được
gửi hơn ba lần số byte so với số byte mà nó đã
nhận được. Điều này giới hạn cường độ của một cuộc tấn công khuếch đại
có thể được thực hiện bằng cách sử dụng các địa chỉ nguồn giả mạo. Đối với mục đích
tránh khuếch đại trước khi xác nhận địa chỉ, máy chủ phải
đếm tất cả các byte tải trọng nhận được trong các datagram mà
được gán duy nhất cho một kết nối duy nhất. Điều này bao gồm các datagram
chứa các gói được xử lý thành công và các datagram
chứa các gói bị loại bỏ hoàn toàn.

Khách hàng phải đảm bảo rằng các datagram UDP chứa các gói Khởi tạo
có tải trọng UDP ít nhất 1200 byte, thêm các khung ĐỆM khi
cần thiết. Một khách hàng gửi các datagram được đệm cho phép máy chủ
gửi nhiều dữ liệu hơn trước khi hoàn thành xác nhận địa chỉ.

Mất một gói Khởi tạo hoặc Bắt tay từ máy chủ có thể gây ra một
đình trệ nếu khách hàng không gửi thêm các gói Khởi tạo hoặc Bắt tay.
Một tình huống đình trệ có thể xảy ra khi máy chủ đạt đến giới hạn
chống khuếch đại của nó và khách hàng đã nhận được xác nhận cho
tất cả dữ liệu mà nó đã gửi. Trong trường hợp này, khi khách hàng
không có lý do để gửi thêm gói tin, máy chủ sẽ không thể gửi
nhiều dữ liệu hơn vì nó chưa xác nhận địa chỉ khách hàng. Để
ngăn chặn sự đình trệ này, các khách hàng phải gửi một gói tin trên Nam Phi Timeout (PTO);
xem Phần 6.2 của [QUIC-RECOVERY]. Cụ thể, các khách hàng
phải gửi một gói Khởi tạo trong một datagram UDP chứa ít nhất
1200 byte nếu nó không có khóa Bắt tay, và ngược lại gửi một
gói Bắt tay.

Máy chủ có thể muốn xác nhận địa chỉ khách hàng trước khi bắt đầu
giao thức mật mã. QUIC sử dụng một token trong gói Khởi tạo
để cung cấp xác nhận địa chỉ trước khi hoàn thành giao thức bắt tay.
Token này được đưa cho khách hàng trong một giao tiếp
thiết lập kết nối qua một gói Retry (xem Phần 8.1.2) hoặc thông qua một
kết nối trước đó sử dụng khung NEW_TOKEN (xem Phần 8.1.3).

Ngoài các hạn chế về việc gửi được áp đặt trước khi xác nhận địa chỉ,
máy chủ cũng bị hạn chế trong những gì mà chúng có thể gửi bởi các giới hạn
được đặt bởi bộ điều khiển cường độ vận tải. Các khách hàng chỉ
bị ràng buộc bởi bộ điều khiển cường độ vận tải.

Xây dựng token
```````````````````````````````````````````````````````

Một token được gửi trong khung NEW_TOKEN hoặc trong một gói Retry phải
được xây dựng theo một cách mà cho phép máy chủ xác định cách mà nó được
cung cấp cho khách hàng. Các token này được mang theo cùng một trường nhưng
yêu cầu hiển thị khác nhau từ máy chủ.

Xác nhận địa chỉ bằng cách sử dụng gói Retry
```````````````````````````````````````````````````````

Sau khi nhận được gói Khởi tạo của khách hàng, máy chủ
có thể yêu cầu xác nhận địa chỉ bằng cách gửi một gói Retry (Phần 17.2.5)
chứa một token. Token này phải được lặp lại bởi khách hàng trong tất cả
các gói Khởi tạo mà nó gửi cho kết nối đó sau khi nhận được
gói Retry.

Đáp lại việc xử lý một gói Khởi tạo chứa một token được
cung cấp trong một gói Retry, máy chủ không thể gửi một gói
Retry khác; nó chỉ có thể từ chối kết nối hoặc cho phép nó tiếp diễn.

Miễn là không có khả năng kẻ tấn công tạo ra một
token hợp lệ cho địa chỉ riêng của nó (xem Phần 8.1.4) và khách hàng có khả năng
trả lại token đó, nó chứng minh với máy chủ rằng khách hàng đã nhận
được token.

Một máy chủ cũng có thể sử dụng một gói Retry để trì hoãn các chi phí xử lý
và trạng thái của việc thiết lập kết nối. Việc yêu cầu máy chủ
cung cấp một ID kết nối khác, cùng với thông số vận chuyển
gốc nhất định trong Phần 18.2, buộc máy chủ phải chứng minh rằng nó,
hoặc một thực thể mà nó hợp tác, đã nhận được gói Khởi tạo gốc từ
khách hàng. Việc cung cấp một ID kết nối khác cũng cấp cho máy chủ
một số quyền kiểm soát cách các gói tiếp theo được định tuyến. Điều này có thể
được sử dụng để chỉ đạo các kết nối đến một phiên bản máy chủ khác.

Nếu máy chủ nhận được một gói Khởi tạo từ khách hàng mà chứa một
token Retry không hợp lệ nhưng gói đó vẫn hợp lệ, nó biết rằng khách hàng
sẽ không chấp nhận một token Retry khác. Máy chủ có thể loại bỏ
gói tin như vậy và cho phép khách hàng tự thời gian ra để phát hiện lỗi
giao thức, nhưng điều đó có thể dẫn đến một khả năng trễ đáng kể
trên khách hàng. Thay vào đó, máy chủ NÊN đóng ngay lập tức (Phần 10.2) kết nối
với lỗi INVALID_TOKEN. Lưu ý rằng một máy chủ không thiết lập
bất kỳ trạng thái nào cho kết nối tại thời điểm này và do đó không bước vào
giai đoạn đóng.

Một luồng mô tả việc sử dụng một gói Retry được trình bày trong Hình 9.

```
Khách hàng                                                     Máy chủ

  Khởi tạo[0]: CRYPTO[CH] ->

                                                <- Retry+Token

  Khởi tạo+Token[1]: CRYPTO[CH] ->

                                 Khởi tạo[0]: CRYPTO[SH] ACK[1]
                       Bắt tay[0]: CRYPTO[EE, CERT, CV, FIN]
                                 <- 1-RTT[0]: STREAM[1, "..."]

                Hình 9: Ví dụ về Giao thức bắt tay có Retry
```


Xác nhận địa chỉ cho các kết nối trong tương lai
`````````````````````````````````````````````````````

Một máy chủ CÓ THỂ cung cấp cho các khách hàng với một token xác nhận địa chỉ trong
một kết nối cho phép sử dụng trong một kết nối tương lai.
Xác nhận địa chỉ đặc biệt quan trọng với 0-RTT bởi vì một máy chủ
có thể gửi một lượng dữ liệu lớn tới khách hàng để đáp lại dữ liệu 0-RTT.

Máy chủ sử dụng khung NEW_TOKEN (Phần 19.7) để cung cấp cho khách hàng
một token xác nhận địa chỉ có thể được sử dụng để xác nhận các kết nối tương lai.
Trong một kết nối tương lai, khách hàng bao gồm token này trong các gói Khởi tạo
để cung cấp xác nhận địa chỉ. Khách hàng PHẢI bao gồm token trong tất cả
các gói Khởi tạo mà nó gửi, trừ khi một Retry thay thế token với một
token mới hơn. Khách hàng không được sử dụng các token cung cấp trong một Retry
cho các kết nối trong tương lai. Các máy chủ CÓ THỂ loại bỏ bất kỳ gói Khởi tạo nào
không mang theo token mong đợi.

Không giống như token được tạo ra cho một gói Retry, cái mà được
sử dụng ngay lập tức, token được gửi trong khung NEW_TOKEN
có thể được sử dụng sau khi một khoảng thời gian đã trôi qua. Do đó, một token
PHẢI có một thời gian hết hạn, có thể là một thời gian hết hạn rõ ràng hoặc
một dấu thời gian phát hành có thể được sử dụng để tính toán động thời gian
hết hạn. Máy chủ có thể lưu thời gian hết hạn hoặc bao gồm nó trong một
dạng mã hóa trong token.

Một token phát hành với NEW_TOKEN KHÔNG ĐƯỢC bao gồm thông tin mà
cho phép các giá trị được liên kết bởi một người quan sát với kết nối mà
trên đó nó đã được phát hành. Ví dụ: nó không thể bao gồm ID kết nối
trước đó hoặc thông tin định tuyến, trừ khi các giá trị đó
được mã hóa. Máy chủ PHẢI đảm bảo rằng mỗi khung NEW_TOKEN mà nó gửi
là duy nhất trên tất cả các khách hàng, ngoại trừ những khung được gửi
để sửa chữa các mất mát của các khung NEW_TOKEN đã gửi trước đó. Thông tin mà
cho phép máy chủ phân biệt giữa các token từ Retry và
NEW_TOKEN có thể được truy cập bởi các thực thể khác ngoài máy chủ.

Có thể địa chỉ nguồn của khách hàng không cùng trên hai
kết nối khác nhau; do đó việc xác nhận cổng là khó thành công hơn.

Một token nhận được trong một khung NEW_TOKEN phù hợp với bất kỳ máy chủ
nào mà kết nối được xem là có thẩm quyền (vd, các tên máy chủ
được bao gồm trong chứng chỉ). Khi kết nối tới một máy chủ mà
khách hàng giữ một token có sẵn và chưa sử dụng, nó NÊN
bao gồm token đó trong trường Token của gói Khởi tạo của nó.
Việc bao gồm một token có thể cho phép máy chủ xác nhận địa chỉ khách hàng mà
không cần thêm một chuyến đi vòng. Khách hàng KHÔNG ĐƯỢC bao gồm một token mà
không phù hợp với máy chủ mà nó kết nối tới, trừ khi khách hàng có
kiến thức rằng máy chủ phát hành token và máy chủ mà khách hàng
kết nối tới đang cùng quản lý các token. Một khách hàng CÓ THỂ sử dụng một token
từ bất kỳ kết nối trước nào với máy chủ đó.

Một token cho phép máy chủ tương quan hoạt động giữa kết nối
mà token đã được phát hành và bất kỳ kết nối nào mà nó được sử dụng.
Các khách hàng muốn phá vỡ tính liên tục của nhận diện với máy chủ có thể
loại bỏ các token được cung cấp bằng khung NEW_TOKEN. Trong khi đó,
một token nhận được trong một gói Retry PHẢI được sử dụng ngay lập tức
trong quá trình thử kết nối và không thể được sử dụng trong các lần thử kết nối
tiếp theo.

Một khách hàng KHÔNG NÊN sử dụng lại một token từ khung NEW_TOKEN cho
các lần thử kết nối khác nhau. Việc sử dụng lại một token cho phép các kết nối
được liên kết bởi các thực thể trên đường đi; xem Phần 9.5.

Khách hàng có thể nhận được nhiều token trên một kết nối duy nhất. Ngoài việc
ngăn chặn tính liên kết, bất kỳ token nào có thể được sử dụng trong bất kỳ lần thử
kết nối nào. Máy chủ có thể gửi thêm token để kích hoạt xác nhận
địa chỉ cho nhiều lần thử kết nối hoặc thay thế các token cũ mà có thể
trở nên không hợp lệ. Đối với khách hàng, sự mơ hồ này có nghĩa là việc
gửi token chưa sử dụng gần đây nhất là cách có hiệu quả nhất.
Tuy nhiên, việc lưu và sử dụng các token cũ hơn không có
ảnh hưởng tiêu cực, khách hàng có thể coi các token cũ hơn là ít
khả thi hơn để máy chủ có thể sử dụng cho xác nhận địa chỉ.

Khi máy chủ nhận được một gói Khởi tạo với một token xác nhận địa chỉ,
nó PHẢI cố gắng xác thực token, trừ khi nó đã hoàn tất
xác nhận địa chỉ. Nếu token là không hợp lệ, thì máy chủ NÊN tiếp tục
xử lý như thể khách hàng không có một địa chỉ đã được xác thực,
bao gồm khả năng gửi một gói Retry. Các token
cung cấp trong các khung NEW_TOKEN và gói Retry có thể được phân biệt
bởi các máy chủ (xem Phần 8.1.1), và sau đó có thể được xác thực
nghiêm ngặt hơn. Nếu xác thực thành công, máy chủ NÊN sau đó
cho phép giao thức bắt tay tiếp tục.

Lưu ý: Lý do để coi khách hàng như không xác thực
thay vì loại bỏ gói là do khách hàng có thể đã
nhận được token trong một kết nối trước sử dụng khung NEW_TOKEN,
và nếu máy chủ đã mất trạng thái, nó có thể không có khả năng
xác thực token, dẫn đến việc kết nối thất bại nếu
gói bị loại bỏ.

Trong một thiết kế không trạng thái, một máy chủ có thể sử dụng các token mã hóa
và xác thực để truyền thông tin tới khách hàng mà máy chủ có thể
sau đó khôi phục lại và sử dụng để xác thực địa chỉ khách hàng. Các token
không được tích hợp vào giao thức bắt tay mật mã, và do đó
chúng không được xác thực. Ví dụ, một khách hàng có thể có khả năng
sử dụng lại một token. Để tránh các cuộc tấn công khai thác đặc tính này,
một máy chủ có thể hạn chế việc sử dụng các token chỉ đối với thông tin
cần thiết để xác minh địa chỉ khách hàng.

Khách hàng CÓ THỂ sử dụng các token nhận được từ một kết nối cho bất kỳ
lần thử kết nối nào sử dụng cùng phiên bản. Khi chọn một token để
sử dụng, các khách hàng không cần thiết phải xem xét các thuộc tính khác
của kết nối đang được thử nghiệm, bao gồm sự lựa chọn của các
giao thức ứng dụng có thể, các vé phiên, hoặc các thuộc tính kết nối khác.

Toàn vẹn token xác thực địa chỉ
```````````````````````````````````````````````````````

Một token xác thực địa chỉ PHẢI khó đoán. Bao gồm một
giá trị ngẫu nhiên với ít nhất 128 bit entropy trong token sẽ
đủ, nhưng điều này phụ thuộc vào việc ghi nhớ của máy chủ để giá trị
nó gửi cho các khách hàng.

Một schema dựa trên token cho phép máy chủ tải qua bất kỳ trạng thái
nào liên quan đến xác thực tới khách hàng. Để thiết kế này hoạt động,
token PHẢI được bảo vệ bởi tính toàn vẹn để tránh
sửa đổi hoặc giả mạo của khách hàng. Nếu không có bảo vệ toàn vẹn,
các khách hàng độc hại có thể tạo ra hoặc đoán giá trị token
sẽ được máy chủ chấp nhận. Chỉ máy chủ
cần truy cập vào khóa bảo vệ toàn vẹn cho các token.

Không cần một định dạng cụ thể duy nhất cho token vì
máy chủ tạo ra token cũng là máy chủ tiêu thụ nó. Các token
gửi trong các gói Retry NÊN bao gồm thông tin cho phép
máy chủ xác minh rằng địa chỉ IP nguồn và cổng
trong các gói tin của khách hàng vẫn không đổi.

Các token gửi trong các khung NEW_TOKEN PHẢI bao gồm thông tin cho phép
máy chủ xác minh rằng địa chỉ IP của khách hàng không thay đổi từ
khi token được phát hành. Máy chủ có thể sử dụng các token từ
các khung NEW_TOKEN trong quyết định không gửi một gói Retry,
thậm chí nếu địa chỉ của khách hàng thay đổi. Nếu địa chỉ IP của khách hàng
đã thay đổi, máy chủ PHẢI tuân thủ giới hạn chống khuếch đại;
xem Phần 8. Lưu ý rằng trong sự hiện diện của NAT, yêu cầu này có thể
không đủ để bảo vệ các máy chia sẻ NAT
khỏi các cuộc tấn công khuếch đại.

Kẻ tấn công có thể phát lại các token để sử dụng máy chủ như các bộ khuếch đại
trong các cuộc tấn công DDoS. Để bảo vệ chống lại các cuộc tấn công như vậy, máy chủ
PHẢI đảm bảo rằng việc phát lại các token bị ngăn chặn hoặc hạn chế.
Máy chủ nên đảm bảo rằng các token gửi trong các gói Retry
được chấp nhận chỉ trong một khoảng thời gian ngắn, như
chúng được trả lại ngay lập tức bởi các khách hàng. Các token cung cấp
trong các khung NEW_TOKEN (Phần 19.7) cần
phải được hợp lệ lâu hơn nhưng KHÔNG NÊN được chấp nhận nhiều lần.
Các máy chủ được khuyến khích chỉ cho phép các token
được sử dụng chỉ một lần, nếu có thể; các token CÓ THỂ bao gồm
thông tin bổ sung về các khách hàng để thu hẹp hơn nữa khả năng áp dụng
hoặc sử dụng lại.

Xác định đường dẫn
```````````````````````````````````````````````````````

Xác định đường dẫn được sử dụng bởi cả hai đồng đẳng trong quá trình di chuyển
kết nối (xem Phần 9) để xác minh khả năng hoạt động sau khi
một địa chỉ thay đổi. Trong xác định đường dẫn, các endpoint kiểm tra khả năng hoạt động
giữa một địa chỉ địa phương cụ thể và một địa chỉ đồng đẳng cụ thể, nơi
địa chỉ là một cặp 2-tuple của địa chỉ IP và cổng.

Xác định đường dẫn kiểm tra rằng các gói tin truyền trên một đường dẫn
đến đồng đẳng được nhận bởi đồng đẳng đó. Xác định đường dẫn
được sử dụng để đảm bảo rằng các gói tin nhận được từ một đồng đẳng di chuyển không mang
theo địa chỉ nguồn giả mạo.

Xác định đường dẫn không xác minh rằng một đồng đẳng có thể gửi
trong hướng ngược lại. Các xác nhận không thể được sử dụng cho
xác thực đường ngược vì chúng không đủ entropy và có thể
bị giả mạo. Các endpoint xác định một cách độc lập khả năng hoạt động ở
mỗi hướng của một đường và do đó khả năng hoạt động ngược chiều chỉ có thể
được xác định bởi đồng đẳng.

Xác định đường dẫn có thể được sử dụng bất kỳ lúc nào bởi bất kỳ endpoint nào. Ví
dụ, một endpoint có thể kiểm tra rằng đồng đẳng vẫn giữ địa chỉ của
nó sau một thời kỳ không hoạt động.

Xác định đường dẫn không được thiết kế như một cơ chế vượt qua NAT.
Mặc dù cơ chế được mô tả ở đây có thể hiệu quả cho việc tạo
các liên kết NAT hỗ trợ vượt qua NAT, kỳ vọng là một
endpoint có khả năng nhận các gói tin mà không cần trước tiên đã gửi một
gói trên đường dẫn đó. Vượt qua NAT hiệu quả cần thêm
các cơ chế đồng bộ hóa không được cung cấp ở đây.

Một endpoint CÓ THỂ bao gồm các khung khác với các khung PATH_CHALLENGE và
PATH_RESPONSE được sử dụng cho xác định đường dẫn. Cụ thể, một
endpoint có thể bao gồm các khung PADDING với một khung PATH_CHALLENGE
để phát hiện Đường truyền đơn tối đa (PMTUD); xem Phần 14.2.1.
Một endpoint cũng có thể bao gồm khung PATH_CHALLENGE của chính nó khi
gửi một khung PATH_RESPONSE.

Một endpoint sử dụng một ID kết nối mới cho các phép dò gửi từ một địa chỉ
địa phương mới; xem Phần 9.5. Khi dò tìm một đường mới, một
endpoint có thể đảm bảo rằng đồng đẳng của nó có một ID kết nối chưa sử dụng có sẵn cho
các phản hồi. Gửi các khung NEW_CONNECTION_ID và PATH_CHALLENGE trong
cùng một gói, nếu giới hạn active_connection_id_limit của đồng đẳng cho phép,
đảm bảo rằng một ID kết nối chưa sử dụng sẽ có sẵn cho đồng đẳng
khi gửi một phản hồi.

Một endpoint có thể chọn dò tìm đồng thời nhiều đường dẫn. Số
đường dẫn đồng thời sử dụng cho các phép dò được giới hạn bởi số
ID kết nối bổ sung mà đồng đẳng đã cung cấp trước đó, vì mỗi
địa chỉ địa phương mới sử dụng cho một phép dò yêu cầu một ID kết nối
chưa sử dụng trước đó.

Bắt đầu Xác định Đường Dẫn
```````````````````````````````````````````````````````

Để bắt đầu xác định đường dẫn, một endpoint gửi một khung
PATH_CHALLENGE chứa một tải trọng không thể đoán trước trên đường
được xác định.

Một endpoint CÓ THỂ gửi nhiều khung PATH_CHALLENGE để bảo vệ chống lại
mất gói tin. Tuy nhiên, một endpoint KHÔNG NÊN gửi nhiều
khung PATH_CHALLENGE trong một gói duy nhất.

Một endpoint KHÔNG NÊN dò tìm một đường mới với các gói chứa một
khung PATH_CHALLENGE thường xuyên hơn nó gửi một
gói Khởi tạo. Điều này đảm bảo rằng việc
di chuyển kết nối không tốn kém nhiều hơn trên một đường mới so với việc
thiết lập một kết nối mới.

Endpoint PHẢI sử dụng dữ liệu không thể đoán trước trong mỗi khung PATH_CHALLENGE
để nó có thể kết hợp phản hồi của đồng đẳng với
khung PATH_CHALLENGE tương ứng.

Một endpoint PHẢI mở rộng các datagram chứa một khung PATH_CHALLENGE
tới ít nhất kích thước datagram tối đa cho phép là 1200 byte,
trừ khi giới hạn chống khuếch đại cho đường không cho phép
gửi một datagram có kích thước này. Gửi các datagram UDP có kích thước này
đảm bảo rằng đường mạng từ endpoint đến đồng đẳng có thể
được sử dụng cho QUIC; xem Phần 14.

Khi một endpoint không thể mở rộng kích thước datagram tới 1200 byte
do giới hạn chống khuếch đại, triệt phá đường PMTU sẽ không được
xác nhận. Để đảm bảo rằng đường PMTU đủ lớn, endpoint
PHẢI thực hiện một xác định đường dẫn thứ hai bằng cách gửi một khung PATH_CHALLENGE
trong một datagram có ít nhất 1200 byte. Xác định bổ sung này
có thể được thực hiện sau khi một PATH_RESPONSE được nhận thành công hoặc khi
đủ byte đã được nhận trên đường đó mà
gửi datagram lớn hơn sẽ không dẫn đến vượt quá giới hạn chống
khuếch đại.

Không giống như các trường hợp khác nơi các datagram được mở rộng, các endpoint
PHẢI KHÔNG loại bỏ các datagram mà dường như quá nhỏ khi chúng chứa
các khung PATH_CHALLENGE hoặc PATH_RESPONSE.

Phản hồi cho xác định đường dẫn
```````````````````````````````````````````````````````

Khi nhận được một khung PATH_CHALLENGE, một endpoint PHẢI phản hồi bằng
cách trả lại dữ liệu chứa trong khung PATH_CHALLENGE trong một
khung PATH_RESPONSE. Một endpoint PHẢI KHÔNG trì hoãn việc truyền một
gói chứa khung PATH_RESPONSE trừ khi bị hạn chế bởi
kiểm soát sự chen nhau.

Một khung PATH_RESPONSE PHẢI được gửi trên đường mà
khung PATH_CHALLENGE đã được nhận. Điều này đảm bảo rằng xác định đường
bởi một đồng đẳng chỉ thành công nếu đường có thể hoạt động ở cả hai hướng.
Yêu cầu này KHÔNG được thực thi bởi endpoint bắt đầu
xác định đường, vì điều đó sẽ cho phép một cuộc tấn công vào việc di chuyển;
xem Phần 9.3.3.

Một endpoint PHẢI mở rộng các datagram chứa một khung PATH_RESPONSE
tới ít nhất kích thước datagram tối đa cho phép là 1200 byte.
Điều này xác minh rằng đường có thể mang các datagram có kích thước
này ở cả hai hướng. Tuy nhiên, một endpoint PHẢI KHÔNG mở rộng datagram
chứa PATH_RESPONSE nếu dữ liệu kết quả vượt quá
giới hạn chống khuếch đại. Điều này dự kiến chỉ xảy ra nếu
PATH_CHALLENGE nhận được không được gửi trong một datagram mở rộng.

Một endpoint PHẢI KHÔNG gửi nhiều hơn một khung PATH_RESPONSE
trong phản hồi cho một khung PATH_CHALLENGE; xem Phần 13.3. Đồng đẳng
được mong đợi gửi thêm các khung PATH_CHALLENGE nếu cần để kích hoạt
các khung PATH_RESPONSE bổ sung.

Xác định đường dẫn thành công
```````````````````````````````````````````````````````

Xác định đường dẫn thành công khi một khung PATH_RESPONSE được nhận
chứa dữ liệu đã được gửi trong một khung PATH_CHALLENGE trước đó.
Một khung PATH_RESPONSE nhận được trên bất kỳ đường nào xác nhận đường
mà PATH_CHALLENGE đã được gửi.

Nếu một endpoint gửi một khung PATH_CHALLENGE trong một datagram không được
mở rộng tới ít nhất 1200 byte và nếu phản hồi cho nó xác nhận
địa chỉ đồng đẳng, đường được xác nhận nhưng không phải đường PMTU. Kết quả là,
endpoint có thể gửi nhiều hơn ba lần lượng dữ liệu mà đã được nhận.
Tuy nhiên, endpoint PHẢI bắt đầu xác định đường khác bằng cách
gửi một khung PATH_CHALLENGE trong một datagram lớn hơn để xác nhận rằng
đường hỗ trợ yêu cầu PMTU.

Nhận được một xác nhận cho một gói chứa một khung PATH_CHALLENGE
không đủ để xác nhận, vì xác nhận đó có thể được
giả mạo bởi một đồng đẳng độc hại.

Xác định đường dẫn thất bại
```````````````````````````````````````````````````````

Xác định đường chỉ thất bại khi endpoint cố gắng xác định
đường bỏ qua nỗ lực của nó để xác định đường.

Các endpoint NÊN bỏ qua xác định đường dựa trên một bộ hẹn giờ.
Khi đặt bộ hẹn giờ này, các triển khai được cảnh báo rằng đường
mới có thể có thời gian vòng tròn lớn hơn so với đường gốc.
Một giá trị của ba lần giá trị lớn hơn của PTO hiện tại hoặc PTO
cho đường mới (sử dụng kInitialRtt, như được định nghĩa trong [QUIC-RECOVERY]) được
KHUYẾN NGHỊ.

Thời gian chờ này cho phép nhiều PTO hết hạn trước khi xác định
đường thất bại, để mất một PATH_CHALLENGE hoặc PATH_RESPONSE duy nhất
không gây ra xác định đường thất bại.

Lưu ý rằng endpoint có thể

nhận khác các gói chứa các khung khác

 trên đường mới, nhưng một khung PATH_RESPONSE với dữ liệu phù hợp
được yêu cầu để xác định đường thành công.
````````````````````````````````````````
Khi một endpoint từ bỏ xác định, nó xác định rằng

đường không hoạt động được. Điều này không nhất thiết

imply a failure of the
connection -- endpoints can continue sending packets over other paths
as appropriate.

----------
A path validation
An endpoint without any successful network path to its peer MAY signal
this using the NO_VIABLE_PATH error connection, noting that this is only possible if
the path exists but does not support the required MTU
(Section 14).
``````````````````````````
```

Note: SSU là lớp giao thức cuối cùng yêu cầu ElGamal
SSU2 is based on Noise Protocol Noise_XK_25519_ChaChaPoly_SHA256.
The identifier for the initial key derivation function is "Noise_XK chaobfse+hs1+hs2+hs3_25519_ChaChaPoly_SHA256"
(see KDF 1 section below).
