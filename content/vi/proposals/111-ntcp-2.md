---
title: "NTCP 2"
number: "111"
author: "EinMByte, orignal, psi, str4d, zzz"
created: "2014-02-13"
lastupdated: "2019-08-13"
status: "Closed"
thread: "http://zzz.i2p/topics/1577"
supercedes: "106"
target: "0.9.36"
implementedin: "0.9.36"
editor: "manas, str4d, zzz"
---

## Lưu ý
Giai đoạn đề xuất đã kết thúc.
Xem [SPEC](/en/docs/spec/ntcp2/) để biết đặc tả chính thức.
Đề xuất này vẫn có thể được tham khảo để có thông tin nền.


## Tổng quan

Đề xuất này mô tả một giao thức thỏa thuận khóa được xác thực nhằm cải thiện khả năng chống lại các hình thức tấn công và xác định tự động khác nhau của [NTCP](/en/docs/transport/ntcp/).

Đề xuất được tổ chức như sau: các mục tiêu bảo mật được trình bày, tiếp theo là thảo luận về giao thức cơ bản. Tiếp theo, đặc tả đầy đủ của tất cả các thông điệp giao thức được đưa ra. Cuối cùng, địa chỉ của bộ định tuyến và nhận dạng phiên bản được thảo luận. Phụ lục thảo luận về một cuộc tấn công chung vào các sơ đồ đệm điển hình cũng được bao gồm, cũng như một phụ lục chứa một số ứng viên cho mật mã được xác thực.

Như với các phương thức truyền tải I2P khác, NTCP2 được định nghĩa chỉ để truyền tải điểm-điểm (bộ định tuyến-tới-bộ định tuyến) của các thông điệp I2NP. Nó không phải là một đường truyền dữ liệu đa dụng.


## Động lực

Dữ liệu [NTCP](/en/docs/transport/ntcp/) được mã hóa sau thông điệp đầu tiên (đồng thời thông điệp đầu tiên xuất hiện dưới dạng dữ liệu ngẫu nhiên), do đó ngăn chặn việc xác định giao thức thông qua "phân tích tải trọng". Nó vẫn dễ bị tổn thương bởi việc xác định giao thức thông qua "phân tích luồng". Đó là vì 4 thông điệp đầu tiên (có nghĩa là tiến trình bắt tay) có chiều dài cố định (288, 304, 448 và 48 byte).

Bằng cách thêm lượng dữ liệu ngẫu nhiên ngẫu nhiên vào mỗi thông điệp, chúng ta có thể làm cho việc xác định trở nên khó khăn hơn nhiều.

Các tác giả thừa nhận rằng thực hành bảo mật tiêu chuẩn sẽ gợi ý sử dụng một giao thức hiện có như TLS, nhưng đây là [Prop104](/en/proposals/104/) và nó có những vấn đề riêng của nó. Ở bất kỳ nơi nào thích hợp, các đoạn "công việc trong tương lai" đã được thêm vào để chỉ ra các tính năng thiếu hoặc các chủ đề thảo luận.


## Mục tiêu thiết kế

- Hỗ trợ NTCP 1 và 2 trên một cổng duy nhất, tự động phát hiện và công khai như một "transport" đơn lẻ (tức là [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) trong [NetDB](/en/docs/how/network-database/).

- Công khai hỗ trợ cho phiên bản 1 chỉ, 2 chỉ hoặc 1+2 trong NetDB trong một trường riêng và mặc định cho phiên bản 1 chỉ (không ràng buộc hỗ trợ phiên bản với một phiên bản bộ định tuyến cụ thể)

- Đảm bảo rằng tất cả các triển khai (Java/i2pd/Kovri/go) có thể thêm hỗ trợ phiên bản 2 (hoặc không) theo lịch trình riêng của họ

- Thêm đệm ngẫu nhiên vào tất cả các thông điệp NTCP bao gồm các thông điệp bắt tay và dữ liệu (tức là làm mờ độ dài để tất cả các thông điệp không phải là bội của 16 byte). Cung cấp cơ chế tùy chọn cho cả hai bên để yêu cầu đệm tối thiểu và tối đa và/hoặc phân phối đệm. Các thông số cụ thể của phân phối đệm phụ thuộc vào triển khai và có thể hoặc không được quy định trong chính giao thức.

- Mở mờ nội dung của các thông điệp không được mã hóa (1 và 2), đủ để các hộp DPI và chữ ký AV không thể dễ dàng phân loại chúng. Cũng đảm bảo rằng các thông điệp gửi đến một đối tượng duy nhất hoặc một tập đối tượng không có một mẫu bit giống nhau.

- Sửa mất bits trong DH do định dạng Java [Ticket1112](https://trac.i2p2.i2p/ticket/1112), có thể (và có lẽ) bằng cách chuyển sang X25519.

- Chuyển sang một hàm dẫn xuất khóa (KDF) thực sự thay vì sử dụng kết quả DH nguyên bản?

- Thêm "kháng thăm dò" (theo cách gọi của Tor); điều này bao gồm kháng lại phát lại.

- Duy trì trao đổi khóa được xác thực 2 chiều (2W-AKE). 1W-AKE là không đủ cho ứng dụng của chúng tôi.

- Tiếp tục sử dụng các loại chữ ký có biến đổi, biến độ dài (từ khóa ký [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) đã được công khai) như một phần của xác thực. Dựa vào một khóa công khai tĩnh được công khai trong RouterInfo như là phần khác của xác thực.

- Thêm tùy chọn/phiên bản trong bắt tay để mở rộng trong tương lai.

- Thêm kháng lại phân đoạn TCP độc hại nếu có thể.

- Không tăng thêm đáng kể CPU yêu cầu cho thiết lập kết nối; nếu có thể, giảm đáng kể.

- Thêm xác thực thông điệp (MAC), có thể là HMAC-SHA256 và Poly1305, và loại bỏ kiểm tra Adler.

- Rút ngắn và đơn giản hóa tiêu đề I2NP:
  Rút ngắn thời gian hết hạn xuống 4 byte, như trong SSU.
  Loại bỏ mã kiểm tra SHA256 rút gọn một byte.

- Nếu có thể, giảm bắt tay 4 thông điệp, hai vòng lặp xuống 3 thông điệp, một vòng lặp, như trong [SSU](/en/docs/transport/ssu/). Điều này sẽ yêu cầu chuyển chữ ký của Bob trong thông điệp 4 sang thông điệp 2. Nghiên cứu lý do cho 4 thông điệp trong các email/trạng thái/cuộc gặp mười năm trước.

- Giảm thiểu chi phí giao thức trước khi đệm. Trong khi đệm sẽ được thêm vào, và có thể rất nhiều, chi phí trước khi đệm vẫn là chi phí. Các nút băng thông thấp phải có thể sử dụng NTCP2.

- Duy trì dấu thời gian để phát hiện phát lại và lệch.

- Tránh bất kỳ vấn đề nào về năm 2038 trong dấu thời gian, phải hoạt động ít nhất đến năm 2106.

- Tăng kích thước thông điệp tối đa từ 16K lên 32K hoặc 64K.

- Bất kỳ nguyên thủy mã hóa mới nào cần có sẵn dễ dàng trong các thư viện để sử dụng trong các triển khai bộ định tuyến Java (1.7), C++, và Go.

- Bao gồm đại diện của các nhà phát triển bộ định tuyến Java, C++, và Go trong thiết kế.

- Giảm thiểu thay đổi (nhưng vẫn sẽ có rất nhiều).

- Hỗ trợ cả hai phiên bản trong một tập hợp mã chung (điều này có thể không thể thực hiện và phụ thuộc vào triển khai trong bất kỳ trường hợp nào).


### Những mục không phải mục tiêu

- Khả năng chống lại DPI một cách đầy đủ... đó sẽ là các trao đổi vận hành cắm được, [Prop109](/en/proposals/109/).

- Một vận chuyển dựa trên TLS (hoặc mô phỏng HTTPS)... đó sẽ là [Prop104](/en/proposals/104/).

- Có thể thay đổi mã hóa dòng đối xứng.

- Khả năng chống lại DPI dựa trên thời gian (thời gian/khoảng cách giữa các thông điệp có thể phụ thuộc vào triển khai; trì hoãn giữa thông điệp có thể được giới thiệu ở bất kỳ điểm nào, bao gồm trước khi gửi đệm ngẫu nhiên, chẳng hạn). Các trì hoãn nhân tạo (mà obfs4 gọi là IAT hoặc thời gian đến) là độc lập với chính giao thức.

- Tính phủ nhận khi tham gia vào một phiên (có chữ ký trong đó).

Các mục không phải mục tiêu nhưng có thể được cân nhắc hoặc thảo luận lại một phần:

- Mức độ bảo vệ chống lại kiểm tra gói sâu (DPI)

- Bảo mật sau lượng tử

- Khả năng phủ nhận



### Những mục tiêu liên quan

- Triển khai một thiết lập thử nghiệm NTCP 1/2

## Mục tiêu bảo mật

Ta cân nhắc ba người tham gia:

- Alice, người muốn thiết lập một phiên mới.
- Bob, người mà Alice muốn thiết lập một phiên.
- Mallory, "người đứng giữa" giữa Alice và Bob.

Tối đa hai người tham gia có thể thực hiện các cuộc tấn công chủ động.

Cả Alice và Bob đều sở hữu một cặp khóa tĩnh, chứa trong [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) của họ.

Giao thức đề xuất cố gắng cho phép Alice và Bob đồng ý trên một khóa bí mật chung (K) theo các yêu cầu sau:

1) Bảo mật khóa riêng: cả Bob lẫn Mallory không học được gì về khóa riêng tĩnh của Alice. Ngược lại, Alice không học được gì về khóa riêng tĩnh của Bob.

2) Khóa phiên K chỉ được biết bởi Alice và Bob.

3) Bảo mật truyền tiếp hoàn hảo: khóa phiên đã đồng ý vẫn giữ bí mật trong tương lai, ngay cả khi các khóa riêng tĩnh của Alice và/hoặc Bob bị công khai sau khi khóa đã được đồng ý.

4) Xác thực hai chiều: Alice chắc chắn rằng cô đã thiết lập một phiên với Bob, và ngược lại.

5) Bảo vệ chống lại DPI trực tuyến: Đảm bảo rằng không dễ dàng phát hiện rằng Alice và Bob đang tham gia vào giao thức chỉ bằng các kỹ thuật kiểm tra gói sâu trực tiếp. Xem dưới đây.

6) Khả năng phủ nhận hạn chế: cả Alice lẫn Bob không thể phủ nhận tham gia vào giao thức, nhưng nếu một trong hai tiết lộ khóa chung, bên kia có thể phủ nhận tính xác thực của nội dung dữ liệu được truyền.

Đề xuất hiện tại cố gắng cung cấp tất cả năm yêu cầu này dựa trên giao thức Station-To-Station (STS) [STS]_. Lưu ý rằng giao thức này cũng là cơ sở cho giao thức [SSU](/en/docs/transport/ssu/).


### Thảo luận bổ sung về DPI

Ta giả định hai thành phần DPI:

1) DPI trực tuyến
`````````````````

DPI trực tuyến kiểm tra tất cả các luồng trong thời gian thực. Các kết nối có thể bị chặn hoặc bị sửa đổi. Dữ liệu hoặc metadata kết nối có thể bị xác định và lưu trữ để phân tích ngoại tuyến. DPI trực tuyến không có quyền truy cập vào cơ sở dữ liệu mạng I2P. DPI trực tuyến chỉ có khả năng tính toán giới hạn trong thời gian thực, bao gồm tính toán độ dài, kiểm tra trường và các phép tính đơn giản như XOR. DPI trực tuyến có khả năng các hàm mã hóa nhanh trong thời gian thực như AES, AEAD, và băm, nhưng những điều này sẽ quá tốn kém để áp dụng cho hầu hết hoặc tất cả các luồng. Bất kỳ ứng dụng nào của các hoạt động mã hóa này sẽ chỉ áp dụng cho các luồng trên các tổ hợp IP/Port đã được nhận diện bằng phân tích ngoại tuyến. DPI trực tuyến không có khả năng các hàm mã hóa có chi phí cao như DH hay elligator2. DPI trực tuyến không được thiết kế cụ thể để phát hiện I2P, mặc dù có thể có các quy tắc phân loại hạn chế cho mục đích đó.

Mục tiêu là ngăn chặn xác định giao thức bằng DPI trực tuyến.

Khái niệm về DPI trực tuyến hoặc DPI "trực tiếp" ở đây được lấy để bao gồm các khả năng của kẻ địch sau:

1) Khả năng kiểm tra tất cả dữ liệu được gửi hoặc nhận bởi mục tiêu.

2) Khả năng thực hiện các phép toán trên các dữ liệu quan sát, chẳng hạn như áp dụng các mã khối hoặc hàm băm.

3) Khả năng lưu trữ và so sánh với các thông điệp đã gửi trước đó.

4) Khả năng sửa đổi, trì hoãn hoặc phân đoạn các gói.

Tuy nhiên, DPI trực tuyến được giả định có những hạn chế sau:

5) Không khả năng ánh xạ địa chỉ IP sang băm bộ định tuyến. Mặc dù điều này là tầm thường với quyền truy cập thời gian thực vào cơ sở dữ liệu mạng,
   điều này sẽ yêu cầu một hệ thống DPI được thiết kế đặc biệt để nhắm mục tiêu I2P.

6) Không khả năng sử dụng thông tin thời gian để phát hiện giao thức. 

7) Nói chung, hộp công cụ DPI trực tuyến không chứa bất kỳ công cụ tích hợp nào được thiết kế cụ thể để phát hiện I2P. Điều này bao gồm
   tạo ra các "honeypots", điều này có thể bao gồm, ví dụ, đệm không ngẫu nhiên trong các thông điệp của họ. Lưu ý rằng điều này không loại trừ
   các hệ thống học máy hoặc công cụ DPI có thể cấu hình cao miễn là chúng đáp ứng các yêu cầu khác.

Để chống lại phân tích tải trọng, đảm bảo rằng tất cả thông điệp là không phân biệt từ ngẫu nhiên. Điều này cũng yêu cầu độ dài của chúng phải ngẫu nhiên, phức tạp hơn chỉ đơn giản là thêm đệm ngẫu nhiên. Thực tế, trong Phụ lục A, các tác giả lập luận rằng một sơ đồ đệm ngây thơ (tức là dạng đồng nhất) không giải quyết vấn đề. Phụ lục A do đó đề xuất bao gồm hoặc các độ trễ ngẫu nhiên hoặc phát triển một sơ đồ đệm thay thế có thể cung cấp sự bảo vệ hợp lý cho cuộc tấn công được đề xuất.

Để bảo vệ chống lại điểm vào thứ sáu ở trên, các triển khai nên bao gồm các độ trễ ngẫu nhiên trong giao thức. Các kỹ thuật này không được đề cập trong đề xuất này, nhưng chúng cũng có thể giải quyết các vấn đề độ dài đệm. Tóm lại, đề xuất cung cấp sự bảo vệ tốt trước phân tích tải trọng (khi các cân nhắc trong Phụ lục A được xem xét), nhưng chỉ cung cấp sự bảo vệ hạn chế trước phân tích luồng.


2) DPI ngoại tuyến
`````````````````

DPI ngoại tuyến kiểm tra dữ liệu được lưu trữ bởi DPI trực tuyến để phân tích sau này.
DPI ngoại tuyến có thể được thiết kế đặc biệt để phát hiện I2P.
DPI ngoại tuyến có quyền truy cập thời gian thực vào cơ sở dữ liệu mạng I2P.
DPI ngoại tuyến có quyền truy cập vào đặc tả này và các đặc tả I2P khác.
DPI ngoại tuyến có khả năng tính toán không giới hạn, bao gồm tất cả các hàm mã hóa được định nghĩa trong đặc tả này.

DPI ngoại tuyến không có khả năng chặn các kết nối hiện có.
DPI ngoại tuyến có khả năng gần-thời gian thực (trong vòng vài phút từ khi thiết lập) gửi đến host/port của các bên, ví dụ TCP RST.
DPI ngoại tuyến có khả năng gần-thời gian thực (trong vòng vài phút từ khi thiết lập) phát lại các thông điệp trước đó (đã chỉnh sửa hoặc không) vì lý do "thăm dò" hoặc lý do khác.

Mục tiêu không phải là ngăn chặn nhận diện giao thức bởi một DPI ngoại tuyến.
Tất cả việc giải mã dữ liệu đã được làm mờ trong hai thông điệp đầu tiên,
chẳng hạn như được triển khai bởi I2P routers, cũng có thể được triển khai bởi DPI ngoại tuyến.

Mục tiêu là từ chối các cố gắng kết nối sử dụng phát lại các thông điệp trước đó.
  
Công việc trong tương lai
`````````````

- Xem xét hành vi của giao thức khi các gói bị rớt hoặc được đặt lại thứ tự bởi kẻ tấn công. Công việc thú vị gần đây trong lĩnh vực này có thể được tìm thấy trong
  [IACR-1150](https://eprint.iacr.org/2015/1150).

- Cung cấp phân loại chính xác hơn cho các hệ thống DPI, tính toán xem xét
  tài liệu hiện có liên quan đến vấn đề này.

- Thảo luận về tính bảo mật chính thức của giao thức đề xuất, lý tưởng là tính đến mô hình tấn công DPI.


## Khung giao thức Noise

Đề xuất này cung cấp các yêu cầu dựa trên Khung giao thức Noise
[NOISE](http://noiseprotocol.org/) (Phiên bản 33, 2017-10-04).
Noise có các thuộc tính tương tự như giao thức Station-To-Station
[STS]_, là cơ sở cho giao thức [SSU](/en/docs/transport/ssu/). Theo cách nói của Noise, Alice
là người khởi tạo, và Bob là người phản hồi.

NTCP2 dựa trên giao thức Noise Noise_XK_25519_ChaChaPoly_SHA256.
(Thực tế, định danh cho hàm dẫn xuất khóa ban đầu
là "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256"
để chỉ ra các tiện ích bổ sung của I2P - xem phần KDF 1 dưới đây)
Giao thức Noise này sử dụng các nguyên thủy sau:

- Mẫu bắt tay: XK
  Alice truyền khóa của mình cho Bob (X)
  Alice biết khóa tĩnh của Bob đã (K)

- Chức năng DH: X25519
  X25519 DH với độ dài khóa 32 byte được chỉ định trong [RFC-7748](https://tools.ietf.org/html/rfc7748).

- Chức năng mã: ChaChaPoly
  AEAD_CHACHA20_POLY1305 được chỉ định trong [RFC-7539](https://tools.ietf.org/html/rfc7539) phần 2.8.
  Một trình đếm nonce 12 byte, với bốn byte đầu tiên được đặt thành không.

- Hàm băm: SHA256
  Băm chuẩn 32-byte, đã được sử dụng rộng rãi trong I2P.


## Bổ sung cho Khung

Đề xuất này định nghĩa các tiện ích bổ sung sau cho 
Noise_XK_25519_ChaChaPoly_SHA256. Những điều này nhìn chung sẽ theo các hướng dẫn trong
[NOISE](http://noiseprotocol.org/) phần 13.

1) Các khóa tạm thời rõ ràng được làm mờ với mã hóa AES sử dụng một khóa đã biết và IV. Điều này nhanh hơn elligator2.

2) Thêm đệm ngẫu nhiên vào thông điệp 1 và 2.
   Đệm rõ ràng được bao gồm trong tính toán băm bắt tay (MixHash).
   Xem các phần KDF dưới đây cho thông điệp 2 và phần 1 của thông điệp 3.
   Đệm ngẫu nhiên AEAD được thêm vào thông điệp 3 và các thông điệp pha dữ liệu.

3) Một trường độ dài hai byte được thêm vào, như cần thiết cho Noise qua TCP,
   và như trong obfs4. Điều này chỉ được sử dụng trong các thông điệp pha dữ liệu.
   Thông điệp 1 và 2 AEAD là các khung có độ dài cố định.
   Phần 1 của thông điệp 3 AEAD có độ dài cố định.
   Độ dài khung của phần 2 thông điệp 3 được chỉ định trong thông điệp 1.

4) Trường độ dài hai byte được làm mờ với SipHash-2-4,
   như trong obfs4.

5) Định dạng tải trọng được định nghĩa cho các thông điệp 1,2,3 và pha dữ liệu.
   Tất nhiên, điều này không được định nghĩa trong Noise.


## Nguyên thủy mã hóa mới cho I2P

Các triển khai bộ định tuyến I2P hiện có sẽ yêu cầu triển khai cho
các nguyên thủy mã hóa tiêu chuẩn sau,
vốn không yêu cầu cho các giao thức I2P hiện tại:

1) Tạo khóa và DH X25519

2) AEAD_ChaCha20_Poly1305 (viết tắt là ChaChaPoly dưới đây)

3) SipHash-2-4


## Ước tính chi phí xử lý

Kích thước thông điệp cho 3 thông điệp:

1) 64 byte + đệm   (NTCP là 288 byte)
2) 64 byte + đệm   (NTCP là 304 byte)
3) khoảng 64 byte + Alice router info + đệm   Trung bình router info là khoảng 750
   byte   Tổng trung bình 814 byte trước khi đệm (NTCP là 448 byte)
4) không yêu cầu trong NTCP2   (NTCP là 48 byte)

Tổng trước khi đệm:
NTCP2: 942 byte
NTCP: 1088 byte
Lưu ý rằng nếu Alice kết nối với Bob để gửi
một thông điệp DatabaseStore của RouterInfo của cô ấy, thông điệp đó không cần thiết,
tiết kiệm khoảng 800 byte.

Các hoạt động mã hóa sau đây được yêu cầu bởi mỗi bên để hoàn thành
bắt tay và bắt đầu pha dữ liệu:

- AES: 2
- SHA256: 7 (Alice), 6 (Bob) (không bao gồm 1 Alice, 2 Bob được tính toán trước cho
  tất cả các kết nối) (không bao gồm HMAC-SHA256)
- HMAC-SHA256: 19
- ChaChaPoly: 4
- Tạo khóa X25519: 1
- X25519 DH: 3
- Xác thực chữ ký: 1 (Bob) (Alice đã ký khi tạo RI của cô ấy) Theo giả định Ed25519 (phụ thuộc vào loại chữ ký RI)


Các hoạt động mã hóa sau đây được yêu cầu bởi mỗi bên cho mỗi thông điệp pha dữ liệu:

- SipHash: 1
- ChaChaPoly: 1



## Thông điệp

Tất cả các thông điệp NTCP2 có độ dài nhỏ hơn hoặc bằng 65537 byte. Định dạng thông điệp được dựa trên các thông điệp Noise, với các sửa đổi cho khung và sự không phân biệt. 
Các triển khai sử dụng thư viện Noise tiêu chuẩn có thể cần phải xử lý trước các thông điệp nhận để từ / tới định dạng thông điệp Noise. Tất cả các trường được mã hóa là các mã văn bản AEAD.


Quá trình thiết lập như sau:

Alice                           Bob

  Yêu cầu Phiên ------------------->
  <------------------- Đã tạo Phiên
  Xác nhận Phiên ----------------->
Sử dụng thuật ngữ Noise, trình tự thiết lập và pha dữ liệu là như sau:
(Tính chất bảo mật tải trọng)

XK(s, rs):           Chứng thực   Bảo mật
    <- s
    ...
    -> e, es                  0                2
    <- e, ee                  2                1
    -> s, se                  2                5
    <-                        2                5
Khi một phiên đã được thiết lập, Alice và Bob có thể trao đổi các thông điệp Data (Dữ liệu).

Tất cả các loại thông điệp (Yêu cầu Phiên, Đã tạo Phiên, Xác nhận Phiên, Dữ liệu và Đồng bộ Thời gian) được chỉ định trong phần này.

Một số ký hiệu::

  - RH_A = Băm Bộ định tuyến cho Alice (32 byte)
  - RH_B = Băm Bộ định tuyến cho Bob (32 byte)


### Mã hóa Xác thực

Có ba mã hóa xác thực riêng biệt (CipherStates).
Một trong pha bắt tay, và hai (truyền và nhận) cho pha dữ liệu.
Mỗi cái có khóa riêng của nó từ một KDF.

Dữ liệu được mã hóa/xác thực sẽ được biểu diễn dưới dạng 

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   Dữ liệu đã được mã hóa và xác thực   |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
ChaCha20/Poly1305
`````````````````

Định dạng dữ liệu đã được mã hóa và xác thực.

Đầu vào cho các hàm mã hóa/giải mã:

k :: Khóa mã hóa 32 byte, như được tạo từ KDF

  nonce :: Nonce dựa trên đếm, 12 byte.
           Bắt đầu từ 0 và tăng lên cho mỗi thông điệp.
           Bốn byte đầu tiên luôn bằng không.
           Bốn byte cuối cùng là bộ đếm, được mã hóa little-endian.
           Giá trị tối đa là 2**64 - 2.
           Kết nối phải bị đóng và khởi động lại sau khi
           nó đạt giá trị đó.
           Giá trị 2**64 - 1 không bao giờ được gửi đi.

  ad :: Trong pha bắt tay:
        Dữ liệu liên kết, 32 byte.
        Giá trị băm SHA256 của tất cả dữ liệu đã gửi đi trước đó.
        Trong pha dữ liệu:
        Mức không byte

  data :: Dữ liệu plain text, 0 hoặc nhiều byte

Đầu ra của hàm mã hóa, đầu vào của hàm giải mã:

+----+----+----+----+----+----+----+----+
  |Obfs Len |                             |
  +----+----+                             +
  |       Dữ liệu đã được mã hóa ChaCha20       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Mã xác thực tin nhắn Poly1305              |
  +              (MAC)                    +
  |             16 byte                  |
  +----+----+----+----+----+----+----+----+

  Obfs Len :: Độ dài của (dữ liệu mã hóa + MAC) tiếp theo, 16 - 65535
              Sử dụng obfuscation với SipHash (xem dưới đây)
              Không sử dụng trong thông điệp 1 hoặc 2, hoặc phần 1 của thông điệp 3, nơi độ dài là cố định
              Không sử dụng trong phần 1 thông điệp 3, vì độ dài được chỉ định trong thông điệp 1

  dữ liệu mã hóa :: Cùng kích thước với dữ liệu plain text, 0 - 65519 byte

  MAC :: Mã xác thực tin nhắn Poly1305, 16 byte

Đối với ChaCha20, những gì được mô tả ở đây tương ứng với [RFC-7539](https://tools.ietf.org/html/rfc7539), cũng được sử dụng tương tự trong TLS [RFC-7905](https://tools.ietf.org/html/rfc7905).

Ghi chú
`````
- Vì ChaCha20 là một mã stream, plain text không cần được đệm.
  Các byte keystream bổ sung sẽ bị loại bỏ.

- Khóa cho mã (256 bit) được đồng ý bằng cách sử dụng
  SHA256 KDF. Chi tiết của KDF cho mỗi thông điệp nằm trong các phần riêng biệt dưới đây.

- Các khung ChaChaPoly cho thông điệp 1, 2, và phần đầu tiên của thông điệp 3,
  là kích thước đã biết. Bắt đầu từ phần thứ hai của thông điệp 3,
  khung là kích thước biến thiên. Kích thước phần 1 thông điệp 3 được chỉ định trong thông điệp 1.
  Bắt đầu từ pha dữ liệu, khung được đặt trước với một độ dài hai byte đã được làm mờ bằng SipHash như trong obfs4.

- Đệm nằm ngoài khung dữ liệu được xác thực cho thông điệp 1 và 2.
  Đệm được sử dụng trong KDF cho thông điệp tiếp theo để bất kỳ sửa đổi nào cũng sẽ
  gây ra việc lỗi thông điệp tiếp theo. Bắt đầu từ thông điệp 3, đệm nằm trong khung dữ liệu được xác thực.


Xử lý lỗi AEAD
```````````````````
- Trong thông điệp 1, 2, và phần 1 và 2 của thông điệp 3, kích thước thông điệp AEAD đã biết trước. 
  Trên thất bại xác thực AEAD, người nhận phải dừng xử lý thông báo và đóng kết nối mà không
  phản hồi lại. Điều này nên là một lần đóng bất thường (TCP RST).

- Để kháng lại thăm dò, trong thông điệp 1, sau khi một AEAD thất bại, Bob nên
  đặt một thời gian chờ ngẫu nhiên (phạm vi TBD) và sau đó đọc một
  số byte ngẫu nhiên (phạm vi TBD) trước khi đóng socket. 
  Bob nên duy trì một danh sách đen của các IP với
  các lần thất bại lặp lại.

- Trong pha dữ liệu, kích thước thông điệp AEAD được mã hóa 
  (làm mờ) với SipHash. Chú ý cần được đưa ra để tránh tạo ra một 
  oracle giải mã. Trên một thất bại xác thực AEAD pha dữ liệu, người nhận nên
  đặt một thời gian chờ ngẫu nhiên (phạm vi TBD) và sau đó đọc một số byte ngẫu nhiên
  (phạm vi TBD). Sau khi đọc, hoặc trên thời gian chờ đọc, người nhận nên gửi một tải trọng
  với một khối chấm dứt chứa một mã lý do "AEAD thất bại", 
  và đóng kết nối. 

- Thực hiện cùng một hành động lỗi đối với một giá trị trường độ dài không hợp lệ trong pha dữ liệu.


### Hàm dẫn xuất khóa (KDF) (cho thông điệp bắt tay 1)

KDF tạo ra một mã khóa pha bắt tay từ kết quả DH, sử dụng HMAC-SHA256(key, data) như được định nghĩa trong [RFC-2104](https://tools.ietf.org/html/rfc2104).
Đây là các hàm InitializeSymmetric(), MixHash(), và MixKey(), chính xác như được định nghĩa trong đặc tả Noise.

Đây là mẫu thông điệp "e":

  // Định nghĩa protocol_name.
  Set protocol_name = "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256"
   (48 byte, mã hóa US-ASCII, không kết thúc NULL).

  // Định nghĩa Hash h = 32 byte
  h = SHA256(protocol_name);

  Định nghĩa ck = mã nối 32 byte. Sao chép dữ liệu h vào ck.
  Set ck = h

  Định nghĩa rs = Khóa tĩnh 32-byte của Bob như được công bố trong RouterInfo

  // MixHash(thuần vô pháp)
  h = SHA256(h);

  // đến đây, tất cả có thể được tính sẵn bởi Alice cho tất cả các kết nối ra

  // Alice phải xác nhận rằng khóa tĩnh của Bob là một điểm hợp lệ trên đường cong ở đây.

  // Khóa tĩnh của Bob
  // MixHash(rs)
  // || dưới đây có nghĩa là nối
  h = SHA256(h || rs);

  // đến đây, tất cả có thể được tính sẵn bởi Bob cho tất cả các kết nối đi vào

  Đây là mẫu thông điệp "e":

  Alice tạo cặp khóa DH tạm thời của cô.

  // Khóa tạm thời X của Alice
  // MixHash(e.pubkey)
  // || dưới đây có nghĩa là nối
  h = SHA256(h || e.pubkey);

  // h được sử dụng như dữ liệu liên kết cho AEAD trong thông điệp 1
  // Giữ lại Hash h cho KDF của thông điệp 2


  Kết thúc của mẫu thông điệp "e".

  Đây là mẫu thông điệp "es":

  // DH(e, rs) == DH(s, re)
  Định nghĩa input_key_material = Kết quả DH 32 byte của khóa tạm thời của Alice và khóa tĩnh của Bob
  Set input_key_material = Kết quả DH X25519

  // MixKey(DH())

  Định nghĩa temp_key = 32 byte
  Định nghĩa HMAC-SHA256(khóa, dữ liệu) như trong [RFC-2104](https://tools.ietf.org/html/rfc2104)
  // Tạo một mã khóa tạm thời từ mã nối và kết quả DH
  // ck là mã nối, định nghĩa ở trên
  temp_key = HMAC-SHA256(ck, input_key_material)
  // ghi đè kết quả DH trong bộ nhớ, không cần thiết nữa
  input_key_material = (tất cả số không)

  // Đầu ra 1
  // Đặt một mã nối mới từ mã khóa tạm
  // byte() nghĩa là một byte
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // Đầu ra 2
  // Tạo mã khóa k
  Định nghĩa k = 32 byte
  // || nghĩa là nối
  // byte() nghĩa là một byte
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
  // ghi đè temp_key trong bộ nhớ, không cần thiết nữa
  temp_key = (tất cả số không)

  // giữ mã nối ck cho KDF thông điệp 2


  Kết thúc của mẫu thông điệp "es".

### 1) Yêu cầu Phiên

Alice gửi đến Bob.

Nội dung Noise: Khóa tạm thời X của Alice
Tải trọng Noise: khối tùy chọn 16 byte
Tải trọng phi Noise: đệm ngẫu nhiên 

(Tính chất bảo mật tải trọng)

XK(s, rs):           Chứng thực   Bảo mật
    -> e, es                  0                2

    Chứng thực: Không (0).
    Tải trọng này có thể được gửi bởi bất kỳ bên nào, bao gồm một kẻ tấn công chủ động.

    Bảo mật: 2.
    Mã hóa cho một người nhận đã biết, bảo mật truyền tiếp cho bên gửi mà chỉ, dễ bị phát lại. Tải trọng này được mã hóa chỉ dựa trên DHs
    liên quan đến cặp khóa tĩnh của người nhận. Nếu khóa riêng tĩnh của người nhận bị công khai, thậm chí là sau này, tải trọng này có thể được giải mã. Thông điệp này cũng có thể bị phát lại, vì không có phần đóng góp tạm thời từ người nhận.

    "e": Alice tạo một cặp khóa tạm thời mới và lưu trữ nó trong biến e,
         viết khóa công khai tạm thời như dữ liệu rõ ràng vào bộ đệm thông điệp, và băm khóa công khai cùng với h cũ để
         tạo một h mới.

    "es": Một DH được thực hiện giữa khóa tạm thời của Alice và khóa tĩnh của Bob.
          Kết quả được băm cùng với ck cũ để tạo ra một ck và k mới, và n được đặt thành không.


Giá trị X được mã hóa để đảm bảo tính không phân biệt và duy nhất của tải trọng, điều cần thiết là các biện pháp đối phó với DPI. Ta sử dụng mã hóa AES để đạt được điều này, thay vì các phương pháp phức tạp hơn và chậm hơn như elligator2.
Mã hóa không đối xứng với khóa công khai của bộ định tuyến của Bob sẽ quá chậm.
Mã hóa AES sử dụng băm bộ định tuyến của Bob làm khóa và IV của Bob như được công bố trong cơ sở dữ liệu mạng.

Mã hóa AES chỉ để kháng lại DPI. Bất kỳ bên nào biết băm bộ định tuyến của Bob và IV, được công bố trong cơ sở dữ liệu mạng, có thể giải mã giá trị X trong thông điệp này.

Đệm không được mã hóa bởi Alice. Có thể cần cho Bob phải giải mã đệm, để ngăn chặn các cuộc tấn công dựa trên thời gian.


Nội dung thô:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        làm mờ với RH_B                +
  |       Mã hóa AES-CBC-256 của X        |
  +             (32 byte)                 +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   Khung ChaChaPoly                    |
  +             (32 byte)                 +
  |   k định nghĩa trong KDF cho thông điệp 1      |
  +   n = 0                               +
  |   xem KDF cho dữ liệu liên kết         |
  +----+----+----+----+----+----+----+----+
  |     đệm được xác thực không mã hóa         |
  ~            đệm động (tùy chọn)             ~
  |     độ dài định nghĩa trong khối tùy chọn   |
  +----+----+----+----+----+----+----+----+

  X :: 32 byte, mã hóa AES-256-CBC của khóa tạm thời X25519, little endian
          khóa: RH_B
          iv: Như được công bố trong mục cơ sở dữ liệu mạng của Bob

  padding :: Dữ liệu ngẫu nhiên, 0 hoặc nhiều byte.
             Tổng chiều dài thông điệp phải nhỏ hơn hoặc bằng 65535 byte.
             Tổng chiều dài thông điệp phải dưới 287 byte nếu
             Bob đang công khai địa chỉ của mình dưới dạng NTCP
             (xem phần Nhận diện Phiên bản bên dưới).
             Alice và Bob sẽ sử dụng dữ liệu đệm trong KDF cho thông điệp 2.
             Nó được xác thực để đảm bảo rằng bất kỳ sửa đổi nào sẽ gây ra việc
             thông điệp tiếp theo bị lỗi.

Dữ liệu không được mã hóa (thẻ Poly1305 không được hiển thị):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                   X                   |
  +              (32 byte)                +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               tùy chọn                 |
  +              (16 byte)                +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     đệm được xác thực không mã hóa         |
  +         đệm động (tùy chọn)            +
  |     độ dài định nghĩa trong khối tùy chọn   |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  X :: 32 byte, khóa tạm thời X25519, little endian

  options :: khối tùy chọn, 16 byte, xem bên dưới

  padding :: Dữ liệu ngẫu nhiên, 0 hoặc nhiều byte.
             Tổng chiều dài thông điệp phải nhỏ hơn hoặc bằng 65535 byte.
             Tổng chiều dài thông điệp phải dưới 287 byte nếu
             Bob đang công khai địa chỉ của mình dưới dạng "NTCP"
             (xem phần Nhận diện Phiên bản bên dưới)
             Alice và Bob sẽ sử dụng dữ liệu đệm trong KDF cho thông điệp 2.
             Nó được xác thực để đảm bảo rằng bất kỳ sửa đổi nào sẽ gây ra việc
             thông điệp tiếp theo bị lỗi.

Khối tùy chọn:
Lưu ý: Tất cả các trường đều lớn-endian.

+----+----+----+----+----+----+----+----+
  | id | ver|  padLen | m3p2len | Rsvd(0) |
  +----+----+----+----+----+----+----+----+
  |        tsA        |   Reserved (0)    |
  +----+----+----+----+----+----+----+----+

  id :: 1 byte, mã định danh mạng (hiện tại là 2, ngoại trừ các mạng thử nghiệm)
        Từ phiên bản 0.9.42. Xem đề xuất 147.

  ver :: 1 byte, phiên bản giao thức (hiện tại là 2)

  padLen :: 2 byte, độ dài của đệm, 0 hoặc nhiều
            Hướng dẫn tối thiểu/tối đa TBD. Kích thước ngẫu nhiên từ 0 đến 31 byte tối thiểu?
            (Phân phối cần được quyết định, xem Phụ lục A.)

  m3p2Len :: 2 byte, độ dài của khung AEAD thứ hai trong Xác nhận Phiên
             (thông điệp 3 phần 2) Xem ghi chú bên dưới

  Rsvd :: 2 byte, đặt thành 0 để đảm bảo khả năng tương thích với các tùy chọn trong tương lai

  tsA :: 4 byte, dấu thời gian Unix, giây không dấu.
         Vòng lại vào năm 2106

  Reserved :: 4 byte, đặt thành 0 để đảm bảo khả năng tương thích với các tùy chọn trong tương lai

Ghi chú
`````
- Khi địa chỉ được công bố là "NTCP", Bob hỗ trợ cho cả NTCP và NTCP2 trên cùng một cổng. Để đảm bảo sự tương thích, khi bắt đầu kết nối đến một địa chỉ được công bố là "NTCP", Alice phải hạn chế kích thước tối đa của thông điệp này, bao gồm cả đệm, đến dưới 287 byte. Điều này tạo điều kiện cho việc xác định phiên bản tự động bởi Bob. Khi được công bố là "NTCP2", không có giới hạn kích thước nào. Xem phần Địa chỉ được Công bố và Nhận diện Phiên bản dưới đây.

- Giá trị X độc nhất trong khối AES ban đầu đảm bảo rằng mã văn bản là khác nhau cho mỗi phiên.

- Bob phải từ chối các kết nối mà giá trị thời gian bị lệch quá xa so với thời gian hiện tại. Gọi thời gian delta lớn nhất là "D". Bob phải duy trì một bộ nhớ đệm cục bộ của các giá trị bắt tay đã được sử dụng trước đó và từ chối các mục trùng lặp, để ngăn chặn các cuộc tấn công phát lại. Các giá trị trong bộ nhớ đệm phải có tuổi thọ ít nhất là 2*D. Các giá trị bộ nhớ đệm là phụ thuộc vào triển khai, tuy nhiên giá trị X 32 byte (hoặc mã hóa tương đương) có thể được sử dụng.

- Các khóa tạm thời Diffie-Hellman không bao giờ được tái sử dụng, để ngăn chặn các cuộc tấn công mã hóa, và việc tái sử dụng sẽ bị từ chối như một cuộc tấn công phát lại.

- Các tùy chọn "KE" và "auth" phải tương thích, tức là khóa chia sẻ K phải có kích thước thích hợp. Nếu các tùy chọn "auth" khác được thêm vào, điều này có thể dẫn đến thay đổi nghĩa của cờ "KE" để sử dụng một KDF khác hoặc kích thước cắt giảm khác.

- Bob phải xác nhận rằng khóa tạm thời của Alice là một điểm hợp lệ trên đường cong ở đây.

- Đệm nên được giới hạn đến một mức độ hợp lý. Bob có thể từ chối các kết nối với đệm quá mức. Bob sẽ chỉ định các tùy chọn đệm của mình trong thông điệp 2. Hướng dẫn tối thiểu/tối đa TBD. Kích thước ngẫu nhiên từ 0 đến 31 byte tối thiểu? (Phân phối cần được quyết định, xem Phụ lục A.)

- Trên bất kỳ lỗi nào, bao gồm AEAD, DH, dấu thời gian, phát lại rõ ràng hoặc thất bại xác nhận khóa, Bob phải tạm dừng xử lý thông điệp và đóng kết nối mà không phản hồi lại. Điều này nên là một lần đóng bất thường (TCP RST). Để kháng lại thăm dò, sau sự cố AEAD, Bob nên đặt một thời gian chờ ngẫu nhiên (phạm vi TBD) và sau đó đọc một số byte ngẫu nhiên (phạm vi TBD), trước khi đóng socket.

- Giảm căng thẳng DoS: DH là một hoạt động tương đối tốn kém. Như với giao thức NTCP trước đây, các bộ định tuyến nên thực hiện tất cả các biện pháp cần thiết để ngăn chặn kiệt quệ CPU hoặc kết nối. Đặt giới hạn số kết nối tối đa đang hoạt động và số thiết lập kết nối tối đa đang tiến hành. Thực thi các thời gian chờ đọc (cả đọc từng dòng và tổng cộng cho "slowloris"). Giới hạn các kết nối lặp lại hoặc đồng thời từ cùng một nguồn. Duy trì danh sách đen cho nguồn gốc thường xuyên thất bại. Không phản hồi lại sự cố AEAD.

- Để tạo điều kiện cho việc phát hiện phiên bản nhanh chóng và tiến hành bắt tay, các triển khai phải đảm bảo rằng Alice đệm và sau đó xả toàn bộ nội dung của thông điệp đầu tiên cùng một lúc, bao gồm cả đệm. Điều này làm tăng khả năng dữ liệu sẽ được chứa trong một gói TCP duy nhất (trừ khi bị phân đoạn bởi hệ điều hành hoặc các hộp ở giữa) và nhận được toàn bộ một lần bởi Bob. Ngoài ra, các triển khai phải đảm bảo rằng Bob đệm và sau đó xả toàn bộ nội dung của thông điệp thứ hai cùng một lúc, bao gồm cả đệm, và rằng Bob đệm và sau đó xả toàn bộ nội dung của thông điệp thứ ba cùng một lúc. Điều này cũng vì hiệu quả và để đảm bảo hiệu quả của đệm ngẫu nhiên.

- Trường "ver": Noise protocol toàn diện, mở rộng, và giao thức NTCP bao gồm các đặc tả tải trọng, chỉ ra NTCP2. Trường này có thể được sử dụng để chỉ ra hỗ trợ cho các thay đổi trong tương lai.

- Độ dài phần 2 thông điệp 3: Đây là kích thước của khung AEAD thứ hai (bao gồm 16-byte MAC) chứa Router Info của Alice và đệm tùy chọn sẽ được gửi trong thông điệp Xác nhận Phiên. Vì các router thường tạo lại và công bố Router Info của họ, kích thước của Router Info hiện tại có thể thay đổi trước khi thông điệp 3 được gửi đi. Các triển khai phải chọn một trong hai chiến lược: a) lưu Router Info hiện tại sẽ được gửi trong thông điệp 3, vì vậy kích thước được biết, và tùy chọn thêm đệm; b) tăng kích thước xác định đủ để cho phép tăng kích thước Router Info, và luôn thêm đệm khi thông điệp 3 thực sự được gửi đi. Trong mỗi trường hợp, "m3p2len" bao gồm trong thông điệp 1 phải chính xác là kích thước của khung đó khi được gửi trong thông điệp 3.

- Bob phải thất bại kết nối nếu có bất kỳ dữ liệu nhập còn lại nào sau khi xác nhận thông điệp 1 và đọc vào phần đệm. Không nên có dữ liệu thêm nào từ Alice, vì Bob chưa phản hồi lại với thông điệp 2.

- Trường mã định danh mạng được sử dụng để nhanh chóng xác định các kết nối qua mạng. Nếu trường này không bằng không, và không khớp với mã định danh mạng của Bob, Bob nên ngắt kết nối và khóa các kết nối trong tương lai. Từ phiên bản 0.9.42. Xem thêm đề xuất 147 để biết thêm thông tin.


### Hàm dẫn xuất khóa (KDF) (cho thông điệp bắt tay 2 và phần 1 thông điệp 3)

```
// lấy h được lưu từ KDF của thông điệp 1
// MixHash(ciphertext)
h = SHA256(h || tải trọng mã hóa 32 byte từ thông điệp 1)

// MixHash(padding)
// Chỉ khi độ dài đệm là không bằng không
h = SHA256(h || đệm ngẫu nhiên từ thông điệp 1)

Đây là mẫu thông điệp "e":

Bob tạo cặp khóa DH tạm thời của mình.

// h là từ KDF cho thông điệp bắt tay 1
// Khóa tạm thời Y của Bob
// MixHash(e.pubkey)
// || có nghĩa là nối
h = SHA256(h || e.pubkey);

// h được sử dụng làm dữ liệu liên kết cho AEAD trong thông điệp 2
// Giữ lại Hash h cho KDF của thông điệp 3

Kết thúc của mẫu thông điệp "e".

Đây là mẫu thông điệp "ee":

// DH(e, re)
Định nghĩa input_key_material = Kết quả DH 32 byte của khóa tạm thời của Alice và khóa tạm thời của Bob
Set input_key_material = Kết quả DH X25519
// ghi đè khóa tạm thời của Alice trong bộ nhớ, không cần thiết nữa
// Alice:
e(công khai và riêng) = (tất cả số không)
// Bob:
re = (tất cả số không)

// MixKey(DH())

Định nghĩa temp_key = 32 byte
Định nghĩa HMAC-SHA256(khóa, dữ liệu) như trong [RFC-2104](https://tools.ietf.org/html/rfc2104)
// tạo một mã khóa tạm thời từ mã nối và kết quả DH
// ck là mã nối, từ KDF cho thông điệp bắt tay 1
temp_key = HMAC-SHA256(ck, input_key_material)
// ghi đè kết quả DH trong bộ nhớ, không cần thiết nữa
input_key_material = (tất cả số không)

// Đầu ra 1
// Chọn một mã nối mới từ mã khóa tạm
// byte() có nghĩa là một byte
ck =       HMAC-SHA256(temp_key, byte(0x01)).

// Đầu ra 2
// Tạo mã khóa k
Định nghĩa k = 32 byte
// || có nghĩa là nối
// byte() có nghĩa là một byte
k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
// ghi đè temp_key trong bộ nhớ, không cần thiết nữa
temp_key = (tất cả số không)

// giữ mã nối ck cho KDF của thông điệp 3

Kết thúc của mẫu thông điệp "ee".
```

### 2) Đã tạo Phiên

Bob gửi cho Alice.

Nội dung Noise: Khóa tạm thời Y của Bob
Tải trọng Noise: khối tùy chọn 16 byte
Tải trọng phi Noise: đệm ngẫu nhiên

(Tính chất an ninh tải trọng)

XK(s, rs):           Chứng thực   Bảo mật
    <- e, ee                  2                1

    Chứng thực: 2.
    Chứng thực người gửi chống lại giả mạo do thoả hiệp khóa (KCI). Chứng thực người gửi này dựa trên DH tạm thời-tĩnh ("es" hoặc "se")
    giữa cặp khóa tĩnh của người gửi và cặp khóa tạm thời của người nhận. Giả sử khóa riêng tương ứng là an toàn, chứng thực này không thể bị giả mạo.

    Bảo mật: 1.
    Mã hóa đến một người nhận tạm thời.
    Tải trọng này có bảo mật truyền tiếp, vì mã hóa liên quan đến DH tạm thời-tạm thời ("ee").
    Tuy nhiên, người gửi chưa xác thực người nhận,
    nên tải trọng này có thể được gửi đến bất kỳ bên nào, bao gồm một kẻ tấn công chủ động.


    "e": Bob tạo một cặp khóa tạm thời mới và lưu trữ nó trong biến e, 
    viết khóa công khai tạm thời như dữ liệu rõ ràng vào bộ đệm thông báo,
    và băm khóa công khai cùng với h cũ để tạo ra một h mới.

    "ee": Một DH được thực hiện giữa cặp khóa tạm thời của Bob và cặp khóa tạm thời của Alice.
    Kết quả được băm cùng với ck cũ để tạo ra một ck và k mới, và n được đặt thành không.

Giá trị Y được mã hóa để đảm bảo tính không phân biệt và duy nhất của tải trọng,
cần thiết cho các biện pháp đối phó DPI. Ta sử dụng mã hóa AES để đạt được
điều này, thay vì các phương pháp phức tạp và chậm hơn như elligator2.
Mã hóa không đối xứng với khóa công khai của bộ định tuyến của Alice sẽ quá chậm.
Mã hóa AES sử dụng băm bộ định tuyến của Bob làm khóa và trạng thái AES từ thông điệp 1
(được khởi tạo với IV của Bob như được công bố trong cơ sở dữ liệu mạng).

Mã hóa AES là để kháng DPI chỉ. 
Bất kỳ bên nào biết băm bộ định tuyến của Bob và IV, được công bố trong cơ sở dữ liệu mạng, 
và đã bắt được 32 byte đầu tiên của thông điệp 1, đều có thể giải mã giá trị Y trong thông điệp này.


Nội dung thô:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        làm mờ với RH_B               +
  |       Mã hóa AES-CBC-256 của Y       |
  +              (32 byte)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |   Khung ChaChaPoly                    |
  +   Dữ liệu đã mã hóa và xác thực      +
  |   32 byte                            |
  +   k định nghĩa trong KDF cho thông điệp 2  +
  |   n = 0; xem KDF cho dữ liệu liên kết  |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     đệm được xác thực không mã hóa       +
  +         padding (tùy chọn)            +
  |     độ dài định nghĩa trong khối tùy chọn  +
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 byte, mã hóa AES-256-CBC của khóa tạm thời X25519, little endian
          khóa: RH_B
          iv: Sử dụng trạng thái AES từ thông điệp 1

Dữ liệu không mã hóa (không hiển thị thẻ Poly1305):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                  Y                    |
  +              (32 byte)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               tùy chọn                 |
  +              (16 byte)               +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     đệm được xác thực không mã hóa       +
  +         padding (tùy chọn)            +
  |     độ dài định nghĩa trong khối tùy chọn  +
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 byte, khóa tạm thời X25519, little endian

  options :: khối tùy chọn, 16 byte, xem bên dưới

  padding :: Dữ liệu ngẫu nhiên, 0 hoặc nhiều byte. 
             Tổng chiều dài thông điệp phải nhỏ hơn hoặc bằng 65535 byte. 
             Alice và Bob sẽ sử dụng dữ liệu đệm trong KDF cho phần 1 của thông điệp 3. 
             Nó được xác thực để đảm bảo rằng bất kỳ sửa đổi nào sẽ gây ra việc thông điệp tiếp theo bị lỗi.

Ghi chú
``````
- Alice phải xác nhận rằng khóa tạm thời của Bob là một điểm hợp lệ trên đường cong ở đây.

- Đệm nên được giới hạn đến một mức độ hợp lý.
  Alice có thể từ chối kết nối với đệm quá mức.
  Alice sẽ chỉ định các tùy chọn đệm của mình trong thông điệp 3.
  Hướng dẫn tối thiểu/tối đa TBD. Kích thước ngẫu nhiên từ 0 đến 31 byte tối thiểu?
  (Phân phối cần được quyết định, xem Phụ lục A.)

- Trên bất kỳ lỗi nào, bao gồm AEAD, DH, dấu thời gian, phát lại rõ ràng hoặc thất bại xác nhận khóa,
  Alice phải dừng xử lý thông điệp và đóng kết nối mà không phản hồi lại. Điều này nên là một đợt đóng bất thường (TCP RST).

- Để thúc đẩy quá trình bắt tay nhanh chóng, các triển khai phải đảm bảo rằng Bob đệm
  và sau đó xả toàn bộ nội dung của thông điệp đầu tiên cùng một lúc, bao gồm cả đệm. 
  Điều này làm tăng khả năng dữ liệu sẽ được chứa trong một gói TCP duy nhất
  (trừ khi bị phân đoạn bởi hệ điều hành hoặc các hộp ở giữa), và
  được nhận toàn bộ một lần bởi Alice. Điều này cũng vì hiệu quả và
  để đảm bảo hiệu quả của đệm ngẫu nhiên.

- Alice phải thất bại kết nối nếu có bất kỳ dữ liệu nhập còn lại nào sau khi xác nhận
  thông điệp 2 và đọc vào phần đệm. Không nên có dữ liệu thêm nào từ Bob,
  vì Alice chưa phản hồi lại với thông điệp 3.

Khối Tùy chọn:
Lưu ý: Tất cả các trường đều lớn-endian.

+----+----+----+----+----+----+----+----+
  | Rsvd(0) | padLen  |   Dự trữ (0)    |
  +----+----+----+----+----+----+----+----+
  |        tsB        |   Dự trữ (0)    |
  +----+----+----+----+----+----+----+----+

  Reserved :: 10 byte tất cả, đặt thành 0 để tương thích với các lựa chọn trong tương lai

  padLen :: 2 byte, big endian, độ dài của phần đệm, 0 hoặc nhiều
            Hướng dẫn min/max TBD. Kích thước ngẫu nhiên từ 0 đến 31 byte tối thiểu?
            (Phân phối cần được quyết định, xem Phụ lục A.)

  tsB :: 4 byte, big endian, dấu thời gian Unix, giây unsigned.
         Wraps around in 2106

Ghi chú
`````
- Alice phải từ chối các kết nối nơi giá trị dấu thời gian bị lệch quá xa so với thời gian hiện tại. Gọi thời gian delta tối đa là "D". Alice phải duy trì một bộ nhớ đệm cục bộ các giá trị bắt tay đã được sử dụng trước đó và từ chối các mục trùng lặp, để ngăn chặn các cuộc tấn công phát lại. Các giá trị trong bộ nhớ đệm phải có tuổi thọ ít nhất là 2*D. Các giá trị bộ nhớ đệm là phụ thuộc vào triển khai, tuy nhiên giá trị Y 32 byte (hoặc mã hóa tương đương) có thể được sử dụng.

Vấn đề
``````
- Bao gồm các tùy chọn tối thiểu/tối đa về đệm tại đây?



### Encryption for for handshake message 3 part 1, using message 2 KDF)

```
// lấy h đã lưu từ KDF thông điệp 2
// MixHash(ciphertext)
h = SHA256(h || tải trọng mã hóa 24 byte từ thông điệp 2)

// MixHash(padding)
// Chỉ khi độ dài đệm là không bằng không
h = SHA256(h || đệm ngẫu nhiên từ thông điệp 2)
// h được sử dụng như dữ liệu liên kết cho AEAD trong phần 1 của thông điệp 3, dưới đây

Đây là mẫu thông điệp "s":

Định nghĩa s = Khóa công khai tĩnh của Alice, 32 byte

// EncryptAndHash(s.publickey)
// EncryptWithAd(h, s.publickey)
// AEAD_ChaCha20_Poly1305(key, nonce, associatedData, data)
// k là từ thông điệp bắt tay 1
// n là 1
ciphertext = AEAD_ChaCha20_Poly1305(k, n++, h, s.publickey)
// MixHash(ciphertext)
// || có nghĩa là nối
h = SHA256(h || ciphertext);

// h được sử dụng như dữ liệu liên kết cho AEAD trong phần 2 của thông điệp 3

Kết thúc của mẫu thông điệp "s".
```

### Hàm dẫn xuất khóa (KDF) (cho phần 2 của thông điệp bắt tay 3)

Đây là mẫu thông điệp "se":

  // DH(s, re) == DH(e, rs)
  Định nghĩa input_key_material = Kết quả DH 32 byte của khóa tĩnh của Alice và khóa tạm thời của Bob
  Set input_key_material = Kết quả DH X25519
  // ghi đè khóa tạm thời của Bob trong bộ nhớ, không cần thiết nữa
  // Alice:
  re = (tất cả số không)
  // Bob:
  e(công khai và riêng) = (tất cả số không)

  // MixKey(DH())

  Định nghĩa temp_key = 32 byte
  Định nghĩa HMAC-SHA256(khóa, dữ liệu) như trong [RFC-2104](https://tools.ietf.org/html/rfc2104)
  // Tạo một mã khóa tạm thời từ mã nối và kết quả DH
  // ck là mã nối, từ KDF cho thông điệp bắt tay 1
  temp_key = HMAC-SHA256(ck, input_key_material)
  // ghi đè kết quả DH trong bộ nhớ, không cần thiết nữa
  input_key_material = (tất cả số không)

  // Đầu ra 1
  // Chọn một mã nối mới từ mã khóa tạm
  // byte() có nghĩa là một byte
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // Đầu ra 2
  // Tạo mã khóa k
  Định nghĩa k = 32 byte
  // || có nghĩa là nối
  // byte() có nghĩa là một byte
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).

  // h từ thông điệp 3 phần 1 được sử dụng như dữ liệu liên kết cho AEAD trong thông điệp 3 phần 2

  // EncryptAndHash(payload)
  // EncryptWithAd(h, payload)
  // AEAD_ChaCha20_Poly1305(khóa, nonce, dữ liệu liên kết, dữ liệu)
  // n là 0
  ciphertext = AEAD_ChaCha20_Poly1305(k, n++, h, payload)
  // MixHash(ciphertext)
  // || có nghĩa là nối
  h = SHA256(h || ciphertext);

  // giữ mã nối ck cho KDF pha dữ liệu
  // giữ h cho KDF Khóa Đối xứng Bổ sung Dữ liệu (SipHash)

  Kết thúc của mẫu thông điệp "se".

  // ghi đè temp_key trong bộ nhớ, không cần thiết nữa
  temp_key = (tất cả số không)

### 3) Xác nhận Phiên

Alice gửi tới Bob.

Nội dung Noise: Khóa tĩnh của Alice
Tải trọng Noise: RouterInfo của Alice và đệm ngẫu nhiên
Tải trọng phi Noise: không có

(Tính chất bảo mật tải trọng)

XK(s, rs):           Chứng thực   Bảo mật
    -> s, se                  2                5

    Chứng thực: 2.
    Chứng thực người gửi chống lại giả mạo do thoả hiệp khóa (KCI). 
    Chứng thực người gửi này dựa trên một DH tạm thời-tĩnh ("es" hoặc "se") 
    giữa cặp khóa tĩnh của người gửi và cặp khóa tạm thời của người nhận. 
    Giả sử các khóa riêng tương ứng là an toàn, chứng thực này không thể bị giả mạo.

    Bảo mật: 5.
    Mã hóa đến một người nhận đã biết, bảo mật truyền tiếp mạnh mẽ.
    Tải trọng này được mã hóa dựa trên một DH tạm thời-tạm thời cũng như một DH tạm thời-tĩnh với cặp khóa tĩnh của người nhận.
    Giả sử các khóa riêng tạm thời là an toàn, và người nhận không bị giả mạo chủ động bởi một kẻ tấn công đã đánh cắp khóa riêng tĩnh của nó, tải trọng này không thể được giải mã.

    "s": Alice ghi khóa công khai tĩnh của cô từ biến s vào bộ đệm thông điệp, mã hóa nó, và băm đầu ra cùng với h cũ để tạo ra một h mới.

    "se": Một DH được thực hiện giữa cặp khóa tĩnh của Alice và cặp khóa tạm thời của Bob.
    Kết quả được băm cùng với ck cũ để tạo ra một ck và k mới, và n được đặt thành không.

Thông điệp này chứa hai khung ChaChaPoly.
Đầu tiên là khóa công khai tĩnh đã mã hóa của Alice.
Thứ hai là Tải trọng Noise: thông tin RouterInfo đã mã hóa của Alice, 
tùy chọn tùy chọn, và đệm tùy chọn. Họ sử dụng các khóa khác nhau, 
bởi vì hàm MixKey() được gọi ở giữa.


Dữ liệu thô:

+----+----+----+----+----+----+----+----+
  |                                       |
  +   Khung ChaChaPoly (48 byte)          +
  |   Được mã hóa và xác thực dữ liệu     |
  +   Khóa tĩnh của Alice S               +
  |      (32 byte)                       |
  +                                       +
  |     k định nghĩa trong KDF cho thông điệp 2  |
  +     n = 1                             +
  |     xem KDF cho dữ liệu liên kết      |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +     Độ dài được chỉ định trong thông điệp 1     +
  |                                       |
  +   Khung ChaChaPoly                    +
  |   Được mã hóa và xác thực dữ liệu     |
  +                                       +
  |       Alice RouterInfo                |
  +       sử dụng định dạng khối 2        +
  |       Các tùy chọn của Alice (tùy chọn)         |
  +       sử dụng định dạng khối 1        +
  |       Đệm tùy ý                       +
  +       sử dụng định dạng khối 254       +
  |                                       |
  +                                       +
  | k định nghĩa trong KDF cho thông điệp 3 phần 2 |
  +     n = 0                             +
  |     xem KDF cho dữ liệu liên kết      |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  S :: 32 byte, Khóa tĩnh X25519 đã mã hóa của Alice, little endian
       bên trong khung ChaChaPoly 48 byte

Dữ liệu không mã hóa (không hiển thị thẻ Poly1305):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |              S                        |
  +       Khóa tĩnh của Alice             +
  |          (32 byte)                    |
  +                                       +
  |                                       |
  +                                       +
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                                       |
  +                                       +
  |       Khối RouterInfo của Alice       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       Khối Tùy chọn tùy chọn          +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       Khối Đệm Tùy chọn               +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  S :: 32 byte, Khóa tĩnh X25519 của Alice, little endian

Ghi chú
`````
- Bob phải thực hiện xác thực thông thường đối với Thông tin Router. 
  Đảm bảo loại chữ ký được hỗ trợ, xác minh chữ ký, 
  xác minh dấu thời gian là trong phạm vi, và bất kỳ kiểm tra nào khác cần thiết.

- Bob phải xác minh rằng khóa tĩnh của Alice nhận được trong khung đầu tiên khớp 
  với khóa tĩnh trong Thông tin Router. Bob phải trước tiên tìm kiếm Thông tin Router 
  cho một Địa chỉ Router NTCP hoặc NTCP2 với một tùy chọn phiên bản (v) phù hợp.
  Xem phần Thông tin Router Đã Công bố và Không Công bố dưới đây.

- Nếu Bob có một phiên bản cũ hơn của Thông tin Router của Alice trong netdb của mình, xác minh
  rằng khóa tĩnh trong thông tin router là tương tự trong cả hai, nếu có,
  và nếu phiên bản cũ hơn là ít hơn XXX cũ (xem thời gian xoay khóa dưới đây)

- Bob phải xác nhận rằng khóa tĩnh của Alice là một điểm hợp lệ trên đường cong ở đây.

- Các tùy chọn nên được đi kèm, để chỉ rõ các thông số đệm.

- Trên bất kỳ lỗi nào, bao gồm AEAD, RI, DH, dấu thời gian, hoặc thất bại xác nhận khóa,
  Bob phải tạm dừng xử lý tiếp tục thông điệp và đóng kết nối mà không
  phản hồi. Điều này nên là một lần đóng bất thường (TCP RST).

- Để thúc đẩy quá trình bắt tay nhanh chóng, các triển khai phải đảm bảo rằng Alice
  lưu trữ và sau đó xả toàn bộ nội dung của thông điệp thứ ba cùng một lúc,
  bao gồm cả hai khung AEAD. Điều này làm tăng khả năng dữ liệu sẽ được chứa trong một gói TCP
  duy nhất (trừ khi bị phân đoạn bởi hệ điều hành hoặc các hộp ở giữa), và nhận được 
  toàn bộ một lần bởi Bob. Điều này cũng vì hiệu quả và để đảm bảo hiệu quả của đệm ngẫu nhiên.

- Độ dài khung phần 2 thông điệp 3: Độ dài
