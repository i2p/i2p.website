---
title: "NTCP 2"
number: "111"
author: "EinMByte, orjinal, psi, str4d, zzz"
created: "2014-02-13"
lastupdated: "2019-08-13"
status: "Kapalı"
thread: "http://zzz.i2p/topics/1577"
supercedes: "106"
target: "0.9.36"
implementedin: "0.9.36"
editor: "manas, str4d, zzz"
---

## Not
Öneri aşaması kapalı.
Resmi spesifikasyon için [SPEC](/en/docs/spec/ntcp2/) bakınız.
Bu öneri, arka plan bilgisi için hâlâ referans alınabilir.


## Genel Bakış

Bu öneri, [NTCP](/en/docs/transport/ntcp/)'nin çeşitli otomatik tanımlama ve saldırılara karşı direncini artırmak için bir kimlik doğrulama protokolünü tanımlar.

Öneri şu şekilde organize edilmiştir: güvenlik hedefleri sunulur, ardından temel protokol tartışılır. Sonra, tüm protokol mesajlarının tam bir spesifikasyonu verilir. Son olarak, yönlendirici adresleri ve sürüm tanımlaması tartışılır. Ortak dolgu şemalarına yönelik genel bir saldırıyı tartışan bir ek ve kimlik doğrulama şifresi için bir dizi aday içeren bir ek de dahil edilmiştir.

Diğer I2P taşıma yöntemleri gibi, NTCP2 sadece
nokta-nokta (yönlendirici-yönlendirici) I2NP mesajlarının taşınması için tanımlanmıştır.
Genel amaçlı bir veri borusu değildir.


## Motivasyon

[NTCP](/en/docs/transport/ntcp/) verileri, ilk mesajdan sonra şifrelenir (ve ilk mesaj rastgele veri gibi görünür), böylece "yük analizi" yoluyla protokol tanımlamasını engeller. Yine de "akış analizi" yoluyla protokol tanımlamasına karşı savunmasızdır. Bunun nedeni, ilk 4 mesajın (yani el sıkışma) sabit uzunlukta olmasıdır (288, 304, 448 ve 48 bayt).

Her mesajın üzerine rastgele miktarlarda rastgele veri ekleyerek bunu çok daha zor hale getirebiliriz.

Yazarlar, standart güvenlik uygulamalarının TLS gibi mevcut bir protokolün kullanılmasını önerse de, bu [Prop104](/en/proposals/104/) ve onun kendi sorunları var. Uygun olan her yerde, eksik özellikleri veya tartışma konularını belirtmek için "gelecek çalışma" paragrafları eklenmiştir.


## Tasarım Hedefleri

- Tek bir portta hem NTCP 1'i hem de 2'yi destekleyin, otomatik algılayın ve tek bir
  "taşıma" (yani [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) olarak [NetDB](/en/docs/how/network-database/) içinde yayınlayın.

- NetDB'de yalnızca sürüm 1'i, yalnızca 2'yi veya 1+2 desteğini ayrı bir alanda yayınlayın ve varsayılan olarak yalnızca sürüm 1'i destekleyin (sürüm desteğini belirli bir yönlendirici sürümüne bağlamayın)

- Tüm uygulamaların (Java/i2pd/Kovri/go) kendi takvimlerine göre sürüm 2 desteği ekleyebilmesini (veya eklememesini) sağlayın

- El sıkışma ve veri mesajları dahil olmak üzere tüm NTCP mesajlarına rastgele dolgu ekleyin (yani tüm mesajlar 16 baytın katı değilmiş gibi olacak şekilde uzunluk bulanıklığı)
  Her iki taraf için de minimum ve maksimum dolgu ve/veya dolgu dağılımı isteme seçenekleri sağlayın. Dolgu dağıtımının ayrıntıları uygulamaya bağlıdır ve protokolün kendisinde belirtilmiş olabilir veya olmayabilir.

- Şifrelenmemiş mesajların içeriğini bulanıklaştırın (1 ve 2),
  Bu, DPI kutuları ve antivirüs imzalarının bunları kolayca sınıflandıramamasını sağlamak için yeterlidir. Ayrıca tek bir eşe veya eş kümesine giden mesajlarda benzer bir bit modeli olmamasını sağlayın.

- Java formatı nedeniyle DH'de oluşan bit kaybını düzeltin [Ticket1112](https://trac.i2p2.i2p/ticket/1112), muhtemelen (muhtemelen?) X25519'a geçerek.

- Sonuç olarak DH'i olduğu gibi kullanmaktan ziyade gerçek bir anahtar türetme fonksiyonuna (KDF) geçin?

- Tor'un adlandırdığı gibi "probing direnci" ekleyin; bu, yeniden oynatma direncini içerecektir.

- İki yönlü kimlik doğrulamalı anahtar değişimini (2W-AKE) sürdürün. 1W-AKE uygulamamız için yeterli değildir.

- Kimlik doğrulamanın bir parçası olarak değişken tipli, değişken uzunluklu imzaları (yayınlanmış [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) imza anahtarından) kullanmaya devam edin.  Diğer bir kimlik doğrulama parçası olarak RouterInfo'da yayımlanan statik bir ortak anahtara güvenin.

- Gelecekteki genişletilebilirlik için el sıkışmada seçenekler/sürüm ekleyin.

- Mümkünse kötü niyetli Ortadaki Adam (MitM) TCP segmentasyonuna karşı direnç ekleyin.

- Bağlantı kurulumuna gereken CPU'yu önemli ölçüde artırmayın; mümkünse bunu önemli ölçüde azaltın.

- Mesaj kimlik doğrulaması (MAC) ekleyin, muhtemelen HMAC-SHA256 ve Poly1305, ve Adler kontrol toplamını çıkarın.

- I2NP başlığını kısaltın ve basitleştirin:
  SSU'da olduğu gibi süresi dolma alanını 4 bayta kısaltın.
  Bir baytlık kesilmiş SHA256 kontrol toplamını kaldırın.

- Mümkünse, 4 mesajlık iki round-trip el sıkışmasını [SSU](/en/docs/transport/ssu/) gibi 3 mesajlık tek round-trip el sıkışmasına indirin. Bu, Bob'un imzasını 4. mesajdan 2. mesaja taşımayı gerektirecektir. On yıl önceki e-posta/durum/toplantı arşivlerinde 4 mesajın nedeninin araştırılması gerekecektir.

- Dolgudan önceki protokolün yükünü minimize edin. Dolgu eklenecek olsa da, belki çok fazla, dolgudan önceki yük hâlâ yüktür.
  Düşük bant genişlikli düğümler NTCP2 kullanabilmelidir.

- Yeniden oynatma ve kayma algılama için zaman damgaları tutun.

- Zaman damgalarında herhangi bir 2038 yılı sorunundan kaçının, en az 2106 yılına kadar çalışabilmelidir.

- Maksimum mesaj boyutunu 16K'dan 32K veya 64K'ya artırın.

- Yeni kriptografik ilkellerin Java (1.7), C++ ve Go yönlendirici uygulamaları için kullanıma hazır kütüphanelerde bulunması gerekmelidir.

- Java, C++ ve Go yönlendirici geliştiricilerini tasarımda temsil edin.

- Değişiklikleri en aza indirin (ama yine de çok fazla değişiklik olacak).

- Ortak bir kod setinde her iki sürümü destekleyin (bu mümkün olmayabilir ve bu her durumda uygulama bağımlıdır).


### Amaç Olmayanlar

- Mermi geçirmez DPI direnci... bu eklenti taşımaları olur,
  [Prop109](/en/proposals/109/).

- Bir TLS tabanlı (veya HTTPS benzeri gözüken) taşıma... bu [Prop104](/en/proposals/104/) olurdu.

- Simetrik akış şifrelemesini değiştirmek sorun değil.

- Zamanlama tabanlı DPI direnci (mesajlar arası zamanlama/gecikmeler uygulama bağımlı olabilir; mesaj içi gecikmeler herhangi bir noktada, örneğin rastgele dolgu gönderilmeden önce, eklenebilir). Yapay gecikmeler (obfs4'ün IAT veya gelme arası süre dediği şey) protokolün kendisinden bağımsızdır.

- Bir oturuma katılımın inkar edilebilirliği (orada imzalar var).

Kısmen tekrar gözden geçirilebilecek veya tartışılabilecek olmayan hedefler:

- Derin Paket İnceleme'ye (DPI) karşı koruma derecesi

- Kuantum sonrası (PQ) güvenlik

- İnkâr edilebilirlik



### İlgili Amaçlar

- NTCP 1/2 test kurulumunu uygulayın


## Güvenlik Hedefleri

Üç tarafı dikkate alıyoruz:

- Alice, yeni bir oturum başlatmak isteyen.
- Bob, Alice'in oturum açmak istediği kişi.
- Mallory, Alice ile Bob arasında "ortadaki adam".

En fazla iki katılımcı aktif saldırılar gerçekleştirebilir.

Alice ve Bob her ikisi de statik bir anahtar çiftine sahip, bu da onların [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) içindedir.

Önerilen protokol, Alice ve Bob'un paylaşılan bir gizli anahtar (K) üzerinde anlaşmalarına izin vermeyi amaçlar, aşağıdaki gereklilikler altında:

1) Özel anahtar güvenliği: Ne Bob ne de Mallory, Alice'in
   statik özel anahtarı hakkında herhangi bir şey öğrenemez. Simetrik olarak, Alice de Bob'un
   statik özel anahtarı hakkında bir şey öğrenemez.

2) Oturum anahtarı K yalnızca Alice ve Bob tarafından bilinir.

3) Mükemmel ileri gizlilik: Kararlaştırılan oturum anahtarı
   gelecekte gizli kalır, hatta Alice ve/veya Bob'un statik özel anahtarları
   anahtar kararlaştırıldıktan sonra ifşa edilse bile.

4) İki yönlü kimlik doğrulama: Alice, Bob ile bir oturum başlattığından ve tam tersi.

5) Çevrimiçi DPI'ye karşı koruma: Sadece düz ileri derin paket inceleme (DPI)
   teknikleri kullanarak Alice ve Bob'un protokole dahil olduğunun tespit edilmesinin
   önemsiz olmamasını sağlayın. Aşağıya bakınız.

6) Sınırlı inkâr edilebilirlik: Ne Alice ne de Bob protokole katılımlarını inkar edemezler, ancak bir taraf
   ortak anahtarı sızdırırsa, diğer taraf gönderilen verinin içeriğinin
   doğruluğunu inkar edebilir.

Bu teklif, Station-To-Station (STS) protokolüne [STS]_ dayanarak tüm beş gerekliliği sağlamayı amaçlar. Bu protokolün
[SSU](/en/docs/transport/ssu/) protokolü için de bir temel olduğunu unutmayın.


### Ek DPI Tartışması

İki DPI bileşeni varsayımında bulunuyoruz:

1) Çevrimiçi DPI
```````````````

Tüm akışları gerçek zamanlı olarak inceleyen çevrimiçi DPI. Bağlantılar
engellenebilir veya başka bir şekilde düzeltilebilir. Bağlantı verileri veya meta veriler
çevrimdışı analize kaydedilebilir. Çevrimiçi DPI,
I2P ağ veritabanına erişimi yoktur. Çevrimiçi DPI
sadece sınırlı gerçek zamanlı hesaplama yeteneğine sahiptir, örneğin uzunluk hesaplama, alan
inceleme ve XOR gibi basit hesaplamalar. Çevrimiçi DPI'nın, AES, AEAD ve
hashleme gibi hızlı gerçek zamanlı kriptografik fonksiyonları uygulama yeteneği vardır, ancak
bunlar çoğu veya tüm akışlara uygulanamayacak kadar pahalı olurdu. Bu kriptografik
işlemler yalnızca daha önce çevrimdışı analiz tarafından tanımlanan IP/Port kombinasyonlarında
uygulanacaktır. Çevrimiçi DPI, DH veya elligator2 gibi yüksek maliyetli kriptografik
fonksiyonları gerçekleştirme yeteneğine sahip değildir. Çevrimiçi DPI özellikle I2P tespitine yönelik
tasarlanmamıştır, ancak bu amaçla sınırlı sınıflandırma kurallarına
sahip olabilir.

Çevrimiçi DPI tarafından protokol tanımlamasını engellemek bir hedeftir.

Çevrimiçi veya "düz ileri" DPI terimi aşağıdaki düşman
yeteneklerini içermektedir:

1) Hedef tarafından gönderilen veya alınan tüm verileri inceleme yeteneği.

2) Gözlemlenen veriler üzerinde işlemler gerçekleştirme yeteneği,
   örneğin blok şifreleri veya hash fonksiyonları uygulamak.

3) Daha önce gönderilen mesajlarla depolama ve karşılaştırma yapma yeteneği.

4) Paketleri değiştirme, geciktirme veya parçalama yeteneği.

Ancak, çevrimiçi DPI'nın aşağıdaki sınırlamaları vardır:

5) IP adreslerini yönlendirici hashleri ile eşleştirememe. Bu, ağ
   veritabanına gerçek zamanlı erişimle kolay olsa da, I2P'yi
   hedeflemek için özel olarak tasarlanmış bir DPI sistemi gerektirirdi.

6) Protokolü tespit etmek için zamanlama bilgilerini kullanma yeteneği yok.

7) Genel olarak, çevrimiçi DPI araç seti, I2P tespiti için özel olarak
   tasarlanmış yerleşik araçları içermez. Bu, örneğin mesajlarında rastgele
   olmayan dolgu içerecek "tuzaklar" oluşturmalarını içerir. Bunun
   diğer gereksinimlere uyan makine öğrenme sistemlerini veya
   yüksek ölçüde yapılandırılabilir DPI araçlarını dışlamadığını unutmayın.

Yük analizine karşı koymak için, tüm mesajların rastgele
verilerden ayırt edilemez olması sağlanır. Bu, uzunluklarının rastgele
olmasını da gerektirir, bu da sadece rastgele dolgu eklemekten daha karmaşıktır.
Aslında, Ek A'da, yazarlar, naif bir (yani uniform) dolgu
şemasının sorunu çözmediği sonucuna varır. Ek A bu nedenle rastgele
gecikmeler eklemeyi veya önerilen saldırıya karşı makul koruma
sağlayacak alternatif bir dolgu şeması geliştirmeyi önerir.

Üstteki anlamda altıncı girişi korumak için, uygulamalar
rastgele gecikmeleri protokol içinde eklemelidir. Böyle teknikler
bu öneri kapsamında değildir, ancak dolgu uzunluğu sorunlarını
çözebilirler de. Kısacası, öneri yük analizine karşı iyi bir koruma
sağlar (Ek A'daki hususlara dikkat edilirse), ancak akış analizine
karşı yalnızca sınırlı koruma sağlar.


2) Çevrimdışı DPI
`````````````````

Çevrimiçi DPI tarafından saklanan verileri daha sonra analiz için
inceleyen çevrimdışı DPI. Çevrimdışı DPI, I2P'yi tespit
etmek için özel olarak tasarlanabilir. Çevrimdışı DPI'nın I2P ağ
veritabanına gerçek zamanlı erişimi vardır. Çevrimdışı DPI, bu ve diğer
I2P spesifikasyonlarına erişime sahiptir. Çevrimdışı DPI, bu spesifikasyonda
tanımlanan tüm kriptografik işlevler dahil olmak üzere sınırsız hesaplama yeteneğine
sahiptir.

Çevrimdışı DPI'nın mevcut bağlantıları engelleme yeteneği yoktur. 
Çevrimdışı DPI'nın belirli bir adrese/port a gönderme yeteneği
vardır, örneğin TCP RST. Çevrimdışı DPI'nın
geçmiş mesajların (değiştirilmiş veya değil) "probing" veya diğer amaçlarla
yeniden oynatma yeteneği vardır.

Çevrimdışı DPI tarafından protokol tanımlamasını engellemek bir hedef değildir.
İlk iki mesajdaki bulanık verilerin kodunu çözme,
I2P yönlendiricileri tarafından uygulandığı gibi çevrimdışı DPI tarafından da uygulanabilir.

Yeniden oynama veya diğer saldırılar dahil, önceki mesajların tekrar oynatmasını
reddetmek bir hedeftir.


Gelecek Çalışmalar
``````````````````

- Paketler saldırgan tarafından bırakıldığında veya sıralandığında protokolün davranışlarını
  inceleyin. Bu alandaki son ilginç çalışmalar şu belgede bulunabilir:
  [IACR-1150](https://eprint.iacr.org/2015/1150).

- Bu konuya ilişkin mevcut literatürü dikkate alarak DPI sistemlerinin daha doğru bir
  sınıflandırmasını sağlayın.

- Önerilen protokolün resmi güvenliğini, özellikle DPI saldırı modelini dikkate alarak tartışın.


## Noise Protokol Çerçevesi

Bu öneri, Noise Protokol Çerçevesi [NOISE](http://noiseprotocol.org/) (Revizyon 33, 2017-10-04)
üzerindeki gereksinimleri sağlar. Noise, [SSU](/en/docs/transport/ssu/) protokolünün
temeli olan Station-To-Station protokolüne [STS]_
benzer özelliklere sahiptir. Noise terminolojisinde, Alice
başlatıcıdır ve Bob yanıt verendir.

NTCP2, Noise protokolü Noise_XK_25519_ChaChaPoly_SHA256'ya dayanmaktadır.
(İlk anahtar türetme fonksiyonu için gerçek tanımlama,
I2P uzantılarını belirtmek için "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256"
'dır - aşağıdaki KDF 1 bölümüne bakınız)
Bu Noise protokolü aşağıdaki ilkel kullanır:

- El Sıkışma Deseni: XK
  Alice, anahtarını Bob'a iletir (X)
  Alice, zaten Bob'un statik anahtarını bilir (K)

- DH Fonksiyonu: X25519
  [RFC-7748](https://tools.ietf.org/html/rfc7748) de belirtilen şekilde X25519 DH, 32 bayt uzunluğunda bir anahtarla.

- Şifreleme Fonksiyonu: ChaChaPoly
  [RFC-7539](https://tools.ietf.org/html/rfc7539) bölüm 2.8 de belirtildiği gibi AEAD_CHACHA20_POLY1305.
  12 baytlık nonce, ilk 4 baytı sıfır.

- Hash Fonksiyonu: SHA256
  I2P'de yaygın olarak kullanılan standart 32 baytlık hash.


## Çerçeveye Eklemeler

Bu öneri, Noise_XK_25519_ChaChaPoly_SHA256'yı şu şekilde geliştirir.
Bunlar, genellikle [NOISE](http://noiseprotocol.org/) bölüm 13'te belirtilen
yönergelere uyar.

1) Şifresiz geçici anahtarlar, bilinen bir anahtar ve IV kullanılarak
   AES şifrelemesi ile bulanıklaştırılır. Bu işlem elligator2'den daha hızlıdır.

2) Mesaj 1 ve 2'ye rastgele şifresiz dolgu eklenir.
   Şifresiz dolgu, el sıkışma karması (MixHash) hesaplamasına dahil edilir.
   Mesaj 2 ve mesaj 3 kısım 1 için KDF bölümlerine bakın.
   Mesaj 3 ve veri aşaması mesajlarına rastgele AEAD dolgusu eklenir.

3) Veri aşaması mesajlarında olduğu gibi, TCP üzerindeki Noise için gereken
   iki baytlık çerçeve uzunluğu alanı eklenir ve obfs4'te olduğu gibi.
   Mesaj 1 ve 2 AEAD çerçeveleri sabit uzunluktadır.
   Mesaj 3 kısım 1 AEAD çerçeve uzunluğu sabittir.
   Mesaj 3 kısım 2 AEAD çerçeve uzunluğu mesaj 1'de belirtilir.

4) Çift baytlık çerçeve uzunluğu alanı, SipHash-2-4 ile bulanıklaştırılır,
   obfs4'te olduğu gibi.

5) Mesajlar 1, 2, 3 ve veri aşaması için yük formatı tanımlanır.
   Elbette, bu Noise'da tanımlanmamıştır.


## I2P için Yeni Kriptografik İlkeler

Mevcut I2P yönlendirici uygulamaları, şu standart kriptografik
ilkeller için uygulamalar gerektirebilir,
mevcut I2P protokolleri için gerekmeyen:

1) X25519 anahtar oluşturma ve DH

2) AEAD_ChaCha20_Poly1305 (aşağıda ChaChaPoly olarak kısaltılmıştır)

3) SipHash-2-4


## İşlem Yükü Tahmini

3 mesajın boyutları:

1) 64 bayt + dolgu (NTCP 288 bayttı)
2) 64 bayt + dolgu (NTCP 304 bayttı)
3) Yaklaşık 64 bayt + Alice yönlendirici bilgisi + dolgu  Ortalama yönlendirici bilgisi yaklaşık 750
   bayt Toplam ortalama 814 bayt dolgu öncesi (NTCP 448 bayttı)
4) NTCP2'de gerekli değil (NTCP 48 bayttı)

Toplam dolgudan önce:
NTCP2: 942 bayt
NTCP: 1088 bayt
Alice, Bob ile iletişim kurmak için
bir RouterInfo Mesajı göndermek için bağlandıysa,
bu mesaj gerekli değildir ve yaklaşık 800 bayt tasarruf edilir.

Anlaşmayı tamamlamak ve veri aşamasına başlamak
için her bir tarafça gereken kriptografik işlemler:

- AES: 2
- SHA256: 7 (Alice), 6 (Bob) (1 Alice, 2 Bob ön hesaplamalı tüm
   bağlantılar için) (HMAC-SHA256'yı içermiyor)
- HMAC-SHA256: 19
- ChaChaPoly: 4
- X25519 anahtar oluşturma: 1
- X25519 DH: 3
- İmza doğrulama: 1 (Bob) (Alice daha önce RI'yi
   oluştururken imzaladı) Muhtemelen Ed25519 (RI
   imza türüne bağlı)


Her veri aşaması mesajı için her bir tarafça gereken
kriptografik işlemler:

- SipHash: 1
- ChaChaPoly: 1



## Mesajlar

Tüm NTCP2 mesajları 65537 bayttan daha küçük veya eşittir.
Mesaj formatı, çerçeveleme ve ayırt edilemezlik için
modifikasyonlarla birlikte Noise mesajlarına dayanır.
Standart Noise kütüphanelerini kullanan uygulamalar,
Noise mesaj formatına/formatından alınan
mesajları ön işlemden geçirmesi gerekebilir. Tüm şifrelenmiş alanlar
VEAD şifrelemeli metinlerdir.


Kurulum sırası aşağıdaki gibidir:

Alice                           Bob

  Oturum İsteği ------------------->
  <------------------- Oturum Oluşturuldu
  Oturum Onaylandı ----------------->
Noise terminolojisinde, kurulum ve veri sırası şu şekildedir:
(Yük Güvenlik Özellikleri)

XK(s, rs):           Kimlik Doğrulama   Gizlilik
    <- s
    ...
    -> e, es                  0                2
    <- e, ee                  2                1
    -> s, se                  2                5
    <-                        2                5
Bir oturum kurulduğunda, Alice ve Bob Veri mesajları alışverişi yapabilirler.

Tüm mesaj türleri (Oturum İsteği, Oturum Oluşturuldu, Oturum Onaylandı, Veri ve
Zaman Senkronizasyonu) bu bölümde belirtilmiştir.

Bazı notasyonlar::

  - RH_A = Alice için Yönlendirici Hashi (32 bayt)
  - RH_B = Bob için Yönlendirici Hashi (32 bayt)


### Kimlik Doğrulama Şifrelemesi

Üç ayrı kimlik doğrulama şifreleme örneği (CipherStates) vardır.
Biri el sıkışma aşamasında ve iki (gönderme ve alma) veri aşamasında.
Her birinin KDF'den aldığı kendi anahtarı vardır.

Şifrelenmiş/doğrulanmış veri şu şekilde temsil edilir 

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   Şifrelenmiş ve doğrulanmış veri     |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
ChaCha20/Poly1305
`````````````````

Şifrelenmiş ve doğrulanmış veri formatı.

Şifreleme/şifre çözme fonksiyonlarına girişler:

k :: 32 bayt şifreleme anahtarı, KDF'den türetilmiş

  nonce :: Sayaç tabanlı nonce, 12 bayt.
           Her mesaj için 0'dan başlayarak artırılır.
           İlk dört bayt her zaman sıfırdır.
           Son sekiz bayt ise sayaçtır, küçük endian kodlanmıştır.
           Maksimum değer 2**64 - 2'dir.
           Bağlantı, bu değere ulaştığında durdurulmalı ve yeniden başlatılmalıdır.
           2**64 - 1 değeri asla gönderilmemelidir.

  ad :: El sıkışma aşamasındayken:
        İlişkili veri, 32 bayt.
        Önceki tüm verilerin SHA256 karma değeri.
        Veri aşamasında:
        Sıfır bayt

  data :: Düz metin veri, 0 veya daha fazla bayt

Şifreleme fonksiyonunun çıktısı, şifre çözme fonksiyonunun girişi:

+----+----+----+----+----+----+----+----+
  |Bulanık Len|                             |
  +----+----+                             +
  |       ChaCha20 ile şifrelenmiş veri        |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Mesaj Kimlik Doğrulama Kodu |
  +              (MAC)                    +
  |             16 bayt                   |
  +----+----+----+----+----+----+----+----+

  Obfs Len :: Takip edecek (şifrelenmiş veri + MAC) uzunluğu, 16 - 65535
              SipHash kullanarak bulanıklaştırma (aşağıya bakınız)
              Sabit uzunluğun kullanıldığı mesaj 1 veya 2'de kullanılmaz
              Sabit uzunluğun kullanıldığı mesaj 3 kısım 1'de kullanılmaz
              Mesaj 3 kısım 1'de kullanılmaz, çünkü uzunluk mesaj 1'de belirtilmiştir

  şifrelenmiş veri :: Aynı boyutta olan düz metin veri, 0 - 65519 bayt

  MAC :: Poly1305 mesaj kimlik doğrulama kodu, 16 bayt

ChaCha20 için burada tarif edilen [RFC-7539](https://tools.ietf.org/html/rfc7539) ile
bağlantılıdır, TLS'te [RFC-7905](https://tools.ietf.org/html/rfc7905) gibi kullanılır.

Notlar
`````
- ChaCha20 bir akış şifresi olduğundan, düz metinler doldurulmak zorunda değildir.
  Ek keystream baytları atılır.

- Şifre için anahtar (256 bit), SHA256 KDF ile kararlaştırılır.
  Her mesaj için KDF'nin detayları ayrı bölümlerde yer alır.

- ChaChaPoly çerçeveleri mesaj 1, 2 ve mesaj 3'ün ilk kısmında
  bilinen boyuttadır. Mesaj 3'ün ikinci kısmından itibaren,<br>çerçeveler değişken boyuttadır. Mesaj 3 kısım 1 boyutu mesaj 1'de belirtilmiştir.
  Veri aşamasından itibaren, çerçeveler obfs4'te olduğu gibi SipHash ile bulanıklaştırılmış çift bayt uzunluğuyla başlatılır.

- Dolgu, mesaj 1 ve 2 için kimlik doğrulanmış veri çerçevesinin dışındadır.
  Dolgu, bir sonraki mesaj için KDF'de kullanılır, böylece müdahale
  herhangi bir sorun yaratacaktır. Mesaj 3'ten itibaren dolgu kimlik
  doğrulanmış veri çerçevesinin içinde yer alır.


AEAD Hata İşleme
`````````````````
- Mesajlar 1, 2 ve mesaj 3 kısımlar 1 ve 2 için, AEAD mesaj boyutu daha önce bilinir.
  Bir AEAD kimlik doğrulama hatasında, alıcı daha fazla mesaj işlemini durdurmalı ve
  yanıt vermeden bağlantıyı kapatmalıdır. Bu anormal bir kapanış (TCP RST) olmalıdır.

- Tarama direnci için, mesaj 1'de, bir AEAD hatasından sonra, Bob
  bir rastgele zaman aşımı ayarlamalı (aralık TBD) ve ardından rastgele bir bayt sayısını okumalıdır (aralık TBD).
  Bob, tekrarlanan başarısızlıklarla IP'leri kara listeye almalıdır.

- Veri aşamasında, AEAD mesaj boyutu SipHash ile "şifrelenmiştir" (bulanıklaştırılmıştır).
  Bir şifre çözme oraklı oluşturmaktan kaçınılmalıdır.
  Bir veri aşaması AEAD kimlik doğrulama hatasında, alıcı
  bir rastgele zaman aşımı ayarlamalı (aralık TBD) ve ardından rastgele bir bayt sayısını okumalıdır (aralık TBD).
  Okumanın ardından veya okuma zaman aşımında, alıcı
  bir "AEAD hatası" neden kodu içeren bir bitim bloğu içeren bir yük gönderip
  ardından bağlantıyı kapatmalıdır.

- Veri aşamasındaki geçersiz uzunluk alanı değeri için aynı hata hareketini alın.


### Anahtar Türetme Fonksiyonu (KDF) (el sıkışma mesajı 1 için)

Bu KDF, DH sonucundan bir el sıkışma aşaması şifre anahtarı k üretir,
HMAC-SHA256(key, data) [RFC-2104](https://tools.ietf.org/html/rfc2104) yerinde tanımlandığı gibi.
Bu, Noise spesifikasyonunda tam olarak tanımlandığı gibi InitializeSymmetric(), MixHash() ve MixKey() fonksiyonlarıdır.

Bu, "e" mesaj deseni:

  // protokol_adını tanımlayın.
  protokol_adı = "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256" olarak ayarlayın
   (48 bayt, US-ASCII kodlanmış, NULL sonlandırması yok).

  // Hash h'yi tanımlayın = 32 bayt
  h = SHA256(protokol_adı);

  32 baytlık bir zincirleme anahtarı ck tanımlayın. h verilerini ck'ye kopyalayın.
  ck = h olarak ayarlayın

  rs = Bob'un Yönlendirici Bilgisi içinde yayımlanan 32 baytlık statik anahtar

  // null prologue ile MixHash()
  h = SHA256(h);

  // buraya kadar, Alice, hepsi giden bağlantılar için ön hesaplama yapabilir

  // Alice burada Bob'un statik anahtarının eğrinin üzerinde geçerli olduğunu onaylamalıdır.

  // Bob statik anahtarı
  // MixHash(rs)
  // aşağıda ||, eklemek anlamına gelir
  h = SHA256(h || rs);

  // buraya kadar, Bob, hepsi gelen bağlantılar için ön hesaplama yapabilir

  Bu, "e" mesaj deseni:

  Alice, geçici DH anahtar çifti e'yi oluşturur.

  // Alice geçici anahtarı X
  // MixHash(e.pubkey)
  // aşağıda ||, eklemek anlamına gelir
  h = SHA256(h || e.pubkey);

  // h, mesaj 1'deki AEAD için ilişkili veri olarak kullanılır
  // Mesaj 2 KDF'si için Hash h'yi saklayın


  "e" mesaj deseninin sonu.

  Bu, "es" mesaj deseni:

  // DH(e, rs) == DH(s, re)
  Alice'in geçici anahtarı ve Bob'un statik anahtarı ile ilgili
  32 baytlık DH sonucunu tanımlayın
  Girdi_anahtar_malzeme = X25519 DH sonucu olarak ayarlayın

  // MixKey(DH())

  32 baytlık bir geçici anahtar tanımlayın
  HMAC-SHA256(key, data) tanımlayın, [RFC-2104](https://tools.ietf.org/html/rfc2104) yerinde
  // zincirleme anahtarı ve DH sonucundan bir geçici anahtar oluşturun
  // ck zincirleme anahtarıdır, yukarıda tanımlanmıştır
  temp_key = HMAC-SHA256(ck, input_key_material)
  // DH sonucunu bellekte overwrite edin, artık gerekmez
  input_key_material = (hepsi sıfır)

  // Çıktı 1
  // Geçici anahtardan yeni bir zincirleme anahtarı ayarlayın
  // aşağıda byte() bir bayt anlamına gelir
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // Çıktı 2
  // Şifreleme anahtarı k oluşturun
  32 baytlık bir k tanımlayın
  // aşağıda ||, ekleme anlamına gelir
  // aşağıda byte(), bir bayt anlamına gelir
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
  // geçici anahtarı bellekte overwrite edin, artık gerekmez
  temp_key = (hepsi sıfır)

  // mesaj 2 KDF'si için zincirleme anahtar ck'yi saklayın


  "es" mesaj deseninin sonu.

### 1) SessionRequest

Alice, Bob'a gönderir.

Noise içeriği: Alice'in geçici anahtarı X
Noise yükü: 16 bayt seçenek bloğu
Noise dışı yük: Rastgele dolgu

(Yük Güvenlik Özellikleri)

XK(s, rs):           Kimlik Doğrulama   Gizlilik
    -> e, es                  0                2

    Kimlik Doğrulama: Yok (0).
    Bu yük, aktif bir saldırgan dahil herhangi bir tarafça gönderilmiş olabilir.

    Gizlilik: 2.
    Bilinen bir alıcıya şifreleme, yalnızca gönderici ihlali durumunda ileri gizlilik
    sunar, yeniden oynatma zafiyetine karşı savunmasızdır. Bu yük, yalnızca alıcının
    statik anahtar çiftini içeren DH'lerle şifrelenir. Alıcının statik özel anahtarı
    ihlal edilirse, bu yük çözülmeye açıktır. Bu mesaj da yeniden oynatılabilir, çünkü
    göndericiden bir geçici katkı yoktur.

    "e": Alice, yeni bir geçici anahtar çifti oluşturur ve bunu 'e'
         değişkeninde saklar, geçici genel anahtarı mesaj
         tamponuna şifresiz yazar ve eski 'h' ile birlikte
         genel anahtarı karma ederek yeni bir 'h' elde eder.

    "es": Alice'in geçici anahtar çifti ve alıcının statik anahtar
          çifti arasındaki bir DH gerçekleştirilir. Sonuç
          eski ck ile birlikte karma edilerek yeni bir
          ck ve k, ve n sıfıra ayarlanır.


X değeri, DPI karşı önlemleri için gerekli olan
yük ayırt edilemezliğinin ve benzersizliğin sağlanması için şifrelenir.
Bunu başarmak için AES şifrelemesini tercih ederiz,
daha karışık ve yavaş alternatiflerden ziyade elligator2 gibi.
Bob'un yönlendirici genel anahtarına yönelik asimetrik şifreleme
çok yavaş olurdu.
AES şifreleme, Bob'un yönlendirici hashini anahtar olarak ve
ağ veritabanında yayımlanan Bob'un IV'sini kullanır.

AES şifreleme yalnızca DPI direnci içindir.
Bob'un yönlendirici hashi ve IV'si bilinirse, ağ veritabanında yayımlanmışsa,
ve mesaj 1'in ilk 32 baytı gözlemlenmişse, bu mesajdaki X değeri
çözülebilir.

Dolgu, Alice tarafından şifrelenmez.
Bu, Bob'un zamanlama saldırılarına karşı güvenlik için
dolgu çözümleyebilir.


Ham içerikler:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        RH_B ile bulanıklaştırıldı     +
  |       AES-CBC-256 ile şifrelenmiş X   |
  +             (32 bayt)                 +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaChaPoly çerçevesi                 |
  +             (32 bayt)                 +
  |   mesaj 1 için KDF'de tanımlanan k    |
  +   n = 0                               +
  |   ilişkili veriler için KDF'ye bakın  |
  +----+----+----+----+----+----+----+----+
  |     şifresiz doğrulanmış dolgu        |
  ~         dolgu (isteğe bağlı)          ~
  |     Uzunluk seçenekler bloğunda tanımlanan   |
  +----+----+----+----+----+----+----+----+

  X :: 32 bayt, AES-256-CBC şifrelenmiş X25519 geçici anahtarı, küçük endian
          anahtar: RH_B
          iv: Bob'un ağ veritabanı girişinde yayımlandığı gibi

  dolgu :: Rastgele veriler, 0 veya daha fazla bayt.
             Toplam mesaj uzunluğu 65535 baytı aşmamalıdır.
             Toplam mesaj uzunluğu 287 bayt veya daha az olmalıdır
             Bob adresini NTCP olarak yayınladığında
             (sürüm tespitine bakın).
             Alice ve Bob, mesaj 2 için KDF'de dolgu verilerini kullanacaktır.
             KDF şemasının, bir sonraki mesajın başarısız olmasına neden olacağı
             şekilde kontrol edilmesi için kimlik doğrulaması yapılır.

Şifresiz veriler (Poly1305 kimlik doğrulama etiketi gösterilmemiştir):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                   X                   |
  +              (32 bayt)                +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               seçenekler             |
  +              (16 bayt)               +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     şifresiz doğrulanmış dolgu        |
  +         dolgu (isteğe bağlı)          +
  |     Uzunluk seçenekler bloğunda tanımlanan   |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  X :: 32 bayt, X25519 geçici anahtarı, küçük endian

  seçenekler :: seçenekler bloğu, 16 bayt, aşağıya bakın

  dolgu :: Rastgele veriler, 0 veya daha fazla bayt.
             Toplam mesaj uzunluğu 65535 baytı aşmamalıdır.
             Toplam mesaj uzunluğu 287 bayt veya daha az olmalıdır
             "NTCP" olarak yayımlandığında
             (sürüm tespitine bakın)
             Alice ve Bob, mesaj 2 için KDF'de dolgu verilerini kullanacaktır.
             Tamamen kontrol edilmesi için kimlik doğrulaması yapılır.
             Herhangi bir müdahale bir sonraki mesajın başarısız olmasına neden olacaktır.

Seçenekler Bloğu:
Not: Tüm alanlar büyük endian'dır.

+----+----+----+----+----+----+----+----+
  | id | ver|  dolguUzunluğu | m3p2len | Rsvd(0) |
  +----+----+----+----+----+----+----+----+
  |        tsA        |   Rezerve (0)    |
  +----+----+----+----+----+----+----+----+

  id :: 1 bayt, ağ kimliği (şu anda 2, test ağları hariç)
        0.9.42 itibarıyla. 147 numaralı öneriye bakın.

  ver :: 1 bayt, protokol sürümü (şu anda 2)

  dolguUzunluğu :: 2 bayt, dolgu uzunluğu, 0 veya daha fazlası
            Min/maks kurallar TBD. 0 ila 31 bayt arasında rastgele boyut minimum?
            (Dağılım belirlenecek, bkz. Ek A.)

  m3p2Len :: 2 bayt, Oturum Onaylandı'da (mesaj 3 bölüm 2) gönderilecek ikinci AEAD çerçevesinin uzunluğu
             Aşağıdaki notlara bakın

  Rsvd :: 2 bayt, uyumlulukla ilgili gelecek seçenekler için 0 ayarlayın

  tsA :: 4 bayt, Unix zaman damgası, işaretsiz saniyeler.
         2106 yılında çevresi doluyor

  Rezerve :: 4 bayt, uyumlulukla ilgili gelecek seçenekler için 0 ayarlayın

Notlar
`````
- Yayımlanan adres "NTCP" olduğunda, Bob aynı portta hem NTCP hem de NTCP2'yi
  destekler. Uyumluluk için, "NTCP" olarak yayımlanmış bir adrese bağlanırken
  Alice, bu mesajın maksimum boyutunu, dahil olan dolgu dahil, 287 bayt veya
  daha azıyla sınırlamalıdır. Bu, Bob tarafından otomatik protokol
  tanımlamasını kolaylaştırır. "NTCP2" olarak yayımlandığında, herhangi bir
  boyut kısıtlaması yoktur. Yayınlanan Adresler ve Sürüm Tespit bölümlerine
  bakınız.

- Başlangıç AES bloğundaki benzersiz X değeri, şifreli metnin
  her oturum için farklı olmasını sağlar.

- Bob, zaman damgası değeri mevcut zamandan çok uzak
  olduğunda bağlantıları reddetmelidir. Maksimum zaman
  farkına "D" adını verin. Bob, yeniden oynatma
  saldırılarını önlemek için daha önce kullanılmış el sıkışma değerlerinden
  oluşan bir yerel önbellek tutmalı ve tekrarları
  reddetmelidir. Önbellekteki değerlerin, en az 2*D
  ömrü olması gerekir. Önbellek değerleri uygulamaya
  bağlıdır, ancak 32 baytlık X değeri (veya şifrelenmiş
  karşılığı) kullanılabilir.

- Kriptografik saldırıları önlemek için Geçici-Hellman geçici anahtarları
  yeniden kullanılmamalıdır ve yeniden kullanım, yeniden
  oynatma saldırısı olarak reddedilecektir.

- "KE" ve "auth" opsiyonları uyumlu olmalıdır, yani paylaşılan sır
  K uygun büyüklükte olmalıdır. Daha fazla "auth"
  seçeneği eklendiğinde, bu, "KE" bayrağının anlamını farklı bir KDF
  veya farklı bir kesikleme boyutu kullanmak üzere
  dolaylı olarak değiştirebilir.

- Bob burada Alice'in geçici anahtarının eğrinin
  üzerinde geçerli olduğunu onaylamalıdır.

- Dolgunun makul miktarda sınırlı olması gerekir. Bob,
  aşırı dolgulu bağlantıları reddedebilir. Bob, dolgu
  seçeneklerini mesaj 2'de belirleyecektir. Min/maks kurallar
  TBD. 0 ila 31 bayt arasında rastgele boyut minimum?
  (Dağılım belirlenecek, bkz. Ek A.)

- Herhangi bir hata, örneğin AEAD, DH, zaman damgası, bariz
  yeniden oynatma veya anahtar doğrulama hatası
  durumunda, Bob daha fazla mesaj işlemini durdurmalı ve
  yanıt vermeden bağlantıyı kapatmalıdır. Bu anormal bir
  kapanış (TCP RST) olmalıdır. Tarama direnci için,
  bir AEAD hatasından sonra Bob, bir rastgele zaman
  aşımı ayarlamalı (aralık TBD) ve ardından rastgele bir
  bayt sayısını okumalı (aralık TBD),
  ardından soketi kapatmalıdır.

- DoS Azaltma: DH nispeten karmaşık bir işlemdir. Önceki NTCP
  protokolünde olduğu gibi, yönlendiriciler CPU veya bağlantı
  yorgunluğunu önlemek için gereken tüm önlemleri almalıdır.
  Maksimum aktif bağlantılar ve maks uçuş bağlantı
  kurulumlarına sınır koyun. Oku zaman aşımı uygulayın
  (hem okuma başına hem de toplamda "yavaş loris" için).
  Aynı kaynaktan yinelenen veya eşzamanlı bağlantıları
  sınırlayın. Tekrar eden hatalarla kara listeye alma
  kaynaklarını koruyun.
  AEAD başarısızlığını yanıtlamayın.

- Hızlı sürüm tespiti ve el sıkışma sağlamak için,
  uygulamalar Alice'in, ilk mesaja kadar
  olan tüm içeriği, dolgu dahil, tek seferde
  tamponlayıp ardından yollamasını sağlamalıdır.
  Bu, verilerin tek bir TCP paketinde (OS veya
  orta kutular tarafından dilimlenmezse) yer almasını
<|vq_2738|>
