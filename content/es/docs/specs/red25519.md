---
title: "Esquema de firma Red25519"
description: "Esquema de firma re-aleatorizable para crear Destinations (identidades de servicio en I2P) cegadas"
slug: "red25519"
lastUpdated: "2025-10"
accurateFor: "2.10.0"
---

## Descripción general

Este documento especifica un esquema de firma re-aleatorizable, adecuado para crear Destinos que pueden ser cegados. Además, puede utilizarse para cegar Destinos Ed25519 existentes, con una ligera reducción de eficacia.

Red25519 ha estado totalmente operativo en los routers de I2P desde la versión 0.9.39 (publicada el 21 de marzo de 2019). Esta especificación se finalizó en la versión 0.9.47 (agosto de 2020) tras 17 meses de despliegue en producción. El esquema de firma opera como tipo de firma 11 (RedDSA_SHA512_Ed25519) en la red I2P.

## Motivación

La Propuesta 123 (New netDB Entries) define un formato LeaseSet2 cifrado que materializa el Principio de mínima autoridad: a cada participante de la red se le proporciona únicamente la información necesaria para su función. En particular, un LeaseSet2 cifrado publicado en un floodfill no revela el Destino al que corresponde, y los Leases solo pueden ser vistos por alguien con conocimiento previo del Destino. Sin embargo, los floodfills siguen necesitando poder autenticar los LeaseSet2 cifrados cuando se publican, y los clientes, además, deben asegurarse de que la autenticación haya sido aplicada por el propio Destino.

La Propuesta 123 lo consigue al cegar las claves de firma de los Destinos. Las claves cegadas pueden usarse para crear firmas verificables por los floodfills, y los clientes pueden estar seguros de que solo el Destino podría haber creado las firmas. Por lo tanto, es necesario especificar un esquema de firma que pueda utilizarse para el cegado.

**Nota sobre el estado de la Propuesta 123**: Partes de la Propuesta 123 se han implementado y desplegado progresivamente desde la versión 0.9.38, y se añadió compatibilidad con Red25519 (curva criptográfica) en la 0.9.39. La funcionalidad cifrada de LeaseSet2 está lista para producción y se utiliza activamente en la red I2P para servicios ocultos con privacidad mejorada.

## Diseño

### Esquema de firma principal

El esquema de firma especificado aquí, Red25519, es una instanciación de RedDSA tal como se define en la Sección 5.4.6 de la Especificación del Protocolo de Zcash (Sapling y posteriores). RedDSA es un esquema de firma basado en Schnorr que admite key re-randomization (re-aleatorización de claves). Tiene las siguientes funciones:

**GENERATE_PRIVATE()** : Devuelve una clave privada aleatoria con distribución uniforme.

**DERIVE_PUBLIC(sk)** : Devuelve la clave pública correspondiente a la clave privada proporcionada.

**GENERATE_RANDOM()** : Devuelve un escalar aleatorio adecuado para volver a aleatorizar un par de claves.

**RANDOMIZE_PRIVATE(sk, alpha)** : Re-aleatoriza una clave privada, utilizando un escalar secreto alpha.

**RANDOMIZE_PUBLIC(vk, alpha)** : Vuelve a aleatorizar una clave pública, utilizando un escalar secreto alpha.

**SIGN(sk, m)** : Devuelve una firma con la clave privada sk sobre el mensaje m dado.

**VERIFY(vk, m, sig)** : Verifica la firma sig frente a la clave pública vk y el mensaje m. Devuelve verdadero si la firma es válida, falso en caso contrario.

Para un par de claves dado (sk, vk) se cumple la siguiente relación:

```
RANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha))
```
### Conversión de claves Ed25519 a Red25519

Las claves Ed25519 PUEDEN convertirse temporalmente y de forma unidireccional en claves Red25519, con el fin de admitir la re-aleatorización de Destinos Ed25519 existentes. Otros tipos de firma no son compatibles.

Definimos las siguientes funciones de conversión:

**CONVERT_ED25519_PRIVATE(privkey)** : Devuelve la clave privada Red25519 correspondiente a la clave privada Ed25519 dada.

**CONVERT_ED25519_PUBLIC(pubkey)** : Devuelve la clave pública Red25519 correspondiente a la clave pública Ed25519 dada.

Para un par de claves Ed25519 dado (privkey, pubkey), se cumple la siguiente relación:

```
CONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey))
```
## Especificación

### Definiciones

**B** : El punto base de Ed25519 según [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html).

**L** : El orden de Ed25519 2^252 + 27742317777372353535851937790883648493 como en [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html).

**[s] B** : Multiplicación escalar de base fija del punto base por s.

**[s] A** : Multiplicación escalar de base variable de A por s.

**x || y** : Concatenar dos arrays de bytes x e y.

### Red25519

El esquema Red25519 es una especialización de RedDSA (un esquema de firma digital) con:

- G := el grupo de puntos en la forma de Edwards de Curve25519. En particular, esto significa que Red25519 utiliza el subgrupo de orden primo L, y el cofactor h_G es 8.
- P_G := el punto base B de Ed25519.
- l_H := 512
- H(x) := SHA-512("I2P_Red25519H(x)" || x)

**Nota sobre la elección de la función hash**: Red25519 usa SHA-512 en lugar de BLAKE2b-512 (como en Zcash RedDSA). Esta decisión de diseño se compensa con la protección mediante prefijo de longitud descrita más abajo. I2P Proposal 148 sugiere una migración futura a BLAKE2b-512 para una protección mejorada contra Duplicate Message Identification (identificación duplicada de mensajes, DMI) y Length Extension Attacks (ataques de extensión de longitud, LEA), además de un mejor rendimiento.

RedDSA asume que H(x) se implementa con una función hash criptográfica segura frente a ataques de extensión de longitud. SHA-512 no cumple este requisito por sí misma. Para remediarlo, requerimos que a los mensajes se les anteponga una codificación libre de prefijos de su longitud:

```
len_u16(M) || M
```
donde `len_u16(M)` es la representación de 2 bytes de la longitud de M, en little-endian (orden de bytes de menor a mayor; para ser coherente con la codificación little-endian de escalares y puntos).

Los mensajes no deben exceder los 65534 bytes. Una longitud de 65535 está reservada para posibles extensiones futuras.

**Nota de seguridad**: La inclusión de la clave pública (vk) en la función hash, combinada con 80 bytes aleatorios en la firma, garantiza protección contra vulnerabilidades SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack; inafalsificabilidad fuerte con claves re-aleatorizadas bajo ataque de mensaje elegido) descubiertas en diseños tempranos de RedDSA. Esta implementación incorpora las correcciones de seguridad de la auditoría de Zcash de NCC Group (Hallazgo NCC-Zcash2018-009).

### Codificación y decodificación

Las claves privadas de Red25519 son escalares módulo L, y se codifican en representación little-endian. Definimos las funciones `DECODE_SCALAR` y `ENCODE_SCALAR` para convertir entre el arreglo de bytes y la representación entera de un escalar.

Las claves públicas Red25519 son puntos en la forma de Edwards de Curve25519. Se codifican como la representación little-endian de 255 bits de la coordenada y, seguida de un único bit que indica el signo de la coordenada x. Esta es la misma codificación que la de Ed25519. Definimos las funciones `DECODE_POINT` y `ENCODE_POINT` para convertir entre la forma de arreglo de bytes y la forma de coordenadas de un punto.

### Funciones de RedDSA

Para facilitar la implementación, a continuación detallamos explícitamente las funciones RedDSA (esquema de firma digital de Zcash), así como varias funciones auxiliares, ya especializadas para Red25519 (parámetros específicos usados por RedDSA). Quienes implementen deben consultar la sección 5.4.6 de la Especificación del Protocolo de Zcash para la especificación general de las funciones RedDSA.

```
HStar(prefix1, prefix2, m) :=
    h = SHA-512()
    h.input("I2P_Red25519H(x)")
    h.input(prefix1)
    h.input(prefix2)

    h.input(len(m) & 0xff)
    h.input((len(m) >> 8) & 0xff)
    h.input(m)

    s = h.digest()
    return s mod L

GENERATE_PRIVATE :=
    s = 64 random bytes
    return s mod L

DERIVE_PUBLIC(sk) := [sk] B

GENERATE_RANDOM :=
    s = 64 random bytes
    return s mod L

RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L

RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B

SIGN(sk, m) :=
    T = 80 random bytes
    vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk))
    r = HStar(T, vkBytes, m)

    R = [r] B
    Rbytes = ENCODE_POINT(R)

    c = HStar(Rbytes, vkBytes, m)
    S = (r + (c * sk)) mod L

    return Rbytes || ENCODE_SCALAR(S)

VERIFY(vk, m, sig) :=
    Rbytes = sig[0..32]
    Sbytes = sig[32..64]

    R = DECODE_POINT(Rbytes)
    if R is invalid:
        return false

    S = DECODE_SCALAR(Sbytes)
    if S >= L:
        return false

    vkBytes = ENCODE_POINT(vk)
    c = HStar(Rbytes, vkBytes, m)
    return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity()
```
### Funciones de conversión

```
CONVERT_ED25519_PRIVATE(privkey) :=
    s = SHA-512(privkey)[0..32]
    s[0] = s[0] & 248
    s[31] = (s[31] & 63) | 64
    return s

CONVERT_ED25519_PUBLIC(pubkey) := pubkey
```
Tenga en cuenta que la implementación de `CONVERT_ED25519_PRIVATE` es equivalente al cálculo del escalar secreto s al derivar una clave pública Ed25519 a partir de una clave privada Ed25519, según se especifica en los pasos 1-3 de la sección 5.1.5 de [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html).

## Implicaciones de seguridad

Volver a aleatorizar un Destino Red25519 y luego crear firmas con él no filtra ninguna información sobre el Destino, porque la distribución de las claves privadas Red25519 generadas mediante `RANDOMIZE_PRIVATE` es idéntica a la distribución de las claves privadas generadas mediante `GENERATE_PRIVATE`, y `DERIVE_PUBLIC` es determinista.

Convertir claves privadas Ed25519 (algoritmo de firma digital de curva elíptica) a Red25519 (variante relacionada de Ed25519) mediante `CONVERT_ED25519_PRIVATE` no produce la misma distribución. Sin embargo, consideramos aceptable la reducción de la seguridad por las siguientes razones:

- El espacio de Ed25519 scalars (escalares de Ed25519) es aproximadamente la mitad del tamaño del espacio de Red25519 scalars (escalares de Red25519) (hay 2^251 Ed25519 scalars posibles, y L ~= 2^252 Red25519 scalars posibles). Por lo tanto, la pérdida de seguridad es como máximo de un factor de alrededor de 2, o de alrededor de 1 bit (porque podríamos haber elegido por casualidad un Red25519 scalar que también sea un Ed25519 scalar válido).
- Los Destinos Ed25519 existentes ya han sido expuestos históricamente en la red, y debe asumirse que los floodfills maliciosos ya los han enumerado.

**Importante**: Los usuarios preocupados por esta reducción de seguridad deberían usar Red25519 (tipo de firma 11) como tipo de firma para sus Destinos en lugar de Ed25519 (tipo de firma 7).

Nótese que el argumento anterior no se aplica al escalar alpha de re-randomization (re-aleatorización); se filtra información sobre la clave cada vez que se elige un alpha sesgado, porque la re-randomization aditiva se comporta como una libreta de un solo uso.

### Estado de la auditoría de seguridad

**Aviso importante**: I2P, incluido Red25519, nunca ha sido sometido a una auditoría de seguridad formal por terceros. El diseño subyacente RedDSA se sometió a una revisión de seguridad por parte de NCC Group como parte de la auditoría del protocolo Sapling de Zcash en 2018, donde se identificaron y corrigieron problemas de seguridad. Sin embargo, la instanciación específica de I2P con SHA-512 (en lugar de BLAKE2b-512) y la separación de dominios de I2P no han sido analizadas de forma independiente.

La implementación de referencia ed25519-java de str4d se sometió a una auditoría independiente de un tercero, pero esta antecedió a la implementación de Red25519 (una extensión de Ed25519) y cubrió únicamente la funcionalidad de Ed25519, no las extensiones de Red25519.

Los usuarios que desplieguen Red25519 deben comprender esta limitación y evaluar las compensaciones de seguridad según su modelo de amenazas.

## Compatibilidad

Las versiones de I2P que admitan Red25519 (versión 0.9.39 y posteriores) podrán verificar las estructuras de datos de red firmadas con ella. Las versiones de I2P que no admitan Red25519 la tratarán como una firma desconocida y PODRÍAN descartar las estructuras de datos.

**Cronología de despliegue**: - **0.9.39** (marzo de 2019): Primera implementación con compatibilidad de Encrypted LS2 en floodfills - **0.9.40** (mayo de 2019): Autorización por cliente para Encrypted LS2 - **0.9.41** (agosto de 2019): Meta LS2 y Encrypted LS2 con claves sin conexión - **0.9.43** (febrero de 2020): Compatibilidad con b32 para Encrypted LS2 - **0.9.47** (agosto de 2020): Finalización de la especificación - **2.10.0** (octubre de 2025): Versión de red actual (equivalente a 0.9.67+)

Los usuarios deberían esperar que la fiabilidad de las estructuras de datos firmadas con Red25519 sea buena para casos de uso de LeaseSet2 cifrado, ya que la red ha tenido más de seis años para actualizarse desde la implementación inicial. Sin embargo, las métricas de adopción sobre el uso general de destinos no están disponibles públicamente.

**Caso de uso principal**: Red25519 se utiliza principalmente para la funcionalidad de LeaseSet2 cifrado, donde se requiere key blinding (cegamiento de clave). Para destinos estándar sin requisitos de leaseset cifrado, Ed25519 (tipo de firma 7) sigue siendo la opción recomendada debido a su mayor compatibilidad y a su trayectoria comprobada más extensa.

## Notas de implementación

Red25519 está implementado en el I2P Java router en `net.i2p.crypto.eddsa.RedDSAEngine` y utiliza la biblioteca ed25519-java de str4d (Jack Grigg) como dependencia de Maven `net.i2p.crypto:eddsa` (versiones 0.1.0 a 0.3.0).

La implementación de i2pd en C++ también admite Red25519 (signaturetype=11) para la publicación cifrada de LeaseSet.

Ejemplo de configuración para i2pd:

```
signaturetype=11
i2cp.leaseSetType=5
```
**Compatibilidad de LeaseSet2 cifrado**: La especificación de LeaseSet cifrado requiere que la clave pública de firma en el unblinded destination (destino no cegado) sea Ed25519 (tipo de firma 7) o Red25519 (tipo de firma 11). No se admiten otros tipos de firma para la funcionalidad de leaseset cifrado.

## Vectores de prueba

Se proporcionan los siguientes vectores de prueba para la validación de la implementación. Cada vector incluye:

- `edsk`: Clave privada Ed25519 (aleatoria)
- `edpk`: Clave pública Ed25519 correspondiente a edsk
- `sk`: CONVERT_ED25519_PRIVATE(edsk)
- `vk`: CONVERT_ED25519_PUBLIC(edpk)
- `msg`: Mensaje a firmar
- `sig`: SIGN(sk, msg)
- `alpha`: GENERATE_RANDOM()
- `rsk`: RANDOMIZE_PRIVATE(sk, alpha)
- `rvk`: RANDOMIZE_PUBLIC(vk, alpha)
- `rsig`: SIGN(rsk, msg)

**Nota de implementación**: Estos vectores de prueba deben integrarse en suites de pruebas unitarias automatizadas para validación continua. Los implementadores deben verificar que todas las conversiones, firmas y operaciones de re-aleatorización coincidan con estos valores esperados.

### Vector de prueba 1

```
edsk:  0101010101010101010101010101010101010101010101010101010101010101
edpk:  8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c
sk:    58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e
vk:    8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c
msg:   0202020202020202020202020202020202020202020202020202020202020202
sig:   61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a
       6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f
alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08
rsk:   8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107
rvk:   6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3
rsig:  533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5
       b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001
```
### Vector de prueba 2

```
edsk:  0202020202020202020202020202020202020202020202020202020202020202
edpk:  8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394
sk:    a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e
vk:    8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394
msg:   0303030303030303030303030303030303030303030303030303030303030303
sig:   0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d
       5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a
alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203
rsk:   9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402
rvk:   527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177
rsig:  9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51
       3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f
```
**Nota**: Los vectores de prueba adicionales 3-10 siguen el mismo formato y pueden encontrarse en la implementación de referencia.

## Referencias

- [Propuesta 123: Nuevas entradas de netDB](/proposals/123-new-netdb-entries/) - Partes implementadas y desplegadas en 0.9.38, 0.9.39 y versiones posteriores
- [Especificación del protocolo de Zcash, sección 5.4.6: RedDSA, RedJubjub y RedPallas](https://zips.z.cash/protocol/protocol.pdf) - RedDSA está definida como parte de la especificación del protocolo de Zcash; auditada en seguridad por NCC Group (enero de 2019)
- [RFC 8032: Algoritmo de firma digital de curva de Edwards (EdDSA)](https://www.rfc-editor.org/rfc/rfc8032.html)
- [Propuesta 148: RedDSA-BLAKE2b-Ed25519](/proposals/148-eddsa-blake2b-ed25519/) - Propuesta pero aún no implementada; sugiere una migración futura a BLAKE2b-512
- [Especificación de LeaseSet cifrado](/docs/specs/encryptedleaseset/)
- [Especificación de criptografía de bajo nivel](/docs/specs/cryptography/)
