---
title: "SSU2"
number: "159"
author: "eyedeekay, orignal, zlatinb, zzz"
created: "2021-09-12"
lastupdated: "2025-03-05"
status: "Closed"
thread: "http://zzz.i2p/topics/2612"
target: "0.9.56"
---

## Estado

Plan de implementación:


| Función | Prueba (no por defecto) | Habilitado por defecto |
|---------|-------------------------|------------------------|
| Código de prueba local | 2022-02 |
| Código de prueba conjunto | 2022-03 |
| Prueba conjunta en red | 0.9.54 | 2022-05 |
| Congelar protocolo básico | 0.9.54 | 2022-05 |
| Sesión Básica | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Validación de Dirección (Reintentar) 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| RI Fragmentado en negociación | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Nuevo Token | 0.9.55 | 2022-08 | 0.9.57 | 2022-11 |
| Congelar protocolo extendido | 0.9.55 | 2022-08 |
| Relé | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Prueba de Par | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| Habilitar para aleatorio 2% | 0.9.55 | 2022-08 |
| Validación de Camino | 0.9.55+ dev | 0.9.56 | 2022-11 |
| Migración de Conexión | 0.9.55+ dev | 0.9.56 | 2022-11 |
| Bandera de ACK Inmediato | 0.9.55+ dev | 0.9.56 | 2022-11 |
| Rotación de Clave | 0.9.57 | 2023-02 | 0.9.58 | 2023-05 |
| Deshabilitar SSU 1 (i2pd) | 0.9.56 | 2022-11 |
| Deshabilitar SSU 1 (Java I2P) | 0.9.58 | 2023-05 | 0.9.61 | 2023-12 |

La Sesión Básica incluye las fases de negociación y de datos.
El protocolo extendido incluye el relé y la prueba de pares.



## Visión General

Esta propuesta describe un protocolo de acuerdo de clave autenticada para mejorar la
resistencia de [SSU](/en/docs/transport/ssu/) a varias formas de identificación automática y ataques.

La propuesta está organizada de la siguiente manera: los objetivos de seguridad son presentados,
seguido de una discusión del protocolo básico. Luego, se da una especificación completa
de todos los mensajes del protocolo. Finalmente, se discuten las direcciones de los routers y la identificación de versiones.

Al igual que otros transportes I2P, SSU2 está definido
para el transporte punto a punto (router-a-router) de mensajes I2NP.
No es una tubería de datos de propósito general.
Como [SSU](/en/docs/transport/ssu/), también proporciona dos servicios adicionales:
Reenvío para atravesar NAT, y Prueba de Par para determinar la accesibilidad de entrada.
También proporciona un tercer servicio, no presente en SSU, para la migración de conexión
cuando un par cambia de IP o puerto.


## Motivación

SSU es la única capa de protocolo restante que requiere ElGamal, que es muy lento.
El control de flujo para SSU es complejo y no funciona bien.
Partes de SSU son vulnerables a ataques de suplantación de direcciones.
La negociación no utiliza Noise.



## Metas de Diseño

- Reducir el uso de CPU eliminando ElGamal. Usar X25519 para el DH.

- Mantener las funciones de Prueba de Par y Relé, e incrementar la seguridad para ellas.

- Facilitar la implementación permitiendo algoritmos estándar de control de flujo.

- Reducir la latencia de configuración.
  El tiempo de configuración medio es actualmente de aproximadamente 135 ms para NTCP2 y 187 ms para SSU,
  a pesar de que NTCP2 tiene un viaje extra de ida y vuelta; reemplazar ElGamal en
  SSU2 debería reducirlo, pero otros cambios también podrían ayudar.

- Mantener o aumentar el rendimiento máximo en comparación con SSU 1,
  como se mide sobre un rango de latencias simuladas y porcentajes de pérdida de paquetes en una red de pruebas.

- Prevenir amplificación de tráfico y ataques de enrutamiento incorrecto desde direcciones de origen falsificadas
  a través de "validación de dirección".

- Facilitar la identificación de paquetes, para reducir la dependencia de retrocesos y
  heurísticas que hacen que el código sea demasiado complejo.

- Formalizar y mejorar la migración de conexión cuando cambian la IP o el puerto del par.
  No migrar conexiones hasta que la validación de dirección esté completa, para prevenir ataques.
  Algunas implementaciones de SSU 1 usan heurísticas costosas para manejar cambios de puerto
  debido a re-asignación NAT. Ninguna implementación conocida de SSU 1 puede manejar cambios de IP en absoluto.

- Soporte para SSU 1 y 2 en un solo puerto, detección automática, y publicado como un solo
  "transporte" (es decir, [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) en el [NetDB](/en/docs/how/network-database/).

- Publicar soporte para la versión 1 solo, 2 solo, o 1+2 en el NetDB en un campo separado, y por defecto a la versión 1 solamente (no vincular el soporte de versión a
  una versión particular del router)

- Garantizar que todas las implementaciones (Java/i2pd/Go) puedan añadir soporte para la versión 2
  (o no) en sus propios horarios

- Añadir relleno aleatorio a todos los mensajes, incluidos los mensajes de negociación y de datos.
  Todo el relleno debe estar cubierto por el MAC, a diferencia del relleno al final del paquete en SSU 1.
  Proporcionar un mecanismo de opciones para que ambos lados soliciten relleno mínimo y máximo
  y/o distribución de relleno. Las especificaciones de la distribución de relleno son:
  dependientes de la implementación y pueden o no estar especificadas en el protocolo
  en sí mismo.

- Ofuscar los encabezados y contenidos de los mensajes que no están completamente cifrados
  lo suficiente como para que las cajas DPI y las firmas AV no puedan clasificarlos
  fácilmente. También asegurar que los mensajes enviados a un solo par o conjunto de pares no
  tengan un patrón similar de bits.

- Arreglar la pérdida de bits en DH debido al formato de Java [Ticket1112](http://{{ i2pconv('trac.i2p2.i2p') }}/ticket/1112), y acelerar el DH
  cambiando a X25519.

- Cambiar a una función real de derivación de clave (KDF) en lugar de usar el 
  resultado de DH tal como es.

- Añadir "resistencia a sondeos" (como lo llama Tor); esto incluye resistencia a la repetición.

- Mantener intercambio de claves autenticado en dos direcciones (2W-AKE). 1W-AKE no es suficiente para nuestra aplicación.

- Confiar en la clave pública estática publicada en el RouterInfo como otra parte de
  autenticación.

- Añadir opciones/versión en negociación para futuras extensiones.

- No añadir significativamente a la CPU requerida para la configuración de conexión; si es posible,
  reducirla significativamente.

- Eliminar el requisito de relleno a un múltiplo de 16 bytes
  impuesto por el cifrado AES en SSU 1.

- Usar ChaCha/Poly1305 estándar para cifrado y MAC,
  reemplazando el cifrado AES y el MAC HMAC-MD5-128 no estándar usado en SSU 1.

- Usar claves de cifrado separadas para envío y recepción, en lugar
  de las claves comunes para ambas direcciones usadas en SSU 1.

- Usar un mensaje de 3, ida y vuelta, como en [NTCP2](/en/proposals/111-ntcp-2/).
  Eliminar la demora esperando por mensajes de datos que hace que
  [SSU](/en/docs/transport/ssu/) sea efectivamente un mensaje de ida y vuelta de dos rondas.

- Mejorar drásticamente la eficiencia de los ACKs y NACKs,
  lo cual es horrible en SSU 1. Reducir el ancho de banda requerido
  para ACKs y NACKs, y aumentar el tamaño del paquete disponible para datos.
  Codificar eficientemente los NACKs para una ráfaga de mensajes perdidos,
  lo cual es común a través de WiFi.

- Reducir la complejidad requerida para implementar la fragmentación de mensajes I2NP.
  Omitir mecanismos de fragmentación y codificación para mensajes completos de I2NP.

- Minimizar la sobrecarga del protocolo antes del relleno, especialmente para los ACKs.
  Si bien se añadirá relleno, la sobrecarga antes del relleno sigue siendo una sobrecarga.
  Los nodos de bajo ancho de banda deben poder usar SSU2.

- Mantener marcas de tiempo para detección de repeticiones y sesgos.

- Evitar cualquier incidencia del año 2038 en las marcas de tiempo, deben funcionar hasta al menos el 2106.

- Aumentar el MTU mínimo de 620 a 1280 por motivos de eficiencia, facilidad de implementación,
  y aumentando el tamaño máximo del mensaje I2NP.
  La fragmentación y reensamblaje son bastante costosos.
  Al proporcionar espacio para mensajes de túnel de 1028 bytes, una gran mayoría de mensajes de I2NP
  no requerirán fragmentación.

- Aumentar el MTU máximo de 1488 (1484 para IPv6) a 1500 por eficiencia.
  Eliminar el requisito de que el MTU sea un múltiplo de 16.

- Aumentar el tamaño máximo del mensaje I2NP de aproximadamente 32K en SSU 1
  a aproximadamente 64 KB como en NTCP2.

- Eliminar la firma de los campos IP y de puerto de la negociación,
  para que los routers que no conozcan su IP y puerto externos puedan conectarse.

- Retener el mecanismo de descubrimiento de IP/puerto de SSU 1 en la negociación,
  para que los routers puedan aprender su IP y puerto externos.

- Incluir representantes de desarrolladores de routers en Java, C++ y Go en el diseño.



### No-Metas

- Resistencia a la DPI a prueba de balas... eso serían transportes enchufables,
  [Prop109](/en/proposals/109-hashcash/).

- Un transporte basado en TLS (o que simule HTTPS)... eso sería [Prop104](/en/proposals/104-new-protocol/).

- Resistencia a DPI basada en tiempo (el tiempo entre mensajes / retrasos pueden ser
  dependientes de la implementación; intra-mensajes los retrasos pueden introducirse en cualquier
  punto, incluyendo antes del envío del relleno aleatorio, por ejemplo). Retrasos
  artificiales (lo que obfs4 llama IAT o tiempo entre llegadas) son independientes
  del propio protocolo.

- Negabilidad de participación en una sesión (hay firmas allí).

No-metas que pueden ser parcialmente reconsideradas o discutidas:

- El grado de protección contra inspección profunda de paquetes (DPI)

- Seguridad Post-Cuántica (PQ)

- Negabilidad



## Metas de Seguridad

Consideramos tres partes:

- Alice, quien desea establecer una nueva sesión.
- Bob, con quien Alice desea establecer una sesión.
- Mallory, el "hombre en el medio" entre Alice y Bob.

Como máximo, dos participantes pueden participar en ataques activos.

Alice y Bob están en posesión de un par de claves estáticas, que se encuentra
en su [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/).

El protocolo propuesto intenta permitir que Alice y Bob acuerden una clave secreta compartida (K) bajo los siguientes requisitos:

1) Seguridad de clave privada: ni Bob ni Mallory aprenden nada sobre la
   clave privada estática de Alice. Simétricamente, Alice no aprende nada sobre la
   clave privada estática de Bob.

2) La clave de sesión K solo es conocida por Alice y Bob.

3) Perfecta confidencialidad hacia adelante: la clave de sesión acordada se mantiene secreta en el futuro, incluso cuando las claves privadas estáticas de Alice y/o Bob son reveladas después de que la clave ha sido acordada. 

4) Autenticación de dos vías: Alice está segura de que ha establecido una sesión
   con Bob, y viceversa.

5) Protección contra DPI en línea: Asegúrese de que no sea trivial detectar que
   Alice y Bob están participando en el protocolo usando solo técnicas explícitas de inspección profunda de paquetes (DPI). Ver abajo.

6) Negabilidad limitada: ni Alice ni Bob pueden negar su participación en el
   protocolo, pero si una de las partes filtra la clave compartida, la otra parte puede negar la
   autenticidad del contenido de los datos transmitidos.

La presente propuesta intenta proporcionar todos los cinco requisitos basados en el
protocolo Station-To-Station (STS) [STS](https://en.wikipedia.org/wiki/Station-to-Station_protocol). Note que este protocolo es también la
base para el protocolo [SSU](/en/docs/transport/ssu/).


### Discusión Adicional sobre DPI

Asumimos dos componentes de DPI:

DPI en línea
``````````````

DPI en línea que inspecciona todos los flujos en tiempo real. Las conexiones pueden ser bloqueadas o manipuladas de otra manera. Los datos de conexión o metadatos pueden ser identificados y almacenados para análisis fuera de línea. El DPI en línea no tiene acceso a la base de datos de red I2P. El DPI en línea solo tiene capacidad computacional en tiempo real limitada, incluyendo cálculos de longitud, inspección de campos, y cálculos simples como XOR. El DPI en línea sí tiene la capacidad de funciones criptográficas rápidas en tiempo real como ChaCha20, AEAD, y hashing, pero serían muy costosas para aplicarse a la mayoría de los flujos. Cualquier aplicación de estas operaciones criptográficas solo se aplicaría a flujos en combinaciones IP/puerto previamente identificadas por análisis fuera de línea. El DPI en línea no tiene la capacidad de funciones criptográficas de alto costo como DH o elligator2. El DPI en línea no está diseñado específicamente para detectar I2P, aunque puede tener reglas de clasificación limitadas para ese propósito.

Es un objetivo evitar la identificación del protocolo por un DPI en línea.

La noción de DPI en línea o "explícita" aquí se toma para incluir las siguientes capacidades de adversario:

1) La capacidad de inspeccionar todos los datos enviados o recibidos por el objetivo.

2) La capacidad de realizar operaciones sobre los datos observados, tales como
   aplicar cifrados de bloque o funciones de hash.

3) La capacidad de almacenar y comparar con mensajes enviados previamente.

4) La capacidad de modificar, retrasar o fragmentar paquetes.

Sin embargo, se asume que el DPI en línea tiene las siguientes restricciones:

5) La incapacidad de mapear direcciones IP a hashes de router. Aunque esto es trivial
   con acceso en tiempo real a la base de datos de red,
   requeriría un sistema DPI diseñado específicamente para atacar I2P.

6) La incapacidad de usar información de temporización para detectar el protocolo. 

7) En términos generales, la caja de herramientas del DPI en línea no contiene ninguna herramienta
   integrada que esté diseñada específicamente para la detección de I2P. Esto incluye
   crear "honeypots", que incluirían por ejemplo relleno no aleatorio en sus
   mensajes. Note que esto no excluye sistemas de aprendizaje automático o
   herramientas DPI altamente configurables siempre que cumplan con los otros requisitos.

Para contrarrestar el análisis de carga útil, se garantiza que todos los mensajes son
indistinguibles de formas aleatorias. Esto también requiere que su longitud sea aleatoria,
lo cual es más complicado que simplemente añadir relleno aleatorio. De hecho, en el Apéndice
A, los autores argumentan que un esquema de relleno ing enXèrminadoçig de resolver el problema. El Apéndice A por lo tanto propone incluir
retrasos aleatorios o desarrollar un esquema de relleno alternativo que pueda proporcionar una
protección razonable para el ataque propuesto.

Para proteger contra la sexta entrada anterior, las implementaciones deberían incluir retrasos
aleatorios en el protocolo. Tales técnicas no están cubiertas por esta propuesta, pero
también podrían resolver los problemas de longitud de relleno. En resumen, la propuesta
provee buena protección contra análisis de carga útil (cuando se tengan en cuenta
las consideraciones en el Apéndice A), pero solo protección limitada contra análisis
de flujo.


DPI fuera de línea
```````````````````

DPI fuera de línea que inspecciona datos almacenados por el DPI en línea para análisis posterior.
El DPI fuera de línea puede estar diseñado específicamente para detectar I2P.
El DPI fuera de línea tiene acceso en tiempo real a la base de datos de la red I2P.
El DPI fuera de línea tiene acceso a esta y otras especificaciones de I2P.
El DPI fuera de línea tiene capacidad computacional ilimitada, incluidas
todas las funciones criptográficas definidas en esta especificación.

El DPI fuera de línea no tiene la capacidad de bloquear conexiones existentes. El DPI
fuera de línea tiene la capacidad de enviar casi en tiempo real (dentro de minutos de
configuración) a la IP/puerto de las partes mediante inyección de paquetes. El DPI fuera de línea
tiene la capacidad de realizar casi en tiempo real (dentro de minutos de
configuración) repeticiones de mensajes anteriores (modificados o no) para "explorar" u
otras razones.

No es un objetivo impedir la identificación del protocolo por un DPI fuera de línea.
Toda la decodificación de datos ofuscados en los dos primeros mensajes, que es
implementada por los routers de I2P, también puede ser implementada por el DPI fuera de línea.

Es un objetivo rechazar intentos de conexiones usando repeticiones de mensajes anteriores.




### Validación de Dirección

Lo siguiente es copiado de QUIC [RFC-9000](https://www.rfc-editor.org/rfc/rfc9000.html).
Para cada sección, revise y edite.

La validación de dirección asegura que un endpoint no pueda ser usado para un
ataque de amplificación de tráfico. En tal ataque, un paquete es enviado a
un servidor con información de dirección de origen falsificada que identifica a
una víctima. Si un servidor genera más o paquetes más grandes en respuesta a
ese paquete, el atacante puede usar el servidor para enviar más datos hacia
la víctima de lo que podría enviar por sí mismo.

La principal defensa contra ataques de amplificación es verificar que un
par sea capaz de recibir paquetes en la dirección de transporte que
reclama. Por lo tanto, después de recibir paquetes de una dirección que no está
aún validada, un endpoint DEBE limitar la cantidad de datos que envía
a la dirección no validada a tres veces la cantidad de datos recibidos
desde esa dirección. Este límite en el tamaño de las respuestas se conoce como
el límite anti-amplificación.

La validación de dirección se realiza tanto durante el establecimiento de conexión
(ver Sección 8.1) como durante la migración de conexión (ver Sección 8.2).

Validación de Dirección durante el Establecimiento de Conexión
```````````````````````````````````````````````````````````````
