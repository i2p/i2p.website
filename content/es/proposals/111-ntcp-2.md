---
title: "NTCP 2"
number: "111"
author: "EinMByte, orignal, psi, str4d, zzz"
created: "2014-02-13"
lastupdated: "2019-08-13"
status: "Closed"
thread: "http://zzz.i2p/topics/1577"
supercedes: "106"
target: "0.9.36"
implementedin: "0.9.36"
editor: "manas, str4d, zzz"
---

## Nota
La fase de propuesta está cerrada.
Consulte [SPEC](/en/docs/spec/ntcp2/) para la especificación oficial.
Esta propuesta aún puede ser referenciada para información de contexto.

## Visión general

Esta propuesta describe un protocolo de acuerdo de clave autenticado para mejorar la resistencia de [NTCP](/en/docs/transport/ntcp/) a varias formas de identificación automatizada y ataques.

La propuesta está organizada de la siguiente manera: se presentan los objetivos de seguridad, seguidos de una discusión del protocolo básico. Luego, se ofrece una especificación completa de todos los mensajes del protocolo. Finalmente, se discuten las direcciones de los routers y la identificación de versiones. También se incluye un apéndice que discute un ataque genérico a esquemas comunes de relleno, así como un apéndice que contiene un número de candidatos para el cifrado autenticado.

Como con otros transportes de I2P, NTCP2 se define únicamente para el transporte punto a punto (router a router) de mensajes I2NP. No es un canal de datos de propósito general.

## Motivación

Los datos [NTCP](/en/docs/transport/ntcp/) están cifrados después del primer mensaje (y el primer mensaje parece ser datos aleatorios), previniendo así la identificación del protocolo a través del "análisis de la carga útil". Todavía es vulnerable a la identificación del protocolo a través del "análisis de flujo". Esto se debe a que los primeros 4 mensajes (es decir, el saludo) tienen una longitud fija (288, 304, 448 y 48 bytes).

Agregando cantidades aleatorias de datos aleatorios a cada uno de los mensajes, podemos hacer que sea mucho más difícil.

Los autores reconocen que las prácticas estándar de seguridad sugerirían usar un protocolo existente como TLS, pero esto es [Prop104](/en/proposals/104/) y tiene sus propios problemas. Donde corresponda, se han añadido párrafos de "trabajo futuro" para indicar características faltantes o temas de discusión.

## Objetivos de diseño

- Soportar NTCP 1 y 2 en un único puerto, autodetectar y publicar como un único "transporte" (es decir, [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)) en el [NetDB](/en/docs/how/network-database/).

- Publicar soporte para la versión 1 solo, 2 solo, o 1+2 en el NetDB en un campo separado, y por defecto a la versión 1 solamente (no vincular el soporte de versión a una versión particular del router).

- Asegurar que todas las implementaciones (Java/i2pd/Kovri/go) puedan añadir soporte para la versión 2 (o no) según sus propios horarios.

- Añadir relleno aleatorio a todos los mensajes NTCP, incluyendo mensajes de saludo y de datos (es decir, ofuscación de longitud para que todos los mensajes no sean múltiplos de 16 bytes). Proporcionar un mecanismo de opciones para que ambas partes soliciten un relleno mínimo y máximo o una distribución de relleno. Las especificaciones de la distribución del relleno son dependientes de la implementación y pueden o no ser especificadas en el protocolo en sí.

- Ofuscar el contenido de los mensajes que no están cifrados (1 y 2), suficientemente para que cajas de DPI y firmas AV no puedan clasificarlos fácilmente. También asegurar que los mensajes que van a un solo par o conjunto de pares no tengan un patrón similar de bits.

- Corregir la pérdida de bits en DH debido al formato de Java [Ticket1112](https://trac.i2p2.i2p/ticket/1112), posiblemente (¿probablemente?) cambiando a X25519.

- ¿Cambiar a una función verdadera de derivación de clave (KDF) en lugar de usar el resultado DH tal cual?

- Añadir "resistencia a la sondeo" (como lo llama Tor); esto incluye resistencia al replay.

- Mantener el intercambio de clave autenticado en dos vías (2W-AKE). 1W-AKE no es suficiente para nuestra aplicación.

- Continuar usando las firmas de tipo variable y longitud variable (de la clave de firma [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/)) como parte de la autenticación. Confiar en una clave pública estática publicada en la RouterInfo como otra parte de la autenticación.

- Añadir opciones/versión en el saludo para futura extensibilidad.

- Añadir resistencia a la segmentación maliciosa de TCP si es posible.

- No añadir significativamente al CPU requerido para el establecimiento de conexión; si es posible, reducirlo significativamente.

- Añadir autenticación de mensajes (MAC), posiblemente HMAC-SHA256 y Poly1305, y eliminar la suma de verificación Adler.

- Acortar y simplificar el encabezado I2NP:
  Acortar la expiración a 4 bytes, como en SSU.
  Eliminar la suma de verificación de SHA256 truncada de un byte.

- Si es posible, reducir el saludo de 4 mensajes y dos viajes de ida y vuelta a un saludo de 3 mensajes y un viaje de ida y vuelta, como en [SSU](/en/docs/transport/ssu/). Esto requeriría mover la firma de Bob en el mensaje 4 al mensaje 2. Investigar la razón para 4 mensajes en los archivos de correo electrónico/status/reuniones de hace diez años.

- Minimizar el overhead del protocolo antes del relleno. Mientras que se añadirá relleno, y posiblemente mucho de ello, el overhead antes del relleno sigue siendo overhead. Los nodos de bajo ancho de banda deben poder usar NTCP2.

- Mantener marcas de tiempo para detección de repetición y desviación.

- Evitar problemas del año 2038 en las marcas de tiempo, debe funcionar hasta al menos 2106.

- Aumentar el tamaño máximo de mensajes de 16K a 32K o 64K.

- Cualquier nuevo primitivo criptográfico debería estar fácilmente disponible en bibliotecas para uso en implementaciones de routers en Java (1.7), C++, y Go.

- Incluir representantes de desarrolladores de routers en Java, C++, y Go en el diseño.

- Minimizar cambios (pero habrá muchos).

- Soportar ambas versiones en un conjunto común de código (esto puede no ser posible y es dependiente de la implementación en cualquier caso).

### No objetivos

- Resistencia a DPI a prueba de balas... eso serían transportes enchufables, [Prop109](/en/proposals/109/).

- Un transporte basado en TLS (o parecido a HTTPS)... eso sería [Prop104](/en/proposals/104/).

- Está bien cambiar la criptografía de flujo simétrico.

- Resistencia a DPI basada en tiempo (la temporización/retardos inter-mensajes puede ser dependiente de la implementación; los retardos intra-mensajes pueden ser introducidos en cualquier punto, incluyendo antes de enviar el relleno aleatorio, por ejemplo). Los retardos artificiales (lo que obfs4 llama IAT o tiempo de llegada) son independientes del protocolo en sí.

- Negación de participación en una sesión (hay firmas ahí).

No objetivos que pueden ser reconsiderados o discutidos parcialmente:

- El grado de protección contra la inspección profunda de paquetes (DPI)

- Seguridad post-cuántica (PQ)

- Negación

### Objetivos relacionados

- Implementar un conjunto de pruebas NTCP 1/2

## Objetivos de seguridad

Consideramos tres partes:

- Alicia, que desea establecer una nueva sesión.
- Bob, con quien Alicia desea establecer una sesión.
- Mallory, el "hombre en el medio" entre Alicia y Bob.

Máximo dos participantes pueden participar en ataques activos.

Alicia y Bob tienen cada uno un par de claves estáticas, que están contenidas en su [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/).

El protocolo propuesto intenta permitir que Alicia y Bob acuerden una clave secreta compartida (K) bajo los siguientes requisitos:

1) Seguridad de la clave privada: ni Bob ni Mallory aprenden nada sobre la clave privada estática de Alicia. Simétricamente, Alicia no aprende nada sobre la clave privada estática de Bob.

2) La clave de sesión K sólo es conocida por Alicia y Bob.

3) Secreto hacia adelante perfecto: la clave de sesión acordada permanece secreta en el futuro, incluso si las claves privadas estáticas de Alicia y/o Bob se revelan después de que se haya acordado la clave.

4) Autenticación en dos vías: Alicia está segura de que ha establecido una sesión con Bob, y viceversa.

5) Protección contra DPI en línea: Asegurar que no sea trivial detectar que Alicia y Bob están comprometidos en el protocolo utilizando solo técnicas simples de inspección profunda de paquetes (DPI). Véase más abajo.

6) Negabilidad limitada: ni Alicia ni Bob pueden negar su participación en el protocolo, pero si alguno filtra la clave compartida, la otra parte puede negar la autenticidad del contenido de los datos transmitidos.

La presente propuesta intenta proporcionar los cinco requisitos basados en el protocolo Station-To-Station (STS) [STS]_. Tenga en cuenta que este protocolo también es la base para el protocolo [SSU](/en/docs/transport/ssu/).

### Discusión adicional sobre DPI

Suponemos dos componentes de DPI:

1) DPI en línea
```````````

DPI en línea inspeccionando todos los flujos en tiempo real. Las conexiones pueden ser bloqueadas o alteradas de alguna manera. Los datos de conexión o metadatos pueden ser identificados y almacenados para análisis fuera de línea. El DPI en línea no tiene acceso a la base de datos de red I2P. El DPI en línea solo tiene capacidad computacional en tiempo real limitada, incluyendo cálculo de longitud, inspección de campo y cálculos simples como XOR. El DPI en línea sí tiene la capacidad de funciones criptográficas rápidas en tiempo real, como AES, AEAD y hashing, pero estas serían demasiado costosas para aplicarse a la mayoría o a todos los flujos. Cualquier aplicación de estas operaciones criptográficas se aplicaría solo a flujos en combinaciones de IP/Port previamente identificados por análisis fuera de línea. El DPI en línea no tiene la capacidad de funciones criptográficas de alto rendimiento como DH o elligator2. El DPI en línea no está diseñado específicamente para detectar I2P, aunque puede tener reglas de clasificación limitadas para ese propósito.

Es un objetivo prevenir la identificación del protocolo por un DPI en línea.

La noción de DPI "directo" o en línea aquí se toma para incluir las siguientes capacidades del adversario:

1) La capacidad de inspeccionar todos los datos enviados o recibidos por el objetivo.

2) La capacidad de realizar operaciones en los datos observados, como aplicar cifrados de bloque o funciones de hash.

3) La capacidad de almacenar y comparar con mensajes enviados previamente.

4) La capacidad de modificar, demorar o fragmentar paquetes.

Sin embargo, se supone que el DPI en línea tiene las siguientes restricciones:

5) La incapacidad de mapear direcciones IP a hashes de router. Aunque esto es trivial con acceso en tiempo real a la base de datos de red, requeriría un sistema de DPI diseñado específicamente para apuntar a I2P.

6) La incapacidad de usar información de temporización para detectar el protocolo.

7) En general, la caja de herramientas del DPI en línea no contiene herramientas integradas diseñadas específicamente para la detección de I2P. Esto incluye crear "honeypots", que incluirían, por ejemplo, relleno no aleatorio en sus mensajes. Tenga en cuenta que esto no excluye los sistemas de aprendizaje automático o herramientas de DPI altamente configurables siempre que cumplan con los otros requisitos.

Para contrarrestar el análisis de carga útil, se asegura que todos los mensajes sean indistinguibles de los aleatorios. Esto también requiere que su longitud sea aleatoria, lo cual es más complicado que solo agregar relleno aleatorio. De hecho, en el Apéndice A, los autores argumentan que un esquema de relleno ingenuo (es decir, uniforme) no resuelve el problema. El Apéndice A propone incluir ya sea demoras aleatorias o desarrollar un esquema de relleno alternativo que pueda proporcionar una protección razonable para el ataque propuesto.

Para proteger contra la sexta entrada anterior, las implementaciones deben incluir demoras aleatorias en el protocolo. Tales técnicas no están cubiertas por esta propuesta, pero también podrían resolver los problemas de longitud de relleno. En resumen, la propuesta proporciona buena protección contra el análisis de carga útil (cuando se tienen en cuenta las consideraciones en el Apéndice A), pero solo protección limitada contra el análisis de flujo.

2) DPI fuera de línea
``````````````

DPI fuera de línea inspeccionando datos almacenados por el DPI en línea para análisis posterior. El DPI fuera de línea puede estar diseñado específicamente para detectar I2P. El DPI fuera de línea tiene acceso en tiempo real a la base de datos de red I2P. El DPI fuera de línea tiene acceso a esta y otras especificaciones de I2P. El DPI fuera de línea tiene capacidad computacional ilimitada, incluyendo todas las funciones criptográficas definidas en esta especificación.

El DPI fuera de línea no tiene la capacidad de bloquear conexiones existentes. El DPI fuera de línea sí tiene la capacidad de enviar casi en tiempo real (dentro de minutos de la configuración) a la dirección/puerto del servidor de las partes, por ejemplo TCP RST. El DPI fuera de línea sí tiene la capacidad de repetir casi en tiempo real (dentro de minutos de la configuración) mensajes anteriores (modificados o no) para fines de "sondeo" u otros.

No es un objetivo prevenir la identificación del protocolo por un DPI fuera de línea. Toda la decodificación de datos ofuscados en los dos primeros mensajes, que es implementada por los routers I2P, también puede ser implementada por el DPI fuera de línea.

Es un objetivo rechazar conexiones intentadas mediante repetición de mensajes anteriores.

Trabajo futuro
```````````

- Considerar el comportamiento del protocolo cuando los paquetes son descartados o reordenados por un atacante. Reciente trabajo interesante en esta área se puede encontrar en [IACR-1150](https://eprint.iacr.org/2015/1150).

- Proporcionar una clasificación más precisa de los sistemas DPI, teniendo en cuenta la literatura existente relacionada con el tema.

- Discutir la seguridad formal del protocolo propuesto, idealmente teniendo en cuenta el modelo de atacante de DPI.

## Marco del Protocolo Noise

Esta propuesta proporciona los requisitos basados en el Marco del Protocolo Noise [NOISE](http://noiseprotocol.org/) (Revisión 33, 2017-10-04). Noise tiene propiedades similares al protocolo Station-To-Station [STS]_, que es la base para el protocolo [SSU](/en/docs/transport/ssu/). En parlance de Noise, Alice es la iniciadora, y Bob es el respondedor.

NTCP2 está basado en el protocolo Noise Noise_XK_25519_ChaChaPoly_SHA256. (El identificador real para la función de derivación de clave inicial es "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256" para indicar extensiones I2P - ver la sección KDF 1 más abajo). Este protocolo Noise utiliza los siguientes primitivos:

- Patrón de saludo: XK
  Alice transmite su llave a Bob (X)
  Alice ya conoce la clave estática de Bob (K)

- Función DH: X25519
  X25519 DH con una longitud de clave de 32 bytes como se especifica en [RFC-7748](https://tools.ietf.org/html/rfc7748).

- Función de cifrado: ChaChaPoly
  AEAD_CHACHA20_POLY1305 como se especifica en [RFC-7539](https://tools.ietf.org/html/rfc7539) sección 2.8.
  Nonce de 12 bytes, con los primeros 4 bytes establecidos en cero.

- Función de hash: SHA256
  Hash estándar de 32 bytes, ya utilizado extensamente en I2P.

## Adiciones al Marco

Esta propuesta define las siguientes mejoras a Noise_XK_25519_ChaChaPoly_SHA256. Estas generalmente siguen las pautas en [NOISE](http://noiseprotocol.org/) sección 13.

1) Las claves efímeras en claro son ofuscadas con cifrado AES usando una clave y IV conocidas. Esto es más rápido que elligator2.

2) Se agrega relleno aleatorio en claro a los mensajes 1 y 2. El relleno en claro se incluye en el cálculo del hash de saludo (MixHash). Véase las secciones KDF a continuación para el mensaje 2 y el mensaje 3 parte 1. Se añade relleno AEAD aleatorio al mensaje 3 y a los mensajes de fase de datos.

3) Se añade un campo de longitud de marco de dos bytes, como se requiere para Noise sobre TCP y como en obfs4. Esto se utiliza solo en los mensajes de fase de datos. Los mensajes 1 y 2 AEAD tienen longitudes fijas de marco. El mensaje 3 parte 1 AEAD del marco tiene una longitud fija. La longitud del mensaje 3 parte 2 del marco AEAD es especificada en el mensaje 1.

4) El campo de longitud del marco de dos bytes está ofuscado con SipHash-2-4, como en obfs4.

5) Se define el formato de carga útil para los mensajes 1, 2, 3 y la fase de datos. Por supuesto, esto no se define en Noise.

## Nuevos Primitivos Criptográficos para I2P

Las implementaciones de routers I2P existentes necesitarán implementar los siguientes primitivos criptográficos estándar, que no son requeridos para los protocolos I2P actuales:

1) Generación de claves X25519 y DH

2) AEAD_ChaCha20_Poly1305 (abreviado como ChaChaPoly a continuación)

3) SipHash-2-4

## Estimación de overhead de procesamiento

Tamaños de mensaje para los 3 mensajes:

1) 64 bytes + relleno (NTCP era 288 bytes)
2) 64 bytes + relleno (NTCP era 304 bytes)
3) aprox. 64 bytes + información del router de Alice + relleno. La información promedio del router es de unos 750 bytes. Total promedio 814 bytes antes del relleno (NTCP era 448 bytes)
4) no requerido en NTCP2 (NTCP era 48 bytes)

Total antes del relleno:
NTCP2: 942 bytes
NTCP: 1088 bytes
Tenga en cuenta que si Alice se conectaba a Bob con el propósito de enviar un mensaje DatabaseStore de su RouterInfo, ese mensaje no es requerido, ahorrando aproximadamente 800 bytes.

Las siguientes operaciones criptográficas son requeridas por cada parte para completar el saludo y comenzar la fase de datos:

- AES: 2
- SHA256: 7 (Alice), 6 (Bob) (sin incluir 1 Alice, 2 Bob precalculados para todas las conexiones) (sin incluir HMAC-SHA256)
- HMAC-SHA256: 19
- ChaChaPoly: 4
- Generación de claves X25519: 1
- DH X25519: 3
- Verificación de firma: 1 (Bob) (Alice previamente firmó al generar su RI). Presumiblemente Ed25519 (dependiente del tipo de firma RI)

Las siguientes operaciones criptográficas son requeridas por cada parte para cada mensaje de la fase de datos:

- SipHash: 1
- ChaChaPoly: 1

## Mensajes

Todos los mensajes NTCP2 son menores o iguales a 65537 bytes de longitud. El formato del mensaje se basa en mensajes de Noise, con modificaciones para encuadre e indistinguibilidad. Las implementaciones que usen bibliotecas estándar de Noise pueden necesitar preprocesar los mensajes recibidos hacia/desde el formato de mensaje de Noise. Todos los campos cifrados son textos cifrados AEAD.

La secuencia de establecimiento es la siguiente:

Alice                           Bob

  SessionRequest ------------------->
  <------------------- SessionCreated
  SessionConfirmed ----------------->
Usando la terminología de Noise, la secuencia de establecimiento y datos es la siguiente:
(Properties de seguridad de la carga útil)

XK(s, rs):           Authentication   Confidentiality
    <- s
    ...
    -> e, es                  0                2
    <- e, ee                  2                1
    -> s, se                  2                5
    <-                        2                5
Una vez que se ha establecido una sesión, Alice y Bob pueden intercambiar mensajes de Datos.

Todos los tipos de mensajes (SessionRequest, SessionCreated, SessionConfirmed, Data y TimeSync) se especifican en esta sección.

Algunas notaciones::

  - RH_A = Hash del Router para Alice (32 bytes)
  - RH_B = Hash del Router para Bob (32 bytes)

### Cifrado Autenticado

Hay tres instancias separadas de cifrado autenticado (CipherStates). Una durante la fase de saludo y dos (transmisión y recepción) para la fase de datos. Cada una tiene su propia clave a partir de un KDF.

Los datos cifrados/autenticados se representarán como 

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   Encrypted and authenticated data    |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
ChaCha20/Poly1305
`````````````````

Formato de datos cifrados y autenticados.

Entradas a las funciones de cifrado/descifrado:

k :: Clave de cifrado de 32 bytes, como generado a partir del KDF

  nonce :: Nonce basado en contador, 12 bytes.
           Comienza en 0 y se incrementa para cada mensaje.
           Los primeros cuatro bytes siempre son cero.
           Los últimos ocho bytes son el contador, codificado en little-endian.
           El valor máximo es 2**64 - 2.
           La conexión debe cerrarse y reiniciarse después
           de alcanzar ese valor.
           El valor 2**64 - 1 nunca debe ser enviado.

  ad :: En fase de saludo:
        Datos asociados, 32 bytes.
        El hash SHA256 de todos los datos precedentes.
        En fase de datos:
        Cero bytes

  data :: Datos en texto plano, 0 o más bytes

Salida de la función de cifrado, entrada a la función de descifrado:

+----+----+----+----+----+----+----+----+
  |Obfs Len |                             |
  +----+----+                             +
  |       ChaCha20 encrypted data         |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Message Authentication Code |
  +              (MAC)                    +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+

  Obfs Len :: Longitud de (datos cifrados + MAC) a seguir, 16 - 65535
              Ofuscación usando SipHash (sigue abajo)
              No se utiliza en el mensaje 1 o 2, o en el mensaje 3 parte 1, donde la longitud es fija
              No se utiliza en el mensaje 3 parte 1, ya que la longitud está especificada en el mensaje 1

  encrypted data :: Mismo tamaño que los datos en texto claro, 0 - 65519 bytes

  MAC :: Código de autenticación de mensaje Poly1305, 16 bytes

Para ChaCha20, lo que se describe aquí corresponde a [RFC-7539](https://tools.ietf.org/html/rfc7539), que también se usa de manera similar en TLS [RFC-7905](https://tools.ietf.org/html/rfc7905).

Notas
`````
- Dado que ChaCha20 es un cifrador de flujo, los textos planos no necesitan ser rellenados.
  Los bytes adicionales del flujo de cifrado son descartados.

- La clave para el cifrador (256 bits) se acuerda por medio del KDF SHA256.
  Los detalles de KDF para cada mensaje están en secciones separadas más abajo.

- Los marcos ChaChaPoly para los mensajes 1, 2 y la primera parte del mensaje 3,
  tienen tamaños conocidos. Comenzando con la segunda parte del mensaje 3,
  los marcos son de tamaño variable. El tamaño de la parte 1 del mensaje 3 se especifica en el mensaje 1.
  A partir de la fase de datos, los marcos se anteponen con una longitud ofuscada de dos bytes
  usando SipHash como en obfs4.

- El relleno está fuera del marco de datos autenticado para los mensajes 1 y 2.
  El relleno se usa en el KDF para el siguiente mensaje de modo que cualquier manipulación
  será detectada. Comenzando en el mensaje 3, el relleno está dentro del marco de datos autenticado.

Manejo de errores AEAD
`````````````````````
En los mensajes 1, 2 y mensajes 3 partes 1 y 2, el tamaño del mensaje AEAD se conoce de antemano.
En caso de fallo de autenticación AEAD, el destinatario debe detener el procesamiento de mensajes
y cerrar la conexión sin responder. Esto debe ser un cierre anormal (TCP RST).

- Para la resistencia al sondeo, en el mensaje 1, después de un fallo AEAD, Bob
  debe establecer un tiempo de espera aleatorio (rango por definir) y luego leer una cantidad
  aleatoria de bytes (rango por definir) antes de cerrar el socket. Bob debe mantener
  una lista negra de IPs con fallos repetidos.

- En la fase de datos, el tamaño del mensaje AEAD está "cifrado" (ofuscado) con SipHash.
  Se debe tener cuidado para no crear un oráculo de descifrado.
  En caso de fallo de autenticación AEAD en la fase de datos, el destinatario debería
  establecer un tiempo de espera aleatorio (rango por definir) y luego leer una cantidad
  aleatoria de bytes (rango por definir). Después de la lectura, o en el tiempo de espera de la lectura,
  el destinatario debería enviar una carga útil con un bloque de terminación que contenga un
  código de motivo de "fallo AEAD", y cerrar la conexión.

- Tome la misma acción de error para un valor de campo de longitud no válido en la fase de datos.


### Función de Derivación de Clave (KDF) (para mensaje de saludo 1)

El KDF genera una clave de cifrado de fase de saludo k a partir del resultado DH,
usando HMAC-SHA256(key, data) como se define en [RFC-2104](https://tools.ietf.org/html/rfc2104).
Estas son las funciones InitializeSymmetric(), MixHash() y MixKey(),
exactamente como se definen en la especificación Noise.

Este es el patrón de mensaje "e":

  // Definir protocol_name.
  Set protocol_name = "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256"
   (48 bytes, codificado en US-ASCII, sin terminación NULL).

  // Definir Hash h = 32 bytes
  h = SHA256(protocol_name);

  Definir ck = clave de encadenamiento de 32 bytes. Copiar los datos de h a ck.
  Set ck = h

  Definir rs = Clave estática de 32 bytes de Bob tal como se publica en el RouterInfo

  // MixHash(null prologue)
  h = SHA256(h);

  // hasta aquí, todo puede ser precalculado por Alice para todas las conexiones salientes

  // Alice debe validar que la clave estática de Bob es un punto válido en la curva aquí.

  // Clave estática de Bob
  // MixHash(rs)
  // || más abajo significa concatenar
  h = SHA256(h || rs);

  // hasta aquí, todo puede ser precalculado por Bob para todas las conexiones entrantes

  Este es el patrón de mensaje "e":

  Alice genera su par de claves efímeras DH e.

  // Clave efímera X de Alice
  // MixHash(e.pubkey)
  // || más abajo significa concatenar
  h = SHA256(h || e.pubkey);

  // h se utiliza como los datos asociados para el AEAD en el mensaje 1
  // Retener el hash h para el KDF del mensaje 2

  Fin del patrón de mensaje "e".

  Este es el patrón de mensaje "es":

  // DH(e, rs) == DH(s, re)
  Definir input_key_material = resultado DH de 32 bytes de la clave efímera de Alice y la clave estática de Bob
  Set input_key_material = resultado DH X25519

  // MixKey(DH())

  Definir temp_key = 32 bytes
  Definir HMAC-SHA256(key, data) como en [RFC-2104](https://tools.ietf.org/html/rfc2104)
  // Generar una clave temporal a partir de la clave de encadenamiento y el resultado DH
  // ck es la clave de encadenamiento, definida más arriba
  temp_key = HMAC-SHA256(ck, input_key_material)
  // sobreescribir el resultado DH en la memoria, ya no es necesario
  input_key_material = (todo ceros)

  // Salida 1
  // Establecer una nueva clave de encadenamiento a partir de la clave temporal
  // byte() más abajo significa un solo byte
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // Salida 2
  // Generar la clave de cifrado k
  Definir k = 32 bytes
  // || más abajo significa concatenar
  // byte() más abajo significa un solo byte
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
  // sobreescribir la temp_key en la memoria, ya no es necesario
  temp_key = (todo ceros)

  // retener la clave de encadenamiento ck para el KDF del mensaje 2

  Fin del patrón de mensaje "es".

### 1) SessionRequest

Alice envía a Bob.

Contenido de Noise: la clave efímera X de Alice
Carga útil Noise: Bloque de opciones de 16 bytes
Carga útil no Noise: Relleno aleatorio

(Properties de seguridad de la carga útil)

XK(s, rs):           Authentication   Confidentiality
    -> e, es                  0                2

    Autenticación: Ninguna (0).
    Esta carga útil puede haber sido enviada por cualquier parte, incluyendo un atacante activo.

    Confidencialidad: 2.
    Cifrado para un destinatario conocido, secreto hacia adelante solo para compromiso del remitente, vulnerable a repetición. Esta carga útil está cifrada solo en función de DHs que involucran el par de claves estáticas del destinatario. Si la clave privada estática del destinatario se compromete, incluso en una fecha posterior, esta carga útil se puede descifrar. Este mensaje también puede ser repetido, ya que no hay contribución efímera del destinatario.

    "e": Alice genera un nuevo par de claves efímeras y las almacena en la variable e, escribe la clave pública efímera como texto claro en el búfer de mensaje, y hasea la clave pública junto con el viejo h para derivar un nuevo h.

    "es": Se realiza un DH entre el par de claves efímeras de Alice y el par de claves estáticas de Bob. El resultado se hasea junto con el antiguo ck para derivar un nuevo ck y k, y n se establece en cero.

El valor X está cifrado para asegurar la indistinguibilidad de la carga útil y la unicidad, que son contramedidas necesarias contra DPI. Usamos cifrado AES para lograr esto, en lugar de alternativas más complejas y lentas como elligator2. El cifrado asimétrico a la clave pública del router de Bob sería demasiado lento. El cifrado AES utiliza el hash del router de Bob como clave y el IV de Bob como se publica en la base de datos de red.

El cifrado AES es solo para resistencia a DPI. Cualquier parte que conozca el hash del router de Bob y el IV, que se publican en la base de datos de la red, puede descifrar el valor X en este mensaje.

El relleno no está cifrado por Alice. Puede ser necesario para Bob descifrar el relleno, para inhibir ataques de temporización.

Contenido bruto:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        ofuscado con RH_B              +
  |       clave efímera X cifrada AES-CBC-256                  |
  +             (32 bytes)                +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   Frame ChaChaPoly                    |
  +             (32 bytes)                +
  |   k definido en KDF para el mensaje 1 |
  +   n = 0                               +
  |   ver KDF para datos asociados        |
  +----+----+----+----+----+----+----+----+
  |     relleno autenticado no cifrado    |
  ~         opcional                      ~
  |     longitud definida en bloque de opciones |
  +----+----+----+----+----+----+----+----+

  X :: 32 bytes, clave efímera X25519 cifrada AES-256-CBC, little endian
          clave: RH_B
          iv: Como se publica en la entrada de la base de datos de red de Bobs

  padding :: Datos aleatorios, 0 o más bytes.
             La longitud total del mensaje debe ser de 65535 bytes o menos.
             La longitud total del mensaje debe ser de 287 bytes o menos si
             Bob está publicando su dirección como NTCP
             (ver sección de Detección de Versión a continuación).
             Alice y Bob utilizarán los datos de relleno en el KDF para el mensaje 2.
             Está autenticado para que cualquier manipulación cause que el
             siguiente mensaje falle.

Datos no cifrados (etiqueta Poly1305 no mostrada):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                   X                   |
  +              (32 bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               opciones                 |
  +              (16 bytes)                +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     relleno autenticado no cifrado    |
  +         opcional                      +
  |     longitud definida en bloque de opciones |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  X :: 32 bytes, clave efímera X25519, little endian

  options :: bloque de opciones, 16 bytes, ver a continuación

  padding :: Datos aleatorios, 0 o más bytes.
             La longitud total del mensaje debe ser de 65535 bytes o menos.
             La longitud total del mensaje debe ser de 287 bytes o menos si
             Bob está publicando su dirección como "NTCP"
             (ver sección de Detección de Versión a continuación)
             Alice y Bob utilizarán los datos de relleno en el KDF para el mensaje 2.
             Está autenticado para que cualquier manipulación cause que el
             siguiente mensaje falle.

Bloque de opciones:
Nota: Todos los campos son big-endian.

+----+----+----+----+----+----+----+----+
  | id | ver|  padLen | m3p2len | Rsvd(0) |
  +----+----+----+----+----+----+----+----+
  |        tsA        |   Reservado (0)   |
  +----+----+----+----+----+----+----+----+

  id :: 1 byte, el ID de la red (actualmente 2, excepto para redes de prueba)
        A partir de 0.9.42. Ver propuesta 147.

  ver :: 1 byte, versión del protocolo (actualmente 2)

  padLen :: 2 bytes, longitud del relleno, 0 o más
            Directrices mínimas/máximas TBD. ¿Tamaño aleatorio de 0 a 31 bytes como mínimo?
            (Distribución por determinar, ver Apéndice A.)

  m3p2Len :: 2 bytes, longitud del segundo frame AEAD en SessionConfirmed
             (mensaje 3 parte 2) Ver notas a continuación

  Rsvd :: 2 bytes, establecer en 0 para compatibilidad con futuras opciones

  tsA :: 4 bytes, marca de tiempo Unix, segundos sin firmar.
         Redondea en 2106

  Reservado :: 4 bytes, establecer en 0 para compatibilidad con futuras opciones

Notas
`````
- Cuando la dirección publicada es "NTCP", Bob soporta tanto NTCP como NTCP2 en el mismo puerto. Para compatibilidad, al iniciar una conexión a una dirección publicada como "NTCP", Alice debe limitar el tamaño máximo de este mensaje, incluyendo el relleno, a 287 bytes o menos. Esto facilita la identificación del protocolo automáticamente por parte de Bob. Cuando se publica como "NTCP2", no hay restricción de tamaño. Véase las secciones de Direcciones Publicadas y Detección de Versión a continuación.

- El valor único X en el bloque inicial de AES asegura que el texto cifrado sea diferente para cada sesión.

- Bob debe rechazar conexiones donde el valor de la marca de tiempo esté demasiado desfasado respecto al tiempo actual. Llame al tiempo delta máximo "D". Bob debe mantener una caché local de valores de saludo previamente utilizados y rechazar duplicados, para prevenir ataques de repetición. Los valores en la caché deben tener una vida útil de al menos 2*D. Los valores de la caché son dependientes de la implementación, sin embargo el valor X de 32 bytes (o su equivalente cifrado) puede usarse.

- Las claves efímeras de Diffie-Hellman nunca deben ser reutilizadas, para prevenir ataques criptográficos, y la reutilización será rechazada como un ataque de repetición.

- Las opciones "KE" y "auth" deben ser compatibles, es decir, el secreto compartido K debe ser del tamaño adecuado. Si se agregan más opciones "auth", esto podría cambiar implícitamente el significado de la bandera "KE" para usar un KDF diferente o un tamaño de truncamiento diferente.

- Bob debe validar que la clave efímera de Alice es un punto válido en la curva aquí.

- El relleno debe limitarse a una cantidad razonable. Bob puede rechazar conexiones con relleno excesivo. Bob especificará sus opciones de relleno en el mensaje 2. Directrices mínimas/máximas TBD. ¿Tamaño aleatorio de 0 a 31 bytes como mínimo? (Distribución por determinar, ver Apéndice A.)

- En cualquier error, incluyendo AEAD, DH, marca de tiempo, repetición aparente o fallo de validación de clave, Bob debe detener el procesamiento de mensajes y cerrar la conexión sin responder. Esto debe ser un cierre anormal (TCP RST). Para resistencia al sondeo, después de un fallo AEAD, Bob debería establecer un tiempo de espera aleatorio (rango TBD) y luego leer una cantidad aleatoria de bytes (rango TBD), antes de cerrar el socket.

- Mitigación de DoS: DH es una operación relativamente costosa. Al igual que con el protocolo NTCP anterior, los routers deben tomar todas las medidas necesarias para prevenir el agotamiento de CPU o conexiones. Colocar límites en las conexiones activas máximas y en las configuraciones de conexión máximas en progreso. Hacer cumplir los tiempos de espera de lectura (tanto por lectura como total para "slowloris"). Limitar las conexiones repetidas o simultáneas desde la misma fuente. Mantener listas negras para fuentes que fallan repetidamente. No responder a fallos AEAD.

- Para facilitar la detección y el saludo de versión rápida, las implementaciones deben asegurar que Alice almacene en búfer y luego envíe todo el contenido del primer mensaje de una vez, incluyendo el relleno. Esto aumenta la probabilidad de que los datos estén contenidos en un único paquete TCP (a menos que sea segmentado por el sistema operativo o middleboxes), y recibidos todos a la vez por Bob. Además, las implementaciones deben asegurar que Bob almacene en búfer y luego envíe todo el contenido del segundo mensaje de una vez, incluyendo el relleno, y que Bob almacene en búfer y luego envíe todo el contenido del tercer mensaje de una vez. Esto también es para eficiencia y para asegurar la efectividad del relleno aleatorio.

- Campo "ver": El protocolo Noise general, extensiones y protocolo NTCP incluyendo especificaciones de carga útil, indicando NTCP2. Este campo puede usarse para indicar soporte para futuros cambios.

- Longitud de la parte 2 del mensaje 3: Este es el tamaño del segundo frame AEAD (incluyendo MAC de 16 bytes) que contendrá la Información del Router de Alice y relleno opcional que será enviado en el mensaje SessionConfirmed. A medida que los routers regeneran y republican periódicamente su Información del Router, el tamaño de la Información del Router actual puede cambiar antes de que se envíe el mensaje 3. Las implementaciones deben elegir una de dos estrategias: a) guardar la Información del Router actual que se enviará en el mensaje 3, de modo que se conozca el tamaño, y opcionalmente agregar espacio para el relleno; b) aumentar el tamaño especificado lo suficiente para permitir un posible aumento en el tamaño de la Información del Router, y siempre agregar relleno cuando el mensaje 3 se envíe realmente. En cualquier caso, la longitud "m3p2len" incluida en el mensaje 1 debe ser exactamente el tamaño de ese frame cuando se envíe en el mensaje 3.

- Bob debe fallar la conexión si quedan datos entrantes después de validar el mensaje 1 y leer el relleno. No debe haber datos adicionales de Alice, ya que Bob no ha respondido con el mensaje 2 todavía.

- El campo de ID de red se utiliza para identificar rápidamente conexiones entre redes. Si este campo es diferente de cero, y no coincide con el ID de red de Bob, Bob debe desconectar y bloquear futuras conexiones. A partir de 0.9.42. Consulte la propuesta 147 para más información.



### Función de Derivación de Clave (KDF) (para mensaje de saludo 2 y mensaje 3 parte 1)

```
// tomar h guardado del KDF del mensaje 1
// MixHash(ciphertext)
h = SHA256(h || carga cifrada de 32 bytes del mensaje 1)

// MixHash(relleno)
// Solo si la longitud del relleno es diferente de cero
h = SHA256(h || relleno aleatorio del mensaje 1)

Este es el patrón de mensaje "e":

Bob genera su par de claves efímeras DH e.

// h es del KDF para el mensaje de saludo 1
// Clave efímera Y de Bob
// MixHash(e.pubkey)
// || abajo significa concatenar
h = SHA256(h || e.pubkey);

// h se usa como el dato asociado para el AEAD en el mensaje 2
// Retener el Hash h para el KDF del mensaje 3

Fin del patrón de mensaje "e".

Este es el patrón de mensaje "ee":

// DH(e, re)
Definir input_key_material = resultado DH de 32 bytes de la clave efímera de Alice y la clave efímera de Bob
Set input_key_material = resultado DH X25519
// sobrescribir la clave efímera de Alice en memoria, ya no es necesario
// Alice:
e(public y private) = (todo ceros)
// Bob:
re = (todo ceros)

// MixKey(DH())

Definir temp_key = 32 bytes
Definir HMAC-SHA256(key, data) como en [RFC-2104](https://tools.ietf.org/html/rfc2104)
// Generar una clave temporal desde la clave de encadenamiento y el resultado DH
// ck es la clave de encadenamiento, desde el KDF para el mensaje de saludo 1
temp_key = HMAC-SHA256(ck, input_key_material)
// sobrescribir el resultado DH en memoria, ya no es necesario
input_key_material = (todo ceros)

// Salida 1
// Fijar una nueva clave de encadenamiento desde la clave temporal
// byte() abajo significa un solo byte
ck =       HMAC-SHA256(temp_key, byte(0x01)).

// Salida 2
// Generar la clave de cifrado k
Definir k = 32 bytes
// || abajo significa concatenar
// byte() abajo significa un solo byte
k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
// sobrescribir la temp_key en memoria, ya no es necesario
temp_key = (todo ceros)

// retener la clave de encadenamiento ck para el KDF del mensaje 3

Fin del patrón de mensaje "ee".
```

### 2) SessionCreated

Bob envía a Alice.

Contenido de Noise: la clave efímera Y de Bob
Carga útil Noise: Bloque de opciones de 16 bytes
Carga útil no Noise: Relleno aleatorio

(Properties de seguridad de la carga útil)

XK(s, rs):           Authentication   Confidentiality
    <- e, ee                  2                1

    Autenticación: 2.
    Autenticación del emisor resistente a la suplantación por compromiso de clave (KCI).
    La autenticación del emisor se basa en un DH efímero-estático ("es" o "se")
    entre el par de claves estáticas del emisor y el par de claves efímeras del destinatario.
    Suponiendo que las claves privadas correspondientes sean seguras, esta autenticación no puede ser falsificada.

    Confidencialidad: 1.
    Cifrado para un destinatario efímero.
    Esta carga útil tiene secreto hacia adelante, ya que el cifrado involucra un DH efímero-efímero ("ee").
    Sin embargo, el emisor no ha autenticado al destinatario,
    por lo que esta carga útil podría ser enviada a cualquier parte, incluyendo un atacante activo.

    "e": Bob genera un nuevo par de claves efímeras y las almacena en la variable e,
    escribe la clave pública efímera como texto claro en el búfer de mensaje,
    y hasea la clave pública junto con el viejo h para derivar un nuevo h.

    "ee": Se realiza un DH entre el par de claves efímeras de Bob y el par de claves efímeras de Alice.
    El resultado se hasea junto con el antiguo ck para derivar un nuevo ck y k, y n se establece en cero.

El valor Y está cifrado para asegurar la indistinguibilidad de la carga útil y la unicidad, que son contramedidas necesarias contra DPI. Usamos cifrado AES para lograr esto, en lugar de alternativas más complejas y lentas como elligator2. El cifrado asimétrico a la clave pública del router de Alice sería demasiado lento. El cifrado AES utiliza el hash del router de Bob como clave y el estado AES del mensaje 1 (que fue inicializado con el IV de Bob tal como se publica en la base de datos de red).

El cifrado AES es solo para resistencia a DPI. Cualquier parte que conozca el hash del router de Bob y el IV, que se publican en la base de datos de la red, y capture los primeros 32 bytes del mensaje 1, puede descifrar el valor Y en este mensaje.

Contenido bruto:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        ofuscado con RH_B              +
  |       clave efímera Y cifrada AES-CBC-256        |
  +              (32 bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |   Frame ChaChaPoly                    |
  +   Datos cifrados y autenticados       +
  |   32 bytes                            |
  +   k definido en KDF para el mensaje 2      +
  |   n = 0; ver KDF para datos asociados |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     relleno autenticado no cifrado    |
  +         opcional                      +
  |     longitud definida en bloque de opciones |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 bytes, clave efímera X25519 cifrada AES-256-CBC, little endian
          clave: RH_B
          iv: Usando el estado AES del mensaje 1

Datos no cifrados (etiqueta Poly1305 no mostrada):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                  Y                    |
  +              (32 bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               opciones                |
  +              (16 bytes)               +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     relleno autenticado no cifrado    |
  +         opcional                      +
  |     longitud definida en bloque de opciones |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 bytes, clave efímera X25519, little endian

  options :: bloque de opciones, 16 bytes, ver a continuación

  padding :: Datos aleatorios, 0 o más bytes.
             La longitud total del mensaje debe ser de 65535 bytes o menos.
             Alice y Bob utilizarán los datos de relleno en el KDF para el mensaje 3 parte 1.
             Está autenticado para que cualquier manipulación cause que el
             siguiente mensaje falle.

Notas
`````

- Alice debe validar que la clave efímera de Bob es un punto válido en la curva aquí.

- El relleno debe limitarse a una cantidad razonable. Alice puede rechazar conexiones con relleno excesivo. Alice especificará sus opciones de relleno en el mensaje 3. Directrices mínimas/máximas TBD. ¿Tamaño aleatorio de 0 a 31 bytes como mínimo? (Distribución por determinar, ver Apéndice A.)

- En cualquier error, incluyendo AEAD, DH, marca de tiempo, repetición aparente o fallo de validación de clave, Alice debe detener el procesamiento de mensajes y cerrar la conexión sin responder. Esto debe ser un cierre anormal (TCP RST).

- Para facilitar el saludo rápido, las implementaciones deben asegurar que Bob almacene en búfer y luego envíe todo el contenido del primer mensaje de una vez, incluyendo el relleno. Esto aumenta la probabilidad de que los datos estén contenidos en un único paquete TCP (a menos que sea segmentado por el sistema operativo o middleboxes), y recibidos todos a la vez por Alice. Esto también es para eficiencia y para asegurar la efectividad del relleno aleatorio.

- Alice debe fallar la conexión si quedan datos entrantes después de validar el mensaje 2 y leer el relleno. No debe haber datos adicionales de Bob, ya que Alice no ha respondido con el mensaje 3 todavía.

Bloque de opciones:
Nota: Todos los campos son big-endian.

+----+----+----+----+----+----+----+----+
  | Rsvd(0) | padLen  |   Reservado (0)   |
  +----+----+----+----+----+----+----+----+
  |        tsB        |   Reservado (0)   |
  +----+----+----+----+----+----+----+----+

  Reservado :: 10 bytes en total, establecer en 0 para compatibilidad con futuras opciones

  padLen :: 2 bytes, big endian, longitud del relleno, 0 o más
            Directrices mínimas/máximas TBD. ¿Tamaño aleatorio de 0 a 31 bytes como mínimo?
            (Distribución por determinar, ver Apéndice A.)

  tsB :: 4 bytes, big endian, marca de tiempo Unix, segundos sin firmar.
         Redondea en 2106

Notas
`````
- Alice debe rechazar conexiones donde el valor de la marca de tiempo esté demasiado desfasado respecto al tiempo actual. Llame al tiempo delta máximo "D". Alice debe mantener una caché local de valores de saludo previamente utilizados y rechazar duplicados, para prevenir ataques de repetición. Los valores en la caché deben tener una vida útil de al menos 2*D. Los valores de la caché son dependientes de la implementación, sin embargo, el valor Y de 32 bytes (o su equivalente cifrado) puede ser usado.

Problemas
``````
- ¿Incluir opciones min/máx de relleno aquí?

### Cifrado para mensaje de saludo 3 parte 1, usando mensaje 2 KDF)

```
// tomar h guardado del KDF del mensaje 2
// MixHash(ciphertext)
h = SHA256(h || carga cifrada de 24 bytes del mensaje 2)

// MixHash(relleno)
// Solo si la longitud del relleno es diferente de cero
h = SHA256(h || relleno aleatorio del mensaje 2)
// h se usa como el dato asociado para el AEAD en el mensaje 3 parte 1, abajo

Este es el patrón de mensaje "s":

Definir s = clave pública estática de Alice, 32 bytes

// EncryptAndHash(s.publickey)
// EncryptWithAd(h, s.publickey)
// AEAD_ChaCha20_Poly1305(key, nonce, associatedData, data)
// k es del mensaje de saludo 1
// n es 1
ciphertext = AEAD_ChaCha20_Poly1305(k, n++, h, s.publickey)
// MixHash(ciphertext)
// || abajo significa concatenar
h = SHA256(h || ciphertext);

// h se usa como el dato asociado para el AEAD en el mensaje 3 parte 2

Fin del patrón de mensaje "s".
```

### Función de Derivación de Clave (KDF) (para mensaje de saludo 3 parte 2)

Este es el patrón de mensaje "se":

  // DH(s, re) == DH(e, rs)
  Definir input_key_material = resultado DH de 32 bytes de la clave estática de Alice y la clave efímera de Bob
  Set input_key_material = resultado DH X25519
  // sobreescribir la clave efímera de Bob en memoria, ya no es necesario
  // Alice:
  re = (todo ceros)
  // Bob:
  e(public y private) = (todo ceros)

  // MixKey(DH())

  Definir temp_key = 32 bytes
  Definir HMAC-SHA256(key, data) como en [RFC-2104](https://tools.ietf.org/html/rfc2104)
  // Generar una clave temporal desde la clave de encadenamiento y el resultado DH
  // ck es la clave de encadenamiento, desde el KDF para el mensaje de saludo 1
  temp_key = HMAC-SHA256(ck, input_key_material)
  // sobrescribir el resultado DH en memoria, ya no es necesario
  input_key_material = (todo ceros)

  // Salida 1
  // Fijar una nueva clave de encadenamiento desde la clave temporal
  // byte() abajo significa un solo byte
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // Salida 2
  // Generar la clave de cifrado k
  Definir k = 32 bytes
  // || abajo significa concatenar
  // byte() abajo significa un solo byte
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).

  // h del mensaje 3 parte 1 se usa como el dato asociado para el AEAD en el mensaje 3 parte 2

  // EncryptAndHash(payload)
  // EncryptWithAd(h, payload)
  // AEAD_ChaCha20_Poly1305(key, nonce, associatedData, data)
  // n es 0
  ciphertext = AEAD_ChaCha20_Poly1305(k, n++, h, payload)
  // MixHash(ciphertext)
  // || abajo significa concatenar
  h = SHA256(h || ciphertext);

  // retener la clave de encadenamiento ck para el KDF de la fase de datos
  // retener el hash h para el KDF de Clave Simétrica Adicional (SipHash) de la fase de datos

  Fin del patrón de mensaje "se".

  // sobreescribir la temp_key en memoria, ya no es necesario
  temp_key = (todo ceros)

### 3) SessionConfirmed

Alice envía a Bob.

Contenido de Noise: clave estática de Alice
Carga útil de Noise: Información del Router de Alice y relleno aleatorio
Carga útil no Noise: ninguna

(Properties de seguridad de la carga útil)

XK(s, rs):           Authentication   Confidentiality
    -> s, se                  2                5

    Autenticación: 2.
    Autenticación del emisor resistente a la suplantación por compromiso de clave (KCI). La autenticación del emisor se basa en un DH efímero-estático ("es" o "se") entre el par de claves estáticas del emisor y el par de claves efímeras del destinatario. Suponiendo que las claves privadas correspondientes sean seguras, esta autenticación no puede ser falsificada.

    Confidencialidad: 5.
    Cifrado para un destinatario conocido, fuerte secreto hacia adelante. Esta carga útil está cifrada en función de un DH efímero-efímero, así como un DH efímero-estático con el par de claves estáticas del destinatario. Suponiendo que las claves privadas efímeras sean seguras, y que el destinatario no esté siendo activamente suplantado por un atacante que haya robado su clave privada estática, esta carga útil no puede ser descifrada.

    "s": Alice escribe su clave pública estática desde la variable s en el búfer de mensaje, cifrando, y hasea la salida junto con el viejo h para derivar un nuevo h.

    "se": Se realiza un DH entre el par de claves estáticas de Alice y el par de claves efímeras de Bob. El resultado se hasea junto con el antiguo ck para derivar un nuevo ck y k, y n se establece en cero.

Este contiene dos frames ChaChaPoly. El primero es la clave pública estática cifrada de Alice. El segundo es la carga útil de Noise: Información del Router de Alice, opciones opcionales y relleno opcional. Usan diferentes claves, porque la función MixKey() se llama entre ellas.

Contenido bruto:

+----+----+----+----+----+----+----+----+
  |                                       |
  +   Frame ChaChaPoly (48 bytes)           +
  |   Cifrado y autenticado                  |
  +   Clave estática S de Alice             +
  |      (32 bytes)                        |
  +                                       +
  |     k definido en KDF para el mensaje 2   |
  +     n = 1                             +
  |     ver KDF para datos asociados        |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +     Longitud especificada en el mensaje 1   +
  |                                       |
  +   Frame ChaChaPoly                    +
  |   Cifrado y autenticado               |
  +                                       +
  |       Información del Router de Alice                |
  +       usando el formato de bloque 2            +
  |       Opciones de Alice (opcional)        |
  +       usando el formato de bloque 1         +
  |       Relleno arbitrario                |
  +       usando el formato de bloque 254            +
  |                                       |
  +                                       +
  | k definido en KDF para el mensaje 3 parte 2 |
  +     n = 0                             +
  |     ver KDF para datos asociados        |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  S :: 32 bytes, clave estática de Alice cifrada ChaChaPoly, little endian
       dentro de frame ChaChaPoly de 48 bytes

Datos no cifrados (etiqueta auth Poly1305 no mostrada):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |              S                        |
  +       Clave estática de Alice         +
  |          (32 bytes)                   |
  +                                       +
  |                                       |
  +                                       +
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                                       |
  +                                       +
  |       Bloque de Información del Router de Alice         |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       Bloque de Opciones Opcionales          +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       Bloque de Relleno Opcional          +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  S :: 32 bytes, clave estática X25519 de Alice, little endian

Notas
`````
- Bob debe realizar la validación usual de Información del Router. Asegurarse de que el tipo de firma es compatible, verificar la firma, verificar que la marca de tiempo está dentro de los límites, y cualquier otra verificación necesaria.

- Bob debe verificar que la clave estática de Alice recibida en el primer frame coincide con la clave estática en la Información del Router. Bob primero debe buscar en la Información del Router una Dirección de Router NTCP o NTCP2 con una versión coincidente (v) opción. Consulte las secciones de Información de Router Publicada y No Publicada a continuación.

- Si Bob tiene una versión anterior de la Información del Router de Alice en su netdb, verificar que la clave estática en la información del router es la misma en ambos, si está presente, y si la versión anterior tiene menos de XXX de antigüedad (ver tiempo de rotación de clave a continuación)

- Bob debe validar que la clave estática de Alice es un punto válido en la curva aquí.

- Las opciones deben incluirse, para especificar parámetros de relleno.

- En cualquier error, incluyendo AEAD, RI, DH, marca de tiempo o fallo de validación de clave, Bob debe detener el procesamiento de mensajes y cerrar la conexión sin responder. Esto debe ser un cierre anormal (TCP RST).

- Para facilitar el saludo rápido, las implementaciones deben asegurar que Alice almacene en búfer y luego envíe todo el contenido del tercer mensaje de una vez, incluyendo ambos frames AEAD. Esto aumenta la probabilidad de que los datos estén contenidos en un único paquete TCP (a menos que sea segmentado por el sistema operativo o middleboxes), y recibidos todos a la vez por Bob. Esto también es para eficiencia y para asegurar la efectividad del relleno aleatorio.

- Longitud del frame de la parte 2 del mensaje 3: La longitud de este frame (incluyendo MAC) es enviada por Alice en el mensaje 1. Véase ese mensaje para notas importantes sobre permitir suficiente espacio para el relleno.

- Contenido del frame de la parte 2 del mensaje 3: Este formato de este frame es el mismo que el formato de frames de fase de datos, excepto que la longitud del frame es enviada por Alice en el mensaje 1. Véase más abajo para el formato de frame de fase de datos. El frame debe contener de 1 a 3 bloques en el siguiente orden: 1) Bloque de Información del Router de Alice (requerido) 2) Bloque de Opciones (opcional) 3) Bloque de Relleno (opcional) Este frame nunca debe contener otro tipo de bloque.

- El relleno de la parte 2 del mensaje 3 no es obligatorio si Alice agrega un frame de fase de datos (que opcionalmente contiene relleno) al final del mensaje 3 y envía ambos de una vez, ya que parecerá un gran flujo de bytes a un observador. Como Alice generalmente, pero no siempre, tendrá un mensaje I2NP para enviar a Bob (por eso se conectó con él), esta es la implementación recomendada, para eficiencia y para asegurar la efectividad del relleno aleatorio.

- La longitud total de ambos frames AEAD del Mensaje 3 (partes 1 y 2) es de 65535 bytes; parte 1 es de 48 bytes, por lo que la longitud máxima del frame de la parte 2 es de 65487; la longitud máxima de texto plano de la parte 2 excluyendo MAC es de 65471.

### Función de Derivación de Clave (KDF) (para fase de datos)

La fase de datos utiliza una entrada de datos asociados de longitud cero.

El KDF genera dos claves de cifrado k_ab y k_ba a partir de la clave de encadenamiento ck, utilizando HMAC-SHA256(key, data) como se define en [RFC-2104](https://tools.ietf.org/html/rfc2104). Esta es la función Split(), exactamente como se define en la especificación Noise.

ck = de la fase de saludo

  // k_ab, k_ba = HKDF(ck, zerolen)
  // ask_master = HKDF(ck, zerolen, info="ask")

  // zerolen es una matriz de bytes de longitud cero
  temp_key = HMAC-SHA256(ck, zerolen)
  // sobrescribir la clave de encadenamiento en memoria, ya no es necesario
  ck = (todo ceros)

  // Salida 1
  // clave de cifrado, para que Alice transmita a Bob (Noise no deja claro cuál es cuál, pero el código de Java lo hace)
  k_ab =   HMAC-SHA256(temp_key, byte(0x01)).

  // Salida 2
  // clave de cifrado, para que Bob transmita a Alice (Noise no deja claro cuál es cuál, pero el código de Java lo hace)
  k_ba =   HMAC-SHA256(temp_key, k_ab || byte(0x02)).

  KDF para SipHash para el campo de longitud:
  Generar una Clave Simétrica Adicional (ask) para SipHash
  SipHash utiliza dos claves de 8 bytes (big endian) y un IV de 8 bytes para los primeros datos.

  // "ask" es 3 bytes, US-ASCII, sin terminación NULL
  ask_master = HMAC-SHA256(temp_key, "ask" || byte(0x01))
  // sip_master = HKDF(ask_master, h || "siphash")
  // "siphash" es 7 bytes, US-ASCII, sin terminación NULL
  // sobrescribir la clave temp_key anterior en memoria
  // h es del KDF para el mensaje 3 parte 2
  temp_key = HMAC-SHA256(ask_master, h || "siphash")
  // sobrescribir ask_master en memoria, ya no es necesario
  ask_master = (todo ceros)
  sip_master = HMAC-SHA256(temp_key, byte(0x01))

  SipHash k1, k2, IV de Alice a Bob:
  // sipkeys_ab, sipkeys_ba = HKDF(sip_master, zerolen)
  // sobrescribir la clave temp_key anterior en memoria
  temp_key = HMAC-SHA256(sip_master, zerolen)
  // sobrescribir sip_master en memoria, ya no es necesario
  sip_master = (todo ceros)

  sipkeys_ab = HMAC-SHA256(temp_key, byte(0x01)).
  sipk1_ab = sipkeys_ab[0:7], little endian
  sipk2_ab = sipkeys_ab[8:15], little endian
  sipiv_ab = sipkeys_ab[16:23]

  SipHash k1, k2, IV de Bob a Alice:

  sipkeys_ba = HMAC-SHA256(temp_key, sipkeys_ab || byte(0x02)).
  sipk1_ba = sipkeys_ba[0:7], little endian
  sipk2_ba = sipkeys_ba[8:15], little endian
  sipiv_ba = sipkeys_ba[16:23]

  // sobrescribir la temp_key en memoria, ya no es necesario
  temp_key = (todo ceros)

### 4) Fase de datos

Carga útil de Noise: Como se define a continuación, incluyendo relleno aleatorio
Carga útil no Noise: ninguna

A partir de la segunda parte del mensaje 3, todos los mensajes están dentro de un "frame" autenticado y cifrado ChaChaPoly con una longitud ofuscada de dos bytes antepuesta. Todo el relleno está dentro del frame. Dentro del marco hay un formato estándar con cero o más "bloques". Cada bloque tiene un identificador de un byte y una longitud de dos bytes. Los tipos incluyen fecha/hora, mensaje I2NP, opciones, terminación y relleno.

Nota: Bob puede, pero no está obligado, a enviar su Información del Router a Alice como su primer mensaje a Alice en la fase de datos.

(Properties de seguridad de la carga útil)

XK(s, rs):           Authentication   Confidentiality
    <-                        2                5
    ->                        2                5

    Autenticación: 2.
    Autenticación del emisor resistente a la suplantación por compromiso de clave (KCI).
    La autenticación del emisor se basa en un DH efímero-estático ("es" o "se")
    entre el par de claves estáticas del emisor y el par de claves efímeras del destinatario.
    Suponiendo que las claves privadas correspondientes sean seguras, esta autenticación no puede ser falsificada.

    Confidencialidad: 5.
    Cifrado para un destinatario conocido, fuerte secreto hacia adelante.
    Esta carga útil está cifrada en función de un DH efímero-efímero, así como
    un DH efímero-estático con el par de claves estáticas del destinatario.
    Suponiendo que las claves privadas efímeras sean seguras, y el destinatario no esté siendo activamente suplantado
    por un atacante que haya robado su clave privada estática, esta carga útil no puede ser descifrada.

Notas
`````
- Para eficiencia y para minimizar la identificación del campo de longitud,
  las implementaciones deben asegurar
