```markdown
---
title: "SSU2"
number: "159"
author: "eyedeekay, orignal, zlatinb, zzz"
created: "2021-09-12"
lastupdated: "2025-03-05"
status: "Closed"
thread: "http://zzz.i2p/topics/2612"
target: "0.9.56"
---

## 상태

배포 계획:


| 기능 | 테스트 중 (기본값 아님) | 기본적으로 활성화 |
|----|----------------|-----------|
| 로컬 테스트 코드 | 2022-02 |
| 공동 테스트 코드 | 2022-03 |
| 네트워크 내 공동 테스트 | 0.9.54 | 2022-05 |
| 기본 프로토콜 동결 | 0.9.54 | 2022-05 |
| 기본 세션 | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| 주소 검증 (재시도) | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| 핸드셰이크에서 조각화된 RI | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| 새 토큰 | 0.9.55 | 2022-08 | 0.9.57 | 2022-11 |
| 확장 프로토콜 동결 | 0.9.55 | 2022-08 |
| 릴레이 | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| 동료 테스트 | 0.9.55 | 2022-08 | 0.9.56 | 2022-11 |
| 무작위 2% 활성화 | 0.9.55 | 2022-08 |
| 경로 검증 | 0.9.55+ dev | 0.9.56 | 2022-11 |
| 연결 마이그레이션 | 0.9.55+ dev | 0.9.56 | 2022-11 |
| 즉각적인 ACK 플래그 | 0.9.55+ dev | 0.9.56 | 2022-11 |
| 키 회전 | 0.9.57 | 2023-02 | 0.9.58 | 2023-05 |
| SSU 1 비활성화 (i2pd) | 0.9.56 | 2022-11 |
| SSU 1 비활성화 (Java I2P) | 0.9.58 | 2023-05 | 0.9.61 | 2023-12 |

기본 세션은 핸드셰이크 및 데이터 단계를 포함합니다.
확장 프로토콜은 릴레이 및 동료 테스트를 포함합니다.


## 개요

이 제안은 다양한 형태의 자동화된 식별 및 공격에 대한 [SSU](/en/docs/transport/ssu/)의 저항력을 개선하기 위해 인증된 키 합의 프로토콜을 설명합니다.

제안서는 다음과 같이 구성되어 있습니다: 보안 목표가 제시되고, 기본 프로토콜에 대한 논의가 이어집니다. 다음으로, 모든 프로토콜 메시지의 완전한 명세가 제공됩니다. 마지막으로, 라우터 주소와 버전 식별에 대해 논의합니다.

다른 I2P 전송과 마찬가지로 SSU2는 I2NP 메시지의 점대점(라우터 간) 전송을 위해 정의됩니다.
일반적인 데이터 파이프가 아닙니다.
[SSU](/en/docs/transport/ssu/)와 마찬가지로 NAT 우회를 위한 릴레이 및 인바운드 도달 가능성 확인을 위한 동료 테스트 두 가지 추가 서비스를 제공합니다.
또한 동료의 IP 또는 포트가 변경될 때 연결 마이그레이션을 위한 세 번째 서비스를 제공합니다.

## 동기

SSU는 매우 느린 ElGamal을 필요로 하는 유일한 남은 프로토콜 계층입니다.
SSU의 흐름 제어는 복잡하며 잘 작동하지 않습니다.
SSU의 일부분은 주소 스푸핑 공격에 취약합니다.
핸드셰이크는 Noise를 사용하지 않습니다.

## 설계 목표

- ElGamal 제거로 CPU 사용량 감소. DH에 X25519 사용.

- 동료 테스트 및 릴레이 기능 유지, 보안 강화.

- 표준 흐름 제어 알고리즘 허용으로 구현 용이성 향상.

- 설정 지연 시간 감소.
  NTCP2의 설정 중간 시간은 현재 약 135ms이고 SSU는 187ms이며, NTCP2는 추가 라운드 트립이 필요하지만,
  SSU2에서 ElGamal을 교체하면 지연 시간이 줄어들 수 있으며, 다른 변경도 도움이 될 수 있습니다.

- 테스트넷의 다양한 지연 시간과 패킷 드롭 비율을 측정했을 때 SSU 1에 비해 최대 처리량을 유지하거나 증가.

- "주소 검증"을 통해 스푸핑된 소스 주소에서 트래픽 증폭 및 오경로 공격 방지.

- 코드 복잡성이 과도하게 증가하는 대체 및 전방 정보를 줄이고 패킷 식별을 더 쉽게 만들기.

- 공격을 방지하기 위해 주소 검증이 완료될 때까지 동료의 IP 또는 포트가 변경된 경우 연결 마이그레이션을 포멀화하고 개선.
  일부 SSU 1 구현은 NAT 리바인딩으로 인해 발생하는 포트 변경을 처리하기 위해 비용이 높은 휴리스틱을 사용합니다.
  IP 변경을 처리할 수 있는 SSU 1 구현은 알려진 바가 없으며, SSU 1 및 2를 단일 포트에서 지원하고,
  [RouterAddress](/en/docs/spec/common-structures/#routeraddress/)(i.e.) [NetDB](/en/docs/how/network-database/)에서 단일 "전송"으로 자동 감지하여 게재.

- 항목 필드 내에서 NetDB에 대해서만, 가능하면 버전 1에 대한 기본 지원
  (특정 라우터 버전에 대한 버전 지원을 바인딩하지 않음).

- 모든 구현(Java/i2pd/Go)이 자체 일정에 따라 버전 2 지원을 추가할 수 있도록 보장.

- 핸드셰이크와 데이터 메시지를 포함한 모든 메시지에 무작위 패딩 추가.
  모든 패딩은 SSU 1의 패킷 끝 패딩과 달리 MAC으로 보호되어야 합니다.
  옵션 메커니즘을 제공하여 양쪽에서 최소 및 최대 패딩과/또는 패딩 분포 요청 가능.
  패딩 분포의 세부사항은 구현에 따라 다르며 프로토콜 자체에 명시적으로 지정되지 않을 수 있습니다.
  AI 및 DPI 박스와 AV 서명이 메시지의 헤더와 내용을 쉽게 분류할 수 없도록 하기 위한 불투명성 제공.
  단일 동료 또는 일련의 동료에게 전송되는 메시지 간에 유사한 비트 패턴이 없도록 보장.

- Java 형식 [Ticket1112](http://{{ i2pconv('trac.i2p2.i2p') }}/ticket/1112)로 인한 DH의 손실 비트를 수정하고 X25519를 전환하여 DH 속도를 높임.

- Result를 직접 사용하는 대신 실제 키 유도 함수 (KDF)로 전환

- "탐침 저항성"(Tor가 부르는 것)을 추가합니다. 이것은 재생 저항성을 포함합니다.

- 2 방향 인증된 키 교환 (2W-AKE)을 유지. 1W-AKE는 우리의 응용 프로그램에 충분하지 않습니다.

- 인증의 또 다른 부분으로 RouterInfo에 게시된 정적 공개 키에 의존.

- 향후 확장성을 위한 핸드셰이크에서 옵션/버전 추가.

- 연결 설정에 필요한 CPU를 크게 추가하지 않음. 가능한 경우, 대폭 줄임.

- SSU 1의 AES 암호화에 의해 강제되는 16 바이트의 배수에 대한 패딩 요구 사항 제거.

- SSU 1에서 사용된 AES 암호화와 비표준 HMAC-MD5-128 MAC을 대체하여 암호화 및 MAC에 대한 표준 ChaCha/Poly1305 사용.

- 양방향에 대해 이전에 사용된 공통 키와 달리 송신 및 수신에 대해 별도의 암호화 키 사용.

- [NTCP2](/en/proposals/111-ntcp-2/)와 같은 한 라운드 트립 핸드셰이크를 위해 3 메세지 사용.
  [SSU](/en/docs/transport/ssu/)가 본질적으로 두 라운드 트립 핸드셰이크가 되게 하는 데이터 메시지 대기 시간 제거.

- ACK 및 NACK의 효율성을 극적으로 개선, 이는 SSU 1에서 심각.
  ACK 및 NACK의 대역폭 요구를 줄이고, 데이터에 사용할 수 있는 패킷 크기 증가.
  WiFi에서 흔히 발생하는 누락된 메시지 버스트에 대해 NACK을 효율적으로 인코딩.

- I2NP 메시지 조각화를 구현하는 데 필요한 복잡성을 줄임.
  전체 I2NP 메시지에 대해 조각화 메커니즘 및 인코딩을 우회.

- 특히 ACK에 대한 패딩 전 프로토콜 오버헤드를 최소화.
  패딩이 추가되겠지만,
  패딩 전 오버헤드는 여전히 오버헤드.
  저대역폭 노드가 SSU2를 사용할 수 있어야 합니다.

- 재생 및 비스코우 탐지를 위한 타임스탬프 유지.

- 타임스탬프에서 2038년도 문제를 피하고, 적어도 2106까지 작동해야 합니다.

- 효율성, 구현 용이성, 최대 I2NP 메시지 크기 증가를 위해 최소 MTU를 620에서 1280으로 증가.
  조각화 및 재조립 비용이 상당히 듭니다.
  1028 바이트 터널 메시지를 허용하면 대다수의 I2NP 메시지가 조각화가 필요하지 않습니다.

- 효율성 증가를 위해 최대 MTU를 1488(IPv6의 경우 1484)에서 1500으로 증가.
  MTU가 16의 배수여야 한다는 요구 사항 제거.

- SSU 1의 약 32K에서 NTCP2와 같은 약 64KB까지 최대 I2NP 메시지 크기 증가.

- 핸드셰이크에서 IP 및 포트 필드의 서명 제거, 따라서 외부 IP 및 포트를 모르는 라우터도 연결 가능.

- 핸드셰이크의 SSU 1에서 IP/포트 탐지 메커니즘 유지, 라우터가 외부 IP 및 포트를 알 수 있도록 함.

- 디자인에 Java, C++, Go 라우터 개발자를 포함.

### 비목표

- 총체적인 DPI 저항... 이는 플러그 가능한 전송이 필요합니다,
  [Prop109](/en/proposals/109-hashcash/).

- TLS 기반(또는 HTTPS 비슷한) 전송... 이는 [Prop104](/en/proposals/104-new-protocol/).

- 타이밍 기반 DPI 저항 (메시지 간 타이밍/지연은
  구현에 따라 다를 수 있으며; 메시지 내의 지연은
  예를 들어, 무작위 패딩을 보내기 전 등) 어느 시점에서든지 도입될 수 있습니다.
  obfs4가 IAT 또는 도착 간격 시간이라고 부르는 인위적인
  지연은 프로토콜 자체와 독립적입니다.

- 세션 참여의 부인 가능성 (서명이 포함되어 있습니다).

일부 비목표는 부분적으로 재고되거나 논의될 수 있습니다:

- 심층 패킷 검사에 대한 보호 수준 (DPI)

- 후양자 (PQ) 보안

- 부인 가능성


## 보안 목표

우리는 세 명의 당사자를 고려합니다:

- 세션을 설정하려는 Alice.
- Alice가 세션을 설정하려는 Bob.
- "중간자"인 Mallory가 Alice와 Bob 사이에 있습니다.

최대 두 명의 참여자가 적극적으로 공격을 할 수 있습니다.

Alice와 Bob은 모두 자신의 [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/)에 포함된 정적인 키 쌍을 가지고 있습니다.

제안된 프로토콜은 다음 요구 사항을 충족하면서 Alice와 Bob이 공유 비밀 키(K)에 동의할 수 있도록 시도합니다:

1) 개인 키 보안: Bob이나 Mallory는 Alice의 정적 개인 키에 대해 아무것도 배우지 못합니다.
   대칭적으로, Alice는 Bob의 정적 개인 키에 대해 아무것도 배우지 못합니다.

2) 세션 키 K는 Alice와 Bob만 알고 있습니다.

3) 완벽한 전방 비밀성: 합의된 세션 키는 미래에도 비밀로 남으며, Alice 및/또는 Bob의 정적 개인 키가 노출되더라도
   키가 합의된 후에도 비밀로 유지됩니다.

4) 양방향 인증: Alice는 자신이 Bob과 세션을 설정했음을 확신하고, 그 반대도 마찬가지입니다.

5) 온라인 DPI에 대한 보호: Alice와 Bob이 프로토콜에 참여 중인지 특정하기 위해
   간단한 심층 패킷 검사 (DPI) 기술만으로 탐지가 쉽지 않도록 보장합니다. 아래를 참조하세요.

6) 제한된 부인 가능성: Alice와 Bob은 프로토콜에 참여한 것을 부인할 수 없지만,
   누군가가 공유 키를 유출하면 다른 당사자는 전송된 데이터의 진정성을 부인할 수 있습니다.

현재의 제안서는 Station-To-Station(STS) 프로토콜 [STS](https://en.wikipedia.org/wiki/Station-to-Station_protocol)을 기반으로 모든 다섯 가지 요구 사항을 제공하려고 합니다.
이 프로토콜은 [SSU](/en/docs/transport/ssu/) 프로토콜의 기반이기도 합니다.


### 추가 DPI 논의

우리는 두 가지 DPI 컴포넌트를 가정합니다:

온라인 DPI
`````````````

실시간으로 모든 흐름을 검사하는 온라인 DPI.
연결이 차단되거나 간섭을 받을 수 있습니다. Connection data or metadata may be identified and stored for offline analysis.
온라인 DPI는 I2P 네트워크 데이터베이스에 접근할 수 없습니다.
온라인 DPI는 길이 계산, 필드 검사, XOR 같은 간단한 계산을 포함하여 제한적인 실시간 계산 역량만을 가지고 있습니다.
온라인 DPI는 ChaCha20, AEAD 및 해시 같은 빠른 실시간 암호화 기능을 가지고 있지만,
대부분의 흐름이나 전부에 이 암호화 기능을 적용하기에는 너무 비용이 큽니다.
이러한 암호화 연산은 이전에 오프라인 분석을 통해 식별된 IP/포트 조합의 흐름에만 적용될 수 있습니다.
온라인 DPI는 DH 및 elligator2와 같은 고비용 암호화 기능을 수행할 수 없습니다.
온라인 DPI는 I2P를 감지하도록 특별히 설계되지 않았지만,
제한적인 분류 규칙을 가질 수 있습니다.

프로토콜 식별이 온라인 DPI에 의해 방지되는 것이 목표입니다.

여기에서 사용된 온라인 또는 "단순한" DPI의 개념에는 다음의 불법적인 행위들을 포함하는 것으로 여깁니다:

1) 대상이 송신하거나 수신하는 모든 데이터를 검사할 수 있는 능력.

2) 관찰된 데이터에 각종 연산을 수행할 수 있는 능력,
   예를 들어 블록 암호 또는 해시 함수 적용.

3) 이전에 전송된 메시지를 저장하고 비교할 수 있는 능력.

4) 패킷을 수정, 지연, 또는 조각화할 수 있는 능력.

그러나 온라인 DPI는 다음과 같은 제한을 가집니다:

5) IP 주소를 라우터 해시로 매핑할 수 있는 능력의 부재.
   이는 네트워크 데이터베이스에 대한 실시간 접근을 통해 간단하지만,
   I2P를 목표로 한 DPI 시스템을 필요로 한다.

6) 프로토콜을 감지하기 위해 타이밍 정보를 사용할 수 없는 제한.

7) 일반적으로, 온라인 DPI 툴박스에는 I2P 감지를 위한
   특별히 설계된 내장 도구가 없습니다. 이는 메시지에 무작위로 패딩을 포함하는
   이른바 "허니팟" 생성 등을 포함합니다. 이는 기계 학습 시스템이나
   다른 제한된 범위의 DPI 도구를 배제하지는 않습니다.

페이로드 분석을 방지하기 위해서는 모든 메시지가 무작위와 구별할 수 없도록 보장하며, 이는 길이가 무작위임을 필요로 합니다.
이는 단순히 무작위로 패딩을 추가하는 것보다 복잡합니다.
실제로, 부록 A에서는
작가들이 일반적인 (즉, 균일한) 패딩 기법이 문제가 해결되지 않는다고 주장합니다. 부록 A에서는
랜덤 지연을 포함하거나 제안된 공격으로부터 적절한 보호를 제공하는 대체 패딩 기법에 대해 설명합니다.

위에서 언급한 여섯 번째 항목을 방지하기 위해 구현은 프로토콜에 무작위 지연을 포함해야 합니다.
이러한 기법은 이 제안서에 포함되어 있지 않지만, 패딩 길이 문제를 해결할 수 있습니다.
요약하자면, 제안서는 페이로드 분석에 대한 좋은 보호를 제공하지만 (부록 A의 고려사항을 염두에 둔다면),
흐름 분석에 대한 보호는 제한적입니다.


오프라인 DPI
``````````````

오프라인 DPI는 온라인 DPI에 의해 저장된 데이터를 나중에 분석하기 위해 검사합니다.
오프라인 DPI는 특별히 I2P를 감지하도록 설계될 수 있습니다.
오프라인 DPI는 실시간으로 I2P 네트워크 데이터베이스에 접근할 수 있습니다.
오프라인 DPI는 이와 다른 I2P 명세서에 접근할 수 있습니다.
오프라인 DPI는 이 명세에서 정의된 모든 암호화 기능을 포함하여
제한 없는 계산 능력을 가지고 있습니다.

오프라인 DPI는 기존 연결을 차단할 수 없습니다.
오프라인 DPI는 피어 간에 패킷 삽입으로 호스트/포트로 전송할 수 있는 근실시간(설치 몇 분 내에) 기능을 가지고 있습니다.
오프라인 DPI는 이전 메시지의 재생 (변경되었든 아니든)을 근실시간(설치 후 몇 분 내에)으로 "탐색"하거나 다른 이유로 사용할 수 있는 기능을 가지고 있습니다.

오프라인 DPI에 의해 프로토콜 식별이 방지되는 것이 목표가 아닙니다.
I2P 라우터에 의해 구현된 첫 두 메시지의 난독 데이터 해독 또한
오프라인 DPI에 의해 구현될 수 있습니다.

재생 시도의 방지
```````````````````````````````````````````````

QUIC의 [RFC-9000]에서 복사했습니다.
각 섹션을 검토하고 편집하세요.

주소 검증은 종점으로 대량 공격이 발생하지 않도록 보장합니다.
이러한 공격에서는 출발지 주소 정보가 위조된 패킷이 서버에 전송되어
서버에서 응답으로 더 크고 많은 패킷을 생성합니다.

주소 검증은 스푸프된 주소에서 더 많은 데이터가 전송될 수 있도록 하기 위해
피어가 주장하는 전달 주소로 패킷이 수신될 수 있는지를 확인하는 것입니다.
따라서 수신되지 않은 주소로 패킷을 보낸 경우 종점은 유효한 주소로 데이터를 보낼 수 없으므로
오히려 유효한 주소 검증이 발생한 후에야 해당 주소로 데이터를 보냅니다.
종점이 전송할 수 있는 송신 응답의 크기를 제한하는 것은
"주소 검증"이라는 선명한 공격을 제한하는 것입니다.

주소 검증은 연결 설정과 연결 마이그레이션 중에 모두 수행됩니다.

연결 설정 중 주소 검증
```````````````````````````````````````````````

연결 설정 중에는 모든 패킷이 암호화됩니다.
송신 측에서 패킷을 수신했다는 확인을 의미합니다.
대응하는 핸드셰이크가 이루어지기 전에 검증하지 않은 주소로 보낼 수 있는 데이터를 제한할 수 있어야 합니다.

연결 설정이 완료되기 전까지 서버는 주소 검증이 완료되기 전까지는
3배 미만의 데이터를 전송할 수 없습니다.
이는 주소 스푸핑 환경에서 발생할 수 있는 증폭 공격의 크기를 제한합니다.
각 연결에 고유히 할당된 데이터 구조는 모든 피어 접근 주소에 대한 패인을 가집니다.
이는 네트워크를 스푸핑에서 보호하는 것입니다.

클라이언트는 네트워크 연속성의 모호함을 없애기 위해 NEW_TOKEN 프레임을 사용하여 제공된 임의의 주소를 포함할 수 없습니다.
가능하면 기존 주소에 대해 기존 제한 없이 새 제한을 따르는 공유 스펙의 고유 데이터를 제공해야 합니다.
이 연결에서 제공된 패킷이 캡슐화된 발신자의 주소 필드 없이 글로벌로 전송되더라도,
경로는 스트림이 연결되고 입력이 제공되는 시기까지 유지됩니다.

보호 릴레이로 고무 암호를 제공하는 서버는 새 송신지를 지정할 수 있습니다
해당 송신지를 통해 보안 경로를 활성화하여 클라이언트가 재전송을 자동으로 무효화하여 상호 인증된 종점을 수신할 수 있습니다.

다음의 제한 요소 이후의 일부 상황에서,
검증을 위해 매번 응답되는 최소 업데이트 시간의 제공을 허용한다.
이러한 연결의 이용 균형을 제거하는 초기 연습은 연결 파라미터 변경 횟수를 제한해야 한다.
추가 업데이트는 이러한 메서드의 증가 또는 축소에 따라 사용할 수 있으며,
해당 변경 또는 초기 조건과는 원래의 체인을 확인할 수 있는 근거를 제공한다.
옵션 위치에서는 새 라우터의 각 연결을 허가 증거를 제공되지 않을 시 제공했던 유연성은 제거될 수 있다.

재생 공격의 구체적인 요구는 연결을 보장하여 제공되고
이 변경 항목이 무효화를 위한 유용한 단서를 클라이언트에 제공한다.
이 유스 케이스에서 추가 전송과 함께 발신자 또는 수신자의 보안 설정을 사용할 수 있으며,
가짜와의 정보 교환을 피하는 반환 가능한 수정자 목록을 보장할 것이다.
각 프로토콜의 수정된 보안 사양은 재생 정보 교환을 지원하고 전송 메커니즘을 제공합니다.
그러나, 주제의 최종적인 수정)은 새로 포함된 추가 검증 기능은 피어 대화 결정을 보장할 수 있어야 한다.
### 연결 변경

QUIC [RFC-9000](https://www.rfc-editor.org/rfc/rfc9000.html)에서 복사했습니다.
각 섹션을 검토하고 편집하세요.

연결 ID를 사용하는 QUIC 연결은 네트워크 집합에 대한 관리를 위한 특정 로컬 주소로 새 클라이언트에 대한 연결 지원을 허용합니다.
QUIC 디자인에서는 연결이 관리에 의해 종료되지 않도록 새 네트워크에 대한 핸드오버를 등록하고 작업하는 것입니다.
가장 최적의 시점에서 종점이 연구되고 전송이 설정되었습니다.
서버와 같이 동일한 고정 구성을 사용하여 인증 권한을 확인하면 인증을 사용한 가상의 변인 사용을 피합니다.
클라이언트 역시 최대 MTU 228 응답으로 강력한 핸드오버의 활성 경로를 테스트하고,
이전에 전송된 패킷과 관련된 스푸핑을 거부합니다.
네트워크 변경에 의해 두 전달 장치의 무역 루트를 중단했을 때,
노드의 범위를 변경하도록 허가하지 않는 한도는 이후의 프로토콜 및 배포를 정상화할 수 있습니다.

고정 위치 제어의 추가 제공은 요청이 유효한지 확인하지 못하는 것과 동일한 네트워크의 연결 동작을 의도적으로 스푸핑하며 가는 패턴을 방해할 수 있습니다.
각 주소의 기준은 변환되며 종종 해당 범위에서 구성됩니다.
예를 들어, 기본적으로 연결 아이디가 이전의 모든 요소 리소스로 접속되는지 여부를 추적하는 데 사용할 수 있습니다.

이 경우 노드에서 귀하의 연결에 의한 별도의 인증서 사용을 제한해야합니다.
전용 목적이 앱리뇽이 유연한 응용 프로그램을 지원하고 연결을 수행하는 데 허용되지 않도록 제한할 수 있으며,
위조된 주소를 필터링 예측 레벨에 넣기 위해 상대 주소의 인스턴스를 수락하는 연결에 대한 동일한 목표를 고려할 수 있습니다.

```
Client                                                  Server

  Initial[0]: CRYPTO[CH] ->

                                                <- Retry+Token

  Initial+Token[1]: CRYPTO[CH] ->

                                 Initial[0]: CRYPTO[SH] ACK[1]
                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                 <- 1-RTT[0]: STREAM[1, "..."]

                Figure 9: Example Handshake with Retry
```
```
