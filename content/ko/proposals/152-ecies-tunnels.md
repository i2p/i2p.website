---
title: "ECIES 터널"
number: "152"
author: "chisana, zzz, orignal"
created: "2019-07-04"
lastupdated: "2025-03-05"
status: "Closed"
thread: "http://zzz.i2p/topics/2737"
target: "0.9.48"
implementedin: "0.9.48"
---

## 노트
네트워크 배포 및 테스트 진행 중.
사소한 수정이 있을 수 있습니다.
공식 사양은 [SPEC](/en/docs/spec/)을 참조하십시오.


## 개요

이 문서는 [ECIES-X25519](/en/docs/spec/ecies/)에서 도입된 암호화 프리미티브를 사용하여 터널 빌드 메시지 암호화를 변경할 것을 제안합니다.
이는 라우터를 ElGamal에서 ECIES-X25519 키로 변환하는 전체 제안 [Prop156](/en/proposals/156-ecies-routers/)의 일부입니다.

네트워크를 ElGamal + AES256에서 ECIES + ChaCha20로 전환하기 위한 목적에서 ElGamal과 ECIES 라우터가 혼합된 터널이 필요합니다.
혼합된 터널 홉을 처리하기 위한 사양이 제공됩니다.
ElGamal 홉의 형식, 처리 또는 암호화에는 변경 사항이 없습니다.

ElGamal 터널 생성자는 각 홉에 대해 임시 X25519 키 쌍을 생성하고 ECIES 홉을 포함하는 터널을 생성하기 위해 이 사양을 따라야 합니다.

이 제안서는 ECIES-X25519 터널 빌딩에 필요한 변경 사항을 명시합니다.
ECIES 라우터에 필요한 전체 변경 사항의 개요는 제안 156 [Prop156](/en/proposals/156-ecies-routers/)를 참조하십시오.

이 제안서는 호환성을 위해 터널 빌드 레코드의 크기를 동일하게 유지합니다.
작은 빌드 레코드 및 메시지는 나중에 구현될 것입니다 - [Prop157](/en/proposals/157-new-tbm/)를 참조하십시오.


### 암호화 프리미티브

새로운 암호화 프리미티브는 도입되지 않았습니다. 이 제안서를 구현하는 데 필요한 프리미티브는 다음과 같습니다:

- [암호화](/en/docs/spec/cryptography/)에서처럼 AES-256-CBC
- STREAM ChaCha20/Poly1305 함수:
  [NTCP2](/en/docs/spec/ntcp2/), [ECIES-X25519](/en/docs/spec/ecies/) 및 [RFC-7539](https://tools.ietf.org/html/rfc7539)에서처럼 ENCRYPT(k, n, plaintext, ad) 및 DECRYPT(k, n, ciphertext, ad)
- [NTCP2](/en/docs/spec/ntcp2/) 및 [ECIES-X25519](/en/docs/spec/ecies/)에서처럼 X25519 DH 함수
- [NTCP2](/en/docs/spec/ntcp2/) 및 [ECIES-X25519](/en/docs/spec/ecies/)에서처럼 HKDF(salt, ikm, info, n)

다른 Noise 함수는 다른 곳에 정의됨:

- [NTCP2](/en/docs/spec/ntcp2/) 및 [ECIES-X25519](/en/docs/spec/ecies/)에서처럼 MixHash(d)
- [NTCP2](/en/docs/spec/ntcp2/) 및 [ECIES-X25519](/en/docs/spec/ecies/)에서처럼 MixKey(d)


### 목표

- 암호화 작업의 속도 증가
- 터널 BuildRequestRecords 및 BuildReplyRecords에 대해 ElGamal + AES256/CBC를 ECIES 프리미티브로 대체
- 호환성을 위한 암호화된 BuildRequestRecords 및 BuildReplyRecords의 크기 변경 없음 (528 바이트)
- 새로운 I2NP 메시지 없음
- 호환성을 위한 암호화된 빌드 레코드 크기 유지
- 터널 빌드 메시지에 포워드 시크릿 추가
- 인증된 암호화 추가
- BuildRequestRecords의 홉 재정렬 탐지
- 블룸 필터 크기를 줄이기 위해 타임스탬프 해상도 증가
- 변동 터널 수명이 가능하게 할 터널 만료 필드 추가 (all-ECIES 터널만 해당)
- 향후 기능을 위한 확장 가능한 옵션 필드 추가
- 기존 암호화 프리미티브 재사용
- 호환성을 유지하면서 터널 빌드 메시지 보안 향상
- 혼합 ElGamal/ECIES 피어 터널 지원
- 빌드 메시지에 대한 "태깅" 공격 방어 강화
- 홉은 빌드 메시지를 처리하기 전에 다음 홉의 암호화 유형을 알 필요가 없음,
  해당 시점에 다음 홉의 RI를 가질 수 없기 때문
- 현재 네트워크와의 호환성 극대화
- ElGamal 라우터에 대해 터널 빌드 AES 요청/응답 암호화 변경 없음
- 터널 AES "레이어" 암호화 변경 없음, [Prop153](/en/proposals/153-chacha20-layer-encryption/) 참조
- 8-레코드 TBM/TBRM 및 가변 크기 VTBM/VTBRM 모두 계속 지원
- 전체 네트워크 업그레이드를 위한 "플래그 데이" 필요 없음


### 비목표

- "플래그 데이"가 필요한 완전한 터널 빌드 메시징 설계
- 터널 빌드 메시지 축소 (all-ECIES 홉 및 새로운 제안 필요)
- [Prop143](/en/proposals/143-build-message-options/)에서 정의된 터널 빌드 옵션 사용, 작은 메시지에만 필요
- 양방향 터널 - [Prop119](/en/proposals/119-bidirectional-tunnels/) 참조
- 작은 터널 빌드 메시지 - [Prop157](/en/proposals/157-new-tbm/) 참조


## 위협 모델

### 설계 목표

- 어떤 홉도 터널의 기원을 결정할 수 없음.

- 중간 홉은 터널의 방향이나 터널 내의 위치를 ​​결정할 수 없음.

- 어떤 홉도 다른 요청 또는 응답 레코드의 내용을 읽을 수 없음,
  단, 다음 홉에 대한 잘린 라우터 해시 및 일시적 키 제외.

- 아웃바운드 빌드를 위한 응답 터널의 어떤 구성원도 응답 레코드를 읽을 수 없음.

- 인바운드 빌드를 위한 아웃바운드 터널의 어떤 구성원도 요청 레코드를 읽을 수 없음,
  단, OBEP는 IBGW의 잘린 라우터 해시 및 일시적 키를 볼 수 있음



### 태깅 공격

터널 빌딩 설계의 주요 목표는 량 합의된 라우터 X와 Y가 동일한 터널에 있는지 아는 것을 어렵게 만드는 것입니다.
만약 라우터 X가 홉 m에 있고 라우터 Y가 홉 m+1에 있다면, 그들은 분명히 알게 될 것입니다.
하지만 라우터 X가 홉 m에 있고 라우터 Y가 홉 m+n에 있다면 n>1인 경우, 이는 훨씬 더 어려워야 합니다.

태깅 공격은 중간 홉 라우터 X가 터널 빌드 메시지를 수정하여
라우터 Y가 빌드 메시지가 도착했을 때 수정을 감지할 수 있게 하는 것입니다.
수정된 메시지가 라우터 Y에 도달하기 전에 X와 Y 사이의 라우터에 의해 삭제되는 것이 목표입니다.
라우터 Y에 도달하기 전에 삭제되지 않은 수정에 대해서는 터널 생성자가 응답에서 손상을 감지하고 터널을 폐기해야 합니다.

가능한 공격:

- 빌드 레코드 수정
- 빌드 레코드 교체
- 빌드 레코드 추가 또는 제거
- 빌드 레코드 재정렬

TODO: 현재 설계가 이러한 모든 공격을 방지하는가?



## 설계

### 노이즈 프로토콜 프레임워크

이 제안서는 Noise 프로토콜 프레임워크
[NOISE](https://noiseprotocol.org/noise.html) (Revision 34, 2018-07-11)을 기반으로 합니다.
Noise 용어에서 Alice는 발신자이고, Bob은 응답자입니다.

이 제안서는 Noise 프로토콜 Noise_N_25519_ChaChaPoly_SHA256에 기반합니다.
이 Noise 프로토콜은 다음 프리미티브를 사용합니다:

- 일방 핸드셰이크 패턴: N
  Alice는 그녀의 정적 키를 Bob에게 전송하지 않음 (N)

- DH 함수: X25519
  [RFC-7748](https://tools.ietf.org/html/rfc7748)에서 지정된 32바이트 키 길이의 X25519 DH.

- 암호 함수: ChaChaPoly
  [RFC-7539](https://tools.ietf.org/html/rfc7539) 2.8절에서 지정된 AEAD_CHACHA20_POLY1305.
  처음 4바이트가 0으로 설정된 12바이트 논스.
  [NTCP2](/en/docs/spec/ntcp2/)에서와 동일.

- 해시 함수: SHA256
  I2P에서 광범위하게 사용되는 표준 32바이트 해시.


프레임워크에 대한 추가 사항
````````````````````````````

없음.


### 핸드셰이크 패턴

핸드셰이크는 [Noise](https://noiseprotocol.org/noise.html) 핸드셰이크 패턴을 사용합니다.

다음 문자 매핑이 사용됩니다:

- e = 일회용 임시 키
- s = 정적 키
- p = 메시지 페이로드

빌드 요청은 Noise N 패턴과 동일합니다.
이는 또한 [NTCP2](/en/docs/spec/ntcp2/)에서 사용된 XK 패턴의 첫 번째 (세션 요청) 메시지와 동일합니다.

  ```dataspec

<- s
  ...
  e es p ->




  ```


### 요청 암호화

빌드 요청 레코드는 터널 생성자가 생성하며 개별 홉으로 비대칭 암호화됩니다.
요청 레코드의 이 비대칭 암호화는 현재 [암호화]에서 정의된 대로 ElGamal이며 SHA-256 체크섬을 포함하고 있습니다. 이 설계는 포워드 시크릿이 아닙니다.

새 설계는 ECIES-X25519 임시-정적 DH와 HKDF, 및
ChaCha20/Poly1305 AEAD를 사용하여 포워드 시크릿, 무결성 및 인증을 제공합니다.
Alice는 터널 빌드 요청자입니다. 터널의 각 홉은 Bob입니다.


(페이로드 보안 속성)

  ```text

N:                      인증          기밀성
    -> e, es                  0                2

    인증: 없음 (0).
    이 페이로드는 활성 공격자를 포함한 모든 당사자에 의해 전송될 수 있습니다.

    기밀성: 2.
    알려진 수신자에게의 암호화, 보낸 사람의 타협을 위한 포워드 시크릿만,
    재생에 취약함. 이 페이로드는 수신자의 정적 키 쌍과 관련된 DH에
    기반하여 암호화됩니다. 수신자의 정적 개인 키가 손상되면, 심지어 나중에라도,
    이 페이로드를 복호화할 수 있습니다. 이 메시지도, 수신자로부터의
    임시 기여가 없기 때문에, 재생될 수 있습니다.

    "e": Alice는 새로운 임시 키 쌍을 생성하고 이를 e 변수에 저장하며,
         에페메럴 공개키를 메시지 버퍼에 명확한 텍스트로 기록하고,
         이전 h와 함께 공개키를 해싱하여 새로운 h를 유도합니다.

    "es": DH는 Alice의 임시 키 쌍과
          Bob의 정적 키 쌍 간의 수행됩니다. 결과는 이전 ck와 함께
          해싱되어 새로운 ck와 k를 유도하고, n은 0으로 설정됩니다.





  ```



### 응답 암호화

빌드 응답 레코드는 홉 생성자가 작성하고 생성자에게 대칭 암호화됩니다.
응답 레코드의 이 대칭 암호화는 현재 AES와 선행된 SHA-256 체크섬과
SHA-256 체크섬을 포함합니다. 이 설계는 포워드 시크릿이 아닙니다.

새 설계는 무결성과 인증을 위해 ChaCha20/Poly1305 AEAD를 사용할 것입니다.


### 정당화

요청에 있는 임시 공개 키는 AES 또는 Elligator2로 난독화될 필요가 없습니다.
이전 홉만 볼 수 있으며, 그 홉은 다음 홉이 ECIES임을 알고 있습니다.

응답 레코드는 다른 DH와 함께 전체 비대칭 암호화를 사용할 필요가 없습니다.



## 사양



### 빌드 요청 레코드

암호화된 BuildRequestRecords는 호환성을 위해 ElGamal 및 ECIES 모두에 대해 528 바이트입니다.


요청 레코드 비암호화 (ElGamal)
```````````````````````````````````````

참고로, 이것은 [I2NP](/en/docs/spec/i2np/)에서 가져온 ElGamal 라우터에 대한 터널 BuildRequestRecord의 현재 사양입니다.
비암호화된 데이터는 Encryption 전에 비영제로 시작하는 바이트 및 데이터의 SHA-256 해시로 선행됩니다.
[암호화]에서 정의된 대로 합니다.

모든 필드는 빅 엔디언입니다.

비암호화된 크기: 222 바이트

  ```dataspec


bytes     0-3: 터널 ID (메시지를 받기 위한), 비영제
  bytes    4-35: 로컬 라우터 아이덴티티 해시
  bytes   36-39: 다음 터널 ID, 비영제
  bytes   40-71: 다음 라우터 아이덴티티 해시
  bytes  72-103: AES-256 터널 레이어 키
  bytes 104-135: AES-256 터널 IV 키
  bytes 136-167: AES-256 응답 키
  bytes 168-183: AES-256 응답 IV
  byte      184: 플래그
  bytes 185-188: 요청 시간 (에포크 시작 이후의 시간, 아래로 반올림)
  bytes 189-192: 다음 메시지 ID
  bytes 193-221: 해석되지 않은 / 임의의 패딩




  ```


요청 레코드 암호화 (ElGamal)
`````````````````````````````````````

참고로, 이것은 [I2NP](/en/docs/spec/i2np/)에서 가져온 ElGamal 라우터에 대한 터널 BuildRequestRecord의 현재 사양입니다.

암호화된 크기: 528 바이트

  ```dataspec


bytes    0-15: 홉의 자동식별 해시
  bytes  16-528: ElGamal 암호화된 BuildRequestRecord




  ```




요청 레코드 비암호화 (ECIES)
```````````````````````````````````````

이것은 제안된 ECIES-X25519 라우터에 대한 터널 BuildRequestRecord의 사양입니다.
변경 사항 요약:

- 사용되지 않는 32바이트 라우터 해시 제거
- 요청 시간을 시간에서 분으로 변경
- 향후 사용을 위한 만료 필드 추가
- 플래그에 더 많은 공간 추가
- 추가 빌드 옵션을 위한 매핑 추가
- 홉의 자신의 응답 레코드에 대한 AES-256 응답 키 및 IV는 사용되지 않음
- 비암호화된 기록이 더 길어짐, 암호화 오버헤드가 적어서

요청 레코드는 어떤 ChaCha 응답 키도 포함하지 않습니다.
그 키들은 KDF에서 파생됩니다. 아래를 참조하십시오.

모든 필드는 빅 엔디언입니다.

비암호화된 크기: 464 바이트

  ```dataspec


bytes     0-3: 터널 ID (메시지를 받기 위한), 비영제
  bytes     4-7: 다음 터널 ID, 비영제
  bytes    8-39: 다음 라우터 아이덴티티 해시
  bytes   40-71: AES-256 터널 레이어 키
  bytes  72-103: AES-256 터널 IV 키
  bytes 104-135: AES-256 응답 키
  bytes 136-151: AES-256 응답 IV
  byte      152: 플래그
  bytes 153-155: 추가 플래그, 사용되지 않음, 호환성을 위해 0으로 설정
  bytes 156-159: 요청 시간 (에포크 시작 이후의 분, 아래로 반올림)
  bytes 160-163: 요청 만료 (생성 후의 초)
  bytes 164-167: 다음 메시지 ID
  bytes   168-x: 터널 빌드 옵션 (매핑)
  bytes     x-x: 플래그나 옵션에 의해 암시되는 기타 데이터
  bytes   x-463: 랜덤 패딩




  ```

플래그 필드는 [Tunnel-Creation](/en/docs/spec/tunnel-creation/)에서 정의된 것과 동일하며 다음을 포함합니다.::

비트 순서: 76543210 (비트 7은 MSB)
비트 7: 설정되어 있으면, 누구로부터의 메시지를 허용
비트 6: 설정되어 있으면, 누구에게나 메시지를 허용하고
        터널 빌드 응답 메시지에서 지정된 다음 홉에 응답을 보냄
비트 5-0: 정의되지 않음, 미래 옵션과의 호환성을 위해 0으로 설정해야 함

비트 7은 홉이 인바운드 게이트웨이 (IBGW)가 될 것임을 나타냅니다.  비트 6은 홉이 아웃바운드 엔드포인트 (OBEP)가 될 것임을 나타냅니다. 둘 다 동시에 설정될 수 없습니다.

요청 만료는 향후 변동 터널 기간을 위한 것입니다.
현재로서는 지원되는 유일한 값은 600 (10분)입니다.

터널 빌드 옵션은 [Common](/en/docs/spec/common-structures/)에서 정의된 매핑 구조입니다.
이는 향후 사용을 위한 것입니다. 현재 정의된 옵션은 없습니다.
매핑 구조가 비어 있는 경우, 이는 두 바이트 0x00 0x00입니다.
매핑의 최대 크기 (길이 필드 포함)는 296 바이트입니다,
매핑 길이 필드의 최대 값은 294입니다.



요청 레코드 암호화 (ECIES)
`````````````````````````````````````

모든 필드는 빅 엔디언입니다, 단 임시 공개 키는 리틀 엔디언입니다.

암호화된 크기: 528 바이트

  ```dataspec


bytes    0-15: 홉의 자동식별 해시
  bytes   16-47: 송신자의 임시 X25519 공개 키
  bytes  48-511: ChaCha20 암호화된 BuildRequestRecord
  bytes 512-527: Poly1305 MAC




  ```



### 빌드 응답 레코드

암호화된 BuildReplyRecords는 호환성을 위해 ElGamal 및 ECIES 모두에 대해 528 바이트입니다.


응답 레코드 비암호화 (ElGamal)
`````````````````````````````````````
ElGamal 응답은 AES로 암호화됩니다.

모든 필드는 빅 엔디언입니다.

비암호화된 크기: 528 바이트

  ```dataspec


bytes   0-31: SHA-256 해시 (바이트 32-527)
  bytes 32-526: 임의의 데이터
  byte     527: 응답

  총 길이: 528




  ```


응답 레코드 비암호화 (ECIES)
`````````````````````````````````````
이것은 제안된 ECIES-X25519 라우터에 대한 터널 BuildReplyRecord의 사양입니다.
변경 사항 요약:

- 빌드 응답 옵션에 대한 매핑 추가
- 비암호화된 레코드가 더 길어짐, 암호화 오버헤드가 적어서

ECIES 응답은 ChaCha20/Poly1305로 암호화됩니다.

모든 필드는 빅 엔디언입니다.

비암호화된 크기: 512 바이트

  ```dataspec


bytes    0-x: 터널 빌드 응답 옵션 (매핑)
  bytes    x-x: 옵션에 의해 암시되는 기타 데이터
  bytes  x-510: 임의의 패딩
  byte     511: 응답 바이트




  ```

터널 빌드 응답 옵션은 [Common](/en/docs/spec/common-structures/)에서 정의된 매핑 구조입니다.
이는 향후 사용을 위한 것입니다. 현재 정의된 옵션은 없습니다.
매핑 구조가 비어 있는 경우, 이는 두 바이트 0x00 0x00입니다.
매핑의 최대 크기 (길이 필드 포함)는 511 바이트입니다,
매핑 길이 필드의 최대 값은 509입니다.

응답 바이트는 다음 값 중 하나입니다
[Tunnel-Creation](/en/docs/spec/tunnel-creation/)에서 정의된 대로:

- 0x00 (수락)
- 30 (TUNNEL_REJECT_BANDWIDTH)


응답 레코드 암호화 (ECIES)
```````````````````````````````````

암호화된 크기: 528 바이트

  ```dataspec


bytes   0-511: ChaCha20 암호화된 BuildReplyRecord
  bytes 512-527: Poly1305 MAC




  ```

정식 ECIES 레코드로 완전히 전환된 후, 범위 패딩 규칙은 요청 레코드와 동일합니다.


### 기록 대칭 암호화

혼합 터널이 허용되며, ElGamal에서 ECIES로의 전환을 위해 필요합니다.
전환 기간 동안, 점점 더 많은 라우터가 ECIES 키로 연결될 것입니다.

대칭 암호화 전처리는 동일한 방식으로 실행됩니다:

- "암호화":

  - 암호는 복호화 모드로 실행
  - 전처리에서 요청 레코드가 사전 복호화됨 (암호화된 요청 레코드 숨김)

- "복호화":

  - 암호는 암호화 모드로 실행
  - 요청 레코드는 홉에 의해 암호화됨 (다음 평문 요청 레코드 드러남)

- ChaCha20는 "모드"가 없으므로 간단히 세 번 실행됩니다:

  - 전처리 중 한 번
  - 홉에 의해 한 번
  - 최종 응답 처리 시 한 번

혼합 터널이 사용될 때, 터널 생성자는 BuildRequestRecord의 대칭 암호화를 현재 및 이전 홉의 암호화 유형에 기반하여 실행해야 합니다.

각 홉은 VariableTunnelBuildMessage (VTBM)에서 자신의 암호화 유형을 사용하여 BuildReplyRecords 및 기타 레코드를 암호화합니다.

응답 경로에서는, 엔드포인트 (송신자)는 [다중 암호화](https://en.wikipedia.org/wiki/Multiple_encryption)를 사용하여 각 홉의 응답 키를 사용해 해독해야 합니다.

명확한 예를 들어보면, ECIES로 둘러싸인 ElGamal를 가진 아웃바운드 터널을 살펴보겠습니다:

- 송신자 (OBGW) -> ElGamal (H1) -> ECIES (H2) -> ElGamal (H3)

모든 BuildRequestRecords는 암호화된 상태 (ElGamal 또는 ECIES 사용)입니다.

AES256/CBC 암호는 여전히 각 레코드에 사용되며, 여러 레코드에 걸쳐 체인닝하지 않습니다.

동일하게, ChaCha20는 각 레코드를 암호화하는 데 사용될 것이며, 전체 VTBM을 스트리밍하지 않습니다.

요청 레코드는 송신자 (OBGW)에 의해 전처리됩니다:

- H3의 레코드는 다음을 사용하여 "암호화"됩니다:

  - H2의 응답 키 (ChaCha20)
  - H1의 응답 키 (AES256/CBC)

- H2의 레코드는 다음을 사용하여 "암호화"됩니다:

  - H1의 응답 키 (AES256/CBC)

- H1의 레코드는 대칭 암호화 없이 나감

단지 H2만 응답 암호화 플래그를 검사하고, 그 다음에 AES256/CBC가 이어질 것임을 봅니다.

각 홉에 의해 처리된 후, 레코드는 "복호화" 상태입니다:

- H3의 레코드는 다음을 사용하여 "복호화"됩니다:

  - H3의 응답 키 (AES256/CBC)

- H2의 레코드는 다음을 사용하여 "복호화"됩니다:

  - H3의 응답 키 (AES256/CBC)
  - H2의 응답 키 (ChaCha20-Poly1305)

- H1의 레코드는 다음을 사용하여 "복호화"됩니다:

  - H3의 응답 키 (AES256/CBC)
  - H2의 응답 키 (ChaCha20)
  - H1의 응답 키 (AES256/CBC)

터널 생성자, 즉 인바운드 엔드포인트 (IBEP)는 응답을 후처리합니다:

- H3의 레코드는 다음을 사용하여 "암호화"됩니다:

  - H3의 응답 키 (AES256/CBC)

- H2의 레코드는 다음을 사용하여 "암호화"됩니다:

  - H3의 응답 키 (AES256/CBC)
  - H2의 응답 키 (ChaCha20-Poly1305)

- H1의 레코드는 다음을 사용하여 "암호화"됩니다:

  - H3의 응답 키 (AES256/CBC)
  - H2의 응답 키 (ChaCha20)
  - H1의 응답 키 (AES256/CBC)


### 요청 레코드 키 (ECIES)

이러한 키는 ElGamal BuildRequestRecords에 명시적으로 포함됩니다.
ECIES BuildRequestRecords의 경우 터널 키와 AES 응답 키가 포함되지만 ChaCha 응답 키는 DH 교환에서 파생됩니다.
라우터 정적 ECIES 키의 세부사항은 [Prop156](/en/proposals/156-ecies-routers/)를 참조하십시오.

아래는 요청 레코드에 이전에 전송된 키를 어떻게 파생하는지에 대한 설명입니다.


초기 ck 및 h에 대한 KDF
````````````````````````

이는 표준 Noise 패턴 "N"에 대한 표준 프로토콜 이름입니다.

  ```text

이것은 "e" 메시지 패턴입니다:

  // 프로토콜 이름 정의
  프로토콜 이름 설정 = "Noise_N_25519_ChaChaPoly_SHA256"
  (31 바이트, US-ASCII 인코딩, NULL 종료 없음).

  // 해시 h = 32 바이트 정의
  // 32 바이트로 패딩. 이것은 32 바이트가 넘지 않기 때문에 해싱하지 마십시오.
  h = 프로토콜 이름 || 0

  체이닝 키 ck = 32 바이트 정의. h 데이터를 ck에 복사합니다.
  체인키 = h 설정

  // MixHash(null 서문)
  h = SHA256(h);

  // 여기까지는 모든 라우터가 선계산할 수 있습니다.




  ```


요청 레코드에 대한 KDF
````````````````````````

ElGamal 터널 생성자는 터널의 각 ECIES 홉에 대해 임시 X25519 키 쌍을 생성하고, 위의 방식을 사용하여 BuildRequestRecord를 암호화합니다.
ElGamal 터널 생성자는 ElGamal 홉을 암호화하기 위해 이 사양을 따를 것입니다.

ECIES 터널 생성자는 각 ElGamal 홉의 공개 키를 사용하여 [Tunnel-Creation](/en/docs/spec/tunnel-creation/)에서 정의된 방식으로 암호화해야 합니다. ECIES 터널 생성자는 ECIES 홉에 대한 암호화를 위해 위의 방식을 사용할 것입니다.

이는 터널 홉이 자신과 동일한 암호화 유형에서만 암호화된 레코드를 보게 됨을 의미합니다.

ElGamal 및 ECIES 터널 생성자는 ECIES 홉에 암호화하기 위해 홉당 고유의 임시 X25519 키 쌍을 생성할 것입니다.

**중요**:
임시 키는 ECIES 홉마다, 빌드 레코드마다 고유해야 합니다.
고유한 키를 사용하지 않으면 협력하는 홉이 동일한 터널에 있음을 확인할 수 있는 공격 벡터를 열게 됩니다.


  ```dataspec


// 각 홉의 X25519 정적 키 쌍 (hesk, hepk) 라우터 아이덴티티에서
  hesk = PRIVATE_GENERATE()
  hepk = PUBLIC_DERIVE(hesk)

  // MixHash(hepk)
  // || 아래는 추가를 의미합니다.
  h = SHA256(h || hepk);

  // 여기까지는 각 라우터가 선계산하고 올 수 있음
  // 모든 수신 빌드 요청에 대해

  // 송신자는 VTBM의 각 ECIES 홉에 대해 X25519 임시 키 쌍 생성 (sesk, sepk)
  sesk = PRIVATE_GENERATE()
  sepk = PUBLIC_DERIVE(sesk)

  // MixHash(sepk)
  h = SHA256(h || sepk);

  "e" 메시지 패턴 종료.

  이것은 "es" 메시지 패턴입니다:

  // Noise es
  // 송신자는 홉의 정적 공개키와 X25519 DH 실행.
  // 각 홉은 자신과 같은 자동으로 식별된 해시 레코드를 찾아서,
  // 암호화된 기록 앞의 송신자의 임시키를 추출합니다.
  유도된 비밀 = DH(sesk, hepk) = DH(hesk, sepk)

  // MixKey(DH())
  //[체인키, k] = MixKey(유도된 비밀)
  // ChaChaPoly를 암호화/복호화할 파라미터
  키데이터 = HKDF(체인키, 유도된 비밀, "", 64)
  // 응답 레코드 KDF에 저장
  체인키 = 키데이터[0:31]

  // AEAD 파라미터
  k = 키데이터[32:63]
  n = 0
  평문 = 464 바이트 빌드 요청 레코드
  ad = h
  암호문 = ENCRYPT(k, n, 평문, ad)

  "es" 메시지 패턴 종료.

  // MixHash(ciphertext)
  // 응답 레코드 KDF에 저장
  h = SHA256(h || 암호문)





  ```

``응답키``, ``레이어키`` 및 ``레이어IV``는 여전히 ElGamal 레코드에 포함되어야 하며,
무작위로 생성될 수 있습니다.


### 요청 레코드 암호화 (ElGamal)

[Tunnel-Creation](/en/docs/spec/tunnel-creation/)에서 정의된 대로.
ElGamal 홉에 대한 암호화에는 변경 사항이 없습니다.




### 응답 레코드 암호화 (ECIES)

응답 레코드는 ChaCha20/Poly1305로 암호화됩니다.

  ```dataspec


// AEAD 파라미터
  k = 빌드 요청에서 체인키
  n = 0
  평문 = 512 바이트 빌드 응답 레코드
  ad = 빌드 요청에서 h

  암호문 = ENCRYPT(k, n, 평문, ad)




  ```



### 응답 레코드 암호화 (ElGamal)

[Tunnel-Creation](/en/docs/spec/tunnel-creation/)에서 정의된 대로.
ElGamal 홉에 대한 암호화에는 변경 사항이 없습니다.



### 보안 분석

ElGamal은 터널 빌드 메시지에 대한 포워드 시크릿을 제공하지 않습니다.

AES256/CBC는 약간 더 나은 상태에 있으며, 알려진 평문 'biclique' 공격의 이론적인 약화에만 취약합니다.

AES256/CBC에 대한 알려진 실질적인 공격 중 하나는 공격자가 IV를 알고 있을 때의 패딩 오라클 공격입니다.

공격자는 다음 홉의 ElGamal 암호화를 깨야 AES256/CBC 키 정보 (응답 키 및 IV)를 얻을 수 있습니다.

ElGamal은 ECIES보다 상당히 더 많은 CPU를 소모하는데, 이는 자원 고갈의 잠재적 위험을 초래합니다.

ECIES는 각 BuildRequestRecord 또는 VariableTunnelBuildMessage에 대해 새로운 일회용 키를 사용하여 포워드 시크릿을 제공합니다.

ChaCha20Poly1305는 AEAD 암호화를 제공하며, 수신자가 복호화를 시도하기 전에 메시지 무결성을 확인할 수 있게 합니다.


## 정당화

이 설계는 기존 암호화 프리미티브, 프로토콜 및 코드를 최대한 재사용합니다.
또한 이 설계는 위험을 최소화합니다.




## 구현 노트

* 구형 라우터는 홉의 암호화 유형을 검사하지 않으며 ElGamal로 암호화된 레코드를 보낼 것입니다.
  일부 최근 라우터는 버그가 있으며 다양한 유형의 잘못된 레코드를 보낼 것입니다.
  구현자는 가능하다면 DH 작업 전에 이러한 레코드를 감지하고 거부하여 CPU 사용량을 줄여야 합니다.


## 문제점



## 마이그레이션

[Prop156](/en/proposals/156-ecies-routers/)를 참조하십시오.



