---
title: "새로운 netDB 항목"
number: "123"
author: "zzz, str4d, original"
created: "2016-01-16"
lastupdated: "2020-07-18"
status: "Open"
thread: "http://zzz.i2p/topics/2051"
supercedes: "110, 120, 121, 122"
---

## 상태

이 제안의 일부는 완료되어 0.9.38 및 0.9.39에 구현되었습니다.
공통 구조, I2CP, I2NP 및 기타 사양은
현재 지원되는 변경 사항을 반영하도록 업데이트되었습니다.

완료된 부분은 여전히 ​​약간의 수정이 필요할 수 있습니다.
이 제안의 다른 부분은 여전히 개발 중이며 
상당한 수정의 대상이 될 수 있습니다.

서비스 조회(유형 9 및 11)는 낮은 우선순위이며
일정에 포함되어 있지 않으며 별도의 제안으로 분리될 수 있습니다.


## 개요

다음 4가지 제안의 업데이트 및 통합입니다:

- 110 LS2
- 120 대규모 멀티호밍용 메타 LS2
- 121 암호화된 LS2
- 122 인증되지 않은 서비스 조회(애니캐스팅)

이 제안들은 대체로 독립적이지만, 여러 제안에서
공통 형식을 정의하고 사용하여 합리적인 사고를 유지합니다.

다음 제안은 약간 관련이 있습니다:

- 140 보이지 않는 멀티호밍(이 제안서와 호환되지 않음)
- 142 새로운 암호 템플릿(새로운 대칭 암호용)
- 144 ECIES-X25519-AEAD 및 Ratchet
- 145 ECIES-P256
- 146 Red25519
- 148 EdDSA-BLAKE2b-Ed25519
- 149 암호화된 LS2용 B32
- 150 Garlic Farm 프로토콜
- 151 ECDSA 블라인딩


## 제안

이 제안서는 5개의 새로운 DatabaseEntry 유형과 
이를 네트워크 데이터베이스에 저장하고 검색하는 과정,
그리고 이들을 서명하고 그 서명을 검증하는 방법을 정의합니다.

### 목표

- 하위 호환성 유지
- LS2를 구형 멀티호밍에서 사용 가능하게 만들기
- 지원에 새로운 암호화나 원시 데이터 필요 없음
- 암호화 및 서명을 분리 유지; 모든 현재 및 미래 버전 지원
- 선택적 오프라인 서명 키 지원
- 지문 식별 방지를 위해 타임스탬프 정확도 감소
- 목적지에 새로운 암호화 지원
- 대규모 멀티호밍 가능
- 기존 암호화된 LS의 여러 문제 해결
- 플러드필에 의한 가시성 감소를 위한 선택적 블라인딩
- 단일 키 및 다중 사용 가능한 키 모두를 지원하는 암호화
- 출프록시, 응용 프로그램 DHT 부트스트랩 및 기타 사용의 용이한 조회를 위한 서비스 조회
- 32 바이트 이진 목적지 해시를 의존하는 것을 손상시키지 않음, 예: 비트토렌트
- routerinfos에 있는 것처럼 속성을 통해 leasesets에 유연성 추가
- 게시된 타임스탬프와 가변 만료를 헤더에 삽입하여, 내용이 암호화된 경우에도 작동하도록 함 (가장 이른 리스에서 타임스탬프 파생하지 않음)
- 모든 새로운 유형은 동일한 DHT 공간과 기존 리스셋과 동일한 위치에 살아가므로, 사용자는 기존 LS에서 LS2로,
  또는 LS2, 메타, 암호화된 세 가지 중에 변경할 수 있으며, 
  목적지나 해시를 변경하지 않아도 됨
- 기존 목적지는 오프라인 키 사용으로 전환할 수 있으며,
  목적지나 해시를 변경하지 않고 온라인 키로 되돌릴 수 있음


### 비목표 / 범위 외

- 새로운 DHT 회전 알고리즘 또는 공유 무작위 생성
- 새로운 암호화 유형 및 해당 새로운 유형을 사용하는 종단 간 암호화 스키마
  는 별도의 제안에 포함될 것입니다. 여기서 새로운 암호화는 지정되거나 논의되지 않습니다.
- RIs 또는 터널 빌딩에 대한 새로운 암호화. 별도의 제안에 포함됩니다.
- I2NP DLM / DSM / DSRM 메시지의 암호화, 전송 및 수신 방법. 변경되지 않음.
- 백엔드 라우터 간 통신, 관리, 장애 조치 및 조정을 포함한 메타 생성 및 지원 방법.
  I2CP, 또는 i2pcontrol, 또는 새로운 프로토콜에 추가될 수 있음.
  표준화될 수도 있고 아닐 수도 있음.
- 실제로 더 긴 만료 터널을 구현하고 관리하는 방법, 또는 기존 터널을 취소하는 방법.
  이는 매우 어렵고, 이를 수행하지 않으면 합리적인 우아한 종료를 가질 수 없음.
- 위협 모델 변경
- 오프라인 저장 형식, 또는 데이터를 저장/검색/공유하는 방법.
- 구현 세부 사항은 여기서 논의되지 않으며 각 프로젝트에 맡김.



### 정당화

LS2는 암호화 유형을 변경하고 미래 프로토콜 변경에 대한 필드를 추가합니다.

암호화된 LS2는 전체 리스 세트를 비대칭 암호화를 사용하여 기존의 암호화된 LS의 여러 보안 문제를 수정합니다.

Meta LS2는 유연하고, 효율적이며, 효과적이고 대규모 멀티호밍을 제공합니다.

서비스 기록 및 서비스 목록은 이름 조회 및 DHT 부트스트래핑과 같은 애니캐스트 서비스를 제공합니다.


### NetDB 데이터 유형

유형 번호는 I2NP 데이터베이스 조회/저장 메시지에서 사용됩니다.

종단 간 열은 쿼리/응답이 Garlic 메시지의 목적지로 전송되는지를 나타냅니다.


기존 유형:

            NetDB 데이터              조회 유형     저장 유형 
any                                       0           any     
LS                                        1            1      
RI                                        2            0      
탐색적                                    3           DSRM    

새 유형:

            NetDB 데이터              조회 유형     저장 유형   표준 LS2 헤더 있음? 종단 간 전송됨?
LS2                                       1            3             예                  예
암호화된 LS2                              1            5             아니오                아니오
Meta LS2                                  1            7             예                  아니오
서비스 기록                              n/a           9             예                  아니오
서비스 목록                              4           11             아니오                아니오



Notes
`````
- 조회 유형은 현재 데이터베이스 조회 메시지에서 비트 3-2에 있습니다.
  추가 유형이 필요하면 비트 4의 사용이 필요합니다.

- 모든 저장 유형은 데이터베이스 저장 메시지 유형 필드의 상위 비트가
  이전 라우터에 무시되기 때문에 홀수입니다.
  LS로 파싱이 실패하는 것보다 압축된 RI로 파싱이 실패하는 것이 더 낫습니다.

- 유형을 데이터에 포함된 서명으로 커버할 때 명시적으로 또는 암시적으로 해야 합니까?



### 조회/저장 프로세스

유형 3, 5 및 7은 표준 리스셋 조회(TYPE 1) 응답으로 반환될 수 있습니다.
유형 9는 조회에 응답하여 절대 반환되지 않습니다.
타입 11은 새로운 서비스 조회 타입(타입 11)에 대한 응답으로 반환됩니다.

오직 TYPE 3만 클라이언트-투-클라이언트 Garlic 메시지에서 전송될 수 있습니다.



### 형식

유형 3, 7, 9는 모두 공통 형식을 가지고 있습니다.::

  표준 LS2 헤더
  - 아래에 정의된 대로

  유형별 부분
  - 각 부분에 아래에 정의된 대로

  표준 LS2 서명:
  - 서명 키의 sig 유형이 암시한 길이

타입 5(암호화됨)은 목적지로 시작하지 않으며
다른 형식을 가집니다. 아래를 참조하십시오.

타입 11(서비스 목록)은 여러 서비스 기록의 집합이며
형식이 다릅니다. 아래를 참조하십시오.


### 개인정보 / 보안 고려 사항

TBD



## 표준 LS2 헤더

타입 3, 7, 9는 아래에 지정된 표준 LS2 헤더를 사용합니다:


### 형식
::

  표준 LS2 헤더:
  - 유형 (1 바이트)
    실제로 헤더에 있는 것이 아니라, 서명으로 커버된 데이터의 일부입니다.
    데이터베이스 저장 메시지에서 필드를 가져옵니다.
  - 목적지 (387+ 바이트)
  - 발행된 타임스탬프 (4 바이트, big endian, 초로 표시, 2106년에 롤오버)
  - 만료일 (2 바이트, big endian) (발행된 타임스탬프에서 초의 오프셋, 최대 18.2시간)
  - 플래그 (2 바이트)
    비트 순서: 15 14 ... 3 2 1 0
    비트 0: 0인 경우, 오프라인 키 없음; 1인 경우, 오프라인 키 있음
    비트 1: 0인 경우, 표준 발행된 리스셋.
           1인 경우, 발행 또는 쿼리에 대한 응답으로 보내지 말아야 할 비작성된 리스셋입니다. 이 리스셋이 만료되면, bit 2가 설정되지 않는 한 netdb에 새 것을 쿼리하지 마십시오.
    비트 2: 0인 경우, 표준 발행된 리스셋.
           1인 경우, 이 암호화되지 않은 리스셋은 게시될 때 블라인드되고 암호화됩니다. 이 리스셋이 만료되면 netdb의 블라인딩된 위치에서 새 것을 쿼리합니다. 이 비트가 1로 설정되면 비트 1도 1로 설정하십시오. 릴리스 0.9.42부터.
    비트 3-15: 호환성을 위해 0으로 설정합니다.
  - 플래그가 오프라인 키를 나타내는 경우, 오프라인 서명 섹션:
    만료 타임스탬프 (4 바이트, big endian, 초로 표시, 2106년에 롤오버)
    Transient sig 유형 (2 바이트, big endian)
    Transient 서명 공개 키 (sig 유형이 암시하는 길이)
    만료 타임스탬프, transient sig 유형 및 공개 키에 대한 서명,
    목적지 공개 키로 서명합니다,
    목적지 공개 키 sig 유형이 암시하는 길이로 서명합니다.
    이 섹션은 오프라인으로 생성될 수 있으며 생성되어야 합니다.


정당화
`````````````

- 비작성/작성: 데이터베이스를 통해 엔드-투-엔드로 전송할 때,
  송신 라우터는 이 리스셋이 다른 사람들에게 전송되지 않아야 함을 나타내고자 할 수 있습니다. 우리는 현재 이 상태를 유지하기 위해 휴리스틱을 사용합니다.

- 작성: 리스셋의 '버전'을 결정하는 복잡한 논리를 대체합니다.
  현재, 버전은 최장 만료 리스의 만료입니다.
  발행 라우터는 만료만 제거되는 리스셋을 발행할 때 최소 1ms 이상 만료를 증가시켜야 합니다.

- 만료일: netdb 항목의 만료가
  마지막 만료 리스의 만료보다 일찍 일어나도록 허용합니다. 
  예상되는 11분 최대 만료를 유지할 LS2에는 유용하지 않을 수 있지만,
  다른 새 유형에는 필요합니다 (아래 Meta LS 및 서비스 기록 참조).

- 오프라인 키는 초기/필수 구현 복잡성을 줄이기 위해 선택적으로 제공됩니다.


### 이슈

- 타임스탬프 정확도를 더 줄이는 것 (10분?)도 가능하지만, 버전 번호를 추가해야 합니다. 
  멀티호밍을 해치지 않으려면 주문 보존 암호화가 필요할 것입니다.
  아마도 타임스탬프 없이 할 수 없을 것입니다.

- 대안: 3바이트 타임스탬프 (10분 단위의 epoch), 1바이트 버전, 2바이트 만료

- 데이터/서명에 명시적 또는 암시적으로 유형이 있는가? 서명용 "도메인" 상수?


Notes
`````

- 라우터는 LS를 1초에 한 번 이상 게시하지 않아야 합니다.
  만일 그렇게 하면, 이전에 게시된 LS보다 1 증가된 발행된 타임스탬프를 인위적으로 증가시켜야 합니다.

- 라우터 구현은 일시적인 키와 서명을 캐시하여
  매번 검증을 피할 수 있습니다. 특히 플러드필, 그리고
  장기 연결의 양단에 있는 라우터는 이점이 있을 수 있습니다.

- 오프라인 키와 서명은
  장기 목적지, 즉 서버에만 적합하며, 클라이언트에는 적합하지 않습니다.



## 새로운 DatabaseEntry 유형


### LeaseSet 2

기존 LeaseSet에서의 변화:

- 발행된 타임스탬프, 만료 타임스탬프, 플래그, 속성 추가
- 암호화 유형 추가
- 철회 키 제거

조회 위치:
    표준 LS 플래그 (1)
저장 유형:
    표준 LS2 유형 (3)
저장 위치:
    목적지의 해시
    이 해시는 이후 LS1의 일일 "라우팅 키"를 생성하는 데 사용됩니다.
일반적인 만료
    일반 LS와 마찬가지로 10분입니다.
게시자:
    목적지

형식
``````
::

  위에서 지정한 표준 LS2 헤더 사용

  표준 LS2 유형별 부분
  - 속성(공통 구조 사양에 지정된 대로 매핑, 없을 경우 2개의 0 바이트)
  - 뒤따를 키 세션 수 (1 바이트, 최대 TBD)
  - 키 세션:
    - 암호화 유형 (2 바이트, big endian)
    - 암호화 키 길이 (2 바이트, big endian)
      명시적이므로 플러드필은 알 수 없는 암호화 유형의 LS2를 구문 분석할 수 있습니다.
    - 암호화 키 (명시된 바이트 수)
  - lease2의 수 (1 바이트)
  - lease2 (각각 40 바이트)
    이것들은 리스이지만, 만료 기간이 8바이트 대신 4바이트입니다.
    epoch 이후의 초수(2106년에 롤오버)

  표준 LS2 서명:
  - 서명
    만약 플래그가 오프라인 키를 나타내면, 이는 임시 공개키로 서명되고,
    그렇지 않으면, 목적지 공개키로 서명됩니다.
    서명 키의 sig 유형이 암시하는 길이.
    위의 모든 것에 대한 서명을 포함합니다.




정당화
`````````````

- 속성: 향후 확장 및 유연성을 위한 것.
  필요한 경우 나머지 데이터를 구문 분석하는 용도로 맨 위 배치.

- 여러 암호화 유형/공개키 쌍은
  새로운 암호화 유형으로의 전환을 용이하게 합니다. 다른 방법은
  여러 리스셋을 발행하는 것인데, 이는 동일한 터널을 사용할 수 있습니다.
  터널에서 들어오는 암호화 유형의 식별
  기존 세션 태그 메커니즘으로 수행할 수 있으며,
  각 키 또는 길이의 시도 복호화로 수행할 수 있습니다.
  들어오는 메시지의 길이도 단서를 제공할 수 있습니다.

논의
``````````

이 제안은 목적지의
종단 간 암호화 키를 위한 리스셋의 공개 키를 계속 사용하며,
목적지의 공개 키 필드는 사용되지 않습니다.
암호화 유형은 목적지 키 인증서에 지정되지 않으며, 0으로 유지됩니다.

거부된 대안은
목적지 키 인증서에 암호화 유형을 지정하고,
리스셋의 공개키를 사용하지 않고,
목적지에서 공개키를 사용하는 것입니다. 우리는 이것을 계획하지 않습니다.

LS2의 이점:

- 실제 공개키 위치는 변경되지 않음.
- 암호화 유형 또는 공개키는 목적지를 변경하지 않고 변경될 수 있음.
- 사용되지 않는 철회 필드 제거
- 이 제안의 다른 DatabaseEntry 유형과의 기본 호환성
- 여러 암호화 유형 허용

LS2의 단점:

- 공개키와 암호화 유형의 위치가 RouterInfo와 다름
- 리스셋에서 사용되지 않는 공개키 유지
- 네트워크 전체의 구현 필요; 대신 실험적인 암호화 유형이 사용될 수 있음,
  (하지만 실험적인 sig 유형 지원 대한 관련 제안 136 및 137 참조).
  대체 제안은 실험적인 암호화 유형의 구현 및 테스트를 위해 더 쉽습니다.


새로운 암호화 문제
````````````````````
이 중 일부는 이 제안의 범위를 벗어납니다,
하지만 우리는 아직 별도의 암호화 제안이 없기 때문에
여기에 노트를 남깁니다.
또한 ECIES 제안 144와 145를 참조하십시오.

- 암호화 유형은 곡선, 키 길이, 및 종단 간 스키마의 조합을 나타냅니다,
  사용되는 KDF 및 MAC을 포함하여.

- 우리는 키 길이 필드를 포함했습니다, 그래서 LS2는
  암호화 유형이 알려지지 않은 경우에도 플러드필이
  구문 분석하고 검증할 수 있습니다.

- 제안될 새로운 암호화 유형의 첫 번째 것은 아마도
  ECIES/X25519일 것입니다. 그것이 어떻게 종단 간 사용되는지(Either
  ElGamal/AES+SessionTag의 약간 수정된 버전
  또는 전혀 새로운 것, 예: ChaCha/Poly)는 하나 이상의
  별도의 제안에서 지정될 것입니다.
  또한 ECIES 제안 144와 145를 참조하십시오.


Notes
`````
- 리스에서 8 바이트 만료가 4 바이트로 변경됨.

- 만약 철회를 구현해야 한다면, 이것은 만료 필드가 0인 것,
  또는 0 리스 또는 둘 다로 할 수 있습니다. 별도의 철회 키가 필요하지 않습니다.

- 암호화 키는 서버 선호도의 순서대로,
  가장 선호하는 것을 먼저 표시합니다.
  기본 클라이언트 동작은
  지원되는 암호화 유형을 가진 첫 번째 키를 선택하는 것입니다.
  클라이언트는 암호화 지원, 상대적 성능 및 기타
  요소를 기반으로 다른 선택 알고리즘을 사용할 수 있습니다.


### 암호화된 LS2

목표:

- 블라인딩 추가
- 여러 sig 유형 허용
- 새로운 암호화 기본 요소 필요 없음
- 각 수신자에게 선택적으로, 취소 가능하게 암호화
- 표준 LS2 및 Meta LS2만 암호화 지원

암호화된 LS2는 절대 엔드-투-엔드 garlic 메시지로 전송되지 않습니다.
위에서 설명한 표준 LS2를 사용합니다.


기존 암호화된 LeaseSet의 변경 사항:

- 보안을 위해 전체를 암호화합니다.
- 오직 AES로 암호화하지 않고 안전하게 암호화합니다.
- 각 수신자에게 암호화합니다.

조회 위치:
   표준 LS 플래그 (1)
저장 유형:
   암호화된 LS2 유형 (5)
저장 위치:
   블라인딩된 sig 유형 및 블라인딩된 공개 키의 해시
   두 바이트 sig 유형 (big endian, 예: 0x000b) || 블라인딩된 공개 키
   이 해시는 이후 LS1의 일일 라우팅 키 생성에 사용됩니다.
일반적인 만료
   일반 LS와 마찬가지로 10분, 또는 메타 LS의 경우 시간 단위.
게시자:
   목적지


정의
```````````
다음 Encrypted LS2에 사용되는 암호화 구성 요소에 해당하는 기능을 정의합니다:

CSRNG(n)
    암호학적으로 안전한 난수 생성기에서 n 바이트의 출력을 생성합니다.

    CSRNG가 암호학적으로 안전해야 하며(따라서 키 자료 생성에 적합),
    n바이트 출력이 네트워크에 노출된 바이트 시퀀스(소금 또는 암호화 패딩)일 때 키 자료로 사용할 수 있어야 합니다. 신뢰할 수 없는 소스를 사용하는 경우 노출될 네트워크 출력은 해시해야 합니다[PRNG-REFS]_.

H(p, d)
    개인화 문자열 p와 데이터 d를 받는 SHA-256 해시 함수로,
    32바이트 길이의 출력을 생성합니다.

    SHA-256을 다음과 같이 사용합니다::

        H(p, d) := SHA-256(p || d)

STREAM
    [RFC-7539-S2.4]_에서 지정한 ChaCha20 스트림 암호이며, 초기 카운터는 1로 설정됩니다. S_KEY_LEN = 32 및 S_IV_LEN = 12입니다.

    ENCRYPT(k, iv, plaintext)
        암호 키 k와 고유해야 하는 nonce iv를 사용하여 평문을 암호화합니다. 평문과 동일한 크기의 암호문을 반환합니다.

        키가 비밀일 경우 전체 암호문은 랜덤과 구별할 수 없어야 합니다.

    DECRYPT(k, iv, ciphertext)
        암호 키 k와 nonce iv를 사용하여 암호문을 복호화합니다. 평문을 반환합니다.


SIG
    개인화 서명 공간의 RedDSA 서명 체계(sig 유형 11에 해당)입니다.
    다음 기능이 있습니다:

    DERIVE_PUBLIC(privkey)
        주어진 개인 키에 대응하는 공개 키를 반환합니다.

    SIGN(privkey, m)
        주어진 메시지 m에 대해 개인 키 privkey에 의해 서명을 반환합니다.

    VERIFY(pubkey, m, sig)
        주어진 공개 키 pubkey와 메시지 m에 대하여 서명 sig를 검증합니다. 서명이 유효하면 true, 그렇지 않으면 false를 반환합니다.

    또한 다음 키 블라인딩 작업을 지원해야 합니다:

    GENERATE_ALPHA(data, secret)
        데이터를 알고 있는 사람들과 선택적 비밀을 알고 있는 사람들에 대한 알파를 생성합니다.
        결과는 개인 키와 동일한 분포여야 합니다.

    BLIND_PRIVKEY(privkey, alpha)
        비밀 알파를 사용하여 개인 키를 블라인드합니다.

    BLIND_PUBKEY(pubkey, alpha)
        비밀 알파를 사용하여 공개 키를 블라인드합니다.
        주어진 키 쌍(privkey, pubkey)에 대해 다음 관계가 유지되어야 합니다::

            BLIND_PUBKEY(pubkey, alpha) ==
            DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha))

DH
    X25519 공개 키 협상 시스템입니다. 개인 키는 32바이트, 공개 키는 32바이트이며, 32바이트의 출력을 생성합니다.
    다음 기능이 있습니다:

    GENERATE_PRIVATE()
        새 개인 키를 생성합니다.

    DERIVE_PUBLIC(privkey)
        주어진 개인 키에 대한 공개 키를 반환합니다.

    DH(privkey, pubkey)
        주어진 개인 및 공개 키로부터 공유 비밀을 생성합니다.

HKDF(salt, ikm, info, n)
    특정 입력 키 자료(주어진 입력 키 자료 ikm에 대해 암호화된 키 도출 함수)를 수신합니다(이것은 좋은 엔트로피를 가지고 있지만 균일한 랜덤 문자열일 필요는 없음), 길이 32바이트의 소금, 그리고 컨텍스트별 '정보' 값, 그리고 n 바이트의 출력을 생성하며 이는 키 자료로 사용하기 적합합니다.

    HMAC 해시 함수 SHA-256을 사용하여 지정된 대로 [RFC-5869]_에 있는 HKDF를 사용합니다. 이 말은 SALT_LEN이 최다 32바이트임을 의미합니다.


형식
``````
Encrypted LS2 형식은 세 가지 중첩 레이어로 구성되어 있습니다:

- 저장 및 검색에 필요한 평문 정보를 포함하는 외부 레이어.
- 클라이언트 인증을 처리하는 중간 레이어.
- 실제 LS2 데이터를 포함하는 내부 레이어.

전체 형식은 다음과 같이 보입니다::

    Layer 0 데이터 + Enc(layer 1 데이터 + Enc(layer 2 데이터)) + Signature

암호화된 LS2는 블라인딩됩니다. 표제에는 목적지가 없습니다.
DHT 저장 위치는 SHA-256(sig 유형 || 블라인딩된 공개 키)이며, 매일 회전합니다.

여기서 지정한 표준 LS2 헤더를 사용하지 않습니다.

#### Layer 0 (외부)
Type
    1 바이트

    실제로 헤더에 있는 것이 아니라, 서명으로 커버된 데이터의 일부입니다.
    데이터베이스 저장 메시지의 필드에서 가져옵니다.

블라인딩된 공개 키 Sig 유형
    2 바이트, big endian
    이는 항상 Red25519 블라인딩된 키를 식별하는 유형 11입니다.

블라인딩된 공개 키
    sig 유형이 암시한 길이

게시된 타임스탬프
    4 바이트, big endian

    epoch 이후의 초, 2106년에 롤오버

만료
    2 바이트, big endian

    발행된 타임스탬프로부터 초 단위의 오프셋, 최대 18.2시간

플래그
    2 바이트

    비트 순서: 15 14 ... 3 2 1 0

    비트 0: 0인 경우, 오프라인 키 없음; 1인 경우, 오프라인 키 있음

    다른 비트: 향후 사용 호환성을 위해 0으로 설정

일시적인 키 데이터
    플래그가 오프라인 키를 나타내는 경우에 있다면

    만료 타임스탬프
        4 바이트, big endian

        epoch 이후의 초, 2106년에 롤오버

    일시적인 서명 유형
        2 바이트, big endian

    일시적인 서명 공개 키
        sig 유형이 암시한 길이

    서명
        블라인딩된 공개 키 유형으로 암시된 길이

        만료 타임스탬프, 일시적인 서명 유형 및 일시적인 공개 키에 대한 서명입니다.

        블라인딩된 공개 키로 검증합니다.

lenOuterCiphertext
    2 바이트, big endian

outerCiphertext
    lenOuterCiphertext 바이트

    암호화된 layer 1 데이터. 키 도출 및 암호화 알고리즘은 아래를 참조하십시오.

서명
    사용된 서명 키의 sig 유형이 암시하는 길이

    위의 모든 것에 대한 서명입니다.

    만약 플래그가 오프라인 키를 나타내면, 서명은 일시적인 공개 키로 검증됩니다.
    그렇지 않으면, 서명은 블라인딩된 공개 키로 검증됩니다.


#### Layer 1 (중간)
Flags
    1 byte
    
    비트 순서: 76543210

    비트 0: 모든 사람에 대해서는 0, 클라이언트별일 경우 인증 섹션에 따라 1

    비트 3-1: 인증 스킴, 클라이언트별인 경우에만 해당, 그렇지 않으면 000
              000: DH 클라이언트 인증(또는 클라이언트별 인증 없음)
              001: PSK 클라이언트 인증

    비트 7-4: 미사용, 향후 호환성을 위해 0으로 설정

DH 클라이언트 인증 데이터
    플래그 비트 0이 1로 설정되고 플래그 비트 3-1이 000으로 설정된 경우에 있다면.

    ephemeralPublicKey
        32 바이트

    클라이언트 수
        2 바이트, big endian

        인증 클라이언트 항목이 뒤따릅니다, 각각 40 바이트

    인증 클라이언트
        단일 클라이언트에 대한 인증 데이터입니다.
        클라이언트별 인증 알고리즘에 대한 참조는 아래를 참조하세요.

        clientID_i
            8 바이트

        clientCookie_i
            32 바이트

PSK 클라이언트 인증 데이터
    플래그 비트 0이 1로 설정되고 플래그 비트 3-1이 001로 설정된 경우에 있다면.

    authSalt
        32 바이트

    클라이언트 수
        2 바이트, big endian

        인증 클라이언트 항목의 수, 각각 40 바이트

    인증 클라이언트
        클라이언트별 인증 데이터입니다.
        클라이언트별 인증 알고리즘에 대한 참조는 아래를 참조하십시오.

        clientID_i
            8 바이트

        clientCookie_i
            32 바이트

innerCiphertext
    lenOuterCiphertext가 암시하는 길이(남아 있는 데이터 전체)

    암호화된 레이어 2 데이터. 키 도출 및 암호화 알고리즘은 아래를 참조하십시오.


#### Layer 2 (내부)
Type
    1 바이트

    3(LS2) 또는 7(Meta LS2)

Data
    LeaseSet2 데이터입니다.

    헤더와 서명을 포함합니다.


블라인딩 키 도출
```````````````````````

Ed25519 및 ZCash RedDSA [ZCASH]_를 기반으로 한 블라인딩 키 도출 스키마를 사용합니다.
Re25519 서명은 Ed25519 곡선 위에서 진행되며, 해시에 대해 SHA-512를 사용합니다.

우리는 Tor의 rend-spec-v3.txt 부록 A.2 [TOR-REND-SPEC-V3]_을 사용하지 않습니다.
유사한 설계 목적을 가지고 있지만,
블라인딩된 공개 키는 프라임 순서 하위 그룹을 벗어날 수 있습니다. 이는 보안적 의미가 명확하지 않습니다.


#### 목표

- 비블라인딩된 목적지에서 Ed25519 (sig 유형 7) 또는 Red25519 (sig 유형 11)의 서명 공개 키이며,
  다른 sig 유형은 지원되지 않습니다
- 서명 공개 키가 오프라인인 경우, 임시 서명 공개 키도 Ed25519이어야 합니다
- 블라인딩은 계산적으로 간단합니다
- 기존 암호화 구성 요소를 사용합니다
- 블라인딩된 공개 키는 비블라인딩될 수 없습니다
- 블라인딩된 공개 키는 Ed25519 곡선 및 프라임 순서 하위 그룹에 있어야 합니다
- 목적지의 서명 공개 키를
  알아야 블라인딩된 공개 키를 도출할 수 있습니다
  (전체 목적지는 필요 없음)
- 블라인딩된 공개 키를 도출하는 데 필요한 추가 비밀을 선택적으로 제공합니다


#### 보안

블라인딩 스키마의 보안은
알파의 분포가 비블라인딩된 개인 키와 동일해야 합니다.
그러나 Ed25519 개인 키(sig 유형 7)를 Red25519 개인 키(sig 유형 11)로 블라인딩할 때,
분포는 다릅니다.
zcash 섹션 4.1.6.1[ZCASH]_의 요구 사항을 충족하기 위해,
Red25519(sig 유형 11)도 비블라인딩된 키와 의해 발생되어야 하므로,
"재랜덤화된 공개 키와 그 아래의 서명이
  그로부터 재랜덤화된 키를 공개하지 않습니다."
우리는 암호화될 목적지에 대해 비블라인딩된 키로 7 유형을 허용하지만 새로운 선택지로는 11 유형을 권장합니다.



#### 정의

B
    Ed25519 기반 점(생성기) 
2^255 - 19 [ED25519-REFS]_

L
    Ed25519 순서 2^252 + 27742317777372353535851937790883648493
    [ED25519-REFS]_

DERIVE_PUBLIC(a)
    개인 키를 공개 키로 변환, Ed25519와 동일(점수 곱셈)

alpha
    목적지를 알고 있는 사람과 선택적인 암호를 알고 있는 사람들이
    가지고 있는 32바이트 랜덤한 숫자입니다.
```
```text
buck converter for level shifters
````

GENERATE_ALPHA(destination, date, secret)
    현재 날짜에 대한 알파를 생성하며, 목적지와 비밀을 알고 있는 사람들이 가능합니다.
    그 결과는 Ed25519 개인 키와 균일하게 분포되어야 합니다.

a
    서명하기 위해 사용되는 비블라인딩된 32바이트 EdDSA 또는 RedDSA 개인 키

A
    Ed25519와 동일하게, 목적지에서 서명에 사용되는 32바이트의 비블라인딩된 EdDSA 또는 RedDSA 공개 키,
    = DERIVE_PUBLIC(a)

a'
    암호화된 리스셋에 서명하기 위해 사용되는 블라인딩된 32바이트 EdDSA 개인 키
    이 값은 유효한 EdDSA 개인키입니다.

A'
    블라인딩된 32바이트 EdDSA 공개 키,
    A와 alpha로부터 도출할 수 있습니다.
    이 값은 유효한 EdDSA 공개 키입니다, 곡선 위와 프라임-순서의 하위 그룹에 있습니다.

LEOS2IP(x)
    입력 바이트의 순서를 작은 엔디안으로 변경합니다.

H*(x)
    32 바이트 = (LEOS2IP(SHA512(x))) mod B, Ed25519 해시-및-리듀스와 동일


#### 블라인딩 계산

날짜(UTC)마다 새로운 비밀 alpha와 블라인딩된 키를 생성하고
있어야 합니다. 비밀 alpha와 블라인딩된 키는
다음과 같이 계산됩니다.

GENERATE_ALPHA(destination, date, secret): 모든 당사자에 대해::

  ```text
// GENERATE_ALPHA(destination, date, secret)

  // secret is optional, else zero-length
  A = destination's signing public key
  stA = signature type of A, 2 bytes big endian (0x0007 or 0x000b)
  stA' = signature type of blinded public key A', 2 bytes big endian (0x000b)
  keydata = A || stA || stA'
  datestring = 8 bytes ASCII YYYYMMDD from the current date UTC
  secret = UTF-8 encoded string
  seed = HKDF(H("I2PGenerateAlpha", keydata), datestring || secret, "i2pblinding1", 64)
  // treat seed as a 64 byte little-endian value
  alpha = seed mod L
```

BLIND_PRIVKEY(), 소유자가 리스셋을 게시하는 경우::

  ```text
// BLIND_PRIVKEY()

  alpha = GENERATE_ALPHA(destination, date, secret)
  // If for a Ed25519 private key (type 7)
  seed = destination's signing private key
  a = left half of SHA512(seed) and clamped as usual for Ed25519
  // else, for a Red25519 private key (type 11)
  a = destination's signing private key
  // Addition using scalar arithmentic
  blinded signing private key = a' = BLIND_PRIVKEY(a, alpha) = (a + alpha) mod L
  blinded signing public key = A' = DERIVE_PUBLIC(a')
```

BLIND_PUBKEY(), 클라이언트가 리스셋을 검색할 때::

  ```text
// BLIND_PUBKEY()

  alpha = GENERATE_ALPHA(destination, date, secret)
  A = destination's signing public key
  // Addition using group elements (points on the curve)
  blinded public key = A' = BLIND_PUBKEY(A, alpha) = A + DERIVE_PUBLIC(alpha)
```

A'의 두 경우의 계산 방식은 필요한 동일한 결과를 내야 합니다.


#### 서명

비블라인딩된 리스셋은 비블라인딩된 Ed25519 또는 Red25519 개인 키에 의해 서명됩니다.
비블라인딩된 Ed25519 또는 Red25519 공개 키(sig 유형 7 또는 11)에 의해 검증됩니다.

서명 공개 키가 오프라인인 경우,
비블라인딩된 리스셋은 비블라인딩된 임시 Ed25519 또는 Red25519 개인 키에 의해 서명되며,
비블라인딩된 Ed25519 또는 Red25519 임시 서명 공개 키(sig 유형 7 또는 11)에 의해 검증됩니다.
암호화된 리스셋에 대한 오프라인 키에 대한 추가 노트는 아래를 참조하십시오.

암호화된 리스셋의 서명을 위해서는
Red25519를 사용하며, RedDSA [ZCASH]_에 기반하여
블라인딩된 키로 서명 및 검증을 수행합니다.
Red25519 서명은 Ed25519 곡선 위에서 진행되며, 해시에 대해 SHA-512를 사용합니다.

Red25519는 여기에 지정된 사항을 제외하고는
표준 Ed25519와 동일합니다.


#### 서명/검증 계산

암호화된 리스셋의 외부 부분은 Red25519 키와 서명을 사용합니다.

Red25519는 Ed25519와 거의 동일합니다. 두 가지 차이점이 있습니다:

Red25519 개인 키는 랜덤한 숫자에서 생성되며, 나중에 L의 모드로 줄여야 합니다, 여기에 L은 위의 정의된 것입니다.
Ed25519 개인 키는 랜덤 숫자에서 생성되며, "클램프" 되어 바이트 0 및 31에 대해 비트 마스킹을 수행합니다. Red25519에는 적용되지 않습니다.
위에서 정의된 GENERATE_ALPHA() 및 BLIND_PRIVKEY() 함수는
Red25519 개인 키를 L로 모듈러하여 적절하게 생성합니다.

Red25519에서는 서명용 r계산에서 추가적인 랜덤 데이터를 사용하며,
개인키의 해시보다 공개 키를 사용합니다.
랜덤 데이터로 인해, 동일한 데이터로 동일한 키로 서명할 때마다
모든 Red25519 서명은 다릅니다.

서명:

  ```text
T = 80 random bytes
  r = H*(T || publickey || message)
  // rest is the same as in Ed25519
```

검증:

  ```text
// same as in Ed25519
```

암호화 및 처리
`````````````````````````

#### 하위 인증자의 파생
블라인딩 과정의 일환으로, 우리는 암호화된 LS2가
목적지의 서명 공개 키를 알고 있는 사람들만 복호화할 수 있도록 해야 합니다.
전체 목적지를 외울 필요는 없습니다.
이를 달성하기 위해, 우리는 서명 공개 키에서 인증자를 도출합니다:

  ```text
A = destination's signing public key
  stA = signature type of A, 2 bytes big endian (0x0007 or 0x000b)
  stA' = signature type of A', 2 bytes big endian (0x000b)
  keydata = A || stA || stA'
  credential = H("credential", keydata)
```

개인화된 문자열은 인증자가 DHT 조회 키로 사용되는 
어떤 해시와도 충돌하지 않도록 보장합니다, 예: 단순 목적지 해시.

주어진 블라인딩 키에 대해, 우리는 다음과 같은 방식으로 하위 인증자를 도출할 수 있습니다:

  ```text
subcredential = H("subcredential", credential || blindedPublicKey)
```

하위 인증자는 아래의 키 도출 과정에서 포함되며, 
이는 이러한 키가 목적지의 서명 공개 키와 결합되어 있다는 것을 보장합니다.

#### 레이어 1 암호화
먼저, 키 도출 과정에 대한 입력 준비를 합니다:

  ```text
outerInput = subcredential || publishedTimestamp
```

다음으로, 랜덤한 소금을 생성합니다:

  ```text
outerSalt = CSRNG(32)
```

그다음, 레이어 1을 암호화할 때 사용되는 키를 도출합니다:

  ```text
keys = HKDF(outerSalt, outerInput, "ELS2_L1K", 44)
  outerKey = keys[0:31]
  outerIV = keys[32:43]
```

마지막으로, 레이어 1의 평문을 암호화하고 직렬화합니다:

  ```text
outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext)
```

#### 레이어 1 복호화
소금은 레이어 1 암호문에서 해석됩니다:

  ```text
outerSalt = outerCiphertext[0:31]
```

그다음, 레이어 1을 암호화할 때 사용된 키를 도출합니다:

  ```text
outerInput = subcredential || publishedTimestamp
  keys = HKDF(outerSalt, outerInput, "ELS2_L1K", 44)
  outerKey = keys[0:31]
  outerIV = keys[32:43]
```

마지막으로, 레이어 1 암호문을 복호화합니다:

  ```text
outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end])
```

#### 레이어 2 암호화
클라이언트 인증이 활성화된 경우, `authCookie`는 아래 설명된 대로 계산됩니다.
클라이언트 인증이 비활성화된 경우, `authCookie`는 길이가 0인 바이트 배열입니다.

암호화는 레이어 1과 유사하게 진행됩니다:

  ```text
innerInput = authCookie || subcredential || publishedTimestamp
  innerSalt = CSRNG(32)
  keys = HKDF(innerSalt, innerInput, "ELS2_L2K", 44)
  innerKey = keys[0:31]
  innerIV = keys[32:43]
  innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext)
```

#### 레이어 2 복호화
클라이언트 인증이 활성화된 경우, `authCookie`는 아래 설명된 대로 계산됩니다.
클라이언트 인증이 비활성화된 경우, `authCookie`는 길이가 0인 바이트 배열입니다.

복호화는 레이어 1과 유사하게 진행됩니다:

  ```text
innerInput = authCookie || subcredential || publishedTimestamp
  innerSalt = innerCiphertext[0:31]
  keys = HKDF(innerSalt, innerInput, "ELS2_L2K", 44)
  innerKey = keys[0:31]
  innerIV = keys[32:43]
  innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end])
```


클라이언트별 인증
````````````````````````
목적지에 대해 클라이언트 인증이 활성화된 경우, 서버는
암호화된 LS2 데이터를 복호화할 수 있도록 클라이언트를 인증하는 목록을 유지합니다.
저장되는 데이터는 인증 메커니즘에 따라 다르며,
각 클라이언트가 생성하고 안전한 비공식 방법으로 서버에 전송하는
일종의 키 정보를 포함합니다.

클라이언트별 인증을 구현하는 두 가지 대안이 있습니다:

#### DH 클라이언트 인증
각 클라이언트는 DH 키 쌍 `[csk_i, cpk_i]`를 생성하고,
공개키 `cpk_i`를 서버에 전송합니다.

서버 처리
^^^^^^^^^^^^^^^^^
서버는 새로운 `authCookie`와 임시 DH 키 쌍을 생성합니다:

  ```text
authCookie = CSRNG(32)
  esk = GENERATE_PRIVATE()
  epk = DERIVE_PUBLIC(esk)
```

그리고 각 인증받은 클라이언트에 대해, 서버는 
`authCookie`를 해당 클라이언트의 공개키로 암호화합니다:

  ```text
sharedSecret = DH(esk, cpk_i)
  authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp
  okm = HKDF(epk, authInput, "ELS2_XCA", 52)
  clientKey_i = okm[0:31]
  clientIV_i = okm[32:43]
  clientID_i = okm[44:51]
  clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie)
```

서버는 각각의 `[clientID_i, clientCookie_i]` 쌍을 
암호화된 LS2의 레이어 1에 배치합니다, `epk`와 함께.

클라이언트 처리
^^^^^^^^^^^^^^^^^
클라이언트는 개인 키를 사용하여 
기대 클라이언트 식별자 `clientID_i`, 
암호화 키 `clientKey_i`, 암호화 IV `clientIV_i`를 도출합니다:

  ```text
sharedSecret = DH(csk_i, epk)
  authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp
  okm = HKDF(epk, authInput, "ELS2_XCA", 52)
  clientKey_i = okm[0:31]
  clientIV_i = okm[32:43]
  clientID_i = okm[44:51]
```

그런 다음, 클라이언트는 레이어 1 인증 데이터에서 
`clientID_i`를 포함하는 항목을 검색합니다. 
일치하는 항목이 있으면, 클라이언트는 이것을 복호화하여 
`authCookie`를 얻습니다:

  ```text
authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie_i)
```

#### 사전 공유 키 클라이언트 인증
각 클라이언트는 32바이트 비밀 키 `psk_i`를 생성하고,
이를 서버에 전송합니다.
대안으로 서버가 비밀 키를 생성하고, 
이를 하나 이상의 클라이언트에게 전송할 수 있습니다.


서버 처리
^^^^^^^^^^^^^^^^^
서버는 새로운 `authCookie`와 소금을 생성합니다:

  ```text
authCookie = CSRNG(32)
  authSalt = CSRNG(32)
```

그리고 각 인증받은 클라이언트에 대해, 서버는 
`authCookie`를 사전 공유 키로 암호화합니다:

  ```text
authInput = psk_i || subcredential || publishedTimestamp
  okm = HKDF(authSalt, authInput, "ELS2PSKA", 52)
  clientKey_i = okm[0:31]
  clientIV_i = okm[32:43]
  clientID_i = okm[44:51]
  clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie)
```

서버는 각각의 `[clientID_i, clientCookie_i]` 쌍을 
암호화된 LS2의 레이어 1에 배치합니다, `authSalt`와 함께.

클라이언트 처리
^^^^^^^^^^^^^^^^^
클라이언트는 사전 공유 키를 사용하여 
기대 클라이언트 식별자 `clientID_i`, 
암호화 키 `clientKey_i`, 암호화 IV `clientIV_i`를 도출합니다:

  ```text
authInput = psk_i || subcredential || publishedTimestamp
  okm = HKDF(authSalt, authInput, "ELS2PSKA", 52)
  clientKey_i = okm[0:31]
  clientIV_i = okm[32:43]
  clientID_i = okm[44:51]
```

그 다음, 클라이언트는 레이어 1 인증 데이터에서 
`clientID_i`를 포함하는 항목을 검색합니다. 
일치하는 항목을 찾으면, 클라이언트는 `authCookie`를 얻기 위해 
이를 복호화합니다:

  ```text
authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie_i)
```

#### 보안 고려사항
위의 클라이언트 인증 메커니즘은 모두 클라이언트 구성원의 
개인 정보를 제공합니다.
목적지만 알고 있는 개체는 인증된 클라이언트를 추적할 수 없지만, 
항상 얼마나 많은 클라이언트가 허용되는지를 알 수 있습니다.

서버는 클라이언트가 자신들의 위치를 ​​파악하지 못하도록 하기 위해 
암호화 된 LS2를 생성할 때마다 클라이언트의 순서를 랜덤화해야 합니다.

서버는 원하는 경우 랜덤 레코드를 목록에 삽입하여 
가입한 클라이언트 수를 숨길 수 있습니다.


DH 클라이언트 인증의 장점
^^^^^^^^^^^^^^^^^^^^^^^^^
- 스킴의 보안은 오프라인의 클라이언트 키 교환에 전적으로 의존하지 않습니다. 
  클라이언트의 비밀 키는 그들의 장치를 떠날 필요가 없으며, 
  교환을 가로채더라도 DH 알고리즘을 깨지 못한 비밀 키를 가지고 있지 않으면 
  암호화된 LS2를 해독할 수 없습니다.

DH 클라이언트 인증의 단점
^^^^^^^^^^^^^^^^^^^^^^^^^^
- 서버 측에서는 N 클라이언트에 대해 N + 1 DH 작업이 필요합니다.
- 클라이언트 측에서는 한 개의 DH 작업만 필요합니다.
- 클라이언트가 비밀 키를 생성해야 합니다.

PSK 클라이언트 인증의 장점
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- DH 작업이 필요하지 않습니다.
- 서버가 비밀 키를 생성할 수 있습니다.
- 서버가 원하는 경우 동일한 키를 여러 클라이언트와 공유할 수 있습니다.

PSK 클라이언트 인증의 단점
^^^^^^^^^^^^^^^^^^^^^^^^^^
- 스킴의 보안은 비밀 키의 오프라인 교환에 심각하게 의존합니다. 
  특정 클라이언트의 교환을 가로채는 공격자는 그 클라이언트에 대해 
  허가된 이후의 모든 암호화된 LS2를 해독할 수 있으며, 
  클라이언트의 액세스가 취소될 시기를 알아낼 수 있습니다.


Base 32 주소가 있는 암호화된 LS
```````````````````````````````````

제안 149를 참조하십시오.

비트 토렌트, 32 바이트의 압축된 응답에는 암호화된 LS2를 
사용할 수 없습니다. 
응답에 암호화된 리스셋을 나타내는 것에 대한 여유 공간이 없습니다.


오프라인 키가 있는 암호화된 LS
`````````````````````````````````
오프라인 키가 있는 암호화된 리스셋의 경우, 
블라인딩된 개인 키도 하루마다 오프라인에서 생성되어야 합니다.

암호화된 리스셋의 명확한 부분에 있는 오프라인 서명 블록을 사용하면, 
플러드필을 해킹하는 어떤 사람이 이를 사용하여 리스셋을 
며칠 동안 추적할 수 있습니다(그러나 복호화할 수는 없습니다).
이를 방지하기 위해 키의 소유자는 또한 매일에 대해 
새로운 임시 키를 생성해야 합니다.
임시 및 블라인딩 된 키는 미리 생성 될 수 있으며, 
번들로 라우터에 제공될 수 있습니다.

이 제안에서는 클라이언트 또는 라우터에 다수의 임시 및
블라인딩된 키를 패키징하여 제공하는 파일 형식을 정의하지 않습니다.
이 제안에서는 오프라인 키가 있는 암호화된 리스셋을 지원하는
I2CP 프로토콜 향상을 정의하지 않습니다.



Notes
`````

- 서비스는 암호화된 리스셋을 플러드필에 게시할 것입니다.
  그러나 효율성을 위해 인증 후에는
  (예: 화이트리스트를 통해) 클라이언트에게 암호화되지 않은 리스셋을
  가르릭 메시지에 보낼 수 있습니다.

- 플러드필은 남용 방지를 위해 최대 크기를 합리적인 값으로 제한할 수 있습니다.

- 복호화 후, 몇 가지 검사를 해야 하며,
  내부 타임스탬프 및 만료가 상위 레벨에서 일치하는지 확인하는 것을 포함합니다.

- ChaCha20은 AES보다 선택되었습니다. AES
  하드웨어 지원이 가능할 때 속도는 비슷하지만, ChaCha20는
  AES 하드웨어 지원이 불가능할 때 하저가 있는 ARM 장치에서 2.5-3배 빠릅니다.

- 우리는 블레이크2b를 사용하지 않는 이유는 그렇게까지 속도에 신경 쓰지 않기 때문입니다. 
  해시와 도출 될 가장 큰 n을 수용 할 수 있는   
  크기의 출력을 가지고 있습니다 (또는 원하는 키에 대해 카운터 인수를 사용하여 
  한 번 호출할 수 있습니다). 
  그러나, 특히 제안 148에서는 우리가 다른 이유로 블레이크2b로 전환하는 것을 제안하고 있습니다. 
  [UNSCIENTIFIC-KDF-SPEEDS]_


### Meta LS2

이것은 멀티호밍을 대체하는 데 사용됩니다. 모든 리스셋과 같이, 
이것은 생성자가 서명합니다. 이는 서비스 참여자의 인증된 목록입니다.

Meta LS2는 트리 구조의 상위에 있으며, 
때로는 중간 노드에도 있습니다.
그것은 LS, LS2 또는 Meta LS2를 지원하기 위한 입력 수를 포함하여
 대규모 멀티호밍을 지원합니다.
Meta LS2는 LS, LS2 및 Meta LS2를 혼합하여 포함할 수 있습니다.
트리의 잎은 항상 LS 또는 LS2입니다.
트리는 DAG입니다; 루프는 금지됩니다; 
루프를 발견하고 따르지 않는 클라이언트는 감지해야 합니다.

Meta LS2는 표준 LS 또는 LS2보다 훨씬 더 긴 만료 기간을 가질 수 있습니다.
최상위 수준은 발행 일시 후 몇 시간 동안 만료될 수 있습니다.
최대 만료 시간은 플러드필과 클라이언트에 의해
집행되며, TBD입니다.

Meta LS2의 사용 사례는 대규모 멀티호밍이지만, 
현재 LS 또는 LS2와 제공되는 대로
터널을 리스셋으로 연관시키는 것 이상으로 보호되지 않습니다(라우터
다시 시작 시).
이는 페이스북과 동일한 사용 케이스에 해당하며, 
아마도 상관 보호가 필요하지 않을 것입니다.
이 사용 사례는 아마도 오프라인 키가 필요할 것입니다.
이는 트리의 각 노드에서 표준 헤더에 제공됩니다.

Mix-and-match leasesets는 여러 라우터에서 리스를 연합, 서명 및 발행하는
것으로, 이 경우 복잡한 백엔드 프로토콜이 필요하다는 것은 사실입니다.
그러나, 페이스북 등과 같은 경우 복잡한 백엔드가 필요하지 않은 이유는
일반적으로 "비밀번호"와 같은 간단한 코드를 사용하기 때문입니다.
백엔드 프로토콜은 매우 간단합니다 - 동료가 살아있음을 검증하고,
몇 시간마다 새 LS를 발행합니다.
종결 및 재생성은 복잡성을 제거합니다.
프로토콜 및 라우터 및 클라이언트 내부와의 상호작용은
상상할 수 있는 것처럼 매우 복잡할 것입니다
투명 멀티호밍의 백엔드 프로토콜 및 
라우터 및 클라이언트 내와의 상호작용은 무너지지 않을 것입니다.

최상위 Meta LS에 대한 플러드필의 과부하를 피하려면, 
만료일은 적어도 몇 시간 이상이 되어야합니다.
클라이언트는 최상위 Meta LS를 캐시하고,
저장된 부분을 검사 하지 않거나 새 모델이 다른 부분에 영향을 주지 않는 한
초기화 해서는 컬리지 않습니다.

클라이언트가 트리를 순회하는 알고리즘을 정의해야 하며, 
사용량이 분산되도록 백업해야 합니다.
해시 거리, 비용 및 임의성의 함수입니다.
노드에 LS 또는 LS2와 Meta LS 모두가 있는 경우, 
그들이 언제 그 리스셋을 사용하도록 허용되고, 
언제 트리를 계속 탐색해야 하는지 알아야 합니다.




조회 위치:
    표준 LS 플래그 (1)
저장 유형:
    Meta LS2 유형 (7)
저장 위치:
    목적지의 해시
    이 해시는 이후 LS1의 일일 "라우팅 키"를 생성하는 데 사용됩니다.
일반적인 만료
    시간 단위. 최대 18.2시간(65535초)
게시자:
    "주관" 목적지 또는 조정자, 또는 중간 조정자

형식
``````
::

  위에서 지정한 표준 LS2 헤더 사용

  Meta LS2 유형별 부분
  - 속성(공통 구조 사양에 지정된 대로 매핑, 없을 경우 2개의 0 바이트)
  - 항목 수 (1 바이트) 최대 TBD
  - 항목. 각 항목은 다음을 포함합니다: (40 바이트)
    - 해시(32 바이트)
    - 플래그(2 바이트)
      TBD. 향후 사용을 위해 호환성을 위해 모두 0으로 설정.
    - 유형(1 바이트) 참조하는 LS 유형;
      LS는 1, LS2는 3, 암호화된 경우는 5, 메타는 7, 미확인 경우 0입니다.
    - 비용 (우선도) (1 바이트)
    - 만료 (4 바이트) (4 바이트, big endian, seconds since epoch, rolls over in 2106)
  - 철회(폐기) 횟수 (1 바이트) 최대 TBD
  - 삭제: 각 삭제는 다음을 포함합니다: (32 바이트)
    - 해시(32 바이트)

  표준 LS2 서명:
  - 서명 (40+ 바이트)
    위의 모든 것에 대한 서명입니다.

플래그와 속성: 향후 사용을 위해


Notes
`````
- 분산 서비스는 일반적으로 사설 네트워크에서, 그들이 현재 사용하고 있는 가상 경로(neutrex routing)를 포함하여 확인된 노드를 지정하고, 목록을 유지하고, 블록체인 이후에 새로워질 수 있는 기능을 포함하여, 일반적으로 인터넷에서 해결됩니다.
- 블록체인 후, 서비스를 안전하게 변경할 수 있습니다.
- 서비스가 Meta LS2를 사용할 때, 터널을 가지지 않습니다.


### 서비스 기록

이는 목적지가 서비스에 참여하고 있다고 말하는 개별 기록입니다. 이는 참가자에서 플러드필에 보내집니다. 개별적으로 플러드필에서 발송되는 서비스 기록이 아니며, 서비스 목록의 일부로 발송됩니다. 서비스 기록은 만료를 0으로 설정하여 서비스 참여 철회를 수행합니다.

이는 LS2가 아니지만 표준 LS2 헤더와 서명 형식을 사용합니다.

조회 위치:
    n/a, 서비스 목록 참조
저장 유형:
    서비스 기록 유형 (9)
저장 위치:
    서비스 이름의 해시
    이 해시는 이후 LS1의 일일 "라우팅 키"를 생성하는 데 사용됩니다.
일반적인 만료
    시간. 최대 18.2 시간 (65535 초)
게시자:
    목적지

형식
``````
::

  위에서 지정한 표준 LS2 헤더 사용

  서비스 기록 유형별 부분
  - 포트 (2 바이트, big endian) (0이면 미지정)
  - 서비스 이름의 해시 (32 바이트)

  표준 LS2 서명:
  - 서명(40+ 바이트)
    위의 모든 것에 대한 서명입니다.


Notes
`````
- 만료가 모두 0이면, 플러드필은 기록을 철회하고 더 이상 서비스를 목록에 포함하면 안 됩니다.

- 저장: 플러드필은 엄격히 제한된 범위의 레코드 저장을 조절하고 
  해시당 저장된 레코드 수 및 만료를 제한할 수 있습니다. 
  가능 목록 사용도 가능합니다.

- 동일한 해시의 다른 netdb 유형이 우선되므로, 
  서비스 기록이 LS/RI를 결코 덮어쓸 수 없습니다. 
  하지만 LS/RI는 그 해시의 모든 서비스 기록을 덮어씁니다.



### 서비스 목록

이는 LS2와 전혀 다른 형식을 사용합니다.

서비스 목록은 플러드필에서 생성 및 서명됩니다. 이는 인증되지 않은 것으로, 
아무나 서비스를 포함할 수 있습니다. 
이것은 플러드필에서 서비스 목록으로 개인 기록을 포함하는 것입니다.

서비스 목록은 단축 서비스 기록을 포함하며, 
풀 서비스 기록은 아닙니다. 
이들은 서명을 포함하지만, 전체 목적지를 없이는 검증할 수 없습니다.

서비스 목록의 보안 및 매력은 TBD입니다.
플러드필은 출판 및 조회를 서비스의 허용 목록으로 제한할 수 있지만, 
그 목록은 구현 또는 운영자 선호도에 따라 달라질 수 있습니다.
공통 기본 허용 목록에 대해 구현간 합의하는 것은 불가능할 수 있습니다.

서비스 이름을 서비스 기록에 포함시키면,
플러드필 운영자가 반대할 수 있습니다.
해시만 포함되면
검증은 없습니다, 서비스 기록은 
어떤 다른 netdb 유형보다 먼저 "들어가"며 플러드필에서 저장될 수 있습니다.

조회 위치:
    서비스 목록 조회 유형 (11)
저장 유형:
    서비스 목록 유형 (11)
상점 위치:
    서비스 이름의 해시
    이 해시는 이후 LS1의 일일 "라우팅 키"를 생성하는 데 사용됩니다.
일반적인 만료
    시간 단위, 목록 자체 내에서는 명시되지 않으며, 로컬 정책에 따라 제공됩니다.
게시자:
    아무도 없음, 플러드필에 보내지 않고 전파되지 않음.

형식
``````
여기서 지정한 표준 LS2 헤더를 사용하지 않습니다.

::

  - 유형 (1 바이트)
    실제로 헤더에 있는 것이 아니라, 서명 커버 데이터의 일부입니다.
    데이터베이스 저장 메시지에서 필드에서 가져옵니다.
  - 서비스 이름의 해시 (암시적, 데이터베이스 저장 메시지 내)
  - 작성자(플러드필)의 해시 (32 바이트)
  - 발행된 타임스탬프 (8 바이트, big endian)

  - 단축 서비스 기록 수 (1 바이트)
  - 단축 서비스 기록 목록:
    각 단축 서비스 기록은 다음을 포함합니다 (90+ 바이트)
    - 목적지 해시 (32 바이트)
    - 발행된 타임스탬프 (8 바이트, big endian)
    - 만료(4 바이트, big endian) (발행된 이후 ms의 오프셋)
    - 플래그 (2 바이트)
    - 포트 (2 바이트, big endian)
    - 서명 길이 (2 바이트, big endian)
    - 목적지의 서명 (40+ 바이트)

  - 삭제 기록 수 (1 바이트)
  - 삭제 기록 목록:
    각 삭제 기록은 다음을 포함합니다 (86+ 바이트)
    - 목적지 해시 (32 바이트)
    - 발행된 타임스탬프 (8 바이트, big endian)
    - 플래그 (2 바이트)
    - 포트 (2 바이트, big endian)
    - 서명 길이 (2 바이트, big endian)
    - 목적지의 서명 (40+ 바이트)

  - 플러드필의 서명 (40+ 바이트)
    위의 모든 것에 대한 서명입니다.

서비스 목록의 서명을 검증하려면:

- 서비스 이름의 해시를 첨부
- 작성자의 해시를 제거
- 수정된 콘텐츠에 대한 서명 확인

각 단축 서비스 기록의 서명을 검증하려면:

- 목적지 가져오기
- (발행된 타임스탬프 + 만료 + 플래그 + 포트 + 서비스 이름의 해시)의 서명 확인zione)

각 삭제 기록의 서명을 검증하려면:

- 목적지 가져오기
- (발행된 타임스탬프 + 4개의 제로 바이트 + 플래그 + 포트 + 서비스 이름의 해시)의 서명 확인

Notes
`````
- 알려진 서명 유형 지원, 서명 유형 대신 서명 길이 사용

- 서비스 목록에는 만료가 없으므로 수신자는 
  개인 정책이나 각 기록의 만료를 기반으로 스스로 결정할 수 있습니다.

- 서비스 목록은 전파되지 않으며, 단일 서비스 기록만 전파됩니다. 
  각 플러드필은 자체 정책으로 전파 및 생성하며, 모든 서비스 및 삭제 
  기록의 최대 수를 결정합니다.



## 공통 구조 사양에 필요한 변경 사항


### 키 인증서

이 제안의 범위를 벗어납니다.
ECIES 제안 144와 145에 추가합니다.


### 새 중간 구조

Lease2, MetaLease, LeaseSet2Header, 및 OfflineSignature용 새로운 구조 추가.
릴리스 0.9.38부터 유효.


### 새로운 NetDB 유형

각각의 새로운 리스셋 유형에 대한 구조 추가, 
위에서 통합된 형식을 따릅니다.
LeaseSet2, EncryptedLeaseSet, 및 MetaLeaseSet의 경우,
릴리스 0.9.38부터 유효.
서비스 기록 및 서비스 목록의 경우,
예비 및 현재 일정 미지정.


### 새로운 서명 유형

새 RedDSA_SHA512_Ed25519 유형 11 추가.
공개 키는 32 바이트입니다; 개인 키는 32 바이트입니다; 해시는 64 바이트입니다; 서명은 64 바이트입니다.



## 암호화 사양에 필요한 변경 사항

이 제안의 범위를 벗어납니다.
제안 144와 145를 참조하십시오.



## I2NP에 필요한 변경 사항

새로운 LS2를 플러드필에만 게시할 수 있는 기준 버전 추가.


### 데이터베이스 조회 메시지

서비스 목록 조회 유형 추가.

변경 사항
```````
::

  플래그 바이트: 조회 유형 필드, 현재 비트 3-2, 비트 4-2까지 확장됩니다.
  조회 유형 0x04는 서비스 목록 조회 유형으로 정의됩니다.

  추가 참고: 서비스 목록 조회는 최소 버전의 플러드필에만 보내야 합니다.
  최소 버전은 0.9.38입니다.


### 데이터베이스 저장 메시지

모든 새로운 저장 유형 추가.

변경 사항
```````
::

  유형 바이트: 유형 필드, 현재 비트 0, 비트 3-0까지 확장됩니다.
  유형 3은 LS2 저장으로 정의됩니다.
  유형 5는 암호화된 LS2 저장으로 정의됩니다.
  유형 7은 메타 LS2 저장으로 정의됩니다.
  유형 9는 서비스 기록 저장으로 정의됩니다.
  유형 11은 서비스 목록 저장으로 정의됩니다.
  다른 유형은 정의되지 않았고 유효하지 않습니다.

  추가 참고: 모든 새로운 유형은 기준 버전 이상의 플러드필에만 게시할 수 있습니다.
  최소 버전은 0.9.38입니다.




## I2CP에 필요한 변경 사항


### I2CP 옵션

SessionConfig 매핑에 전송된 클라이언트 측으로 해석된 새로운 옵션:

::

  i2cp.leaseSetType=nnn     생성 리스셋 메시지에서 보낼 리스셋 유형입니다
                            값은 위 표의 netdb 저장 유형과 동일합니다.
                            클라이언트 측에서 해석되지만 의도를 선언하고
                            지원을 확인하기 위해 SessionConfig에서
                            라우터에 전송됩니다.

  i2cp.leaseSetEncType=nnn[,nnn]  사용할 암호화 유형입니다.
                                  클라이언트 측에서 해석되지만 의도를 선언하고
                                  지원을 확인하기 위해 SessionConfig에서
                                  라우터에 전송됩니다..
                                  제안 144와 145를 참조하십시오.

  i2cp.leaseSetOfflineExpiration=nnn  오프라인 서명의 만료, ASCII,
                                      epoch 이후의 초입니다.

  i2cp.leaseSetTransientPublicKey=[type:]b64  임시 개인 키의 기본 64,
                                              선택적 sig 유형 번호 또는 이름 앞에 나와 있으며,
                                              기본 DSA_SHA1입니다.
                                              길이는 sig 유형에서 유추됩니다.

  i2cp.leaseSetOfflineSignature=b64   오프라인 서명의 base 64. 
                                      길이는 대상 서명 공개 키 유형에서 유추됩니다.

  i2cp.leaseSetSecret=b64     리스셋 주소를 블라인드 하는 데 사용되는 base 64의 비밀,
                              기본값 ""

  i2cp.leaseSetAuthType=nnn   암호화된 LS2에 대한 인증 유형.
                              0은 클라이언트별 인증이 없음(기본값)
                              1
