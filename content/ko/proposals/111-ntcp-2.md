---
title: "NTCP 2"
number: "111"
author: "EinMByte, orignal, psi, str4d, zzz"
created: "2014-02-13"
lastupdated: "2019-08-13"
status: "Closed"
thread: "http://zzz.i2p/topics/1577"
supercedes: "106"
target: "0.9.36"
implementedin: "0.9.36"
editor: "manas, str4d, zzz"
---

## Note
Proposal phase is closed.
See [SPEC](/en/docs/spec/ntcp2/) for the official specification.
This proposal may still be referenced for background information.


## Overview

이 제안서는 인증된 키 합의 프로토콜을 설명하여 [NTCP](/en/docs/transport/ntcp/)의 다양한 형태의 자동화된 식별 및 공격에 대한 저항성을 향상시키기 위한 것입니다.

제안서는 다음과 같이 구성되어 있습니다: 보안 목표를 제시하고, 기본 프로토콜에 대한 설명이 이어집니다. 그 다음에는 모든 프로토콜 메시지의 완전한 사양이 제공됩니다. 마지막으로 라우터 주소와 버전 식별에 대해 논의합니다. 흔한 패딩 스킴에 대한 일반적인 공격을 논의하는 부록과 인증된 암호 후보 목록이 포함된 부록도 포함되어 있습니다.

다른 I2P 전송과 마찬가지로, NTCP2는 오직 I2NP 메시지의 점대점(라우터 대 라우터) 전송을 위해 정의됩니다. 일반적인 데이터 파이프가 아닙니다.


## Motivation

[NTCP](/en/docs/transport/ntcp/) 데이터는 첫 번째 메시지 후에 암호화되고 (첫 번째 메시지는 무작위 데이터처럼 보임), "페이로드 분석"을 통한 프로토콜 식별을 방지합니다. 그러나 "흐름 분석"을 통한 프로토콜 식별에는 여전히 취약합니다. 이는 첫 번째 4개의 메시지(즉, 핸드셰이크)가 고정 길이(288, 304, 448, and 48 bytes)이기 때문입니다.

각 메시지에 무작위로 임의의 데이터를 추가하면 식별이 훨씬 어려워집니다.

저자는 표준 보안 관행이 TLS와 같은 기존 프로토콜을 사용할 것을 제안할 수 있음을 인정하지만, 이는 [Prop104](/en/proposals/104/)이며 자체적으로 문제를 안고 있습니다. 적절한 경우, 부재 기능이나 논의 주제를 나타내기 위해 "미래 작업" 단락이 추가되었습니다.


## Design Goals

- 단일 포트에서 NTCP 1 및 2를 지원하고, 자동 감지하며, [NetDB](/en/docs/how/network-database/)에 단일 "전송"으로 게시합니다.

- NetDB의 별도 필드에 버전 1만, 2만, 또는 1+2 지원을 게시하고, 기본적으로 버전 1만을 지원하도록 설정합니다 (특정 라우터 버전에 버전 지원을 묶지 않음)

- 모든 구현(Java/i2pd/Kovri/go)이 자신의 일정에 따라 버전 2 지원을 추가할 수 있도록 보장합니다 (또는 하지 않을 수 있음)

- 핸드셰이크 및 데이터 메시지를 포함하여 모든 NTCP 메시지에 무작위 패딩을 추가합니다 (즉, 모든 메시지가 16 바이트의 배수가 되지 않도록 길이 난독화). 양쪽이 최소 및 최대 패딩 및/또는 패딩 분배를 요청할 수 있는 옵션 메커니즘을 제공합니다. 패딩 분포의 세부 사항은 구현에 따라 다르며 프로토콜 자체에서 지정되지 않을 수 있습니다.

- 암호화되지 않은 메시지의 내용을 난독화하여 DPI 박스 및 AV 서명이 쉽게 분류할 수 없도록 합니다. 또한, 단일 피어 또는 피어 집합으로 가는 메시지가 유사한 비트 패턴을 가지지 않도록 합니다.

- Java 형식[Tiket1112]_으로 인해 발생하는 DH의 비트 유실을 수정하고, 가능하면 X25519으로 바꾸는 것이 좋습니다.

- DH 결과를 그대로 사용하기보다는 실질적인 키 유도 함수(KDF)로 전환할까요?

- "탐침 저항성"(Tor의 용어) 추가; 여기에는 재생 공격 저항성이 포함됩니다.

- 양방향 인증 키 교환(2W-AKE) 유지. 1W-AKE는 우리의 애플리케이션에 충분하지 않습니다.

- 인증의 일부로서 발행된 [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/) 서명 키에서 가변 유형, 가변 길이 서명을 계속 사용합니다. 인증의 다른 부분으로서 RouterInfo에 발행된 정적 공개 키에 의존합니다.

- 미래 확장을 위해 핸드셰이크에 옵션/버전 추가.

- 가능하면 악의적인 MiTM TCP 세분화에 대한 저항성 추가.

- 연결 설정에 필요한 CPU를 크게 늘리지 않기; 가능하면 크게 줄이세요.

- 메시지 인증(MAC) 추가, 가능하면 HMAC-SHA256 및 Poly1305를 추가하고, Adler 체크섬을 제거하세요.

- I2NP 헤더를 짧고 간단하게 만들기:
  만료를 4 바이트로 줄이기, SSU와 같이.
  단일 바이트 SHA256 체크섬 삭제.

- 가능하다면 4 메시지, 2 왕복 핸드셰이크를 3 메시지, 1 왕복 핸드셰이크로 줄이기, [SSU](/en/docs/transport/ssu/)와 같이. 메시지 2에 Bob의 서명을 옮기는 것이 필요. 10년 된 이메일/상태/회의 기록에서 4 메시지의 이유를 연구하세요.

- 패딩 전에 프로토콜 오버헤드를 최소화합니다. 패딩이 추가될 것이고, 어쩌면 많은 양이 추가되겠지만, 패딩 전 오버헤드는 여전히 오버헤드입니다. 저대역폭 노드는 NTCP2를 사용할 수 있어야 합니다.

- 리프레이 및 스큐 탐지를 위한 타임스탬프 유지.

- 타임스탬프에 있어 년 2038 문제를 피하고, 적어도 2106까지 작동할 수 있도록 합니다.

- 최대 메시지 크기를 16K에서 32K 또는 64K로 증가합니다.

- 새 암호학적 원시문은 Java(1.7), C++, Go 라우터 구현을 위한 라이브러리에서 쉽게 사용 가능해야 합니다.

- Java, C++, Go 라우터 개발자의 대표를 디자인에 포함합니다.

- 변화를 최소화합니다(하지만 여전히 많은 변화가 있을 것입니다).

- 일반적인 코드 집합에서 두 버전을 지원합니다(이것은 불가능할 수 있으며, 어떤 경우든 구현에 따라 다릅니다).


### Non-Goals

- 방탄 DPI 저항 ... 그것은 플러그 가능한 전송이 될 것이다,
  [Prop109](/en/proposals/109/).

- TLS 기반(또는 HTTPS 유사) 전송... 그것은 [Prop104](/en/proposals/104/)이 될 것이다.

- 대칭 스트림 암호화 변경은 가능합니다.

- 타이밍 기반 DPI 저항 (메시지 간 타이밍/지연은 구현 의존적일 수 있으며, 무작위 패딩을 보내기 전에 예를 들어, 메시지 내의 지연이 도입될 수 있음). 인위적 지연(obfs4가 IAT 또는 도착 간 시간이라고 부르는 것)은 프로토콜 자체와 독립적입니다.

- 세션에 참여한다는 부인 (서명이 그 안에 있음).

부분적으로 재고되거나 논의될 수 있는 비목표:

- 심층 패킷 검사를 방어하는 정도(DPI)

- 양자 이후(Post-Quantum, PQ) 보안

- 부인



### Related Goals

- NTCP 1/2 테스트 설정을 구현합니다


## Security Goals

세 명의 당사자를 고려합니다:

- 새로운 세션을 설정하고자 하는 Alice.
- Alice가 세션을 설정하고자 하는 Bob.
- Alice와 Bob 사이에 있는 "중간자" Mallory.

최대 두 명의 참여자가 적극적인 공격을 수행할 수 있습니다.

Alice와 Bob은 둘 다 자신의 [RouterIdentity](/en/docs/spec/common-structures/#routeridentity/)에 포함된 정적 키 쌍을 보유하고 있습니다.

제안된 프로토콜은 다음 요구 사항에 따라 Alice와 Bob이 공유 비밀 키(K)를 합의하도록 시도합니다:

1) 개인 키 보안: Bob도 Mallory도 Alice의 정적 개인 키에 대해 아무것도 배우지 못합니다. 대칭적으로, Alice도 Bob의 정적 개인 키에 대해 아무것도 배우지 못합니다.

2) 세션 키 K는 Alice와 Bob만 알고 있습니다.

3) 완벽한 순방향 보안: 합의된 세션 키는 Alice 및/또는 Bob의 정적 개인 키가 키가 합의된 후 공개되더라도 미래에 비밀로 유지됩니다.

4) 양방향 인증: Alice는 Bob과 세션을 설정했음을 확신하고, 반대로 Bob도 마찬가지입니다.

5) 온라인 DPI에 대한 보호: Alice와 Bob이 간단한 심층 패킷 검사(DPI) 기술만 사용하여 프로토콜에 참여하고 있음을 탐지하기 어렵도록 합니다. 아래 참조.

6) 제한된 부인: Alice나 Bob 중 누구도 프로토콜에 참여했다는 것을 부인할 수 없습니다. 하지만 한 쪽이 공유 키를 누설하면 다른 쪽은 전송된 데이터의 내용의 진실성을 부인할 수 있습니다.

현재의 제안서는 Station-To-Station (STS) 프로토콜 [STS]_을 바탕으로 모든 다섯 가지 요구 사항을 제공하려고 합니다. 이 프로토콜은 또한 [SSU](/en/docs/transport/ssu/) 프로토콜의 기반이 됩니다.


### Additional DPI Discussion

두 가지 DPI 구성 요소가 있다고 가정합니다:

1) Online DPI
`````````````

실시간으로 모든 데이터를 검사하는 Online DPI. 연결이 차단되거나 다른 방식으로 조작될 수 있습니다. 연결 데이터나 메타데이터가 식별되고 오프라인 분석을 위해 저장될 수 있습니다. Online DPI는 I2P 네트워크 데이터베이스에 실시간으로 접근할 수 없습니다. Online DPI는 길이 계산, 필드 검사 및 XOR와 같은 단순 계산을 포함한 제한된 실시간 계산 기능만 가지고 있습니다. Online DPI는 AES, AEAD 및 해시와 같은 빠른 실시간 암호화 함수를 수행할 수 있지만, 대부분의 또는 모든 흐름에 대해 적용하기에는 너무 비쌉니다. 이러한 암호화 작업의 응용은 이전에 오프라인 분석에 의해 식별된 IP/포트 조합의 흐름에만 적용됩니다. Online DPI는 DH 또는 elligator2와 같은 높은 오버헤드를 가지는 암호화 작업을 수행할 수 없습니다. Online DPI는 I2P를 특정하게 감지하도록 설계된 것이 아니지만, 그 목적을 위해 제한된 분류 규칙을 가질 수 있습니다.

Online DPI에 의해 프로토콜이 식별되지 않도록 하는 것이 목표입니다.

여기서 "간단한" 또는 "직접적인" DPI 분석의 개념은 다음과 같은 공격자 능력을 포함합니다:

1) 대상이 송수신하는 모든 데이터를 검사하는 능력.

2) 관찰된 데이터에 대한 작업을 수행하는 능력, 예를 들어 블록 암호화 함수나 해시 함수를 적용하는 것.

3) 이전에 전송된 메시지와 비교하여 저장할 수 있는 능력.

4) 패킷을 수정하거나 지연시키거나 조각화하는 능력.

그러나 Online DPI는 다음과 같은 제한이 있다고 가정합니다:

5) 특정 IP 주소를 라우터 해시로 매핑할 수 없음. 이건 데이터베이스에 실시간으로 접근하는 것으로도 할 수 있는 것이지만, I2P에 맞추어 설계된 DPI 시스템이 필요합니다.

6) 프로토콜을 탐지하기 위한 타이밍 정보를 사용할 수 없음.

7) 일반적으로 Online DPI 도구 상자에는 I2P 감지를 위해 특별히 설계된 도구가 포함되어 있지 않습니다. 예를 들어 메시지에 비랜덤 패딩을 포함하는 "함정"을 만드는 것을 포함.

페이로드 분석에 대항하기 위해 모든 메시지가 무작위 데이터와 구별되지 않도록 보장됩니다. 이는 또한 메시지의 길이가 무작위여야 하여 더 복잡합니다. 사실 부록 A에서 저자는 단순한(즉, 균일한) 패딩 스킴이 문제를 해결하지 못한다고 주장합니다. 따라서 부록 A에서는 무작위 지연을 포함시키거나 제안된 공격에 대한 합리적인 보호를 제공할 수 있는 다른 패딩 스킴을 개발할 것을 제안하고 있습니다.

위 6번째 항목에 대한 보호를 위해 구현은 프로토콜 내에 무작위 지연을 포함시켜야 합니다. 이러한 기술은 이 제안서에 포함되지 않았지만, 패딩 길이 문제를 해결할 수도 있습니다. 요약하자면, 제안서는 페이로드 분석에 대한 좋은 보호를 제공하지만(부록 A의 고려 사항을 고려할 때), 흐름 분석에 대한 보호는 제한적입니다.


2) Offline DPI
``````````````

온라인 DPI가 저장한 데이터를 오프라인으로 검사하는 Offline DPI.
Offline DPI는 I2P를 감지하도록 특정하게 설계될 수 있습니다.
Offline DPI는 I2P 네트워크 데이터베이스에 실시간으로 접근할 수 있습니다.
Offline DPI는 이 및 다른 I2P 명세에 접근할 수 있습니다.
Offline DPI는 이 명세에 정의 된 모든 암호화 기능을 포함하여
무제한 계산 능력을 갖추고 있습니다.

Offline DPI는 기존 연결을 차단할 수 없습니다.  Offline DPI는
대상자들의 호스트/포트로 실시간(설정 후 몇 분 내에)
발신이 가능한 TCP RST를 보낼 수 있습니다.
원격 분석을 위해 기존 메시지를 재생(수정되거나 그렇지 않거나)할 수 있는
"탐침" 등으로 사용할 수 있습니다.

Offline DPI에 의해 프로토콜이 식별되지 않도록 하는 것이 목표가 아닙니다.
모든 1, 2 메시지의 데이터를 암호화된 데이터를
디코딩 할 수 있습니다. 이는 I2P 라우터에 의해 구현되며,
Offline DPI도 구현할 수 있습니다.

리플레이 된 기존 메시지를 사용하여 연결 시도를 거부하는 것이 목표입니다.


Future work
```````````

- 공격자가 패킷을 드롭하거나 순서를 변경할 때 프로토콜의 동작을 고려하십시오. 이 영역에서 최근의 흥미로운 연구가 [IACR-1150](https://eprint.iacr.org/2015/1150)에서 발견될 수 있습니다.

- 주제와 관련된 문헌을 참고하여 DPI 시스템의 보다 정확한 분류를 제공합니다.

- 제안된 프로토콜의 형식적인 보안을 논의하고, 가능하면 DPI 공격 모델을 고려합니다.


## Noise Protocol Framework

이 제안서는 Noise Protocol Framework [NOISE](http://noiseprotocol.org/) (개정 33, 2017-10-04)를 기반으로 요구 사항을 제공합니다.
Noise는 Station-To-Station 프로토콜과 유사한 속성을 갖추고 있습니다
[STS]_, 이 프로토콜이 [SSU](/en/docs/transport/ssu/) 프로토콜의 기반이 됩니다. Noise의 용어로, Alice는 이니시에이터이고, Bob은 리스폰더입니다.

NTCP2는 Noise_XK_25519_ChaChaPoly_SHA256 프로토콜을 기반으로 구축되었습니다.
(초기 키 유도 함수의 실제 식별자는
"I2P 확장을 나타내기 위한 Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256"입니다 - 아래 KDF 1 섹션 참조)
이 Noise 프로토콜은 다음 원시문을 사용합니다:

- 핸드셰이크 패턴: XK
  Alice는 자신의 키를 Bob에게 전송합니다 (X)
  Alice는 이미 Bob의 정적 키를 알고 있습니다 (K)

- DH 함수: X25519
  [RFC-7748](https://tools.ietf.org/html/rfc7748)에 명시된 32 바이트 길이의 X25519 DH가 사용됩니다.

- 암호 함수: ChaChaPoly
  [RFC-7539](https://tools.ietf.org/html/rfc7539) 섹션 2.8에 명시된 AEAD_CHACHA20_POLY1305가 사용됩니다.
  12 바이트 논스, 처음 4 바이트는 항상 0입니다.

- 해시 함수: SHA256
  표준 32 바이트 해시로, I2P에서 광범위하게 사용됩니다.


## Additions to the Framework

Noise_XK_25519_ChaChaPoly_SHA256의 다음 강화 기능을 정의합니다.
이들은 일반적으로 [NOISE](http://noiseprotocol.org/) 섹션 13의 지침을 따릅니다.

1) 명확한 임시 키는 알려진 키와 IV를 사용하여 AES 암호화를 통해 난독화됩니다.
   이는 elligator2보다 빠릅니다.

2) 메시지 1과 2에 임의의 명확한 패딩이 추가됩니다.
   명확한 패딩은 핸드셰이크 해시(MixHash) 계산에 포함됩니다.
   아래에서 메시지 2와 메시지 3의 부분 1에 대한 KDF를 참조하십시오.
   메시지 3과 데이터 페이즈 메시지에는 임의로 AEAD 패딩이 추가됩니다.

3) 데이터 페이즈 메시지에만 Noise over TCP에 필요한 두 바이트 프레임 길이 필드가 추가되며 obfs4에 있습니다.
   메시지 1과 2의 AEAD 프레임 길이는 고정 길이입니다.
   메시지 3의 부분 1 AEAD 프레임 길이는 고정 길이입니다.
   메시지 3의 부분 2 AEAD 프레임 길이는 메시지 1에 명시되어 있습니다.

4) 두 바이트 프레임 길이 필드는 SipHash-2-4을 사용하여 난독화 됩니다.
   obfs4에서와 같이.

5) 메시지 1, 2, 3 및 데이터 페이즈에 대한 페이로드 형식이 정의됩니다.
   물론, Noise에서는 정의되지 않습니다.


## New Cryptographic Primitives for I2P

기존 I2P 라우터 구현에서는
다음의 표준 암호학적 원시문을 필요로 합니다.
이는 현재 I2P 프로토콜에서는 필요 없었습니다:

1) X25519 키 생성 및 DH

2) AEAD_ChaCha20_Poly1305 (아래에서는 ChaChaPoly로 줄임)

3) SipHash-2-4


## Processing overhead estimate

세 메시지에 대한 메시지 크기:

1) 64 바이트 + 패딩   (NTCP는 288 바이트였습니다)
2) 64 바이트 + 패딩   (NTCP는 304 바이트였습니다)
3) 대략 64 바이트 + Alice 라우터 정보 + 패딩   평균 라우터 정보는 약 750
   바이트   패딩 전 평균 814 바이트 (NTCP는 448 바이트였습니다)
4) NTCP2에서는 필요 없음   (NTCP는 48 바이트였습니다)

패딩 전 합계:
NTCP2: 942 바이트
NTCP: 1088 바이트
Alice가 Bob에게 자신의 RouterInfo를 DatabaseStore 메시지로 전송하기 위해
연결을 설정한 경우 해당 메시지가 필요하지 않으므로
약 800 바이트를 절약합니다.

각 당사자가 핸드셰이크를 완료하고 데이터 페이즈를 시작하는 데 필요한 암호화 작업은 다음과 같습니다:

- AES: 2
- SHA256: 7 (Alice), 6 (Bob) (모든 연결에 대해 선계산되지 않은) (HMAC-SHA256 제외)
- HMAC-SHA256: 19
- ChaChaPoly: 4
- X25519 키 생성: 1
- X25519 DH: 3
- 서명 검증: 1 (Bob) (Alice는 RI를 생성할 때 이전에 서명함) 아마도 Ed25519 (RI 서명 형식에 따라 다름)


각 데이터 페이즈 메시지에 대한 각 당사자가 필요한 암호화 작업은 다음과 같습니다:

- SipHash: 1
- ChaChaPoly: 1



## Messages

모든 NTCP2 메시지는 길이가 65537 바이트를 초과하지 않습니다. 메시지
형식은 Noise 메시지를 기반으로 하며 프레이밍과 입농화
수정이 있습니다. 표준 Noise 라이브러리를 사용하는
구현은 받은 메시지를 미리 처리하여
Noise 메시지 형식으로 변환해야 할 수 있습니다. 모든
암호화된 필드는 AEAD
암호문입니다.


설립 시퀀스는 다음과 같습니다:

Alice                           Bob

  SessionRequest ------------------->
  <------------------- SessionCreated
  SessionConfirmed ----------------->
Noise 용어를 사용하여, 설립 및 데이터 시퀀스는 다음과 같습니다:
(페이로드 보안 속성)

XK(s, rs):           인증          기밀성
    <- s
    ...
    -> e, es                  0                2
    <- e, ee                  2                1
    -> s, se                  2                5
    <-                        2                5
세션이 설정되면 Alice와 Bob은 데이터 메시지를 교환할 수 있습니다.

모든 메시지 유형(SessionRequest, SessionCreated, SessionConfirmed, 데이터 및
TimeSync)이 이 섹션에서 지정됩니다.

일부 표기법::

  - RH_A = Alice의 라우터 해시 (32 바이트)
  - RH_B = Bob의 라우터 해시 (32 바이트)


### Authenticated Encryption

핸드셰이크 단계에서는 하나, 전송 및 수신을 위한 데이터 단계에서는 두 개의
별도 인증 암호화 인스턴스가 있습니다 (암호 상태).
각 설정에는 KDF에서 온 키가 있습니다.

암호화/인증된 데이터는 다음과 같이 표시됩니다 

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   암호화되고 인증된 데이터   |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
ChaCha20/Poly1305
`````````````````

암호화되고 인증된 데이터 형식.

암호화/복호화 함수의 입력:

k :: 32 바이트의 암호 키, KDF에서 생성됨

  nonce :: 카운터 기반 nonce, 12 바이트.
           각 메시지에 대해 0에서 시작하여 증가.
           처음 네 바이트는 항상 0.
           마지막 8 바이트는 카운터이며, 리틀 엔디언으로 인코딩됨.
           최대값은 2**64 - 2.
           그 값에 도달하면 연결을 삭제하고 다시 시작해야 합니다.
           값 2**64 - 1을 절대로 전송하지 마십시오.

  ad :: 핸드셰이크 단계에서:
        관련 데이터, 32 바이트.
        모든 이전 데이터의 SHA256 해시.
        데이터 단계에서는:
        0 바이트

  data :: 평문 데이터, 0 바이트 이상

암호화 함수의 출력, 복호화 함수의 입력:

+----+----+----+----+----+----+----+----+
  |난독화 길이 |                             |
  +----+----+                             +
  |       ChaCha20 암호화된 데이터         |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 메시지 인증 코드 |
  +              (MAC)                    +
  |             16 바이트                  |
  +----+----+----+----+----+----+----+----+

  난독화 길이 :: (암호화된 데이터 + MAC)의 길이, 16 - 65535
              SipHash를 사용하여 난독화 (아래 참조)
              메시지 1, 2 또는 메시지 3의 부분 1에서는 사용되지 않음, 길이는 고정됨
              메시지 3의 일부 1에서는 사용되지 않음, 길이는 메시지 1에 지정됨

  암호화된 데이터 :: 평문과 같은 크기, 0 - 65519 바이트

  MAC :: Poly1305 메시지 인증 코드, 16 바이트

ChaCha20에 대한 설명은 [RFC-7539](https://tools.ietf.org/html/rfc7539)에 해당하며,
TLS에서는 유사하게 사용됩니다 [RFC-7905](https://tools.ietf.org/html/rfc7905).

Notes
`````
- ChaCha20는 스트림 암호이므로, 평문이 패딩될 필요 없습니다.
  추가적인 키 스트림 바이트는 버려집니다.

- 암호의 키 (256 비트)는 SHA256 KDF를 통해 합의됩니다.
  각 메시지에 대한 KDF의 세부 사항은 아래의 별도 섹션에 있습니다.

- 메시지 1, 2 및 메시지 3의 첫 번째 부분에 대한 ChaChaPoly 프레임은 고정 크기입니다. 메시지 3의 두 번째 부분부터 프레임 크기는 가변입니다. 메시지 3의 부분 1 크기는 메시지 1에 지정되었습니다. 데이터 단계부터 프레임은 obfus4처럼 SipHash로 난독화된 두 바이트 길이를 선행합니다.

- 패딩은 메시지 1, 2의 인증된 데이터 프레임 밖에 있습니다. 패딩은 다음 메시지에 대한 KDF에서 사용됩니다. 따라서 변경이 발생하면 다음 메시지가 실패합니다. 메시지 3부터는 패딩이 인증된 데이터 프레임 안에 있습니다.


AEAD Error Handling
```````````````````
- 메시지 1, 2 및 메시지 3의 부분 1과 2에서 AEAD 메시지의 크기는 사전에 알려져 있습니다. AEAD 인증 실패 시 수신자는 메시지 처리를 중단하고 응답 없이 연결을 닫아야 합니다. 이것은 비정상적인 종료(TCP RST)이어야 합니다.

- 탐침 저항성에서 메시지 1에서 AEAD 실패 후 Bob은 타임아웃을 임의로 설정해야 하며(범위 TBD), 소켓을 닫기 전에 임의의 바이트 수(범위 TBD)를 읽어야 합니다. Bob은 반복적인 실패가 있는 IP의 블랙리스트를 유지해야 합니다.

- 데이터 페이즈에서 AEAD 메시지 크기는 SipHash로 "암호화"됩니다. 디코딩 오라클을 만들지 않도록 주의하십시오. 데이터 페이즈 AEAD 인증 실패 시 수신자는 타임아웃(범위 TBD)을 무작위로 설정하고 읽기 타임아웃 후 무작위로 바이트 수(범위 TBD)를 읽어야 합니다. 읽기 후 또는 읽기 타임아웃 시 수신자는 "AEAD 실패" 이유 코드가 포함된 종료 블록을 포함하는 페이로드를 보내고 연결을 닫아야 합니다.

- 데이터 페이즈에서 잘못된 길이 필드 값에 대해 동일한 오류 조치를 취하십시오.


### Key Derivation Function (KDF) (for handshake message 1)

이 KDF는 DH 결과로부터 핸드셰이크 페이즈 암호 키 k를 생성합니다.
[RFC-2104](https://tools.ietf.org/html/rfc2104)에 정의된 HMAC-SHA256(key, data)를 사용하여 생성됩니다.
이는 Noise 사양에서 정의된 그대로의 InitializeSymmetric(), MixHash(), 그리고 MixKey() 함수들입니다.

다음은 "e" 메시지 패턴입니다:

  // protocol_name을 정의합니다.
  Set protocol_name = "Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256"
   (48 바이트, US-ASCII로 인코딩된, NULL 종료 없음).

  // Hash h = 32 바이트를 정의합니다.
  h = SHA256(protocol_name);

  체인 키를 정의합니다. 32 바이트. h 데이터를 ck에 복사합니다.
  Set ck = h

  rs를 정의합니다. Bob의 32-byte 정적 키는 RouterInfo에 게시됨.

  // MixHash(null prologue)
  h = SHA256(h);

  // 여기까지는 모두 Alice에 의해 모든 연결에 대해 선계산될 수 있습니다.

  // Bob은 여기서 자신의 정적 키가 커브 위의 유효한 점인지 검증해야 합니다.

  // Bob 정적 키
  // MixHash(rs)
  // || 아래는 붙임을 의미합니다.
  h = SHA256(h || rs);

  // 여기까지는 모두 Bob에 의해 모든 수신 연결에 대해 선계산될 수 있습니다.

  다음은 "e" 메시지 패턴입니다:

  Alice는 자신의 임시 DH 키 쌍 e를 생성합니다.

  // Alice 임시 키 X
  // MixHash(e.pubkey)
  // || 아래는 붙임을 의미합니다.
  h = SHA256(h || e.pubkey);

  // h는 메시지 1에서 AEAD의 관련 데이터로 사용됩니다.
  // 메시지 2의 KDF를 위해 Hash h를 유지합니다.


  여기서 "e" 메시지 패턴이 끝납니다.

  다음은 "es" 메시지 패턴입니다:

  // DH(e, rs) == DH(s, re)
  입력 키 자료를 정의합니다. Alice의 임시 키와 Bob의 정적 키 간의 32 바이트 DH 결과.
  Set input_key_material = X25519 DH 결과

  // MixKey(DH())

  임시 키(temp_key)를 정의합니다. 32 바이트.
  [RFC-2104](https://tools.ietf.org/html/rfc2104)에 따른 HMAC-SHA256(key, data)을 정의합니다.
  // 체인링 키와 DH 결과로부터 임시 키를 생성합니다.
  // ck는 위에서 정의한 체인링 키입니다.
  temp_key = HMAC-SHA256(ck, input_key_material)
  // 더 이상 필요 없는 메모리의 DH 결과를 덮어씁니다.
  input_key_material = (전부 0으로 설정)

  // 출력 1
  // 임시 키로부터 체인링 키를 설정합니다.
  // byte()는 아래의 경우 단일 바이트를 의미합니다.
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // 출력 2
  // 암호 키 k 생성을 시작합니다.
  k를 정의합니다. 32 바이트.
  // || 아래는 붙임을 의미합니다.
  // byte()는 아래의 경우 단일 바이트를 의미합니다.
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
  // 메모리에서 더 이상 필요없는 임시 키를 덮어씁니다.
  temp_key = (전부 0으로 설정)

  // 메시지 2 KDF를 위한 체인링 키 ck를 유지합니다.


  여기서 "es" 메시지 패턴이 끝납니다.

### 1) SessionRequest

Alice가 Bob에게 전송합니다.

Noise 내용: Alice의 임시 키 X
Noise 페이로드: 16 바이트 옵션 블록
비-노이즈 페이로드: 무작위 패딩

(페이로드 보안 속성)

XK(s, rs):           인증          기밀성
    -> e, es                  0                2

    인증: 없음 (0).
    이 페이로드는 어떤 당사자에 의해 보내졌을 수 있으며, 심지어 적극적인 공격자도 포함됩니다.

    기밀성: 2.
    알려진 수신자로의 암호화, 전방 비밀성은 보낸 사람 손실의 경우에만 발생함, 재생에 취약. 이 페이로드는 수신자의 정적 키 쌍을 포함하는 DH에만 기반하여 암호화되었습니다. 수신자의 정적 개인 키가 손상되면(심지어 이후라도) 이 페이로드가 해독될 수 있습니다. 또한, 수신자의 임시 기여물이 없기 때문에 이 메시지는 재생될 수도 있습니다.

    "e": Alice는 새로 임시 키 쌍을 생성하고 e
         변수에 저장합니다. 임시 공개 키를 메시지 버퍼에
         명확한 텍스트로 작성하고, 이전 h와 함께 공개 키를 해싱하여
         새로운 h를 유도합니다.

    "es": DH는 Alice의 임시 키 쌍과 Bob의
          정적 키 쌍 사이에서 수행됩니다. 그 결과는
          이전의 ck와 함께 해싱되어 새로운 ck와 k를 유도하며 n은
          0으로 설정됩니다.


X 값은 페이로드 입농구의 구별 가능성과 유일성을 보장하기 위해 암호화됩니다.
우리는 이를 달성하기 위해 AES 암호화를 사용하며,
더 복잡하고 느린 대안인 elligator2를 사용하지 않았습니다.
Bob의 라우터 공개 키로 비대칭 암호화는 너무 느립니다.
AES 암호화는 Bob의 라우터 해시를 키로 하고, 네트워크 데이터베이스에 게시된 Bob의 IV를 사용합니다.

AES 암호화는 오직 DPI 저항을 위한 것입니다.
Bob의 라우터 해시 및 IV를 알고 있는 모든 당사자는,
네트워크 데이터베이스에 게시된 것으로, 이 메시지에서 X 값을 해독할 수 있습니다.

패딩은 Alice에 의해 암호화되지 않습니다.
Bob이 타이밍 공격을 억제하기 위해 패딩을 해독해야 할 수도 있습니다.


세부 내용:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        RH_B로 난독화됨           +
  |       AES-CBC-256으로 암호화된 X         |
  +             (32 바이트)                +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaChaPoly 프레임                    |
  +             (32 바이트)                +
  |   K는 메시지 1의 KDF에서 정의됨      |
  +   n = 0                               +
  |   관련 데이터는 KDF 참조              |
  +----+----+----+----+----+----+----+----+
  |     암호화되지 않은 인증된 패딩         |
  ~         패딩 길이는 옵션 블록에 정의됨  ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  X :: 32 바이트, AES-256-CBC 암호화된 X25519 임시 키, 리틀 엔디언
          키: RH_B
          IV: Bobs 네트워크 데이터베이스 항목에 게시된 대로

  패딩 :: 무작위 데이터, 0 바이트 이상.
             총 메시지 길이는 65535 바이트 이하이어야 합니다.
             총 메시지 길이는 287 바이트 이하이어야 합니다.
             Bob이 자신의 주소를 NTCP로 게시하는 경우입니다
             (아래 버전 감지 섹션 참조).
             Alice 및 Bob은 메시지 2의 KDF에서 패딩 데이터를 사용합니다.
             그게 인증된 것이므로, 어떤 변경이 발생하면
             다음 메시지가 실패하게 될 것입니다.

암호화되지 않은 데이터 (Poly1305 인증 태그는 표시되지 않음):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                   X                   |
  +              (32 바이트)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               옵션                 |
  +              (16 바이트)               +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     암호화되지 않은 인증된 패딩         |
  +         패딩 (선택적)            +
  |     패딩 길이는 옵션 블록에 정의됨   |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  X :: 32 바이트, X25519 임시 키, 리틀 엔디언

  옵션 :: 옵션 블록, 16 바이트, 아래 참조

  패딩 :: 무작위 데이터, 0 바이트 이상.
             총 메시지 길이는 65535 바이트 이하이어야 합니다.
             Bob이 자신의 주소를 "NTCP"로
             게시하는 경우 총 메시지 길이는 287 바이트 이하이어야 합니다
             (아래 버전 감지 섹션 참조)
             Alice 및 Bob은 메시지 2의 KDF에서 패딩 데이터를 사용합니다.
             그게 인증된 것이므로, 어떤 변경이 발생하면
             다음 메시지가 실패하게 될 것입니다.

옵션 블록:
참고: 모든 필드는 빅 엔디언입니다.

+----+----+----+----+----+----+----+----+
  | id | ver|  padLen | m3p2len | Rsvd(0) |
  +----+----+----+----+----+----+----+----+
  |        tsA        |   Reserved (0)    |
  +----+----+----+----+----+----+----+----+

  id :: 1 바이트, 네트워크 ID (현재 2, 테스트 네트워크 제외)
        0.9.42부터. 제안 147 참조.

  ver :: 1 바이트, 프로토콜 버전 (현재 2)

  padLen :: 2 바이트, 패딩의 길이, 0 이상
            최소/최대 가이드라인 TBD. 최소 0부터 31까지의 무작위 크기?
            (분포는 결정되어야 함, 부록 A 참조)

  m3p2Len :: 2 바이트, SessionConfirmed의 두 번째 AEAD 프레임의 길이
             (메시지 3의 부분 2) 아래 주석 참조

  Rsvd :: 2 바이트, 미래의 옵션과의 호환성을 위해 0으로 설정

  tsA :: 4 바이트, Unix 타임스탬프, unsigned 초.
         2106에 랩 어라운드됨

  Reserved :: 4 바이트, 미래의 옵션과의 호환성을 위해 0으로 설정

노트
`````
- 발행된 주소가 "NTCP"일 경우, Bob은 동일한 포트에서 NTCP 및 NTCP2를 모두 지원합니다. 호환성을 위해, Alice는 "NTCP"로 게시된 주소에 대한 연결을 시작할 때, 패딩을 포함한 이 메시지의 최대 크기를 287 바이트 이하로 제한해야 합니다. 이는 Bob이 자동으로 프로토콜을 식별할 수 있게 해줍니다. "NTCP2"로 게시된 경우, 크기에 제한이 없습니다. 발행된 주소 및 버전 감지 섹션을 참조하세요.

- 초기에 AES 블록 내의 고유한 X 값은 각 세션에 대해 암호화 내용을 다르게 보장합니다.

- Bob은 타임스탬프 값이 현재 시간과 너무 차이가 클 경우 연결을 거부해야 합니다. 최대 델타 시간을 "D"라고 합시다. Bob은 이전에 사용한 핸드셰이크 값을 로컬 캐시에 유지하고 중복을 거부하여 재생 공격을 방지해야 합니다. 캐시 값은 최소 2*D의 수명을 가져야 합니다. 캐시 값은 구현에 의존하며, 32 바이트 X 값(또는 암호화된 equivalent)이 사용될 수 있습니다.

- Diffie-Hellman 임시 키는 절대로 재사용할 수 없으며, 암호학적 공격을 방지하고 재사용은 재생 공격으로 거부됩니다.

- "KE" 와 "auth" 옵션은 호환 가능해야 하며, 즉 공유 비밀 K는 적절한 크기여야 합니다. 추가 "auth" 옵션이 추가되면 이는 다른 KDF 또는 다른 트렁크 크기를 사용하도록 "KE" 플래그의 의미를 암묵적으로 변경할 수 있습니다.

- Bob은 Alice의 임시 키가 커브 위의 유효한 점인지 확인해야 합니다.

- 패딩은 합리적인 양으로 제한되어야 합니다. Bob은 지나치게 많은 패딩이 있는 연결을 거부할 수 있습니다. Bob은 메시지 2에서 자신의 패딩 옵션을 지정할 것입니다. 최소/최대 가이드라인 TBD. 최소 0에서 31 바이트까지의 무작위 크기? (분포는 결정되어야 함, 부록 A 참조)

- 오류가 발생할 경우, AEAD, DH, 타임스탬프, 명백한 재생, 또는 키 유효성 확인 실패를 포함하여, Bob은 추가 메시지 처리를 중단하고 응답 없이 연결을 닫아야 합니다. 이것은 비정상적인 닫기(TCP RST)이어야 합니다. 탐침 저항성에서 AEAD 실패 후 Bob은 소켓을 닫기 전에 타임아웃을 임의로 설정해야 하며(범위 TBD), 임의의 바이트 수(범위 TBD)를 읽어야 합니다.

- DoS 완화: DH는 상대적으로 비싼 작업입니다. 이전 NTCP 프로토콜과 마찬가지로, 라우터는 CPU 또는 연결 고갈을 방지하기 위해 필요한 모든 조치를 취해야 합니다. 최대 활성 연결 및 최대 진행 중인 연결 설정에 대한 제한을 설정합니다. 읽기 시간 제한(단위 읽기 및 "slowloris"에 대한 총)을 적용합니다. 동일한 출처에서 반복되거나 동시에 연결하는 것을 제한합니다. 반복적으로 실패하는 출처를 위한 블랙리스트를 유지합니다. AEAD 실패에 응답하지 않습니다.

- 빠른 버전 감지 및 핸드셰이킹을 용이하게 하기 위해 구현은 Alice가 처음 메시지 전체 내용을 버퍼링한 다음 패딩을 포함하여 한 번에 플러시하도록 보장해야 합니다. 이는 데이터가 단일 TCP 패킷에 포함될 가능성을 증가시킵니다(OS 또는 미들 박스에 의해 분할되지 않는 경우), 그리고 Bob은 한 번에 모든 데이터를 받을 것입니다. 이는 또한 효율성을 위해서이며, 무작위 패딩의 효과를 보장하기 위해서입니다. 이는 NTCP 및 NTCP2 핸드셰이크 모두에 적용됩니다.

- "ver" 필드: 전체 Noise 프로토콜, 확장, NTCP 프로토콜 포함 페이로드 사양, NTCP2를 나타냅니다. 이 필드는 향후 변경 사항에 대한 지원을 나타내기 위해 사용할 수 있습니다.

- 메시지 3 부분 2 길이: 이것은 두 번째 AEAD 프레임의 크기(16 바이트 MAC 포함)로서, 메시지 1에서 Alice가 보낸 Alice의 라우터 정보와 선택적 패딩을 포함합니다. 라우터는 주기적으로 자신의 RouterInfo를 재생성하고 게시하므로, 메시지 3이 전송되기 전까지의 현재 RouterInfo의 크기가 변경될 수 있습니다. 구현은 두 가지 전략 중 하나를 선택해야 합니다: a) 보내려고 하는 현재 RouterInfo를 저장하여 크기가 알려지게 하고, 선택적으로 패딩에 대한 여유 공간을 추가합니다; b) RouterInfo 크기의 가능성 있는 증가를 허용하도록 크기를 증가시키고, 메시지 3이 실제로 전송될 때 항상 패딩을 추가합니다. 어느 쪽이든, 메시지 1에 포함된 "m3p2len" 길이는 실제로 메시지 3에 보낼 때 그 프레임의 크기여야 합니다.

- Bob은 메시지 1을 검증하고 패딩을 읽은 후 남아있는 데이터가 있는 경우 연결을 실패해야 합니다. 겉보기에는 Alice의 추가 데이터가 없어야 합니다, Bob은 아직 메시지 2로 응답하지 않았으므로.

- 네트워크 ID 필드는 교차 네트워크 연결을 빠르게 식별하는데 사용됩니다. 만약 이 필드가 0이 아니고, Bob의 네트워크 ID와 일치하지 않으면, Bob은 연결을 해제하고 향후 연결을 차단해야 합니다. 0.9.42부터. 제안 147에 대한 자세한 정보는 확인하십시오.



### Key Derivation Function (KDF) (for handshake message 2 and message 3 part 1)

```
// 메시지 1 KDF에서 h를 저장했습니다.
// MixHash(ciphertext)
h = SHA256(h || 메시지 1에서 32 바이트 암호화된 페이로드)

// MixHash(padding)
// 패딩 길이가 0이 아닐 때만
h = SHA256(h || 메시지 1에서 무작위 패딩)

여기는 "e" 메시지 패턴입니다:

Bob은 자신의 임시 DH 키 쌍 e를 생성합니다.

// h는 메시지 1 KDF에서 가져온 것입니다.
// Bob의 임시 키 Y
// MixHash(e.pubkey)
// || 아래는 추가를 의미합니다.
h = SHA256(h || e.pubkey);

// h는 메시지 2에서 AEAD의 관련 데이터로 사용됩니다.
// 메시지 3의 KDF를 위해 Hash h를 유지합니다.

여기서 "e" 메시지 패턴이 끝납니다.

여기는 "ee" 메시지 패턴입니다:

// DH(e, re)
입력 키 자료를 정의합니다. Alice의 임시 키와 Bob의 임시 키 간의 32 바이트 DH 결과.
Set input_key_material = X25519 DH 결과
// 메모리에서 더 이상 필요없는 Alice의 임시 키를 덮어씁니다.
// Alice:
e(공개 및 개인) = (전부 0으로 설정)
// Bob:
re = (전부 0으로 설정)

// MixKey(DH())

임시 키(temp_key)를 정의합니다. 32 바이트.
[RFC-2104](https://tools.ietf.org/html/rfc2104)에 따른 HMAC-SHA256(key, data)을 정의합니다.
// 체인링 키와 DH 결과로부터 임시 키를 생성합니다.
// ck는 핸드셰이크 메시지 1의 KDF로부터 온 체인링 키입니다.
temp_key = HMAC-SHA256(ck, input_key_material)
// 더 이상 필요 없는 메모리의 DH 결과를 덮어씁니다.
input_key_material = (전부 0으로 설정)

// 출력 1
// 임시 키로부터 체인링 키를 설정합니다.
// byte()는 아래의 경우 단일 바이트를 의미합니다.
ck =       HMAC-SHA256(temp_key, byte(0x01)).

// 출력 2
// 암호 키 k 생성을 시작합니다.
k를 정의합니다. 32 바이트.
// || 아래는 추가를 의미합니다.
// byte()는 아래의 경우 단일 바이트를 의미합니다.
k =        HMAC-SHA256(temp_key, ck || byte(0x02)).
// 메모리에서 더 이상 필요없는 임시 키를 덮어씁니다.
temp_key = (전부 0으로 설정)

// 메시지 3의 KDF를 위해 체인링 키 ck를 유지합니다.

여기서 "ee" 메시지 패턴이 끝납니다.
```

### 2) SessionCreated

Bob이 Alice에게 보냅니다.

Noise 내용: Bob의 임시 키 Y
Noise 페이로드: 16 바이트 옵션 블록
비-노이즈 페이로드: 무작위 패딩

(페이로드 보안 속성)

XK(s, rs):           인증          기밀성
    <- e, ee                  2                1

    인증: 2.
    키-손상 위조 불가능한 보낸 사람 인증.
    보낸 사람 인증은 수신자의 임시 키 쌍과의 임시-정적 DH("es" 또는 "se")에 기반합니다.
    해당하는 개인 키가 안전하다고 가정하면, 이 인증은 위조될 수 없습니다.

    기밀성: 1.
    임시 수신자로의 암호화.
    이 페이로드는 임시-임시 DH("ee")를 포함하므로, 전방 보안성을 갖추고 있습니다.
    그러나, 보낸 사람은 수신자를 인증하지 않았고,
    이 페이로드가 모든 당사자, 심지어는 적극적인 공격자에게 전송되었을 가능성이 있습니다.


    "e": Bob은 새로운 임시 키 쌍을 생성하고 e 변수에 저장합니다.
    임시 공개 키를 메시지 버퍼에 명확한 텍스트로 작성하고,
    공개 키를 이전 h와 함께 해싱하여 새로운 h를 유도합니다.

    "ee": DH는 Bob의 임시 키 쌍과 Alice의 임시 키 쌍 사이에서 수행됩니다.
    그 결과는 이전의 ck와 함께 해싱되어 새로운 ck와 k를 유도하며, n은 0으로 설정됩니다.

Y 값은 페이로드 식별 불가성과 고유성을 보장하기 위해 암호화됩니다.
우리는 이를 달성하기 위해 AES 암호화를 사용하며,
더 복잡하고 느린 대안인 elligator2를 사용하지 않았습니다.
Alice의 라우터 공개 키로 비대칭 암호화는 너무 느립니다.
AES 암호화는 네트워크 데이터베이스에 게시된 Bob의 라우터 해시를 키로
사용하고 메시지 1에서 초기화된 AES 상태를 사용합니다.

AES 암호화는 DPI 저항성을 위한 것만입니다.
Bob의 라우터 해시와 IV를 알고,
메시지 1의 첫 32 바이트를 캡처한 모든 당사자는
이 메시지에서 Y 값을 해독할 수 있습니다.


세부 내용:

+----+----+----+----+----+----+----+----+
  |                                       |
  +        RH_B로 난독화됨           +
  |       AES-CBC-256으로 암호화된 Y         |
  +              (32 바이트)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |   ChaChaPoly 프레임                    |
  +   암호화되고 인증된 데이터    +
  |   32 바이트                            |
  +   k는 메시지 2의 KDF에서 정의됨      +
  |   n = 0, 관련 데이터는 KDF 참조          |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     암호화되지 않은 인증된 패딩         |
  +         패딩 (선택적)            +
  |     패딩 길이는 옵션 블록에 정의됨   |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 바이트, AES-256-CBC 암호화된 X25519 임시 키, 리틀 엔디언
          키: RH_B
          IV: 메시지 1에서 AES 상태를 사용

암호화되지 않은 데이터 (Poly1305 인증 태그는 표시되지 않음):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                  Y                    |
  +              (32 바이트)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |               옵션                 |
  +              (16 바이트)               +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     암호화되지 않은 인증된 패딩         |
  +         패딩 (선택적)            +
  |     패딩 길이는 옵션 블록에 정의됨   |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 바이트, X25519 임시 키, 리틀 엔디언

  옵션 :: 옵션 블록, 16 바이트, 아래 참조

  패딩 :: 무작위 데이터, 0 바이트 이상.
             총 메시지 길이는 65535 바이트 이하이어야 합니다.
             Alice 및 Bob은 메시지 3의 부분 1에 KDF로 패딩 데이터를 사용합니다.
             그게 인증된 것이므로, 어떤 변경이 발생하면
             다음 메시지가 실패하게 될 것입니다.

Notes
`````

- Alice는 여기에서 Bob의 임시 키가 커브 위의 유효한 점인지 확인해야 합니다.

- 패딩은 합리적인 양으로 제한되어야 합니다.
  Alice는 지나치게 많은 패딩이 있는 연결을 거부할 수 있습니다.
  Alice는 메시지 3에서 자신의 패딩 옵션을 지정할 것입니다.
  최소/최대 가이드라인 TBD. 최소 0에서 31 바이트까지의 무작위 크기?
  (분포는 결정되어야 함, 부록 A 참조)

- 오류가 발생할 경우, AEAD, DH, 타임스탬프, 명백한 재생, 또는 키 유효성 확인 실패를 포함하여, Alice는 추가 메시지 처리를 중단하고 응답 없이 연결을 닫아야 합니다. 이것은 비정상적인 닫기 (TCP RST)이어야 합니다.

- 신속한 핸드셰이크를 촉진하기 위해 구현은 Bob이 처음 메시지의 전체 내용을 버퍼링한 다음 패딩까지 모두 한 번에 플러시하도록 보장해야 합니다. 이는 데이터가 단일 TCP 패킷에 포함될 가능성을 증가시킵니다(OS 또는 미들박스에 의해 분할되지 않은 경우), 그리고 Clint이 한 번에 모든 데이터를 받을 것입니다. 이는 또한 효율성을 위해서이며, 무작위 패딩의 효과를 보장하기 위해서입니다.

- Alice는 메시지 2를 검증하고 패딩을 읽는 후 남아있는 데이터가 있는 경우 연결을 실패해야 합니다. 겉보기에는 Bob의 추가 데이터가 없어야 하며, Alice는 아직 메시지 3으로 응답하지 않았으므로.


옵션 블록:
참고: 모든 필드는 빅 엔디언입니다.

+----+----+----+----+----+----+----+----+
  | Rsvd(0) | padLen  |   Reserved (0)    |
  +----+----+----+----+----+----+----+----+
  |        tsB        |   Reserved (0)    |
  +----+----+----+----+----+----+----+----+

  Reserved :: 10 바이트 총, 미래의 옵션과의 호환성을 위해 0으로 설정

  padLen :: 2 바이트, 빅 엔디언, 패딩의 길이, 0 이상
            최소/최대 가이드라인 TBD. 최소 0에서 31까지의 무작위 크기?
            (분포는 결정되어야 함, 부록 A 참조)

  tsB :: 4 바이트, 빅 엔디언, Unix 타임스탬프, unsigned 초.
         2106에 랩 어라운드됨

노트
`````
- Alice는 타임스탬프 값이 현재 시간과 너무 차이가 큰 경우 연결을 거부해야 합니다. 최대 델타 시간을 "D"라고 합시다. Alice는 이전에 사용한 핸드셰이크 값을 로컬 캐시에 유지하고 중복을 거부하여 재생 공격을 방지해야 합니다. 캐시 값은 최소 2*D의 수명을 가져야 합니다. 캐시 값은 구현에 의존하며, 32 바이트 Y 값 (또는 암호화된 equivalent)이 사용될 수 있습니다.

Issues
``````
- 여기의 최소/최대 패딩 옵션을 포함하시겠습니까?



### Encryption for for handshake message 3 part 1, using message 2 KDF)

```
// 메시지 2 KDF에서 h를 가져옵니다.
// MixHash(ciphertext)
h = SHA256(h || 메시지 2의 24 바이트 암호화된 페이로드)

// MixHash(padding)
// 패딩 길이가 0이 아닐 때만
h = SHA256(h || 메시지 2에서 무작위 패딩)
// 메시지 3 부분 1에서 AEAD의 관련 데이터로 사용되는 h

여기는 "s" 메시지 패턴입니다:

s = Alice의 정적 공개 키를 정의합니다, 32 바이트입니다.

// EncryptAndHash(s.publickey)
// EncryptWithAd(h, s.publickey)
// AEAD_ChaCha20_Poly1305(key, nonce, associatedData, data)
// k는 메시지 1에서 받았습니다.
// n은 1입니다.
ciphertext = AEAD_ChaCha20_Poly1305(k, n++, h, s.publickey)
// MixHash(ciphertext)
// || 아래는 추가를 의미합니다.
h = SHA256(h || ciphertext);

// 메시지 3 부분 2에서 AEAD의 관련 데이터로 사용되는 h

엔드 오브 "s" 메시지 패턴.
```

### Key Derivation Function (KDF) (for handshake message 3 part 2)

여기는 "se" 메시지 패턴입니다:

  // DH(s, re) == DH(e, rs)
  입력 키 자료를 정의합니다. Alice의 정적 키와 Bob의 임시 키 간의 32 바이트 DH 결과.
  Set input_key_material = X25519 DH 결과
  // 메모리에서 더 이상 필요없는 Bob의 임시 키를 덮어씁니다.
  // Alice:
  re = (전부 0으로 설정)
  // Bob:
  e(공개 및 개인) = (전부 0으로 설정)

  // MixKey(DH())

  임시 키(temp_key)를 정의합니다. 32 바이트.
  [RFC-2104](https://tools.ietf.org/html/rfc2104)에 따른 HMAC-SHA256(key, data)을 정의합니다.
  // 체인링 키와 DH 결과로부터 임시 키를 생성합니다.
  // ck는 핸드셰이크 메시지 1의 KDF로부터 온 체인링 키입니다.
  temp_key = HMAC-SHA256(ck, input_key_material)
  // 더 이상 필요없는 메모리의 DH 결과를 덮어씁니다.
  input_key_material = (전부 0으로 설정)

  // 출력 1
  // 임시 키로부터 체인링 키를 설정합니다.
  // byte()는 아래의 경우 단일 바이트를 의미합니다.
  ck =       HMAC-SHA256(temp_key, byte(0x01)).

  // 출력 2
  // 암호 키 k 생성을 시작합니다.
  k를 정의합니다. 32 바이트.
  // || 아래는 추가를 의미합니다.
  // byte()는 아래의 경우 단일 바이트를 의미합니다.
  k =        HMAC-SHA256(temp_key, ck || byte(0x02)).

  // h는 메시지 3 부분 2에서 AEAD의 관련 데이터로 사용됩니다.

  // EncryptAndHash(payload)
  // EncryptWithAd(h, payload)
  // AEAD_ChaCha20_Poly1305(key, nonce, associatedData, data)
  // n은 0입니다.
  ciphertext = AEAD_ChaCha20_Poly1305(k, n++, h, payload)
  // MixHash(ciphertext)
  // || 아래는 추가를 의미합니다.
  h = SHA256(h || ciphertext);

  // 데이터 페이즈 KDF에 대한 체인링 키 ck를 유지합니다.
  // 데이터 페이즈 추가 대칭 키 (SipHash) KDF에 대한 해시 h를 유지합니다.

  여기는 "se" 메시지 패턴의 끝입니다.

  // 메모리에서 필요 없는 임시 키를 덮어 씁니다.
  temp_key = (전부 0으로 설정)

### 3) SessionConfirmed

Alice가 Bob에게 보냅니다.

Noise 내용: Alice의 정적 키
Noise 페이로드: Alice의 RouterInfo와 무작위 패딩
비-노이즈 페이로드: 없음

(페이로드 보안 속성)


XK(s, rs):           인증          기밀성
    -> s, se                  2                5

    인증: 2.
    키-손상 위조 불가능한 보낸 사람 인증. 보낸 사람이 수신자의 임시 키 쌍과의 임시-정적 DH("es" 또는 "se")에 기반한 인증입니다. 해당 개인 키가 안전하면, 이 인증은 조작할 수 없습니다.

    기밀성: 5.
    잘 알려진 수신자에게 암호화, 강력한 순방향 비밀성. 이 페이로드는 임시-임시 DH 및 수신자의 정적 키 쌍과의 임시-정적 DH에 기반으로 암호화됩니다. 임시 개인 키가 안전하고, 수신자가 공격자에 의해 역활되어지지 않은 것으로 가정할 때, 이 페이로드는 해독될 수 없습니다.

    "s": Alice는 메시지 버퍼에 s 변수에서 자신의 정적 공개 키를 작성하고, 암호화 후 출력물을 해싱하여 이전 h와 함께 새로운 h를 유도합니다.

    "se": DH는 Alice의 정적 키 쌍과 Bob의 임시 키 쌍 사이에서 수행됩니다. 이 결과는 이전의 ck와 함께 해싱되어 새로운 ck와 k를 유도하며, n은 0으로 설정됩니다.

이 메시지는 두 개의 ChaChaPoly 프레임을 포함합니다.
첫 번째는 Alice의 암호화된 정적 공개 키입니다.
두 번째는 Noise 페이로드: Alice의 암호화된 RouterInfo, 선택적
옵션, 그리고 선택적 패딩입니다. 서로 다른 키를 사용합니다, 왜냐하면 MixKey()
함수가 그 사이에 호출되었습니다.


세부 내용:

+----+----+----+----+----+----+----+----+
  |                                       |
  +   ChaChaPoly 프레임 (48 바이트)         +
  |   암호화되고 인증된           |
  +   Alice 정적 키 S               +
  |      (32 바이트)                       |
  +                                       +
  |     k는 메시지 2의 KDF에서 정의       |
  +     n = 1                             +
  |     관련 데이터는 KDF에서 참조됨     |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +     메시지 1에서 지정한 길이           +
  |                                       |
  +   ChaChaPoly 프레임                    +
  |   암호화되고 인증된           |
  +                                       +
  |       Alice RouterInfo                |
  +       블록 형식 2 사용         +
  |       Alice 옵션 (선택적)        |
  +       블록 형식 1 사용         +
  |       임의의 패딩               |
  +       블록 형식 254 사용       +
  |                                       |
  +                                       +
  | k는 메시지 3 부분 2의 KDF에 정의됨      |
  +     n = 0                             +
  |     관련 데이터는 KDF에서 참조됨     |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  S :: 32 바이트, ChaChaPoly로 암호화된 Alice의 X25519 정적 키, 리틀 엔디언
       48 바이트 ChaChaPoly 프레임 내

암호화되지 않은 데이터 (Poly1305 인증 태그는 표시되지 않음):

+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |              S                        |
  +       Alice 정적 키                +
  |          (32 바이트)                   |
  +                                       +
  |                                       |
  +                                       +
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                                       |
  +                                       +
  |       Alice RouterInfo 블록        |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       선택적 옵션 블록          +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       선택적 패딩 블록          +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  S :: 32 바이트, Alice의 X25519 정적 키, 리틀 엔디언


Notes
`````
- Bob은 일반적인 Router Info 검증을 수행해야 합니다.
  서명 유형이 지원되는지 확인하고, 서명을 검증하고,
  타임스탬프가 경계 내에 있는지 확인하며, 필요한 다른 검사도 수행해야 합니다.

- Bob은 메시지의 첫 번째 프레임에서 받은 Alice의 정적 키가
  Router Info의 정적 키와 일치하는지 확인해야 합니다. Bob은 먼저 Router Info에서
  일치하는 버전(v) 옵션이 있는 NTCP 또는 NTCP2 Router Address를 검색해야 합니다.
  발행된 Router Info 및 미발행 Router Info 섹션을 참조하세요.

- Bob은 자신의 netdb에서 Alice의 이전 버전의 RouterInfo가 있는 경우,
  일정량의 오래된(아래의 재키 이동 시간 참조) 경우 두 버전의 적절성을 검토하여 서명이 동일한지 확인해야 합니다.

- Bob은 여기에서 Alice의 정적 키가 커브 위의 유효한 점인지 확인해야 합니다.

- 옵션은 패딩 매개변수를 지정하기 위해 포함되어야 합니다.

- 오류가 발생할 경우, AEAD, RI, DH, 타임스탬프, 또는 키 유효성 확인 실패를 포함하여, Bob은 추가 메시지 처리를 중단하고 응답 없이 연결을 닫아야 합니다. 이것은 비정상적인 닫기 (TCP RST)이어야 합니다.

- 신속한 핸드셰이크를 촉진하기 위해 구현은 Alice가 메시지의 전체 내용을 한 번에 버퍼링한 다음 두 개의 AEAD 프레임을 포함한 모든 내용을 한 번에 플러시하도록 보장해야 합니다. 이는 데이터가 단일 TCP 패킷에 포함될 가능성을 증가시킵니다(OS 또는 미들 박스에 의해 분할되지 않는 경우), 그리고 Bob은 한 번에 모든 데이터를 받을 것입니다. 이는 또한 효율성을 위해서이며, 무작위 패딩의 효과를 보장하기 위해서입니다.

- 메시지 3 부분 2 프레임 길이: 이 프레임의 길이(MAC 포함)는 메시지 1에서 Alice에 의해 전송됩니다. 패딩을 위한 충분한 공간을 허용하는 것에 대한 중요한 설명은 해당 메시지를 참조하십시오.

- 메시지 3 부분 2 프레임 내용: 이 프레임의 형식은 데이터 페이즈 프레임의 형식과 동일하지만, 그 프레임의 길이는 메시지 1에서 Alice에 의해 전송됩니다. 데이터 페이즈 프레임 형식을 아래에서 참조하십시오. 이 프레임은 1에서 3개의 블록을 포함할 수 있으며, 다음 순서로 포함되어야 합니다: 1) Alice의 Router Info 블록(필수) 2) 옵션 블록(선택적) 3) 패딩 블록(선택적) 이 프레임에는 다른 블록 유형이 포함되어서는 안 됩니다.

- 메시지 3 부분 2 패딩은 메시지 3의 끝에 데이터 페이즈 프레임(선택적으로 패딩을 포함) ​​을 추가하고, 그것을 한 번에 보내는 경우 요구되지 않습니다. 주로 Alice는 Bob에게 보낼 I2NP 메시지가 있을 것입니다(그녀가 연결한 이유입니다), 이것은 효율성과 무작위 패딩의 효과를 보장하기 위한 권장 구현입니다.

- 총 메시지 3 AEAD 프레임의 전체 길이는 65535 바이트입니다; 부분 1은 48 바이트이므로, 부분 2의 최대 프레임 길이는 65487입니다; 부분 2의 최대 평문 길이는 MAC을 제외한 65471입니다.


### Key Derivation Function (KDF) (for data phase)

데이터 페이즈는 0 길이의 관련 데이터 입력을 사용합니다.


KDF는 체인링 키 ck로부터 두 개의 암호키 k_ab와 k_ba를 생성하며,
[RFC-2104](https://tools.ietf.org/html/rfc2104)에 정의된 HMAC-SHA256(key, data) 를 사용합니다.
이는 Noise 사양에서 정의된 Split() 함수와 정확히 동일합니다.

ck는 핸드셰이크 페이즈에서 가져온 것입니다

  // k_ab, k_ba = HKDF(ck, zerolen)
  // ask_master = HKDF(ck, zerolen, info="ask")

  // zerolen은 길이가 0인 바이트 배열입니다
  temp_key = HMAC-SHA256(ck, zerolen)
  // 메모리에서 더 이상 필요없는 체인링 키를 덮어씁니다
  ck = (모두 0)

  // 출력 1
  // 암호 키, Alice에서 Bob으로 보내는 것 (Noise는 어느 것이 어느 것인지 명확하게 하지 않지만, Java 코드는 합니다)
  k_ab =   HMAC-SHA256(temp_key, byte(0x01)).

  // 출력 2
  // 암호 키, Bob이 Alice에 보내는 것 (Noise는 어느 것이 어느 것인지 명확히 하지 않지만 Java 코드가 합니다)
  k_ba =   HMAC
